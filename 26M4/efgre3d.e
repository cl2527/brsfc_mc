/*
 * GEMSBG C source File
 * Copyright (C) 1991 The General Electric Company
 *
 * File Name:  @efgre3d.e@
 * Developer:  ELIZABETH ABRAHAMS
 *
 * $Source: efgre3d.e $
 * $Revision: 1.72 $ $Date: 6/18/98 13:02:13 $
 *
 */

/*@Synopsis
  Fast SPoiled Gradient Recalled 3D Database
  */

/*@Description

*/
/* *********************************************************************
Internal
Release # Date    Person     Comments

5.5.1  11/09/93  J. Mitchel  Modified for 5.5
5.5.2  02/24/94  J. Mitchell More 5.5 modifications
5.5.3  03/02/94  J. Mitchell Changed - refocus to - area_gzk in
                             encode2 calculation, changed position
                             of PSDRAMPEDTRAP multiplier in
                             a_delta2 equation

5.5.4  03/14/94  MMS         Added param to ACQUIREDATA macro,
                             Incorporated changes from branched
                             version fgre3d:54 93fw45.3 (from sccs version 1.35)
                             to latest version fgre3d:54 94fw8.2 into this
                             5.5 version.

5.5.5 940321     MMS         add a ninth argument to obloptimize
                             calls: &opnewgeo, add a seventh argument to
                             the loaddab calls: PSD_LOAD_DAB_ALL,
                             fix for MRIge19319 - set waveform amplitudes
                             to max if not fcomp, use a_base and a_base2
                             calc the same as 3dgrass

sccs 1.41       MGH          Change loc3t logic to loctransmit.

5.5.7           BES          Move position of PSpredownload so fasttg
                            filter isn't overwritten

5.5.8  940511   JM           Added yfov_aspect definition
                             Changed default slice thickness buttons
                             Defined iso_delay and replaced refs to t_exb

5.5.9  940701   JM           Redefined sp_killer as sp_killerx and sp_killerz
                             to correct a build failure (pw_satramp changed
                             to pw_satrampx or pw_satrampy or pw_satrampz

5.5.10 7-13-94  LP           gy1r turned into single instruction pulse for updates
                             gy1 start position corrected
                             gzp volumetab2 fix, a_end2 fix

5.5.11 8/9/94   BES          change psd_grad_acq_delay name to psd_grd_wait.
                             move SpSat, ChemSat inits after obloptimize in
                             cvinit and cveval. Remove PHASE_OFF struct, now in
                             epic.h Explicitly place dab,xtr and 3d packets.

5.5.12 8/12/94  BES          Add dutycycle_scale to up the dutycycle limit
                             by 20% as per 5.4 if sr17.  This will solve a lot of
                             the "long TR" problems (MRIge20179).

5.5.13 8/25/94  BES          Move position of cvinit.in after all *.e inits.
                             remove arg from SpSatIAmp.  Change THREEDIMDAB
                             to be compatible with new definition.

5.5.14 940908   AEK          Fixes MRIge21139 - reset the oddnex and evennex
                             flags each time through cveval.

5.5.15 940908   AEK          Fixes MRIge20264 - lock out Graphic ROI.

7.0    11/11/94 YI           Added changes for cerd and solaris 2.

5.5.16 11/16/94 FHE          Fixed MRIge21762,MRIge21763,MRIge21766,MRIge21780.

5.5.17 12/01/94 BES          MRIge21816 - calc of maxslquant

7.0.1  12/28/94 YI           Changed for Vectra hardware. Changed receiver frequency.

5.5.18 01/31/95 BES          MRIge22268 - type cast act_tr to float in pitscan calc

sccs1.55 950216 MGH          Min slice thickness button is now .7mm.

sccs1.56 950222 MGH          Turned off 3d packet after startsec in core().

sccs1.57 950302 MGH          Added system safety.

7.0.2   04/25/95 YI/YS       Changed data type of elements for calc_xresfn()
                             to fix YMSmr00179.

7.0.3   05/02/95 KS          Added res_rf0 value to fix IR problem.

7.0.4   05/04/95 YI/KS       Fixed mav fov problem for advisory.
                             Change data type of rsprot_orig to int.

7.0.5   05/11/95 KS          Added changes of :55 95fw18.1
                             (sccs1.61, 62, 66, 67)

7.0.6   05/25/95 KS          Changed the out phase TE value for 0.5T.

7.0.7   06/01/95 NM          Added cffield support for 0.2T(profile)

7.0.8   06/05/95 YI          Calculate sar in cveval also for scan panel.

7.0.10  06/07/95 KS          Added changes of :55 95fw19.5

7.0.11  06/19/95 YI          Use acqs for pislquant for prescan.

8.0.0   05/17/95 JDM         Removed extern FMax(), FMin() statements.
----- vmx/ufi merge ----
8.0.1   06/20/95 JDM
                             re: sccs1.69 950612 MGH    spike noise-tns box change
sccs1.61 950331 MGH          Initalized powscale for gxks,gzks, and gzrf1sat trapezoids.
sccs1.62 950414 MGH          Initialized the rf resolution of rf0 pulse.
sccs1.66 950420 MGH          global changes for phasefov buttons, power scale
                             and amppwencode calls.
sccs1.67 950501 MGH          Removed hard coded limit for opslthick.
sccs1.67 950512 MGH          moved scalerfpulses to cveval.
sccs1.69 950612 MGH          spike noise-tns box change
sccs1.70 950628 MGH          Remove gzrf1sat pulse, and minimize sp_sattime.
sccs1.71 950721 MGH          Make the sat timing cv's unused for non sat scans.
sccs1.72 950803 RJL          MRIge26267. Fix sat logic for computing sp_satend. Add logic
                             to only calculate timing for SATS if opsat<x,y,z>==PSD_ON
                             *AND* opsat==PSD_ON. Doesn't make sense otherwise.
sccs1.73 950809 MGH          Removed exist macros from pulsegen section.

sccs1.3  95/10/17  RJL       Merge with :55 95fw32.5 (QT) for removal of gzrf1sat stuff to
                          speed up logic.
sccs1.4  05/10/18  RJL       Change rot_delay to pw_rotupdate in sp_satend calculation to
                             conform to SpSat.e changes.
sccs1.5  10/24/95  RJL       Initialize max,min,def values of opslquant_old equal to opslquant
                             in cvinit(). Removed gzrf1sat pulse per 950628 of MGH missed during
                             last merge.
sccs1.64 11/3/95   RJL       Move setsysparms to cvinit to ensure SpSat has access to psd_rf_wait
                             when determining time calcs.
sccs1.67 12/05/95  RJL       Merged with fgre3d:mrp (95fw46.2). Changes to turbofilter to calculate
                             filter bw exactly (15.63 instead of 16 for example). Modify opte
                             calculation per vmx changes. I did not merge any Profile specific
                             modifications (0.2T system). Added tmpbw.
                             MRIge28740,MRIge28755 - Pass xres to setfilter routine for fractional
                             echo and CERD hw. If pass opxres then with homodyne since xres reduced
                             data in window will be too large and overun into next setfilter() call.
sccs 1.68 12/12/95 RJL       MRIge28858 - Change rffrequency_length to rffrequency_length[bd_index].
                             Former uses pointer address in timing calculations. This is bad....
sccs 1.69 12/19/95 RJL       Lockout MT for this PSD - MRIge28286
sccs 1.70 04/21/96 RJL       Numerous modifications for Advisory Panel Popup support.
sccs 1.71 05/06/96 RJL       MRIge32263 - Remove phasefov error bounds checking. This is bad.

sccs 1.73 23-May-96 JDM      MRIge32346
                             Added setting of z gradient scale factors, to
                             provide more accurate rms and amptrans calcs
                             on Z axis (courtesy of J. Polzin).

sccs 1.74 29-May-96 VB       MRIge30804
                             made sure that selecting vasc tof spgr in fgre3d
                             enables spgr_flag.Also changed killer area check,
                             area_gzk, to be dependent on spgr_flag rather than oppseq.
                             (fix taken from 55 - J.Polzin)
                             MRIge31322
                             Included max_seqsar in tmin_total calculation.
                             (fix taken from 55 - J.Polzin)

sccs 1.75 30-May-96  RJL     Initialize all advisory panel values in cveval() so they are not
                             overwritten by call to InitAdvPnlCVs().

sccs 1.76 07-June-96 RJL     return ADVISORY_FAILURE for RBW range checks located in cveval().
                             This was missed in prior conversion.

sccs 1.77 13-Aug-96  PH      MRIge34129 - set _opslquant.fixedflag = 0
                             to allow switching from 3dfse to fgre3d.
                             Comment out opslquant_old since there is no
                             reason to use it.

sccs 1.78 13-Aug_96  VB      MRIge32187;
                             defined a new variable DISCARDSLICE and set it equal to 4.
                             In cvcheck defined Tempslquant and set it equal to
                             avminslquant - DISCARDSLICE. This way the correct value
                             is displayed in the error message.

sccs 1.79  23-Aug-96 VB      MRIge34604: set avminyres to 128.

sccs 1.80  30-Aug-96 PH      MRIge34735 - set opslquant=avminslquant in
                             cvinit if opslquant is exist and less than
                             avminslquant.
sccs 1.81  4-Sep-96 JAP      Fixed fwphase subroutine (MRIge34478)

sccs 1.82  26-Sep-96 RJL     MRIge35532: Modified fix of sccs1.78 to send the slice quantity
                             - kissoff slices to scan. This ensures ermes and popup values
                             are correct so scan can add its 4 slices when sending to PSD.

------------------------ LX2 -------------------------
This version will replace the existing fgre3d code. Without the SmartPrep
and SpecIR Option Keys the PSD will fucntion as fgre3d without the enhanced features.

sccs1.41  17-Aug-97  VB      MRIge41314: Spatial Saturation is not compatible
                             with SpecIR. The error checking was missing
                             for this.

sccs1.42  08/20/97   LR      MRIge41369: ChemSatPulse was not
                             initialized properly for SpecIR.

sccs1.43  27-Aug-97  CMC     MRIge41507 Wrong argument for mintr was passed and it is
                             corrected.

sccs1.44  08-Sep-97  CMC     Removed the redundant part of the code from pulsegen

sccs1.45  08-Sep-97  CMC     Added the line avminsldelay = TR_PASS; in cvinit.

sccs1.46  23-Sep-97  JAP     Modify #includes to use stdio.h for host
                             and ipg sim and use stdioLib.h for IPG hw
                             compilations.

sccs1.47  10/01/97   LR      MRIge42048 - added values to be placed
                             in the pulldown menu for fractional Yfov

sccs1.48  10/03/97   VB      MRIge42034 - removed the section where rhtype1
                             was being set to 8 if multicoil was used.

sccs1.49  10/06/97   JAP    MRIge41817 - Removed setfrequency and
                            settriggerarray from reset_for_scan. These
                            have been set up already. Initialize the
                            dab and gy1 before start of Monitor
                            sequence. These fixes prevent EOS errors
                            when switching from the Monitor sequence to the
                            imaging sequence.

sccs1.50  24-Oct-97  CMC    Fix for MRIge42439

sccs1.51  06-Nov-97  CMC    Fix for MRIge42443

sccs1.52  06-Nov-97  CMC    A correction

sccs1.53  19-Nov-97  CMC    Fix for MRIge41368 is done for lx-2

****************************** CV1 version ********************************
sccs1.54  07-Jan-98  JFS    Added the following enhancements for CV1
                            1. Added ECG gating for CV1. Most ECG gating code is in Gate.eh
                            2. Added support for reversed loop order with slice encoding nested
                               inside phase encoding. Most code is in LoopOrder.eh
                            3. Added support for 125 kHz bandwidth
                            4. Added Fractional decimation(VRGF) between 62.5 kHz and 125 kHz
                            5. Added support for SGD (Scaleable Gradient Driver)
                               Added SGD CV's and their initialization
                               Replaced minseqgram() with minseqgrad() to support SGD
                               Removed calls to minseqgrddrv()

sccs1.55  13-Feb-98  JFS    Fixed MRIge4429 on minfov calculation

sccs1.56  18-Feb-98  JFS    Cleaned up fractional decimation.
                            Changed call to local functions to psdsupport functions fdcalcfiltinfo
                            and fdsetup. Removed conditional compilation flag VRGF_JFS as the
                            library functions will support both integral and fractional decimation
                            now.
sccs1.57  06-Mar-98  JFS    Expanded rbw buttons to include 125, 83.33 etc.
                            Changed exist(xres) to xres;

                            MRIge44642: fixed the calculation of sp_satend and sp_sattime.
                            sp_satend is the time at the end of the last crusher gradient,
                            and is used to calculate the timing for gxks and gzks.
                            Too much time was subtracted from sp_satend and sp_sattime,
                            which lead to sp_sattime being less than the actual sequence length.
                            Fixed the calculation of sp_killerx and sp_killerz. Incorrect pulse width,
                            pw_satrampx+pw_gks, was used to calculate the timing of gxks and gzks. The
                            actual pulse width is now used in calculating sp_killerx and sp_killerz.

                            MRIge44700: Changed cvmax(opslthick, 1000.0) to cvmax(opslthick,8.0) and
                            cvmin(opslthick,0.0) to cvmin(opslthick,0.1) to prevent illegal values for
                            slice thickness;

                            MRIge44780: Added piccsatnub=0 after SpSatEval() call to lock out ConSat.

sccs1.58  13-Mar-98  JFS   MRIge44811: Filled in image annotation when either ECG
                           or Respiratory gating/triggering is on.

sccs1.59  24-Mar-98  JFS   MRIge44987 (search for rvssliceenc): When
                          rsp_info[1].rsptloc > rsp_info[opslquant-1].rsptloc
                           reversed order of slice encoding gradient (i.e. going from Gmax to -Gmax),
                           reversed order of slice linear phase shift (slab_ph_tab[]), and changed
                           sign of the phase for half slice shift.

                           MRIge43582: Added a global variabl SGDKey to check for the CARDIAC KEY.
                           When opcgate==0, disabled reversed loop order and hid opuser15. Locked out
                           cardiac gating for TOF sequences.

sccs1.60  01-Apr-98  JFS   MRIge45105: Moved the calculation of avminti in cveval1() from
                           before to after the calculation of optr because avminti depends on optr.
                           MRIge45161: Disabled burstmode as it is not needed anymore
                           according to Jason Polzin.
                           (the shortest TR was already used in non-burst mode.)
                           Unlocked cardiac gating for TOF sequences (they were compatible after all)

                           MRIge44992: moved from cvcheck() to predownload()
                           the check for the selection of of water/fat sat when SpecIR was enabled,
                           to avoid the problem of scan loop.

                           MRIge45155 & MRIge45153: The bound check was added for oprtarr.

sccs1.61  05-Apr-98  JFS  MRIge45215 & MRIge45218 : Increased sp_sattime accordingly when
                          the spoiler gradient length was increased as a result of
                          increasing the # of spoiler gradients from 1 to 3.

sccs1.62  09-Apr-98  JFS  MRIge45334: mintr() could set avmintr to less than tmin_total.
                          To guard against this, added avmintr = IMAX(2, avmintr, tmin_total)
                          after the call to mintr().

************************************ CV1M3 version **************************************
sccs1.63  21-APr-98  JFS  Created the version for the CV1M3 context by merging
                          efgre3d:cardiac CV1.26j_9817.2b.0 and efgre3d:lx2 82.26p_9816a.0.
                          The following LX2 fixes were incorporated into the CV1 version:

sccs1.54  CMC    Fix for  MRIge43708
sccs1.55  CMC    Fix for  MRIge43740
sccs1.56  CMC    Internationalisation
sccs1.57  VB     MRIge43788 - There was bug in the calculation
                 of the SAR values in cveval. The change in TR
                 due to the specIR was not accounted for in
                 in the powermon_b1scale(). This was resulting
                 in a much higher sar value for specIR scans.
                 the calculation was correct in the predownload section.

sccs1.58  VB     MRIge43823 - added a check for the maxbursttime value (60).

sccs1.59  LR     MRIge44882 - added an argument (which was missing)
                 to the epic_error() call.

sccs1.62  SGT    MRIge44238 - power monitor trip issue for RF Pen II:
                 The power monitor parameters calculated by the program
                 rfstat is not good enough for the minimum phase RF pulse
                 used in efgre3d or 3dtof.
                 A proposal has been proposed to deal with the issue. The reason
                 for the failure of the current model has also been explained
                 there. The proposal has been reviewed and approved by systems,
                 RF subsystems, and safety engineers.
                 The current change implements the proposed changes:
                           SAR_DTYCYC_RF3D16MIN from 0.2694 --> 1.0
                           SAR_MAXPW_RF3D16MIN  from 0.2306 --> 1.0

sccs1.65  24-Apr-98  JFS  Compared opuser16 with _opuser16.maxval instead of 60.0

sccs1.66  29-Apr-98  JFS  MRIge45584: When opslquant<12, the calculated value of scansat0
                          was  less than 0 and was out of range. The fix was to set scansat0 to 0.
sccs1.67  05-May-98  JFS  MRIge45634: cveval returns FAILURE if LoopOrderCveval()<0.
sccs1.68  18-May-98  JFS  MRIge45848: Changed # of image header from exist(opslquant)
                          slicezp*exist(opslquant)
                          MRIge45847: Turn off exist flag of opti if no IR.
sccs1.69  18-May-98  JFS  MRIge42112(CQA 974987): Added psd_grd_wait in the non_tetime
                          calculation to allow the last gradient pulse to complete and
                          to stabilize (psd_grd_wait was mostly taken by the WARP)
sccs1.71 11-Jun-98  JFS  MRIge46182: Recalculated scan time.
sccs1.72 18-Jun-98  JFS  MRIge44718 & MRIge46149: Set pimultislab=0 to disable multislab
                          and set pilocnub=4 (>0) to enable graphics Rx.
sccs1.73 8-Jul-98   JFS  Removed previous fix. The Scan was unable to complete single-slab,
                          Smartprep prescription. The previous fix can be put in once the
                          problem with the Scan is fixed.
                          MRIge45111 extension: Added range check for opuser10 and enhanced
                          range check for opuser16.
sccs1.74 10-Jul-98  JFS  Removed check for the CARDIAC key which does not exist anymore
                          and add check for the SGD key for burst mode.

sccs1.75 01-Aug-98  JAP  MRIge46780. Set avmaxrbw based on config
                          value cfcerdbw. Delete vbw64_flag and all
                          logic associated with it.
sccs1.76 04-Aug-98  JFS  MRIge44674. the SPEC IR required opfat or opwater to be selected;
                          The calculation of avminti and avmaxti depended on fat or water SAT.
                          The workaround was to display a message and to set opuser10 back to
                          0 if opuser10 was set to 1 before fat or water SAT was selected.

sccs1.77 12-Aug-98  VB    MRIge46787: Added code for SNR Monitor.
                          Search for pifractecho.

27-Aug-199                MRIge47131- Changed ifndef ERMES_DEBUG to
                          ifdef PSD_HW

sccs1.174 1-Sept-98  VB   Added three include files.

11/13/98             LR   Added Multislab and Multigroup
                          compatibility as a part of
                          3d oblique feature, for encore program.

11/19/98             PRA  Added 1024 ZIP imaging feature for ENCORE.

11/25/98             CMC  Removed the local declaration of prototypes and added them
                          into the efgre3d.h. Changed all the return types of the functions
                          which return either SUCCESS or FAILURE to STATUS.

12/04/98             CMC  Fix for MRIge49415 Changed the minima and maxima of rf1_pulse_type
                          and some clean up

02-Dec-98            PRA  MRIge49419 Need to lockout projections and allow
                          only collapse with 1024 ZIP

10-Dec-98            CMC  Bolus Chasing Changes

10-Dec-98            CMC  pidisableprescan needs to be droped from the code

12/18/98 GFN   MRIge47485: Removed duplicate definitions of minseqpwm_x,
               minseqpwm_y, minseqpwm_z, and minseq_gpm.

12/28/98 GFN   Updated call to checkOptionKey(). It takes only
               one argument now.

01/05/1999 GFN   MRIge50101: Changed #ifdef GATE_JFS conditional
               compilation for use_ecg_scancore CV declaration to
               %ifdef GATE_JFS instead to prevent download
               failure.
               Added check for opmultistation to set pscahead
               accordingly.

01/06/1999 GFN   MRIge49418: Removed check for sigrammode when
               calling minsegrad() to allow SR20 mode.

14-Jan-99  VB  MRIge50281: fix the problem where sar_amp,
               sar_width, and sar_cycle were 0.


15-Jan-99  VB  Fix turbo logic. opuser8 will be used to
               turn turbo ON and OFF. If turbo is ON
               the .8ms RF pulse is selected and the
               turbo_flag is set to 1.
               The rewinders are always turned ON.

15-Jan-99  VB  rewinder_flag was defaulted to 0 and
               never getting turned ON. Initialized
               it to 1.
               reverted to using opuser6 instead of
               opuser8.
               Set turbo_flag to 0. The user can turn this
               on from the modify cv screen. This is
               a temporary solution till the problem
               with the turbo_core section is fixed.

               moved boffset(off_seqcore) to outside
               the ifdef GAT_JFS section. This was
               wrongly placed in this section during
               some previous merge.

01/19/1999 GFN   MRIge50275: Moved the update to autoadvtoscn
                 together with the update for auto prescan.
                 MRIge50364: Changed SmartStep for Multistation.
                 MRIge47485: Initial cleanup to accept pulsegen
                 on the host for Full SGD enhancements.
                 MRIge49548: Changed view bit field size from
                 :9 to :10 to allow 512 views. Note that in the
                 future, this value will have to be increased
                 to :11 to allow 1024 views.

02/18/1999 LR/JAPIncreased no. of disdaqs played out for prescan.
                 Changed the disdaqs played out for smartprep and
                 elliptic centric scanning.
                 Changed exicter chop to receiver chop in prescan.

02/25/1999 FEC   MRIge49446: Fixed check for opuser6 and opuser12
                 to verify it is either 0 or 1.


02/25/1999 GFN   MRIge47485: Updated average values for ia_gy1 and
                 ia_gy1r to be multiplied by max_pg_iamp so that
                 the integer result is greater than 0.

03/02/1999 JAP   MRIge50201. Moved all slice and view ordering lookup
                 to the host. The zy_export structure now
                 contains will now support centric view and
                 slice ordering as well as elliptical
                 centric ordering. Removed redundant
                 setfltrs calls.

03/01/1999 LR    MRIge51463 - changed the default value for ellipt_flag to 0
                 for non-TOF mode and (int)exist(opuser12) for TOF mode.
                 MRIge51294 - check for selection of fat/water sat with specir
                 was done in predownload. moved this to cvcheck() to prevent the psd
                 from downloading unless fat/water suppression is selected with specir.
                 MRIge51364 - If chemsat is a separate sequence we need to create it after seqcore.
                 This is due to a limitation in pulsegen on the host where the first sequence
                 must be the main imaging sequence - seqcore.

03/02/1999 LR   MRIge51415 - Spec IR and IR prep are incompatible. Added a check for this.

03/10/1999 JAP/LR  MRIge51629 - Moved 3D DAB packet out
                   towards the end of the PASS sequence to make sure that
                   previous frame has been processed by the CERD. This
                   fixes a problem in which the frame corresponding to the
                   last view and last slice was missing from the raw data.

03/10/1999   LR    MRIge51582 - Added backward compatibility case for the 3.2ms rf pulse.

03/11/1999   LR    MRIge51626 - Enabling Turbo (and use the shorter rf pulse)
                   only when the SGD perf key is enabled and when grad amp is 8651 (SGD-high slew).
                   8645-GRAM grad amp are limited by duty cycle and sr17 & sr20 are
                   limited by slew rates.

03/18/1999   GFN   Commented out code in pulsegen to be executed only
                   on the IPG side.  Fixed a logic problem with
                   'if (slicecount = 0)', it should be
                   'if (slicecount == 0)'.

03/17/1999   AMJ   MRIge50657 BAm allocation mismatch bet
                   psd and recon. weighted table value in
                   vas_ovrhd increased to 3904 for 1600
03/23/1999   LR   MRIge52102 - The fix for MRIge44718 was commented
                  out because of some scan problem. Uncommenting
                  that now.

03/24/1999   LR   MRIge51832 - Find minimum slab thickness always,
                  not only when we suspect an invalid slthick
                  entered. ampslice below calculates the minslthick
                  for the maximum target amplitude.

04/01/1999   PRA  MRIge45660 - SPECS state a min slthick of
                  0.2mm for SR20 systems.

04/02/1999   JAP  Updates with slab_off and slab_phase to make
                  download times shorter.

04/02/1999   JAP  MRIge51879 - Created new function
                  calcPulseParams() to set parameters for pulse
                  generation (e.g., pulse widths, instruction
                  amplitudes).  This allows the pulsegen on
                  the host feature call this function instead
                  of predownload().

04/09/1999   GFN  When setting gradHeatMethod to ON, set it ON in
                  all cases. Even when SAT is ON.

04/09/1999   LR   Set minimum value of BPM to 6.

04/15/1999   GFN  Added debugging info.
                  Changed setting of gradHeatMethod to be ON all the time.


08-Apr-1999  JAP  825->83 merge


             BJM   MRIge50374 - set fracdec = PSD_ON before
                   fdcalcfiltinfo() call to prevent it from being
                   overridden by the function

             AKG   MRIge48318 disabled fractional decimation for
                   512x512 NPW.  Decrease tlead to 12 usec.

             JAP   MRIge52076 - For high X res values, e.g., 512,
                   the value of cerd_out_points will be more than
                   the upper limit for rhdaxres cvmax( rhdaxres, 1024 );

04/16/99   LR/JAP  MRIge51587 - Turn OFF 3d dab packet in SatPrep() before
                   next startseq. It is possible that we set this in the previous
                   sequence and never turned OFF. This might lead to reFFTing
                   the same view.

04/16/1999   FEC   Moved opuser0 range check to cveval, was core
                   dumping in cvcheck. (MRIge52288)

04/20/99    LR     MRIge51582 - missed out certain changes while adding
                   the case of 3.2ms rf pulse (backward compatibility).

04/29/99    LR     Corrected a mistake did while making changes for MRIge51582.

05/25/99    JFS    MRIge53533 - Recalculated the scan time if
                   respiratory triggering was selected.


05/28/1999  GFN    MRIge45285 - Turn multislab/group/angle OFF if
                   Cardiac Gating is ON.

06/08/1999  GFN    MRIge48400 - Do not show the Vascular page if
                   Multiphase is selected.

06/16/1999  GFN    MRIge53899 - Locking out Multistation for ME2 software.

06/23/1999  GFN    MRIge54141 - Reactivating Multistation for M3 software.

06/23/1999  GFN    MRIge54002 - Changed hardcoded index 0 to new
                   idx_seqcore when calling minseq();

07/02/1999  JFS    MRIge54218 - Increased tlead by to 56 us from 12 us to
                   avoid gradient overrange.

07/02/1999  GFN    MRIge54002 - Use the new seqEntryIndex CV instead
                   of the idx_* variables.

07/21/1999  GFN    MRIge54212 - Changed setup of the User CV page
                   for the Number of Stations CV used in Bolus Chasing scans.

07/21/1999  JFS    MRIge51710 - Recalculated avmintscan to take into
                   account that Spatial Sat was executed once for
                   multiple NEX and that there was one disdacq after
                   each SAT.


07/29/1999  JAP    MRIge54386 - Delayed sending of 3D
                   packet by one TR. The variable
                   threedpktdly is set to one but can be
                   increased for further delay. Cleaned up
                   the filter generation code.

07/30/1999  JFS    MRIge54740 - Changed cvmax(opslthick,8.0) to cvmax(opslthick,10.0).

08/09/1999  BJM    MRIge54963 - Check for multistation option key added.

08/20/1999  BJM    MRIge54970 - Check new config variables for maxcerdbw.

09/07/1999  TAA    MRIge55039 - Corrected calculation of scan time for Resp. Gating.

09/10/1999  JAH    MRIge55533 - Fixed artifact when both Spatial and
                   Fat SAT are selected.

09/14/1999  RAK    MRIge55728:  Adding support for the nMR swing
                     table.  With the nMR swing table the patient
                   coordinate system and gradient coordinate
                   system no longer coincide. Therefore, the CV
                   opplane can no longer be used indiscriminately.
                   When a portion of code refers to the gradient
                   coordinate system the CV opphysplane will be
                   used instead of opplane.
02/08/1999  AMJ   MRIge57298: Corrected obloptimize implementation
                  corrected error handling in cvinit and cveval

03/14/2000  AKV   MRIge59032: set min slice thickness to 0.2 for SR25 mode(nMR)
                  same as that of SR20 mode.
03/10/2000  SK    MRIge58851: Corrected scan time calculation with
                  respiratory triggering when tscanperview is larger
                  than the respiratory period.


11/11/1999  RJF    Implementing Slew-Rate optimization based on actual dB/dt
                   for 8.4/Pulsar

BJM 83M5 -> 84 MERGE.....
12/01/1999  AF     MRIge56509 - Added gradient amp 8915 to turbo mode enabling and
                                burst mode disabling logic.

01/12/2000  JAH    MRIge57440 - changed the logic for playing the
                                IR and ChemPrep pulses to use the elliptic
                                centric rsp variable slicecount.

02/11/2000 BJM/YZ  MRIge58026 - Move ChemSatEval() after act_tr is set.
                   MRIge57976 - Update pinexnub to add NEX=1 in
                   MRIge57588 - set avmaxrbw2 = avmaxrbw

02/15/2000 YZ      MRIge58272 - Change calcOptimizedPulses return value to avoid
                                error message popping out on prescription window.

02/29/2000  KVA   MRIge57698 - fixed the timing miscalculation with
                              multi-phase option & removed 'pisctim2 to 6'

03/16/2000 BJM     MRIge57740 - we should probably set bw_rf0 if we want a slab-selective
                                gradient during IR prep.

03/24/2000 BJM     MRIge59148 - fix for SmartPrep Acq. delay problem

04/28/2000  YZ     MRIge59009 Disable rf file reading for pulsegen-on-host to save time

05/08/2000 BJM     MRIge59988 - added check against zero for viewsPerCycle

07/12/2000  YZ     MRIge58050 - Added check before increasing TR for line trigger.

08/18/2000  AF     MRIge57455 - Moved gradHeatMethod definition above inittargets function call.

08/29/2000  YZ     MRIge61564 - Change a coding error which causes SAR violations.

06/30/2000 AMJ     MRIge60866. Adding Moving Metal Compensation
                              implementation (DFM feature).
                              The feature is preprocessor flagged with DFMONITOR
                              It is turned on for nMR only.
                              Added fgre_loaddabwithnex_echo1() function for DFM feature

07/31/2000 AKV     MRIge61176: Limiting  the maximum FOV value to 40 in the
                              pulldown menu.

09/07/2000 SK      MRIge61722: Fixed EOS problem at the very end of scan for
                              elliptic centric phase encoding.

09/25/2000 BSA     MRIge61973:
                              - Corrected errors in display of avmaxrbw based on max Gx and maxcerdbw
                              - Corrected errors when avminfov>avmaxfov
                              - made pifovvals for body coil based on avmaxfov rather
                                than fixed values, and removed edits of MRIge61176.

10/25/2000  AF     MRIge57455 - Initialized pgen_debug to FALSE.

10/27/2000  DCZ    MRIge60917: Fix the NEX looping structure in scancore() to be similar
                               to 825 if it is not elliptical centric. The contrast should
                               not change from 1 NEX to multi NEX.

10/30/2000  DCZ              : Limit the maximum opfov to 440 when turbo_flag = 2 and opyres
                               is below 128. Based on testing,leaving it to 480 leads to IPG
                               and download problem. This is just a quick fix. A better method
                               can be applied if available.

11/10/2000  DCZ  MRIge62803/MRIge62804:
                               When smartprep is ON and turbo mode is 2, EOS errors occur at
                               opxres of 128 and 160. Testing showed that when tmin falled
                               below 2.15 ms, this IPG problem would occur. Therefore,
                               when smartprep is ON and tmin is smaller than 2.15 ms,
                               set ipg_mintr to 2150. Discussed with Tony Vu to increase the
                               mininum time required for the machine to run.


11/10/2000  DCZ  MRIge62819  : At a rbw below 7.81 kHz, CERD problem occured in ASP2.
                               Tested at 512 x 512 and different combinations. At this
                               value, the minimum FOV is allowed at 2 cm.

11/10/2000  ATV              : Added supported for fully-balanced steady state coherent imaging
                               feature (FIESTA)

11/10/2000 AMJ     MRIge62915/MRIge62817:
                               Added check for opfov < minfov after changing minimum for
                               avminfov based on gradient strength

11/10/2000 AMJ     MRIge62916  Corrected logic for passtime reduction so that the
                               reduced value for mph scan for last pass is reinstated.
                               This comes into play when the same scan is run again.

11/20/2000 JAH/DCZ MRIge62876: max_seqsar is an interger. The
                               rounding has led to some problem in
                               SAR evaluation. Add 1 microsand to
                               ensure that the max_seqsar is not
                               violated.

11/20/2000 DCZ/JAH MRIge62874: tmin_total refinement: Fix at multi locations.
                               Use powermon_b1scale() appropriately,
                               fix tmin_total adjustment, and fix adj_act_tr.


11/28/2000 DCZ: MRIge61444: Pick ALP's "big ugly" fix from
                            efgre3d.e@@/main/mr_main/83_M5/3.
                       ALP: enable queuing mode at CAP end..this fix is to 
                            address the 'big ugly' artifact 
                            issue with efgre3d  multiphase and smartstep scans..
                            this does not fix the issue, but decreases the frequency 
                            of artifact occurance..the hope is that this will suffice
                            until MGD happens.

12/6/2000 DCZ/JAH: MRIge63351: Relocate error check for avminti and avmaxti 
                          before cvmin(opti,avminti). This allows the update of
                          minimum TI and error flag more meaningful. 

01/4/2001  JAP     MRIge63638   Changed minseqgrad() in the burstmode heating
                                calculation section to minseq(). This will use
                                the linear segment heating model for calculating
                                the minimum sequence time. This is especially
                                important for obliques where the minimum the
                                older model in minseqgrad() can be overly
                                conservative.



01/12/2001 JAH   MRIge63197  Changed the calculations of the instruction
                             amplitudes of the phase and slice encodes to
                             take into account the power scaling during
                             gradient heating calculations but NOT to apply
                             power scaling -- that is, use worst case
                             amplitudes -- for dB/dt optimization in 
                             Pulsegen on Host.

01/23/2001 AC   MRIge63745  Changed the maximum fov for surface coil to 40 cm and
                            maximum slice thickness to 10.0 mm.

01/23/2001 AC   MRIge63749  Removed opuser7 (fiesta3D user CV) to fix the copy
                            paste problem. Now fiesta3D is chosen thru the
                            FIESTA Pulse Sequence button which in turn enables
                            the ssfp_flag. 

01/23/2001 AC   MRIge63750  Turned of User CV and SAT windows which 
                            were not required for Fiesta3D.

11/29/2000 MS/NDG           Navigator gated efgre3d feature introduced 
                            for CNV4. 
                            RJF picking this up for MGD2 baseline.

01/22/2001 JAH  MRIge62820  Respiratory gating calculations break down when
                            more than 1 respiratory cycle is required per
                            view (including slice and nexing for each view)
                            need to round the resp. cycles to the nearest
                            half-integer step based on the window.

01/31/2001 JAH  MRIge63197  Following FGRE model, scale a_gy1 based on the
                            largest PE amplitude and make sure ia_gy1 goes to
                            endview_iamp in dB/dt optimization.
                            This has the same effect as the old definition:
                            loggrd.ty_xyz/endview_scale. Use the derated
                            scale factor to account for average gradient
                            power when evaluating for gradient heating.
                            Z encodes are calculated with the instruction
                            amplitudes scaled, not the waveform amplitudes.

01/31/2001  BSA   MRIge64230  Corrected gxw timing errors for fractional 
                              decimation and cfswgut=16us.

02/01/2001  BSA   MRIge64348  Corrected DFM table size with NPW

03/20/2001 ATV  MRIge65040  Update nreps calculation to reflect the fact that
                            spatial SAT are played out for every nex.

04/01/2001 ATV  MRIge57602  Added support for reverse centric, reverse elliptical
                            centric, quiet trigger delay 
05/16/2001 ATV  MRIge66079  Added support for ftMRA (RTIA3D) feature.
05/24/2001 ATV  MRIge65041  Changed avminrbw for turbo mode =2 to 31.25 kHz.
06/05/2001 ATV  MRIge66706  Fixed download failure due to zero duration for gxwex pulse. 
06/08/2001 ATV  MRIge66806  Turn-off both opsat/opsatz for 2nd and subsequent station 
                            if ellipt/reverse ellipt centric 
                            is selected in the 1st station of a multi-station FTMRA scan. 
06/08/2001 ATV  MRIge66887  Enhanced turbo mode. 
06/14/2001 ATV  MRIge66808  Turn the Vasc button back on for Multi-station and FTMRA.
06/18/2001 ATV  MRIge67085  Correct scan time calculation and clock display for FTMRA.
06/19/2001 ATV  MRIge66833  Shown No. of stations, Mask/Venous Acqs CV for 1st arterial 
                            series only. 
06/19/2001 ATV  MRIge67086  Fixed EOS error for FTMRA by making minimum TR for regular 
                            core to be 2.5ms based on experimental data. 
06/21/2001 ATV  MRIge67181  Lock-out Real-time imaging option from the UI.
06/22/2001 ATV  MRIge67141  Correct off_center_dist for ZOOM mode. 
07/03/2001 ATV  MRIge67080  Correct max TI advisory message.
07/06/2001 ATV  MRIge67207  Correct maximum slices advisory message with Cardic gating option.
07/12/2001 ATV  MRIge67603  Stop scan time clock from counting down for ftMRA.        
07/26/2001 DG   MRIge67827  zoom_limit checking only if relevant CVs "exist" 
07/28/2001 ATV  MRIge67886  Allow receiver bandwidth as low as 7.81 Khz for turbo 2 mode.
08/03/2001 BWL  MRIge67407  Added ASSET feature (marked ASSET).
08/16/2001 ATV  MRIge53799  Default TI for SPECIAL FATSAT to minimum value.  
08/15/2001 DG   MRIge68820  zoom_limit checking using inlines

12/20/2002 RJF  MRIgexxxxx  Merge of 91 baseline for MGD2. 
                            Navigator related fixes.
----------------------------------------------------------------------

02/22/2001  NDG     Set rhdacqctrl for NAVs so that CERD does not use the
                    queued filter mode. The "big ugly" is never expected
                    for Navigator based coronary artery application.

03/05/2001  NDG     Changes for T2 Prep timing with cardiac gating.

05/01/2001  NDG     Merged changes from latest CNV3 version.
06/08/2001 ATV      MRIge66887/MRIge66995  Enhanced turbo mode. 
06/29/2001  NDG     MRIge67375 - Lock out ultra-fast for navigator option. 
07/03/2001  NDG     MRIge67430 - Change t2prep_rate for T2 Prep to a less conservative value.
07/20/2001  NDG     MRIge67118 - Reverse loop order to be removed for navigator.
07/24/2001  NDG     MRIge68079 - Maximum slice limits based on cardiac delay.
01/08/2002  NDG     MRIge71791 - Adjusted TR time logic changed for navs.

02/20/2002  KVA     MRIge72936 - Adjusted Asset Scan Time with ir_prep and intermittent_chem
03/02/2002  ETH     MRIge73171 - Turned off specir_flag and spchemsat when operator
                    deselects Fat/Water SAT.
03/09/2002  KVA     MRIge73320 : Round-up for tmp_minfov was missing.
03/28/2002  RS      MRIge72695   Changed obl_method=0 for fluorotrigger (FTMRTA) oblique scans
03/29/2002  ETH     MRIge73379 - Minumum avminfov for navigator set at 10 cm. 
04/11/2002  RS      MRIge72695 - Increased rtca_min_fov and rtca_max_fov
                                 by 1.732 times for ftMRA oblique scans.
                               - Changed the obl_method to 1 for ftMRA by
                                 removing the previous obl_method=0
                                 (03/28/02). 
06/28/2002  RS      MRIge75651 - SAR calculation has Coil_SAR parameter 
                                 added. Coresponding changes were made 
                                 to powermon_b1scale and addition of picasar

08/12/2002  RS      MRIge62659 - Added "rhhnover" variable to the 
                                 avmintscan calculation with 
                                 irprep_flag and intermittant_chemsat flg.

08/29/2002  AC      MRIge77507   RJF Adapted fix for MGD2 baseline. 
---------------------------------------------------------------------- 

03/21/2002 RJF  MRIge73549  Changed end time calculation for rba and rec.unblank pulses.
06/06/2002 RJF  MRIge75771  Rounded up sat time to grad bounds for sat seq creation.
06/12/2002 ATV  MRIge75785  Fixed gradient fault in case of (very) thick slice imaging (>6mm) with
                            FTMRA. Slice encoding/refocus combined gradient pulse will now able to 
                            accomodate the potential increase in refocusing area when real-time 
                            slice thickness is reduced significantly from the original (thick) 
                            3D slab thickness. Two additional support functions are included 
                            as part of LoopOrder.eh    
06/14/2002 AKG MRIge75282   widened cvmin-max range for opfov to be greater than avmin-maxfov.
                            This prevents unnecessary adv popups during protocol loads. 
06/22/2002 ATV MRIge75871   Added ecg_scancore_YZ and ecg_scancore_ZY for standard and reverse loop 
                            order ECG/Resp gating support. Disabled IRPrep, SPECIAL Fatsat and Spatial 
                            SAT for reverse loop order. Enabled Resp Gating with Fiesta.   

10/30/2001 SXZ MRIge70233   Wrong scanning time calculation when respiratory
                            gating is on. The main reason is the update time
                            of RespGate() for respiratory gating was by mistake
                            considered as "per view" (including nex and slice).
                            correct case should be is "per nex" (only including slice).

08/15/2002 JAH MRIge76940   The calculations for minimum FOV needed to be tied
                            in with the ASSET implementation. To get all the
                            limits calculated correctly in one place, the
                            min. FOV code was moved before the ASSET min. FOV
                            inline section. Consolidations were made to 
                            simplify the interactions between imaging options,
                            UI entries and the FOV/PhaseFOV.

02/10/2002 RJF MRIge78320   Picking up LS's fixes from 3T for prep failure with 
                            turbo 2, specIR, and flip angle <= 10. Applied fixes
                            to ecg_scancore_YZ and ecg_scancore_ZY as well.

10/30/2002 SVR MRIge78984   Removed the bit fields for linux-MGD.These
                            bit-fields were not endian-converted and so scan
                            failed. -Venkat.

02/24/2003  AP              Added for BBA - Multi Volume Prescan feature

02/27/2003  HK MRIge81313   Added changes for Fiesta-C feature for mgd2.

03/05/2003  KVA             MRIge81518 ECTRICKS Specific Changes.

02/21/2003  ALP MRIge81470  MGD2 cardiac features 3d fatsat fiesta and 3d MDE 
                            - 1/2 alpha 1/2 TR preparation pulse (psd_seqhtrtime)
                            - New local inline file VAST.e 
                            - New 600 us RF pulse for gated fatsat fiesta

03/10/2003  AP              Added for BBA - Improved SPECIAL and Slice ASSET 

03/12/2003  AP MRIge81695   Fixed the scan timing problem for Slice ASSET. 

03/14/2003  AP              Changed rhasset to 2 for slice asset as requested
                            by recon. Use MAXSLQUANT3D_FGRE instead of 
                            MAXSLQUANT3D for BBA.

03/18/2003  HK MRIge81744   3D slice data windowing for Fiesta-C.  

03/18/2003  PL MRIge81273   Revert to reverse sequential encoding if centric
                            or reverse centric is selected with 0.5 or 0.75 NEX.
                            Moved REVERSE_SEQUENTIAL code to phase_order_fgre3d.

03/26/2003  RJF MRIge82182  Implementing Navigator Platform on EXCITE-ii

03/26/2003  AC  MRIge83260  Implemented a way to remove line artifacts in high resolution
                            efgre3d scans with fat sat option selected. 

03/26/2003  AP  MRIge81886  slice ASSET to be  compatible with turbomode 2 
                            MRIge81888 - check the number of slices to be multiple of 4
                            for slice ASSET.
                            MRIge81887 - slice ASSET to be compatible with 3D gradient echo 
                            MRIge81889 - set minimum slab thickness for Slice ASSET bilateral acq 

03/29/2003 KVA              MRIge82237 ECTRICKS: Have Min Max values for t phases
                            MRIge82238 ECTRICKS - Change Slab phases to rhnpasses
                            MRIge81874 To reduce use of user CV's

04/05/2003 KVA              MRIge82041  Option Key check.

04/07/2001 AP               MRIge82247 & MRIge82677 BBA - Improved SPECIAL and Slice ASSET 
                            imaging option compatibility checks 
                            MRIge82540 BBA - Put the BILATERAL key present when turning on the 
                            multivolume prescan, improve SPECIAl and Slice ASSET flags
                            MRIge82659 BBA - Multi volume prescan, Improved SPECIAL, and Slice ASSET 
                            should be available only for 3D Fast GRE and SPGR only, not available for 
                            Fast TOF GRE, Fast TOF SPGR, ECTRICKS, FIESTA, FIESTA-C

04/15/2003 AP               MRIge82745 - Reset rhassetsl_R to 1 for non slice asset sequences. 
                            MRIge82820 - Error check for mstation and  multi volume prescan 
                            MRIge82485 - Add the rhassetsl_R assignment to cveval so that Scan can read
                            rhassetsl_R for slice ASSET locs/slab Up and Down button increament. 
                            MRIge82429 - Added existcv on Asset conditional to prevent download failure

                            Also Changed the BILATERAL Option key to BREAST2 Option Key. BREAST2 Option
                            Key will be the key name for the BBA feature. 

04/17/2003 HK               MRIge82045 - Option Key check for Fiesta-C.

04/22/2003 AP               MRIge82738 - Option Key Check for BBA
                            MRIge83130 - Modify assetph_flag conditional so that the flag is not ON
                            when user swicthes 2_BREAST to R_BREAST/ L_BREAST coil. 

04/22/2003  KVA/SVR         MRIge82896 - Excessive ghosting for multi-nex scans
                                         Corrected phase offset calculation
                            MRIge83165 - Error checking for scan locs 
                            MRIge82801 - Mask acq. time should be displayed at prep.

04/25/2003  HK              MRIge83237 - lockout of cardiac gating for Fiesta-C.  

04/30/2003  HK              MRIge83457 - lockout of Resp Trig/Gating, fluorotrigger
                                         and multistation img options for fiesta-c.   

04/30/2003  AP              MRIge83191 - Lockout multi slab for BBA. Set pimultigroup to 0 for BBA. 

05/02/2003  ALP             MRIge82400 - 1024 images/series limit updated for all efgre3d features.

05/05/2003  PL              MRIge82182 - Remove LoopOrder.eh

05/07/2003  KVA             MRIge83575 -  Moved T2prep Tricks check from CV check to Cveval.

05/12/2003  PL              MRIge82182 - vast_mode selection for navs
                            Removed pre-Excite implementation of navigator

05/14/2003  ALP             MRIge82249: Changes for new Crosspoint switch, RtpEnd() task moved
                            such that it occurs right after the RTP acquisition/processing (instead
                            of the end of the scan).  This is needed so the coil switch is handled
                            correctly.
05/15/2003  SVR             MRIge82414 -  Add 1 to dabview to prevent NEX-table
                                          error for ectricks-MRIge82414

05/22/2003  AP              MRIge84072 - Added EM_PSD_VTHICK_OUT_OF_RANGE if the slab thickness for BBA
                            exceed the maximum value. 

05/20/2003  RJF             MRIge84099 - thickslab prjn now reset to 0 with usercv 20.

05/23/2003  RJF             MRIge82249 - cross point 2, clarified RtpEnd
                            logic.

05/21/2003  PL              MRIge84180 - Enable vast_mode for gated FIESTA

05/23/2003  PL              MRIge84319 - Place nav checks prior to vast checks.


05/26/2003  SVR             MRIge82416 - Returned FAILURE when minseqrfamp_b1scale(), mintr() and 
                                         slicein1() fail.
                                       - Added EE_ARGS() support.

05/30/2003  SVR             MRIge84316 - Took out truenex for slice_size calculation 
                                         if NOPROC rawdata is not desired.

05/29/2003  AP              MRIge84540 - Removed error checking for slice ASSET incompatibilities
                            with NPW & ZIP512

05/30/2003  RJF             MRIge82507 - SpecIR is now selected with opspecir, not usercv10.

06/3/2003   AP              MRIge84672 - Lockout GRE and SPGR sequences except for BBA

06/03/2003  SVR             MRIge82977 - Initialise rhrcyres and vas_ovrhd before maxslquanttps()

06/04/2003  KVA             MRIge81948 - Pause ON/OFF and dynamic pull down tricks phases.

06/04/2003  LS              MRIge84810 - max intensity too low with 3D. 

06/06/2003  PL              MRIge81824 - Add ASSET support for 3D MDE and
                            fatsat gated FIESTA
                            MRIge84546 - Add cvcheck to lockout T2Prep with Navs

06/06/2003  AP              MRIge83805 - Fixed tdel annotation for specir pulses for multi phase case

06/10/2003  PL              MRIge81824 - Add ASSET support for 3D MDE

06/15/2003  HK              MRIge85189 - Added appropriate error messages for special, ir_prep,
                            fat and sat imaging options incompatibility with Fiesta-C.

06/17/2003  SVR             MRIge84938 - Make SPECIAL easier to select with 3D-Gated Fiesta
                            Corrected typos in error message strings.

06/19/2003  AK              MRIge85378 - Reorganised logic for setting vast_mode, added error
                            checks to make sure the option key related features cannot be bypassed.

06/23/2003  RJF             MRIge85584 - See SPR enclosure for related SPRs.
                            Fixing trigger delay related issues with 3d MDE and 3D Special FIESTA.

07/21/2003  PL              Call ChemSatEval twice.
                            Reset specir_ti after ChemSatEval calls. 
                            Move VASTtiming to end of cveval1()

07/18/2003  SVR             MRIge86470 - Unlock Turbo mode for SmartSpeed (SR50)
                            systems -Venkat.

07/24/2003  PL              MRIge86743: For FS FIESTA default RBW to 125 and set opautoti


07/30/2003  GFN             MRIge86755 - Enabled Senospeed support for VIBRANT

08/22/2003  SVR             MRIge84131 - Played extra disdaqs for every new
                            slice in the monitor mode to resolve IQ issues.

08/27/2003  AP              MRIge87879 - For extraspecial, reset specir_ti to min_specirti
                            after ChemSatEval instead of 8ms.  

08/27/2003  PL              MRIge87708 - Calculate 1 second worth of disdaqs
                            for SmartPrep regardless of phase encoding order.

09/19/2003  RS              MRIge88413 - Change exist(equant) to equant to correct "slorder"
                            computation with FTMRA

09/25/2003  SVR             MRIge87907 - Enable Turbo mode for ACGD-Lite
                            systems -Venkat

10/17/2003  RS              MRIge88393 - Changed the location of SAT in ftMRA

10/17/2003  GFN             MRIge85082 - When VAST is ON, NEX is internally
                            set to 0.5 and the user cannot change it.
                            So, if the NPW option is selected, we just post
                            a message that says that NPW is incompatible
                            instead of saying that the selected NEX is
                            not valid for NPW.

10/21/2003  PL              MRIge89462 - Added arrhythmia check logic for
                            3D FIESTA Cardiac Gated.

11/13/2003  HAD             MRIge88944 - Fineline Artifact Fix. Increased area
                            for the X crusher gradient.

11/17/2003  AP              MRIge89078 - Changes for VIBRANT:
                            (1) For turbomode 2, used current RF pulses w/
                                slab_fact = 1.0
                            (2) Use sequential ordering for extraspecial.
                                It is defaulted to ON, but the user can
                                turn it OFF with a user CV.

12/22/2003  SVR             MRIge90521 - Separation of Tricks related code in to
                            a separate file ( Tricks.e )

02/11/2004  SVR             MRIge91178: Changes for Simultaneous acq/recon
                            TRICKS.
03/10/2004  ATV/AP          MRIge91682 - LAVA/aVIBRANT initial implementation

03/10/2004  ATV/SXZ         MRIge91683 - Vascular enhancement


03/12/2004  SVR             MRIge91727: Changes for supporting > 1024 im/ser

03/23/2004  ATV             MRIge91973 - Removes unused FIESTA3D code; unbridged
                            read-out rewinder gradient.

03/24/2004  HK/AK           MRIge91352 - SAR/dbdt changes for E3.


03/26/2004   AP             Activate LAVA/VIBRANT from a button on the new 
                            UI. Scan send GE Coil Name to _opcoilid.descr
                            field for PSD to activate the feature.

04/02/2004  SVR             MRIge92209: Changes for supporting Tricks
                            memory usage optimization

04/02/2004  ZL              MRIge91361 - Modified RtpInit and RtpEnd function
                            calls in RTP Server, added RtpCoilSwitch function
                            see details in:
                            /vobs/mgd/aps/adaptive/rtp/rtp/RtpServer.c
                            Therefore, added SmartPrep_CoilSwitch function
                            call for the coilswitch and modified
                            load_SmartPrep_Rtptask 

04/14/2004  AP              Remove pipscvol that controls multi volume prescan. 
                            Now Scan will activate one prescan volume for all PSD but
                            two prescan volumes with 2_BREAST and 8Breast coils.
                            The new Axial/Sagittal VIBRANT activated via the VIBRANT
                            button is controled by VIBRANT2 option Key. 

4/22/2004   AP              Changed the GE coilname to have GE_ in front of it, due
                            to some changes in CoilConfig file.

4/24/2004   ZL              MRIge92895 - check dbdt level to insure shorter TR for 
                            first control level for FIESTA

04/27/2004  ZL              MRIge92832 - add 8916 HFD gradamp type

04/28/2004  SXZ/ATV         MRIge93061: inrease area_gzk and area_gxwex for IRPrep 
                            T1 weighted head imaging.

4/29/2004   AP              Defaulted bandwidth to 31.25 KH for Sagittal VIBRANT and
                            62.5 KH for everything else with turbomode > 1

5/14/2004   LS              MRIge92746 - need to do RUP_GRD to fix the problem for HFD/TRM
                            system ZGRAD processor invalid wait period problem since part
                            of the grad time calculation has psd_grd_wait is not dividable
                            by 4 us.  

6/9/2004    SVR             MRIge94253: Introduced a new CV to indicate whether
                            "Save Series" is pressed or not.

6/15/2004   LS              MRIhc00737: checks for zip vs xres 512 and higher

6/16/2004   AMR             MRIge94165: Lock out Fiesta-C with ASSET

6/21/2004   AMR             MRIhc00484: Lock out multiple NEX prescriptions with
                            ASSET

6/22/2004   LS              MRIhc00679, MRIge94268: 1) lock out no phase wrap
                            for xres > 512; 2) support collapse image for
                            1024 recon (xres==1024 or zip1024)
    
7/7/2004    LS              MRIhc01538 -- lock out asset for xres > 512

8/13/2004   ZL              MRIhc02499: change ELLIPT_CEN_MAX to be maxY (1024)*
                            maxSlice(256) so that ZY_export table would have a proper
                            upper limit. Add a check so that opslquant*opyres is not
                            exceeding ELLIPT_CEN_MAX

7/19/2004   HAD             MRIge92645: Disable Sat page for PC_FIESTA and
                            ungated Fiesta.  

08/22/2004  SVR             MRIge89759: Cleanup code related to burstmode.

09/2/2004   AP              MRIhc01635: PSD will throw error when the VIBRANT Key
                            is not present when type in from the psd field. 

09/9/2004   AP              MRIhc03227: Removed VIBRANT2 Key and use BREAST2 Key
                            instead to run all VIBRANT modes
                            MRIhc02746: Use two prescan volumes only for bilateral 
                            VIBRANT, all others only use one shim volume.

09/10/2004  LS              MRIhc02932: turn off pure filter for tof mode.

10/18/2004  LS              MRIhc04159: opslicecnt should not be > 0 if acqs == 1.

10/15/2004  AP              MRIhc41013: For Axial VIBRANT, use chemsat_dda=2 for 
                            bandwdith greater than 60KH and chemsat_dda=1 for
                            lower bandwidth to remove banding/stripes slice
                            direction. 

10/28/2004  AP              Axial VIBRANT: removed the 32KH bandwith and 
                            replaced it with 50KH bandwidth. The minimum
                            bandwidth would be 42KH.

11/06/2004  ZL              MRIhc04779: set up a sequence with 200ms delay
                            for Rtp_end() and CoilSwitch function call. 

12/14/2004  YI              FIESTA-C enhancement for value 1.5T. 
                            Initial coding for silent mode support. 

12/22/2004  ZL              MRIhc05287: moved the Rtp_end() and CoilSwitch function
                            into Monitor.e (monitor_signal), therefore, remove
                            the corresponding code from efgre3d.

01/27/2005  ZL              MRIhc05807: add HFD-S (8917) gradamp type

02/01/2005  AP              MRIhc05836 - Set rhinitpass = rhnpasses for VIBRANT
                            with asset. All BAM should be available prior to scans
                            including allocation for all phases to be acquired.

02/17/2005  AP              MRIhc06064 - Use the same crushers as irprep for regular
                            3DFSPGR applied for brain application to improve IQ

03/02/2005  LS              MRIhc06378: remove gradamp type check, turbo mode should
                            be enabled for all DV MR config.

04/14/2005  YI              Supported Auto Voice.
05/11/2005  YI              Supported rect FOV with NPW.
05/16/2005  YI              Added de-rating for FIESTA with HFD-S-lite.

04/22/2005  ARI             MRIhc07063: Added write_nav_data_file() for Navigator
                            Set time_ssi to 200ms for VAST mode


05/19/2005  AMR             MRIhc07358: Merge of SPR fix for YMSmr06691 from
                            Value 1.5T to HDMR2. The default value of opuser1 for the 
                            type of phase cycling should be set to the basic
                            scheme (similar to 12.0).

05/26/2005  HH              MRIhc07580 : Switch in sh3t2.rho and pha for 3T for IR-SPGR
                            All changes labelled with MRIhc07580 HH May 2005

05/28/2005  ARI             MRIhc07063: Added write_nav_data_file() for Navigator

06/03/2005  ARI/MF          MRIhc07226: Navigator Enhancements: 
                            cylindrical navigator & slice tracking

06/15/2005  ATV             MRIhc07974: COSMIC initial implementation
06/21/2005  KA              YMSmr06958: Supported Fat Sat FIESTA without cariac gating
                            (ungated FatSat FIESTA). Setting allow_ugfsf to 0 locks out
                            this feature.


06/28/2005  AMR             MRIhc07357: Merge of fix from Value 1.5T
                            Dynamic plan is incompatible with Multistation.

07/10/2005  SVR             Changes for SWIFT.
07/17/2005  YI              YMSmr07288: Changed kiss-off slices for FIESTA.

07/19/2005  HK              YMSmr07350: turn off torch1 recon for Value1.5T

07/29/2005  YI              YMSmr07158: Forbade Fat SAT to avoid annefact like
                            artifacts on value.
07/29/2005  YI              YMSmr07277: Forbade SAT on FIESTA to avoid banding images.

08/02/2005  ZL              MRIhc07887: needs to support RTMRA with LAVA-XV

08/04/2005  AP              MRIhc09097. Removed ap config check for sagittal VIBRANT
                            since in 14.0 we use VRE instead of Reflex config.

08/24/2005  CRM             MRIhc09598. Included rhhnover views for each IR
                            prep segment in avmintscan calculation.


08/25/2005  AP              MRIhc09278, MRIhc09277, MRIhc09279: Turn off B1 opt for
                            sagittal VIBRANT at 3T.

09/02/2005  AP              MRIhc09362: For 3T VIBRANT, TE is defaulted to Full Echo
                            in-phase to have expected IQ.

09/23/2005  AMR             MRIhc10432: Disable ASSET with Fiesta-C. The functionality
                            was enabled with the Value 1.5T merge to HDx.
                            However, it will be enabled for Value 1.5T systems. 

09/22/2005 CRM              MRIhc09877 Don't allow more overscans than frames.

09/28/2005 CRM/TRS          MRIhc10697. Use modified phase_order_fgre3d support 
                            routine to allow using the full y-res for the 2D
                            FTMRA mode.  When using FTMRA, play a 3d DAB packet
                            during the first disdaq to notify recon of the 
                            switch from 2D FTMRA mode to 3D mode.

10/12/2005 HKC, AP          MRIhc10961: Corrected fwphase_fullecho implementation, 
                            mainly fullte_flag setting.  Added vibrant-xv PSD name 
                            check to activate ARC.

10/20/2005 HKC              TE for vibrant-xv was getting set to MinFull as 
                            arc_research_flag sets opautote after brava_flag.
                            Added if-not-3T-Axial-VIBRANT for setting opautote
                            to MinFull for ARC.

11/07/2005 AP               MRIhc11880 - Set opslblank, pislblank, and rhslblank to zero so that
                            reconstructions slice start at the first location for Sagittal
                            VIBRANT.

10/19/2005 AP               MRIhc10282 - PSD now removes "Bolus (Not) Detected" message 
                            with a new agp function rsp_psd_err_clear. Previously, this 
                            was cleared by RTP. PSD receives the detected flag from the 
                            global smartprep buffer. The function was executed after 
                            monitor signal within smartprep_flag in the scan section.

11/15/2005 MSK, CRM         MRIhc11575 - Packed the zy_export structure array into a zy_export_packed 
                            structure array. This size is 25% of the original size. The purpose was to
                            use this packed array in the ipgexport section instead of the original zy_export
                            array to speed up CV download time and decrease CV file size. The packing is done
                            at the end of function predownload and the unpacking into the zy_export structure
                            array is done at the beginning of function pulsegen.

12/15/2005 CRM              MRIhc12606 - Removed unused argument to ugfsf_view_order()

12/20/2005 CRM              MRIhc09608 - For SWIFT, always setup prescan volume 
                            and coil when switching entry points.

01/30/2006 KA               YMSmr08768 - prohibitted odd nex NPW for ungated FatSat FIESTA.                            

02/07/2006 CRM              MRIhc13033 - Use SwiFT prescan coil switching function
                            from Prescan.e

02/09/2006 RKS              MRIhc13419 - Following RBWs need xRes to be in multiples of 4 since the hardware
                            does not support other resolution (per James Zhang)
                            200 kHz, 142.85 kHz, 111.11 kHz, 90.91 kHz (fractional decimation filters

2/10/2006  AP               MRIhc13407 - Move the MPH/DynaPlan front check before the checking
                            of the number of slices. 

2/17/2006  AP               MRIhc13682 - Axial VIBRANT should not be compatible with grayed out imaging options
                            when type in.

02/18/2006 CRM              MRIhc12595 - Use function in efgre3d_iopts to set vast_mode.

03/03/2006 HKC              MRIhc11441 - For Axial VIBRANT with field strength > 1.5T, 
                            set flip_rfcssat to 180.

04/12/2006 ARI              MRIhc14923 - Remove GRAM model.

04/13/2006 HH               MRIhc14895 - IRprep download failure with XRMB changes

05/15/2006 ATV              Added infrastructure to support 3D Multi-echo acquisition (MEDAL, MERGE etc.) 

06/06/2006 HAD              MRIhc15630 - With 3DFGR+IR-Prep+gated get SAR exceeded messages
                            with smaller patient weights (~10Kgs).

06/26/2006 EB               MRIhc16180 - Add fractional NEX support for ARC

06/27/2006 CRM              MRIhc16278 - Updated ZY_EXPORT table and add
                            "dynamic" ZY_EXPORT table download.

06/29/2006 RV               MRIhc16353 -  IDEAL changes integrated into efgre3d. All IDEAL-related 
                            changes contained within (ideal_flag == PSD_ON). Can be located with 
                            comments that contain "RV: IDEAL change"

07/10/2006 ARI              MRIhc16496 - Change minseq() function interface.

07/12/2006 RV               MRIhc16579 - TRICKS functionality was broken because of cvoverride
                            of opnecho incorrectly in case of TRICKS too. Merged all IDEAL
                            init and eval code into multiEcho_init() and multiEcho_eval() calls.
                            Also removed ideal_on check in SIM case.                                      

07/26/2006 RV               MRIhc16353 - Completes changes needed for full functionality of
                            IDEAL for Phase 1.
                            * dixon_necho default value changed from 3 to 1
                            * ideal_debug options created for host recon support 
                            * Moved a whole bunch of IDEAL initialization code into multiEcho_init()
                            * Bunched together all IDEAL-related cveval code and moved into multiEcho_eval()
                            * ideal_pi, two_thirds_pi and one_half_pi made multiples of one_sixth_pi
                            * IDEAL-specific rhCV setting moved into predownload section
                            * Fixed reason for minTE echo shift from position as in non-IDEAL efgre3d acquisitions, pass
                              the number of points acquired before the echo on the readout to recon via rhfeextra
                            * Moved ideal-specific ihte1, ihte2, ihte3, ihdixonte, ihdixonipte and ihdixonoopte changes into
                              the predonwload section
                            * minTE Rx requiring centering of echo in readout direction accomplished by informing recon
                              on rhfeextra as well as by setting rhrcideal's 4th bit

08/08/2006 RV               MRIhc17126 - File-write host recon implementation logic for ASSET cases, where the original
                            implementation was found to be faulty.

08/15/2006 VSN              MRIhc14873 - Reintialization of *rt and *ft values before calcOptimizedPulse() 
                            call to avoid printing of wrong value of srderate in dbdt.log

08/16/2006 RV               MRIhc17355 - Added support for IDEAL option key, removing the hidden file for IDEAL 
                            activation.

09/07/2006 RV               MRIhc16353 - IDEAL changes made to meet more PSD specifications
                            * Min xres and yres made 128 for IDEAL
                            * opvquant > 1 not allowed for IDEAL
                            * ihnex multiplied by 3 for IDEAL

09/07/2006 EB,CRM           MRIhc18076 - Added box sampling support for 2D self-calibrated 
                            parallel imaging (ARC). As part of the support, zy_export 
                            is changed to dynamic structure and it is the lookup table for 
                            sampling pattern. Calculations are done on an unaccelerated & 
                            non-partial kspace size. Furthermore, partial Fourier calculations 
                            with self-calibrated acceleration are also separated from each other 
                            as ASSET type uniform k-space coverage is no longer valid. 
                            See efgre3d_support.c for the support routines.

09/08/2006 ARI              MRIhc18055 - Remove pgen_debug flag.

09/21/2006 RV               MRIhc16353 - Generalizing and extending the logic for calculating
                            ihdixonipte and ihdixonoopte to any value of k_ideal_pi, beyond 
                            k_ideal_pi value of 2, which is what was coded originally. During
                            1st round of testing on 3T, it was found that k_ideal_pi values
                            beyond 2 are easily reached for small FOV, high-res Rx's, hence
                            this change is critical.

                            MRIhc18634 - Data acquisition failure caused by non-resetting of
                            seq_necho to 1 in non-IDEAL cases is fixed. This was fixed earlier,
                            but got missed out in an early promote.

                            MRIhc16353 - Also made area_gzk = 3000G/cm.micro-sec for SPGR-IDEAL
                            to overcome some steady-state effect which caused an underestimation
                            of water:fat ratio.

09/26/2006 CRM              MRIhc18622 - Convert to use parts of Asset.e.
                            Does not use AssetCheck or AssetMinFov sections.

06/22/2006 TS               MRIhc16194: coilInfo related changes

07/10/2006 TS               MRIhc15304: Changes for HDv to change coil by changing
                            hubindex using SSP packet for RG

08/25/2006  CRM & RKS       MRIhc18543 - With IR prep, scan time is calculated incorrectly for
                            partial kz acquisition.
                           
10/18/2006 CRM              Account for slice zip in maxslquanttps.

10/25/2006 RV               MRIhc19003 - (1) UI behavior on copy/paste of IDEAL
                            Rx to turn OFF IDEAL imaging option was an issue
                            because opnecho was being forced to 3 in IDEAL case
                            by cvoverride calls in init and eval. Since IDEAL
                            is an imaging option, turning it OFF only causes an
                            eval to be done with no init call. This leaves
                            opnecho set to 3, causing opetl to be set to 3 and
                            3dfspgr starts off as T2* mapping multiEcho 3DFSPGR,
                            where NEX and TE are non-Rx'able. To fix this,
                            all references to opnecho in IDEAL case are removed,
                            and ideal_necho is used in its place. opnecho is
                            only a dummy variable for IDEAL now.
                            (2) opdixproc was not getting reset to 0 when IDEAL
                            imaging option is turned OFF and 3DFGRE/FSPGR is
                            Rx'ed. This is fixed by forcing opdixproc to 0 in
                            non-IDEAL, non-MEDAL cases in init and eval.
                            (3) The BAM model for 3DFSPGR/FGRE with IDEAL needs
                            rhinitpass to be set for multi-phase acquisitions.
                            This will be set to min of opfphases and 3 since
                            IDEAL is supposed to be used only in non-contrast 
                            scans, so that BAM will be allocated for acquisition and IDEAL
                            processing for at most 3 phases only, allowing high-
                            res scans. 
                            (4) Advisory Panel Error with No Solution Found was
                            occurring for respiratory gated scans with IDEAL
                            since cvmin and cvmax of opnecho was incorrectly
                            being set to 1 inclusive of IDEAL case. This is
                            fixed now.

11/15/2006 JM               MRIhc19567 - Conversion of 2D Fast GRE to 3D Fast GRE fails.

10/09/2006 HH               MRIhc18869 - port fix from 12.0/14/0 for bright vessles in IP-Prep SPGR.
                                         Change gscale_rf0 for sh3t2.rho to 0.3. 

11/09/2006 UN               MRIhc16039 - Fix for Longer TR in COSMIC for lower weights.

11/23/2006 RV               MRIhc20531 - Incorrect annotation of TE for in- and
                            out-of-phase images with IDEAL for 3DFSPGR

12/08/2006 VAK              MRIhc20775 - Scan time difference observed with multiphase option

01/11/2007 RV               MRIhc21429 - During VATP testing, it was decided
                            original echo images won't be saved to database
                            by default. Default value of opdixproc is made 1
                            in case of IDEAL now. Also, coil-combine operation
                            control now moves to PSD control, so rhrcdixproc's
                            12th bit is turned on only if multi-coil and not
                            phase or slice ASSET now.

01/11/2007 EB               MRIhc21457 Switched LAVA-XV RF to LAVA RF pulse
                            Increased calibration sizes and removed extra crusher
                            1D acceleration is 100% of maximum possible accel
                            Removed obsolete multiple of 4 requirement for arc
                           
01/30/2007 SWL              MRIhc20751 In multiecho_init(), the opnecho is set to 1 for non-multiecho
                            sequences to avoid advisory panel error on ETL when switching between
                            multiecho (e.g. TRICKS) and non-multiecho sequences (e.g. Vasc TOF SPGR)

02/02/2007 ZL               MRIhc21427 - change fgre_loaddab_echo1 function call to resolve the bad 
                            Hub index issue with Tricks. 

01/25/2007 VAK              MRIhc16225 - Removing a check from endview fucntion call and 
                            making the change in efgre3d.e

02/09/2007 SWL              MRIhc21416 Increased area_gxwex to 4000 to reflect
                            the change made in 14.0 (MRIhc17788).

01/31/2007 HAD              MRIhc18659 Added support for PEDiatric SAR model for.

14/02/2007 SHM              MRIhc16236 and MRIhc22382 - Added option key check for COSMIC, LAVA, and LAVA-XV.

02/20/2007 SWL              MRIhc21964 - Modularized arc_factor related functions.

03/02/2007 EB               MRIhc22784 - clean up variable kissoff code and removed not Vibrant-XV checks

03/07/2007 EB               MRIhc22868 - account for linestodiscard in generateZyExport

03/20/2007 RV               MRIhc23207 - Disable swap_fat_cs flag in IDEAL, TRICKS and multitr MEDAL cases
                            MRIhc22014 - Enable fldata dump ON by default for IDEAL

03/12/2007 EB               MRIhc21457 - switched LAVA, LAVA-XV, MERGE and MEDAL to multi-slab

03/26/2007 EB               MRIhc23320,MRIhc23375 - force cross cal with 1D accel. Don't write kacq if R=1

03/22/2007 SWL              MRIhc21901, MRIhc23348, MRIhc23349 - new BAM model supports multi phase, 
                            dynaplan phase, and requires less input arguments in maxslquanttps().

04/06/2007 EB               MRIhc22783  Allow ftMRA with QUICKSTEP

05/11/2007 SW               MRIhc24149  Fix the DualEcho support for efgre3d

05/17/2007 EB               MRIhc24281  Added walkSamplingPattern() to calculate the exact scan time. 

06/18/2007 EB               MRIhc24709  Check for LAVADE, VIBRANTDE and QUICKSTEP option keys

06/22/2007 SW               MRIhc24880  Enable Tukey slice window for MEDAL when slthick >= 3mm.

06/27/2007 LS               MRIhc24436, MRIhc20970: Supports for displaying grayed out fields: TE/TR/TI/RBW. 

06/27/2007 SRW              MRIhc24341, Enable acq to disk with multiphase VIBRANT-DE 

07/02/2007 EB               MRIhc10173  phFOV > 1 support for LAVA and VIBRANT based applications

07/02/2007 EB               MRIhc22327  1D Box sampling support with 2D acceleration

07/12/2007 EB, CRM & VSN    MRIhc10955: TRICKS enhancement for HD Lower Leg
                            coil to minimize eddy-current effects due to
                            inter-region jumps.

07/18/2007 EB               MRIhc17394 - Port from 14.0. Corrected Tdel time stamp calculation for Vibrant Mph 
                            with Special.

07/18/2007 EB               MRIhc17479 - Port from 14.0. Minimum FOV for ASSET scan should be set based on 
                            Asset.e AssetMinFOV section.

07/18/2007 EB               MRIhc21113 - Port from 14.0. Change the load3d call for the dummy pulse for FTMRA

07/18/2007 RV               MRIhc23627, MRIhc25344: ChemSat options need to be grayed
                            out for IDEAL by default, in- and out-of-phase options
                            for opautote and displayed values are meaningless
                            for IDEAL. pichemsatopt and pisupnub set to 0, cvmax
                            of opautote made 2, pite1nub set to 6, only pite1val2
                            and piteval3 set to the PSD computed values. MRIhc23627 
                            also calls for Chemsat UI to be unavailable with MEDAL as 
                            well; also, turn pisupnub back to 1 in non-IDEAL/MEDAL 
                            cases. Rearranged code in multiEcho_init function to handle
                            IDEAL case first so as to not turn on multiEcho_flag even
                            during init.

                            As per new requirement, IDEAL shall have Water and Fat ON
                            by default as Dixon processing options. Accordingly, cvdef
                            of opdixproc set to 3, and 0x0002 added to rhrcdixproc value
                            for IDEAL. 

07/19/2007 EB               MRIhc25374 Need to check ARC key from psd side 

07/25/2007 EB               MRIhc25590 Switch BRAVO to centric order. Open up NEX field. 

07/27/2007 SW               MRIhc25657 Enable Spatial SAT for LAVADE/3DE.

08/08/2007 EB               MRIhc25992 Lock LAVADE/VIBRANTDE to 1 slab.

08/17/2007 EB               MRIhc26140 Scale down rhuser0 (3D) by rh3dscale and 
                            rhscalei (2D) by rh3dscale to avoid overrange at 3D -> 2D   

08/17/2007 EB               MRIhc24466 Removed scan time update at predownload 

08/19/2007 SW               MRIhc26220 Only enable multi-TR acquisition mode for LAVADE,
                            VibrantDE and 3DE when arc_research_flag is ON.

08/20/2007 SW               MRIhc26269 Fixed the bug that 3D Dual Echo Mode could not be 
                            activated from a saved protocol. 

08/22/2007 EB               MRIhc25788 Fractional echo (minTE) support for ARC

08/24/2007 EB               MRIhc10173  phFOV > 1 limit to 1.9 and update rhimsize, rhrcyres, rhrcxres
                            and put ASSET and axmaxyres limits. 

08/29/2007 KK               MRIhc22324 Fast table movement with multi station

08/31/2007 KK               MRIhc20325 Remove UserCVs for multi station

09/10/2007 EB               MRIhc26757 Uniform acceleration support with box 

09/11/2007 SW               MRIhc26692 Check minval for rhmedal_smooth_kernel_size to avoid download
                            failure when opslthick is bigger than 6.0mm.

09/12/2007 YI               YMSmr09956: savedata and TR_PASS are controled by environment variables.

09/18/2007 EB               MRIhc26772 Added !(TRICKS or SWIFT or MERGE) check to trigger Dual-Echo  

09/25/2007 EB               MRIhc26821 piechnub is incorrect use: switched to pulldown menu 

10/04/2007 SW               MRIhc27137 set opte2 value for LAVADE/3DDE/VIBRANTDE

10/05/2007 LS               MRIhc26688 set No Echo button as bit mask (piechnub).

10/10/2007 RV               MRIhc27316: ihdixonipte, ihdixonoopte computation logic
                            changed to make it less confusing with single-peak IDEAL.

10/10/2007 EB               MRIhc26480 Switched LAVA-DE and Dual Echo to pfkz. Vibrant-DE:pfkr

10/11/2007 EB               MRIhc25812,MRIhc25827,MRIhc27203 Switched autocalibrated PI support to ARC

10/16/2007 ATV              Added infrastructure to support flexible TR/TE. 

10/23/2007 KA/EB            MRIhc27185 Move kacq file generation to predownload and write 
                            a time-stamp labeled kacq file. Host cleans up at end exam.      

10/24/2007 EB               MRIhc27888 large-selective excitation support  

10/25/2007 SW/GFN           MRIhc27123: Fixed the avminfov and avmaxxres calculation bug

10/30/2007 EB               MRIhc20185: ARC UI support. Separate psd ARC logic from opgem

11/07/2007 ATV/SW           MRIhc28508: Fixed LAVADE download failure caused by DAB overlap

11/12/2007 EB               MRIhc20185: ARC UI support and typein removal 

11/20/2007 EB               MRIhc29163: ARC recon performance model changes 

11/27/2007 RV/EB            MRIhc20624: The target pfkr_fraction being set to 0.6 with NPW on means
                            that with the worst-case anisotropicity of 1024 views and
                            8 slices, the actual pfkr_fraction used, pfkr_fraction_act
                            becomes more like 0.5, so the min value of this CV is made
                            0.5 in cases where NPW is turned ON. Without this change, it
                            was observed that pfkr_fraction_act was set to 0.53, leading
                            to a download failure in NPW with minTE cases.

11/30/2007 LS               MRIhc28660: Need to set pite1nub correctly to ensure TE field disable
                            /enable when swtich between 1 and 2 echoes.

12/10/2007 RVB              MRIhc24440: Syscheck failed when IDEAL + IRPREP is prescribed because of 
                            The value of act_tr is passed through minseq() for pulsegen-on-host 
                            feature. There is a difference between the value passed 
                            from cveval1() and syscheck() when minseq() is called from cveval1(), 
                            tmin is passed and when it is called from syscheck(), avail_image_time is passed. 
                            Replacing act_tr with tmin to calculate PosGzp.

12/10/2007 ATV/EB/SW        MRIhc25811: Added infrastructure to support adaptive TE optimization

12/21/2007 SW               MRIhc31087: Add option key check for 3D Dual Echo

12/21/2007 RBA              MRIhc26882,MRIhc30257: Option key check for 3D MERGE Protocol Loads and Add TE annotation
                            for 3D MERGE individual echoes

12/26/2007 VSN              MRIhc31301: pipscvol was not getting set to 2 for VIBRANT-IDEAL               

12/31/2007 EB               MRIhc31558: ARC acceleration logic implementation               

01/01/2008 SW               MRIhc25811: Set the max value of opxres to limit TE less than 1.5ms
                            and TE2 less than 2.8ms for most of the clinical protocols

01/07/2008 CRM              MRIhc31929 - Add loaddab wrapper functions 
                            for compatibility with previous releases.

08/01/2008 EB               MRIhc30104: Recon model performance support 

01/18/2008 RV		    MRIhc32324: When a saved IDEAL protocol is loaded on a system without IDEAL
            		    option key installed, "opdixon out of range" error rather than "IDEAL is
	                    not available without the option key" pop-up message. Added appropriate
            		    epic_error call when option key is not present. Also, as cvinit is called,
	                    made the setting of cvmax of opdixon 0 when key is not present only on existence
            		    of opdixon, else it is the "opdixon out of range" error pop-up that takes
	                    precedence.

01/22/2008 VSN              MRIhc32324: This is to fix a miss in the above promote. The opdixon check needs to be 
                            added in multiecho_eval also.

02/04/2008 RV/VSN           MRIhc32537: avminxres and avmaxxres were calculated only when opfov was between
                            avminfov and avmaxfov for MEDAL. Thus when an invalid FOV is entered correct xres 
                            was not calculated causing the multiple advisory state. It also cause FOV to be in
                            wrong state as the XRES was calculated with a different FOV.     

01/08/2008 EB               MRIhc33223: Lock BRAVO IRPrep ON and 100% slice res. remove vibrant-xv typein 

02/15/2008 ALI              MRIhc33013: added !ftmra_flag check to oprealtime and asset check to prevent download
                            failure of opfluorotrigger with ASSET.

03/13/2008 ZZ               MRIhc34151: SPECIAL Key check.
                            MRIhc33972: UltraFast Option Key check.

03/19/2008 AKR              MRIhc33773: Update rhnecho at eval time for Recon Lag Model. 

03/21/2008 ALI              MRIhc34181: removed incorrect error message for SQP with extraspecial_flag 
                            and axial vibrant. SQP is now disabled in imaging options 
                            for sagital vibrant with extraspecial_flag and axial vibrant.

03/31/2008  XZ              MRIhc35530: Corrected the miscalculation of Slice_limit, the multiphase factor was twice multipled 
                            to calculate the slice_limit. 

04/10/2008 VSN              MRIhc35599: FOV-XRES curves for Dual Echo for HDxt are put in. This promote includes 
                            curves for 1.5T CRM.

04/11/2008 VSN              MRIhc35574: SWAN stops scanning midway. Put the old fgre_loaddab_echo1 and echo2 back.
                            This also makes spgr_flag ON when SWAN is enabled. 

04/14/2008 ALI              MRIhc34854: ogsfZ removed from min slice thickness calculation.  

04/14/2008 ALI              MRIhc35723: added min slice thickness limitation for LAVA-DE, VIB-DE to ensure 
                                        in-phase, out-phase TE times.

04/15/2008 VSN/EB           MRIhc35895: FIESTA-C scan time to account for corner removal with 0.5NEX and 0.75NEX

04/15/2008 VSN              MRIhc35885: DE/MEDAL will have 1mm as minimum slice thickness and maximum allowed 
                            bandwidth at 1.5T will be 125KHz

04/15/2008 EB/VSN           MRIhc35857: type-in Vibrant-XV support restored. If the psd name is not vibrant-xv setting
                            opgem = 0, arc_flag = 0, vibrantxv_flag = 0;

04/16/2008 ALI              MRIhc35905: FOV-XRES curves for 3T CRM.

04/18/2008 VSN              MRIhc35438: SWAN : Increasing the maximum allowed flip to 35

04/18/2008 ZZ               MRIhc35831: set default value for equant to avoid the failure when Navigator option is selected 

4/21/2008 KA                YMSmr11391: minimum gradient scaling factor (ogsfMin) for HDe2 is 0.3.

4/22/2008 KA                YMSmr11392: For HDe2, set piechnub to 2+4 even when ASSET is selected.

04/21/2008 VSN              MRIhc36064: SWAN : This promote fixes the following issues
                            - Option key check not available 
                            - Setting up swan_flag on SWAN activation from UI. This was missed on 20.0 syncup
                            - Eliminating the bug in setting the FA up to 35     

05/13/2008 EB               MRIhc36810: Limit the 4ch coils to 1D ARC acceleration.     

05/13/2008 XZ               MRIhc36786: update the calculation of max No. of slices when ARC is turned on

5/20/2008 KA                YMSmr11463: - recovered gradient derating for HDe oblique LAVA

5/20/2008 KA                YMSmr11449: - added gradient derating for HDe 3D dual echo
                                        - HDe 3D dual echo does not use adaptive TE optimization
                                        - bridge gxw2 and gxwex for HDe 3D dual echo

05/14/2008 XZ               MRIhc36899: Update the calculation of slice_size to support ARC by replacing
                                        1+rhnframes+rhhnover with rhdayres in the equation

05/20/2008 RVB              MRIhc37023: The minimum bandwidth for SWAN should be 31.25KHz. 

05/22/2008 ATV/VSN          MRIhc37130: swanEcho2Skip Changed to swanFirstTE. Default TE values are added for SWAN feature.
                            - Corrected merge_necho calculation.
                            - Cleaned up BW and XRES code 
                            - Fixed TR pop-up issue
                            - Changed the default SLICES declarations. Changed them back to 14.0 values to avoid prep failures.   
        

05/22/2008 ALI              MRIhc37053: corrected 2nd echo time UI display for multitr mode for LAVA-DE, VIB-DE.

05/26/2008 VSN              MRIhc37124: Fix from MRIhc34151 was missed from the backward merge from 20.0          

06/04/2008 XZ               MRIhc36459 - rhrawsize is upgraded from an INT to an N64.

05/28/2008 EB               MRIhc37692: Update the logic to handle ARC acceleration factors. 

06/10/2008 VSN              MRIhc37251: Graying out SPECIAL button on UI for FIESTA when FATSAT FIESTA option key is not present.                              
06/10/2008 EB               MRIhc37774: updated the Ny extent for kacq: 3/4NEX + ARC fix

06/17/2008 RV               MRIhc37957: Partial-ky acquisitions (0.5nex and 1nex NPW) with IrP FSPGR resulted
                            in severe artifacts with IDEAL technique. Turns out this was because partial ky
                            acquisitions with IrP are incompatible with elliptical corner removal and hence,
                            enable homodyne with low overscans (16*nop). The artifacts resulted from incorrect
                            rhtype and rhtype1 settings that enforced homodyne recon of the original 3 echo
                            images, thereby resulting in loss of phase information critical for IDEAL
                            processing. Due to the lack of in-house verification and validation of homodyne
                            with efgre3d IDEAL, it is decided to lock out fractional-NEX homodyne scans
                            with IrP FSPGR with IDEAL.

06/30/2008 RV               MRIhc37790 - Scantime was incorrectly computed by
                            pitscan in IrP+IDEAL cases, fixed by multiplication
                            ideal_necho to the avmintscan increment for IrP
                            cases. This multiplication is valid only for FGRE
                            cases, not FSPGR because the IR pulses are played
                            out only once per 3 echoes' complete slice encode
                            loop.

07/02/2008 ALI              MRIhc38426, MRIhc38437: multitr mode for vibde updated to get the first out-phase 
           ATV              and first in-phase when medal_multitr_flag is on. For vibde TE range tightened for 
                            OOP and exact IP TE based on 440Hz w/f separation assumption,
                            improved medal_te2 calculation so exact IP TE can be used. Min BW for vibde multitr acq
                            updated to 142.86KHz. For axial vibde bipolar acquisition new TE curve introduced to 
                            limit TEs to 1.3 and 2.5 ms. For sagital and vibde multitr mode TEs will be limited by old 
                            curve to 1.5 and 2.8 ms.  

07/08/2008 VSN              MRIhc38427: Navigator + FAT + Trigger Delay set to Recommended mode was causing download
                            failure because of improper handling of tdel1_time. The trigger delay time is handled as
                            dda's when vast_mode is ON. Hence the trigger delay time (tdel1_time) should not be part of
                            cs_satstart.

07/09/2008 SW               MRIhc38556: Add Breast coil check for LAVA-Flex.

07/10/2008 EB               MRIhc38431: Scale COSMIC signal down (rhuser0) as an overrange precaution

07/10/2008 SW               MRIhc38556: Add Breast coil check for LAVA.

09/04/2008 SW               MRIhc39688 - Add Inh-3DIFIR feature based on Naoyuki Takei's prototype.

09/12/2008 FUKU             MRIhc39772: Added infrastructure to support 3D SWAN.

09/18/2008 YS               YMSmr12248 - There are the following modifications to support IFIR on HDe2 system.
                                         1. Changed fiesta_gated_dda to 6 to optimize TI for HDe2.  
                                         2. Changed the popup menu of Trigger Point.

09/15/2008 ATV              MRIhc40746: Added infrastructure to support adaptive TE/TR optimization.

08/06/2008 VSN              MRIhc39234: Sync up from DVMR. Added the missing brackets in cs_satstart.
                            Also, taking the FA fix ( YMSmr11783)from Hino ( Asano-San)

08/22/2008 SW               MRIhc39379 - Add Inh-3DIFIR feature based on Naoyuki Takei's prototype.

09/19/2008 VSN              MRIhc39891 - Usercv15 was not getting updated with CG. Corrected the issue 

10/11/2008 RV		    MRIhc40164 - min_seqgrad was not scaled by
			    osfp_weight for COSMIC

10/16/2008 SW               MRIhc40306 - Fixed the SpSat bugs in IFIR 

12/05/2008 EB               MRIhc41187: Add Multi-NEX support to LAVA-FLex. Removed redundant evennex
                            and oddnex CVs. Switch to pfkr with LAVA-Flex and increase partial Fourier fractions 
                            when multi-NEX is selected. Don't allow oddnex-npw with LAVA-Flex. Add NPW with LAVA+ARC

12/30/2008 SW/CRM           MRIhc39347: Moved xres-FOV curves to efgre3d_support
                                        Add the xres-FOV curve of 3DDE for DV2 1.5T

12/31/2008 SW/CRM           MRIhc37978: Move the position of rsp_psd_err_clear() to keep the
                                        (No) Blous detection message until the scan finish

01/06/2009 ZZ/EB            MRIhc41231: Add LAVAXVKey check against lava_flag to prevent D/L error when LAVAXVKey missing

01/12/2009 SW               MRIhc39210: Add the rewinder_flag/zrewind_flag check for gy1r/gzp
                                        to avoid runtime error.

01/20/2009 SW               MRIhc41589: Remove the typein psd name "Inh-3DIFIR" since the UI is ready.

01/26/2009 SW               MRIhc41648: Improve the workflow of IFIR by adding the avmaxslquant check.

02/03/2009 EB               MRIhc41840: ARC clean up. Remove HDx kacq and update local ARC variable names. 
                                        Set Recommended acceleration to userCV entries arc_research mode

02/05/2009 EB               MRIhc41746: Force all phases to fit into BAM for >=16ch scans with ARC to cope with 
                            increased recon lag. Improve QuickSTEP BAM model. Generic multi-station BAM model 
                            scales down BAM size by number of station. QuickSTEP no longer scales down BAM by number 
                            of stations. QuickSTEP has multi-channel coil only on lower leg hence if Arterial + venous 
                            phase for each station fits into BAM with a 1GB buffer for other stations, PSD will allow Rx.
                            Model needs to be revisited if multiple Multi-channel coils are used with QuickSTEP. Lift
                            VIBRANT + ASSET BAM availibility for all phases limit. Only 3 will suffice. 

02/18/2009 SW               MRIhc42136: Changed the FA in the UI to 50 and 70 for IFIR on 3T.

02/18/2009 JX               MRIhc42138: sync up zy_views and phaseres in set_gy1_gy1r_params() to fix the bug of opyres cv eval error.

02/19/2009 SW               MRIhc42162: Do not check "FIESTA" and "FSFIESTA" option keys for IFIR.

02/24/2009 ZZ               MRIhc42243: Support SMARTPREP for LAVAXV; Open CV13 for LAVA

02/25/2009 ZZ               MRIhc42270: Add multiTR support to LAVA-FLEX in clinic mode

03/11/2009 KK               MRIhc42482: Corrected bw_rf1 and iso_delay for
                            ns3d_flag.
              
03/16/2009 YI               HDsv: SPECIAL support on 3D FIESTA-C

03/16/2009 YI               GEHmr02454: Support only APC with SPECIAL.

03/17/2009 JX               MRIhc42617: Allow asymmtric regions of upper and
                            lower calibration areas to avoid the scan time
                            increasing error with increasing slice
                            acceleration factor for small number of slices.

03/17/2009 ZZ               MRIhc42618: Limit the scope of swap_fat_cs to
                            single-echo FSPGR/FGRE only.

03/25/2009 JAH              MRIhc42752: Use the setupPowerMonitor function
                            so we can pass the established average SAR for
                            pulse monitor guard band calculations. 

04/01/2009 ZZ               MRIhc42671: Increase time_ssi to address SSI watchdog timeout issue.
                            Added 32us to regular efgre3d application, and 20us for FT. Scope is limited to DV platform only.

04/20/2009 EB               MRIhc43105: Correct scan time when FMTRA + Acqs b4 Pause > 0

04/28/2009 EB               MRIhc43145: VIBRANT-Flex SAT performance and scan time fix. Introduced encode_group CV to provide 
                            MRIhc43146: more flexible view orders to support non-separable sampling patterns such as 
                                        corner removal, ARC box/elliptical sampling. Could be extended to other apps

05/16/2009 EB               MRIhc43585: Revert the minRBW for VIBRANT-Flex in multi-tr mode back to 31.2. 

06/02/2009 EB               MRIhc43727: Expanded encode_group view order support for medal/ARC cases when SAT is 
                                        selected to correct scantime. 

06/18/2009 KA               GEHmr01503: fast coil switch support for SV.

06/23/2009 VSN/ATV          MRIhc43912: a) Fixed the rounding issues with fatsat segment and pfkz_total calculation with 
                                        LAVA. b) This also contains changed made to correct a_gy1/a_gy1r setting with
                                        adaptive TE+TR.
              
07/10/2009 VSN/ZZ/EB        MRIhc44076  Moved swap_fat_cs gx amplitude negation to set_rdout_and_tmin() to avoid 
                                        image flip with FMTRA. 

07/13/2009 EB               MRIhc44108  Fixed xlFOV functionality and increased the FOV limit to 70cm.

07/31/2009 Lai              GEHmr01839: when ogsfY is different from ogsfYk, ss_rewinder_flag is set to 0.

08/06/2009 YS               GEHmr01844: waveform adjustment for SV Fiesta, Fiesta-C, 
                                        TRICKS, COSMIC and VIBRANT.  

08/18/2009 EB               MRIhc44826  Added the xres-FOV curve of 3DDE for HDw 1.5T and simplified calculations
                                        in setOptimizedGradientScalingFactor()

08/28/2009 MM               GEHmr01998: IFIR GraphicRx Enhancement

09/25/2009 Lai              GEHmr02509: Support smart derating in SV to shorten TR when min_seqgrad is dominant.  

10/14/2009 Lai              GEHmr02676: Changed smart derating logic to update waveform (run setOptimizedGradientScalingFactor())
                                        only once during dbdt optimization.

10/14/2009 Lai              GEHmr02897: Add osfp_weight_grad for gradient scale. Original osfp_weight is used only for RF scale.
                                        Compared with osfp_weight, osfp_weight_grad is finer to avoid oscillation of smart derating.

10/16/2009 KA               GEHmr02699: Corrected position of gy1r to avoid download failure.

10/19/2009 MM               GEHmr02730: Changed InversionGRx_calc_pulse_timing() function call position
                                        to avoid download failure.

10/21/2009 EB/TAC           MRIhc45743  Locked encode_group functionality to only supported scancore()

10/22/2009 Lai              GEHmr01918: When SpSat is on, wrong avmintscan is caused by below reasons:
                                        > sp _sattime is different from act_tr.
                                        > calculation of num_sats is wrong when pfkz_flag==ON
                                        > calculation of phase encoding used to calculate amount of SpSat sequence is wrong.
                                        Change the codes to fix them.

10/22/2009 Lai              GEHmr02863: Download fail due to two reasons:
                                        > when get_cvs_changed_flag() is false, minseq() does not run. But min_seqgrad is still multipled by
                                          osfp_weight_grad, wrong min_seqgrad lets smart derating work wrongly
                                        > osfg_weight is used in System Safety Checck. But osfg_weight_grad is used in efgre3d. 
                                        Add get_cvs_changed_flag() before min_seqgrad *= osfp_weight_grad and make consistence 
                                        between efgre3d and System Safety Check.

10/22/2009 MH               GEHmr02868: Added limit check for ogsf* parameters to avoid download fail.

10/30/2009 MM               GEHmr03199  IFIR: longer TI was needed for coronal IFIR. So, changed maximum TI.

11/01/2009 RBA              MRIhc42465 Added support for Common Parallel Imaging UI

11/06/2009 Lai              GEHmr03245: min_seqrfamp should be multipled by osfp_weight always

11/10/2009 TAC/EB           MRIhc46084  Fixed download failure involving small slab thickness and B1 optimization

11/20/2009 MM               GEHmr03400: pgen_on_host does not need InversionGRx pulse.
  
12/14/2009 EB/TAC           MRIhc46352  MinTE support for 3D Dual Echo, LAVA-Flex and VIBRANT-Flex. Updated 
                                        medal_freq_ave to catch 1.1ms OOP TE at 3T. 

12/22/2009 TAC              MRIhc46445  Added TE Lock feature for automatically ensuring 3D Dual Echo/LAVA-Flex/VIBRANT-Flex
                                        TEs remain within upper limits

12/22/2009 EB               MRIhc46841  COSMIC enhancements: ASPIR + ARC support. SpSAT compatible with ASPIR

12/22/2009 EB               MRIhc46844  Enable ARC with FIESTA-C

12/31/2009 VSN/VAK          MRIhc46886  SV to DV Apps Sync Up

01/04/2010 JX               MRIhc46488  Fix partial Kz UI (opuser23) bug for 3D Heart
         
01/06/2010 JX               MRIhc46925  Added support for DVC ARC compressed BAM model.

01/15/2010 JX               MRIhc47133  Lockout cylr nav from 3DHeart for 1.5T MDE and 
                                        3T MDE/FGRE/FIESTA. Increase kissoff slice to 3 
                                        if turbo_flag==2 for 3D Heart.

01/18/2010 VSN              MRIhc44866  Moved local declaration of fnecho_lim to epic.h

02/01/2010 EB               MRIhc47042  Force opautoti OFF if SPECIAL not selected. 

02/04/2010 EB               MRIhc47529  Increase LAVA-Flex max flip angle to 25 in research mode

02/04/2010 EB               MRIhc47346  BRAVO ASPIR infrastructure support 

03/01/2010 JX               MRIhc48111  Lock nex to 0.5 for 3DMDE if navigator is absent

03/03/2010 RKS              MRIhc46944  Ensure that ART is disabled for dual echo

03/03/2010 TAC              MRIhc48193  Increased area_gzk to 2400 for MERGE due to fine-line artifact.

03/03/2010 TAC              MRIhc47617  For COSMIC with ASPIR, fixed download failure for certain high TI values.
                                        Also provided specific pitival values and set avmaxti to 1000 ms.

03/12/2010 TAC              MRIhc46858  Disabled ability to paste a spatial sat from another series when
                                        spatial sat is not supported by setting pisatnub = 0

03/12/2010 TAC              MRIhc47629  Fixed TE Lock failure when set_cvs_changed_flag is incorrectly set to false
                            MRIhc47988

03/17/2010 JX               MRIhc48573  Fix max TI time bug for non-vast mode FGRE with 
                                        cardiac gating and IRPrep options on.

03/17/2010 RBA              MRIhc48034  Fix for Blanking Phase Accel fields. REset arc_ph_netaccel and arc_sl_netaccel

03/17/2010 JX               MRIhc48587  Change dependency of 3dHeart applications on 3dHeartKey/3dMDEKey 

03/23/2010 CRM              MRIhc48628  Always call prescan pulsegen.  Prescan pulses are needed for coil
                                        switching even when prescan is skipped for Multistation.

03/24/2010 EB               MRIhc47151  COSMIC/FIESTA-C: Switch 1D Slice ARC to 1D Phase ARC if Axial/Obl Axial scan

03/24/2010 ZZ/ATV           MRIhc48775  Add water excitation spsprf pulse to efgre3d

03/25/2010 EB               MRIhc48723  Don't set pisatnub to 0 when ChemSat is available

03/29/2010 EB               MRIhc48889  Don't set fullte_flag ON for MEDAL 

03/30/2010 JX               MRIhc48949  Enable 2D ARC support for ceMRA

04/07/2010 ZZ               MRIhc48883  Increased minimal time_ssi to 160 for DV Platform
                                        This is based on the "Rule of Thumb" recommened by Firmware Team:
                                        min time_ssi = 120 + # of updates
                                        leave 15 to 20 us head room beyond the min value 

04/09/2010 ZZ               MRIhc48684  when loading a medal with Fluorotigger protocol, advisory error poped out. 
                                        This is due to the cvoverride of opnecho in cveval() but not in cvinit().  
                                        This explains why we only see the problem only when loading the protocol 
                                        or change to a type-in PSD but not in copy/paste series.
                                        Copied the code to cvinit() to solve the problem.

04/14/2010 TAC              MRIhc49390  Enabled aTRopt_flag for TE Lock to provide consistent search results

04/14/2010 CRM              MRIhc49358  Disable coil switching in XTR packet at start of
                                        each entry point to keep SwiFT coil switching
                                        from impacting other entry points.

04/14/2010 JX               MRIhc49377  Lock out Water option for 3dHeart FIESTA

04/30/2010 TAC/CRM          MRIhc49891  Fixed issue with incorrect display of xres when advisory error is canceled.

06/02/2010 EB/ZZ            MRIhc50626  Protocol load bogus ETL==1 error fix with LAVA-Flex when FTMRA or Smartprep is used. 
                                        Removed oppseq = SPGR check to set medal_flag ON as it is out of sync with opmedal ON

06/23/2010 JX               MRIhc51477  Fixed SAR calculation rounding error for IFIR

07/08/2010 UNO              GEHmr04241: ART on Dual Echo

07/20/2010 TAC/CRM/RV       MRIhc50672  Fixed prep failure when >3 slabs are prescribed with Dynaplan.

10/28/2010 KA               MRIhc52512  IDEAL IQ feature promote.

11/19/2010 XZ               MRIhc52421  Implement turbo mode to meet marcketing datasheet claim

12/03/2010 JX               MRIhc53952  NavSat for 3dHeart FS FIESTA with cylin nav on 1.5T.

12/08/2010 XZ               MRIhc53613  Update FGRE/EFGRE#D/EPI2/FSEMASTER for epic mode

12/08/2010 KA               MRIhc54068  new rh-CV (rhrcidealctrl) support for IDEAL. Also replaced some hard coding with
                                        appropriate bit definition.

12/14/2010 JM               MRIhc54044  Unable to prescribe 3D dual echo in 3T. Disabling rfb1 optmisation
                                        for dual echo sequences.

02/08/2011 KA               MRIhc55012  IDEAL IQ option key check

02/23/2011 ZZ               MRIhc55288  Enable ASPIR with type-in PSD efgre3d_aspir

03/01/2011 KA               MRIhc55392  Fixed logic error that IDEALIQ would run in dual echo mode with a certain
                                        condition. Also changed error message on echo spacing for better UI.

03/25/2011 YS               MRIhc54088 Corrected gradient scaling

03/31/2011 KA               MRIhc56002  IDEAL IQ PSD waveform modifications:
                                        - support minimum TE (80%, zero filling )
                                        - area_gzk reduced
                                        - enabled smart derating with adaptive TE optimization
                                        - incorporated smart gx2 derating
04/08/2011 YS               MRIhc55998 Support smart derating on TRICKS, VIBRANT, VIBRANT-Flex,
                                       LAVA-Flex, Fiesta-C, Dual Echo, and IDEAL.

04/14/2011 SW               MRIhc56409 Increase avmaxbspti to 2000ms for IFIR. 

05/06/2011 ZZ               MRIhc56390  Enable flexible echo order for high res VIBRANT-Flex via opuser16

05/18/2011 SW               MRIhc56990  Fix the waveform issue after download

06/02/2011 KA               MRIhc56341  Implement IDEAL IQ Phase Correction.

06/16/2011 YS               MRIhc57424  ADVISORY_FAILURE caused to display unexpected error mesasge. 

06/23/2011 YS            HCSDM00076741  Modified ART compatibility. 

06/23/2011 KA            HCSDM00082388  Enable IDEAL IQ multi slab only when PSD name is idealiq_mslab

06/23/2011 YS            HCSDM00077353  Moved the position of oprbw range check. 

06/23/2011 YS            HCSDM00077753  Added more usercvs to usercvintchk to avoid floating number input. 

06/28/2011 KA            HCSDM00083301  Fixed rhechopc_ctrl setting for IDEAL IQ.

06/30/2011 YS            HCSDM00083869  Returned acceleration error handling to legacy code.

07/22/2011 SW            HCSDM00087467  Remove IDEAL_ORDER bit from psd side. Reorder will be done
                                        from Recon side.

07/22/2011 ZZ            HCSDM00086263  Enable Water Excitation

08/04/2011 MH            HCSDM00090513  For FIESTA turned dbdtlevel_opt off to reduce calculation time 

08/04/2011 MH            HCSDM00090755  For FIESTA turned stre_flag off to avoid gxw and gzp overlapped

08/11/2011 YS            HCSDM00088253  3D FGRE/FSPGR supports Smart Derating to reduce scan time of 
                                        Ready Brain Registration Localizer.

07/29/2011 SS            HCSDM00088901  Change rf unblank time to HD specific CV - rfupacv

07/29/2011 VSN           HCSDM00089930  Replace vibrant-xv with VIBRANT+ARC

08/19/2011 NB            HCSDM00092825  Code cleanup and changes related to RTP on VRE for HD23

09/09/2011 KN            HCSDM00097024  Allow phase fov greater than 1 for IFIR

08/19/2011 KA            HCSDM00093235  Reset rhechopc_ctrl to 0 when Echo Phase Corretion is not used.

08/26/2011 WXC           HCSDM00094105  Change elava control method from type-in PSD to CV. Because all CVs have been occupied,
                                        we have to reuse one CV that has already in use. CV0 is selected,
                                        so CV0 is used for both multi station and elava.

09/30/2011 Lai           HCSDM00092046  Initial promote to support Smart Burst Mode (SBM) in 16BEAT

09/30/2011 Lai           HCSDM00100051  To avoid oscillation, support pseudo convergence and fix gradOpt_slewRate

10/08/2011 Lai           HCSDM00100069  Update pulse locattion for gzp and gz1r based on setting of count_grd_wait

10/08/2011 Lai           HCSDM00100058  Turn of aTEOpt_flag for IDEAL and IDEALIQ in 16BEAT. Add another parameter
                                        gradOpt_flag to setOptimizedGradientScalingFactor()

11/04/2011 Lai           HCSDM00106836  SBM: remove limitation for cvs: sbm_**_scale

11/16/2011 Lai           HCSDM00107553  For smart derating, change (int) to ceil() to make rise/fall time not
                                        to exceed HW limitation
12/12/2011 WJZ           HCSDM00112662  For 16Beat system, Enable the EFGRE3D sequence to have lower
                                        limiting values for TR and TE (less than 1ms and 0.4ms)
                                        under certain extreme conditions.

12/20/2011 Lai           HCSDM00114077  Set big tolerance for pseudo convergence when InPh or OutPh is set.

27/Dec/2011 WXC          HCSDM00114912  Correct maximum #slice per loc in pop up message for Inhance IFIR.

01/31/2012 Lai           HCSDM00118534  Enable input for shots and etl for IDEALIQ to make DICOM Header correct.

02/06/2012 Lai           HCSDM00137456  Disable medal_autotelock_flag in SV due to it does not work well when
                                        smart derating is on.

06/Feb/2012 WXC          HCSDM00118536  Change elava user cv name to "Image Uniformity Optimization".

09/07/2011 ZZ            HCSDM00096606  Fix multislab water excitation.

09/20/2011 ZZ            HCSDM00098701  Sag VIBRANT ASPIR support.

10/06/2011 KA            HCSDM00102307  Corrected scan time of IDEAL IQ with Spatial Sat.

10/07/2011 ZZ            HCSDM00102223  Use STEAM CFH prescan for VIBRANT

10/09/2011 Lai           HCSDM00102521  Update cfxfd_power/temp_limit by modify CVs xfd_power/temp_limit

10/17/2011 KA            HCSDM00103916  Fixed flip angle for IDEALIQ in clinical mode. 

10/21/2011 VSN           HCSDM00103887  QuickSTEP TR and TE optimization

12/02/2011 VSN           HCSDM00111381  BRAVO - HD23 INTEG to HD23 merge error 

12/09/2011 VSN           HCSDM00112236  Image flip with BRAVO in coronals

12/16/2011 VSN           HCSDM00113848  Overscan CVs to be shown in research mode only

12/16/2011 ZZ            HCSDM00113857  efgre3d_aspir : Fix ASSET support with SAG prescription

01/06/2012 VSN           HCSDM00116061  Do not display usercv6 for SSRF + Ax VIBRANT.

01/06/2012 XZ            HCSDM00112806  Promote option key check for smart gradient optimization (smart derating) support
                                        smart gradient optimization is support on 450w/750w/GEM system only

02/10/2012 KN            HCSDM00122239  Changing time_ssi to 160us for HDx similar to DV

02/24/2012 YS            HCSDM00124452  Added error check code for Daq error of LAVA ARC. 

06/27/2012 MH            HCSDM00143691  Expand IDEALIQ to 750, 450 and 450w system.

07/19/2012 XZ            HCSDM00147985  Fix high signal non-uniformity from left to right for 3DMERGE with SPECIAL SAT

07/18/2012 MH            HCSDM00143692  Auto Flip Angle feature for IDEALIQ

07/25/2012 VSN           HCSDM00145018  SWAN:Phase Imaging feature promote

07/27/2012 MH            HCSDM00148431  For multi-peak ideal processing, 217Hz must be used as fat frequency.

08/01/2012 YS            HCSDM00148687  Support variable discard slices as userCV.

07/19/2012 YT            HCSDM00147804  Body Navigator feature promote

08/03/2012 SW            HCSDM00150795  Increase maximum flip angle to 40 for LAVA.

08/03/2012 ZZ            HCSDM00146403  Sag VIBRANT slice ghosting fix

08/07/2012 NB            HCSDM00149998  Excitation Mode field on the UI related changes

08/07/2012 MU            HCSDM00150650  IFIR: STIR support through type-in.

08/07/2012 TAC           HCSDM00136783  3D Calibration feature

08/24/2012 VSN           HCSDM00151278  Remove the error check with LAVA ARC put by HCSDM00124452 

08/24/2012 MK            HCSDM00079558  Display the value of Auto TI in pitival2
                                        and make piautoti to tell scn that Auto TI is supported by PSD.

08/23/2012 YT            HCSDM00153381  scan time calculation was modified in Body Navigator

08/31/2012 YS            HCSDM00148687  Corrected rhslblank setting for Fiesta-C without ARC.

09/04/2012 MK            HCSDM00155796  Display the value of Auto TI for ChemSatEval

09/06/2012 MU            HCSDM00150650  IFIR: STIR support, corrected the rho filename for FRIR.

09/07/2012 SW            HCSDM00157485  Replace HARDRF to FERMI124 for T2Prep and IRP in ftMRA.

09/11/2012 YT            HCSDM00157187  navscale should not be applied to IFIR with Navigator

09/12/2012 SW            HCSDM00158328  remove cfEllipticDriveEnable since it is not needed and will
                                        be removed from host tools side

09/17/2012 YT            HCSDM00159295  move Monitor_Eval call into cveval1 to setup rfpulse information correctly

09/28/2012 MK            HCSMD00157337  Display Gray Out TI field for VIBRANT-Axial and LAVA with specir.

10/16/2012 MH            HCSDM00154502  Added flip angle setting for IDEAL-IQ in cveval() function to set it correctly

10/22/2012 YS            HCSDM00165362  Modified a_gzrf1 calculation for Fiesta-C with variable discard slices.

12/12/2012 MU            HCSDM00161087  Fix for DL failure due to non-divisible pw by res for FRIR in ifir_stir.

12/07/2012 YS            HCSDM00161199  Added check of min_slquant for variable discard slices.

12/21/2012 YT            HCSDM00172035  Corrected behavior of Dual Echo + Body Nav during psd loading.

01/29/2013 YT            HCSDM00180050  Moved optionkey check from cvinit to cvcheck since variables set in cveval are used

01/29/2013 YT            HCSDM00181166  Corrected navigator interval calculation for body navigator

02/05/2013 YS            HCSDM00168104  Updated minimum value for error check.

02/07/2013 YT            HCSDM00183121  Fix for slabtracking along frequency direction with multi-echo

02/03/2013 MHI           HCSDM00174087  Enabling FA scaling for ASPIR pulse for 3T Body Transmit coil
                                        having very high patient weight. Refer to HCSDM00175770 as well.

03/05/2013 VSN           HCSDM00189003  Limit phase acceleration to 2 with swan whenever phase imaging is prescribed

03/05/2013 YT            HCSDM00187273  Need to disable Turbo ARC and (Reverse) Elliptical Centric in navigator gating

03/08/2013 MHI           HCSDM00189231  Fix for calculating tseq_irprep in 3DMDE.

03/08/2013 TAC           HCSDM00190012  For COSMIC, changed limit on max number of locs to limit on max volume thickness.

03/13/2013 YS            HCSDM00184881  Modified conditional statement to display pop-up message correctly

03/13/2013 XZ            HCSDM00190850  Enable Multi-NEX with interleave/sequential option for LAVA and LAVA-FLEX

03/18/2013 YT            HCSDM00190933  corrected pirtetr calculation for IFIR

03/19/2013 VSN           HCSDM00191523  Throw appropriate error message for acceleration with SWAN 2.0

03/19/2013 SW            HCSDM00190681  Set turbo_flag to 0 for LAVA once the FA is bigger than 15 in order to reduce
                                        slab wrap

03/23/2013 TAC           HCSDM00192869  For FIESTA-C, disabled availability of PURE 2.0.                                        

04/08/2013 MH            HCSDM00194775  Initialized ogsfX2 when gradOpt_flag is OFF

04/23/2013 MH            HCSDM00192126  For 450w & 450 IDEAL IQ, gradOpt_tor is set to 0.05. 

05/14/2013 TAC           HCSDM00192669  Fixed setting of seqpass period when scan is stopped and restarted.

05/15/2013 MH            HCSDM00201178  IDEAL IQ always makes IDEAL3D option key Present.

06/06/2013 VSN           HCSDM00205268  Increase flip angle for LAVA and LAVA-Flex as per HCSDM00150795
                                        Dont increase it for Zoom coil

06/24/2013 KK            HCSDM00220015  Corrected data type of temprffa.

07/04/2013 VSN           HCSDM00222170  QuickSTEP revert back to thin slab excitation

07/04/2013 VSN           HCSDM00207745  Enable UserCV20 for QuickSTEP Fluoro Trigger

10/03/2013 NT            HCSDM00241750  Fast LAVA feature promote

11/18/2013 SR/JM         HCSDM00251643  syncup from HD23

12/13/2013 TAC           HCSDM00256085  Enabled ARC for multi-station.

01/16/2014 XZ            HCSDM00261363  Extend E3DFGRE RF to Fiesta-C for reducing slab wrap

02/21/2014 ZZ            HCSDM00268699  Avoid setScale failure for COSMIC with SpSat and ASPIR

02/24/2014 ZZ            HCSDM00264804  Initial Flip Angle for ASPIR fatsat pulse

03/11/2014 JX            HCSDM00267622  Fix ghost artifact on heart coronary MRA without 3dheart option.

03/14/2014 TAC/KW/DWR    HCSDM00264720  DISCO feature 

03/28/2014 KK            HCSDM00272946  Rounded up target rise time for smart derating.

04/25/2014 ABS/AF        HCSDM00282845  Adding temporal resolution display in UI for 3DMDE and 3DHeart

03/14/2014 ZBG           HCSDM00272187 & HCSDM00254700
                                        Close gradOpt_TE from Smart derating in LAVA-Flex and Vibrant-Flex,
                                        both SPR share the same code modification.

06/10/2014 ZBG           HCSDM00293669  ogsfXwex, ogsfYk, ogsfZk should not scale when aTRopt_flag is OFF in smart derating.

11/07/2014 ZBG           HCSDM00300336: PSD static code analysis violations in MULAN;

05/22/2014 YI            HCSDM00289009  MSDE IOPT support.

04/22/2014 YT            HCSDM00282488  Added support for KIZUNA gradient thermal models

07/25/2014 YT            HCSDM00289004  support APx for breathhold scan
                                        use xres step = 4 to support Auto BW in LAVA APx
                                        calculate max xres in MEDAL and IDEALIQ for APx

09/02/2014 MM            HCSDM00289009  Added MSDE.

09/05/2014 YT            HCSDM00309738  In Fluoro Trigger, search rotation matrix with highest duty
                                        at the final cveval1()

11/07/2014 TAC           HCSDM00318045  Tuned SmartDerating gradOpt_tor for certain applications.

11/07/2014 TAC           HCSDM00318053  Tuned TE range for 1.5 T fractional echo Flex.

12/11/2014 MHI           HCSDM00320963  Introduce Packed SliceZIP for non-AcqtoDisk configuration such as iVRF.
                                        This can eliminate the necessary memory size for Slice ZIP from BAM
                                        when ARC and Multi-Phase (except for Dynaplan) are selected.

12/19/2014 NT            HCSDM00326359  Turbo Mode of ceMRA feature promote

01/20/2015 MHI           HCSDM00330706  Delta frequency(Hz) used in IDEAL (rhdf) was restored to 210Hz,
                                        which is used by recon as reference.

01/27/2015 MHI           HCSDM00329387  Corrected PosTemp and PosXtrPkt in case of multi-echo acquisition.

02/09/2015 YT            HCSDM00331456  Initialize gradOpt_scale and ogsf* to remove hysteresis.
                                        It is enabled only when APx can be used,
                                        where the hysteresis might cause non-negligible issue.

04/06/2015 MHI           HCSDM00342945  Added error handling for Minimum TE in MERGE/SWAN.

04/15/2015 YI            HCSDM00343651  Fixed advisory error problem after switching PSD from T2 FLAIR.
                                        Changed condition for returning ADVISORY ERROR regarding TE1 and TE2.

04/20/2015 YI            HCSDM00339164  Added annefact reduction.

04/30/2015 MHI           HCSDM00342605 : Need to reduce FA of SPSP pulse for higher weight

05/05/2015 MHI           HCSDM00341590  Improved dual echo calculation and error handling for FLEX.
                         HCSDM00344193
                         HCSDM00345891 

05/14/2015 MHI           HCSDM00306522  Fixed IQ issue caused by OOP TE too close to IP TE.

05/19/2015 YT            HCSDM00352042  Initialize gradOpt_scale before rfb1opt iteration

05/20/2015 MJ            HCSDM00352456  3D MDE improvement (MDE 3.0): alternative IR prep pulse

06/16/2015 YI            HCSDM00356574  Fixed the problem that APx window did not open on LAVA-Flex.

07/16/2015 KL            HCSDM00326359 + HCSDM00359899  Turbo Mode of ceMRA feature promote

07/22/2015 LH            HCSDM00362877  Set K15 smart derating configuration same as SV.

08/05/2015 YI            HCSDM00363811  Changed pichemsatopt control regarding sp_sat.

08/26/2015 YT            HCSDM00341147  Support image cut reduction except for Fluoro Trigger realtime scan

09/11/2015 YI            HCSDM00370378  Supported C3 recon with CV25 for annefact reduction.

09/24/2015 AS            HCSDM00274558  idealiq bipolar PC readout polarity error, lock out bipolar

10/06/2015 YI            HCSDM00360543  Added force_gradOpt_loop_break control to break smart derating iteration.
                                        Advisory error check on RBW is supported.

10/15/2015 RV            HCSDM00348704	Enable (in-plane) pixel Size, RBW/pixel and ESP informational display

                         HCSDM00373423 - eSWAN enhancements - Inverted phase image support phase background 
                                                              suppression support

10/21/2015 AS            HCSDM00265426  set avmaxflip after flip (and act_tr) exists to avoid erronous flip-angle 
                                        message when loading protocol

10/27/2015 YI            HCSDM00375610  Forbade C3 recon with CV25 on applications which support auto subtraction.

10/27/2015 YI            HCSDM00367499  Allowed opautote=0 for CV25 support to avoid resetting CV25 in Setup.

11/17/2015 YI            HCSDM00370772  Fixed scan failure on IDEAL-IQ in case of odd Nex NPW with ARC by fixing
                                        conflict between idealiq_pc_num_ref_acq and actual #views for PC.

12/11/2015 HM            HCSDM00385665  Fixed issue with the number of zy_export lines in kacq_yz.txt for Turbo LAVA.

12/23/2015 RV		 HCSDM00387299  Enable series per phase support for DISCO

01/12/2016 RV		 HCSDM00348704  Fix avinplaneyres calculation for SqP case; replace aviplanexres, avinplaneyres,
                                        avesp and avrbwperpix with corresponding piCV names

01/28/2016 LS            HCSDM00383601  With Ox recon can support all 3D multi-slab scans with 3D Gradwarp now.
                                        remove the block for 3D multi-slab for 3D Gradwarp.

02/19/2016 ZW            HCSDM00388402  Fix the pulse overlap bewteen echo1dab and d3d pulses.This issue occurs when the psd_rf_wait/psd_grd_wait become very small.

02/29/2016 YI            HCSDM00392380  Added set_run_eval_from_get_required call to enable cveval call
                                        for GETCVVALS and GETSHAREDVAR op-code to avoid oscillation of TR value
                                        in setting SAR tables.

09/MAR/2016 GJ           HCSDM00389634  One bug for the default value of opuser6.

03/14/2016 TAC           HCSDM00398032 Interleaved Calibration feature
03/08/2016 NLS           HCSDM00396145  Optimized APx parameters boundary for 1.5T: LAVA Auto BW (62.5~83.3KHz)
10/Mar/2016  PL/ AS      HCSDM00397174  Feature addition for 3DCINE / 4DFLOW

15/MAR/2016 GJ           HCSDM00389691  Delay time between acqs doesn't add to pitscan when multiphase, under some conditions.

23/MAR/2016 GJ           HCSDM00382904  Increase Killer area of 3D Calibration to reduce the banding artifact, only for Kizuna 1.5T.

30/MAR/2016 MXX          HCSDM00396830  on SV systems decrease 3D COSMIC xfd_power_limit for all readout bandwidth down to 7.3 to avoid Under-Voltage issue.

30/MAR/2016 MXX          HCSDM00400131  fixed 3D COSMIC min_seqgrad calculation collision, which led to wrong scan time. Function minseq() 
                                        must be followed by min_seqgrad recalculation: multiplied with osfp_weight_grad.

18/APR/2016 GJ           HCSDM00402300  Delete the assignment statement for default value of CV6 to avoild error.

22/APR/2016 SW           HCSDM00403867  Cloned from HCSDM00403567  
                                        Forbade swapping chemical shift direction(swap_fat_cs = 1) with Fluoro Trigger
                                        because recon does not support echo flip on partial ky data in realtime scan.

06/MAY/2016 WMR          HCSDM00405673  Avoid download failure for COSMIC with SpSat and ChemSat
                                        Restore original pw/fa before scaling 

26/MAY/2016 GJ           HCSDM00408706  Under voltage issue showed on some protocol of LAVA without fatsat. Need to reduce power_limit for LAVA without fatsat.

26/JUN/2016 SW           HCSDM00411206  Fix the cosmic TR change issue when it is load from protocol.

14/JUL/2016 GJ           HCSDM00415682  Under voltage issue showed when lava-flex with cv16=1. Need to reduce power_limit for SV system.

28/Jul/2016 GJ           HCSDM00417122  Disco download failed becuase num_sub_regions out of range.

11/AUG/2016 GJ           HCSDM00416801  3D calibration has longer TR after re-selecting coil mode when pre-saved coil is not in existed coil database.
                                        Because 3D calibration need turbo_flag =2 to use a shorter RF.
                                        For 3D calibration, opuser6 is not exist, so turbo_flag shouldn't be decided by the value of opuser6.
 
31/AUG/2016 YL	         HCSDM00419530  opuser23 is related to pfkz_hnover, when opuser23 < 100%, hnover > 0. 
					And when pfkz_hnover > 0, SEQUENTIAL instead of CENTRIC slice order will be implemented, even if slorder and phorder are defined to be CENTRIC. 
					Slice ordering impacts PUREMIX parameter settings, so need to transfer cv pfkz_hnover to model_parameters for PUREMIX parameter calculation.

26/Oct/2016 MO           HCSDM00428609  Support Apodization filteri for MERGE and BRAVO.

10/Jan/2017 VSN	         HCSDM00439672  Scan time fix when pfkr_yz_flag is 1 and slice encodes are greater than phase encodes.

13/Feb/2017 VSN          HCSDM00445314  For FTMRA, sampledPoints need to be multiple of views per segment

13/Apr/2017 WMR          HCSDM00454878  IDEAL-IQ autoFA is incorrect, opflip was set up back by initialzation, turn on FIX value in cvoverride. 

28/Apr/2017 YI/VSN       HCSDM00456761  3D MERGE : Ghosting artifacts appeared

24/May/2017 VSN          HCSDM00460334  Remove User CV26 from 3D MERGE. Restrict CV27 for Spine and Lower extremity

25/May/2017 VSN          HCSDM00461033  Change minimum BW for LAVA to 31.25KHz

02/June/2017 LS          HCSDM00462327  Added additional dda (4s of ps2_dda_cal3d) to help MR signal with long T1 to recover. Changes
                                        only apply to cal3d mode
*********************************************************************/

@inline epic.h

@global 
/*********************************************************************
 *                    EFGRE3D.E GLOBAL SECTION                       *
 *                                                                   *
 * Common code shared between the Host and Tgt PSD processes.  This  *
 * section contains all the #define's, global variables and function *
 * declarations (prototypes).                                        *
 *********************************************************************/

#include "em_psd_ermes.in"
#include "grad_rf_efgre3d.globals.h"
#include "stddef_ep.h" 
#include "epicconf.h"
#include "pulsegen.h"
#include "filter.h"

#include "support_func.h"
#include "epicfuns.h"
#include "chemsat_defs.h" /* SpecIR pulse definitions */

#include "psd_proto.h"

#include "efgre3d.h"
#include "efgre3d_support.h"

#define NAV_EFGRE3D
#define GATE_TRIGGER_WINDOW_MAX  90     /* maximum respiratory trigger window size */
 
#define PSD_IPG_DEBUG

/* ChemSat supported in CFH */
#define PSD_CFH_CHEMSAT

   /* IR PREP (pjg) */
#define EM_PSD_DEPREP_INCOMPATIBLE 1

#define ELLIPT_CEN_MAX 262144  /*MRIhc02499 1024x256 for e3 limit*/
/* Killer areas for prep pulses */
#define GZRF0KAREA_FGRE3D 5040.0
#define GKILLERAREA_GRE 600.0
#define GKILLERAREA_SPGR 600.0
#define GXSATKILLER 1995.0
#define GYSATKILLER 3420.0
#define GZSATKILLER 1995.0

/* SVBranch, HCSDM00092046 */
#define  HEAT_Z_NUM_MIN 4
#define  HEAT_Z_NUM_MAX 10

#define  HEAT_Y_NUM_MIN 4
#define  HEAT_Y_NUM_MAX 20


#define MINSLQUANT3D 8 
#define MINSLQUANT3D_FGRE 16
#undef  MAX_SLICE3D 
#define MAX_SLICE3D 2048 
#undef MAXSLQUANT3D
#define MAXSLQUANT3D 2048 
#define MAXSLQUANT3D_FGRE 2048
#define DISCARDSLICE (2 * opslblank) 

#define DFM_TR_THRESHOLD 0
#define IMG_TO_DFM_DELAY 0

@inline ChemSatSpecIR.e ChemSatGlobal

#define NAV_MAX_SLICES 24
#define NAV_MIN_SLICES 8
#define NAV_MIN_FOV    100.0

#define START_UP 0
#define SLOW_DOWN 1
#define MAX_OSFP_VFA 512

/* IFIR GRx */
@inline InversionGRx.e InversionGRxGlobal

/* define rf0_pulse_type values */
#define RF0_INVI0 0
#define RF0_HS_20MS 1
#define RF0_ADIABATIC 2
#define RF0_HS_3T 3
#define RF0_ADIABTAN 4

/* define rf1_pulse_types */
#define RF_3DFGRE 0 /* backward compatibility - added by latha@mr */
#define RF_E3DFGRE 1
#define RF_TURBO 2
#define RF_TBW3_005_01 3
#define RF_TBW3_005_01_48 4
#define RF_TBW6 5 
#define RF_TBW8 6 
#define RF_3D_600US_01P_01S_10KHZ 7
#define RF_TB3_01_001_250 8
#define RF_HARD100 9 
#define RF_TBW12 10
#define RF_TBW8_001_001_200LP 11 
#define RF_TBW8_001_001_200 12
#define RF_TBW24 13 
#define RF_HARD24 14

#define DEG_TO_RAD 0.01745

/***** Correct values for new 3.2 ms min phase SLR pulse ********/
#define SAR_MAXB1_NEWALPHA1 0.0644207
#define SAR_MAX_INT_B1_SQ_NEWALPHA1 0.001335
#define NOM_BW_ALPHA1 3664
#define ISO_DELAY_ALPHA1 440us

/***** 1600us 7500 Khz rf pulse definitions ****/

#define RES_RF3D16MIN 800
#define SAR_ABS_RF3D16MIN 0.1950
#define SAR_AREA_RF3D16MIN 0.0943
#define SAR_EFFW_RF3D16MIN 0.1036
#define SAR_DTYCYC_RF3D16MIN 1.0        /* MRIge44238 - changed from 0.2694 */
#define SAR_MAXPW_RF3D16MIN  1.0        /* MRIge44238 - changed from 0.2306 */
#define SAR_MAXB1_RF3D16MIN 0.194498
#define SAR_MAX_INT_B1_SQ_RF3D16MIN 0.00627166
#define SAR_MAX_RMS_B1_RF3D16MIN 0.0627166
#define NOM_BW_RF3D16MIN 7232.0
#define ISO_DELAY_RF3D16MIN 252.0

/***** 800us 15 Khz 30 deg, 1/0.1 % pass/stop, small tip, min phase rf pulse definitions ****/

#define RES_RF3D8MIN 400
#define SAR_ABS_RF3D8MIN 0.1960
#define SAR_AREA_RF3D8MIN 0.0954
#define SAR_EFFW_RF3D8MIN  0.1045
#define SAR_DTYCYC_RF3D8MIN 1.0             /* MRIge51370 - changed from  0.2707 */
#define SAR_MAXPW_RF3D8MIN 1.0              /* MRIge51370 - changed from 0.500 */
#define SAR_MAXB1_RF3D8MIN 0.256422
#define SAR_MAX_INT_B1_SQ_RF3D8MIN 0.00549569
#define SAR_MAX_RMS_B1_RF3D8MIN 0.0828831
#define NOM_BW_RF3D8MIN 14403.0
#define ISO_DELAY_RF3D8MIN 124.0

/* fast-receiver 100ns minimum programmable delay */
#define FREC_MIN_PROG_DEL 0.1
#define MAX_PHASEFOV 1.9
#define MAX_ECHOES 16

#define FOV_MAX_EFGRE3D 999

/* VAL15 12/14/2004 YI */
#define PC_APC 0
#define PC_SGS 1
#define PC_BASIC 2

/* Define in phase TE limits for Brava at 3T */
#define LLIMTEIN1_BRAVA_3T 2.1ms
#define ULIMTEIN1_BRAVA_3T 2.85ms
#define LLIMTEIN2_BRAVA_3T 4.25ms
#define ULIMTEIN2_BRAVA_3T 5.0ms
#define LLIMTEIN3_BRAVA_3T 6.5ms

/* For ARC */
#define ARC_YRES_MAX 1024

#define MERGE_TE_1HT 20.0ms
#define MERGE_TE_3T 13.0ms
#define MERGE_TR_1HT 40.0ms
#define MERGE_TR_3T 30.0ms

#define SWAN_1ST_TE_3T 13.0ms
#define SWAN_TE_1HT 50.0ms
#define SWAN_TE_3T 25.0ms

#define IFIR_MAX_SLAB_VTHICK 200.0  /* 20cm */
#define IFIR_IR_VTHICK 300.0  /* 30cm */

#define OSFP_MAX_VTHICK 240.0

/* Minimum number of phases in BAM when using acquisition to disk */
#define DISK_ACQ_RHINITPASS 2

/* SVBranch, Smart Burst Mode */
#define SBM_MPS2_MAX_LOOP 30000
#define SBM_MAX_NEX 6

/* For SPSP pulse, used in ss.e */
#define NO_GMN 0
#define CALC_GMN1 1
#define CALC_GMN2 2

/* IDEAL IQ: upper/lower bound of esp in units of pi */
#define IDEALIQ_MIN_ESP_COEFF 0.48
#define IDEALIQ_MAX_ESP_COEFF 0.96

#define IDEALIQ_MIN_NECHO 6
#define IDEALIQ_MAX_NECHO 16

#define IDEALIQ_PC_DDA 2
#define IDEALIQ_2DPC_YLINES 16
#define IDEALIQ_PC_MIN_ZLINES 8

/* IDEAL IQ: T1 values used in calculation of optimized flip angle. Water T1 is a typical liver T1 value */
/* These values come from "Relaxation Times of Abdominal and Pelvic Tissues" in Radiology vol.230 Num 3  */
/* page 652 which was written by de Bazelaire et al                                                      */
#define IDEALIQ_FAT_T1_15000 343
#define IDEALIQ_FAT_T1_30000 382
#define IDEALIQ_WAT_T1_15000 586
#define IDEALIQ_WAT_T1_30000 809 

#define RDB_PHASE_MASK      67108864 /* 0x4000000 */
#define RDB_PHASE_IM_INVERT 32768    /* 0x8000 */

/* For multi-peak processing, 217 must be used as fat frequency. This values (3.4ppm) */
/* comes from "In vivo characterization of the liver fat H MR spectrum" in NMR Biomed */
/* 2011 vol.24 page 784 which was written by Gavin Hamilton et al                     */
#define FATWATER_MPFREQ_1_5T 217 /* values in Hz @1.5T */

/* HCSDM00339164 */
#define ANNEFACT_REDUCTION_MID 1
#define ANNEFACT_REDUCTION_HIGH 2

/*ipg export structure does not require "distances" which are used in
predownload to perform sort */

typedef struct slaboff {
        int zsign;  /* sign of the phase offset */
        int zoffs;  /* calculated phase offset from rsp_info structure */
       } SLAB_OFF;

@inline Monitor.e MonitorGlobal

@inline ChemSatSpecIR.e ChemSatGlobal

@inline SpSat.e SpSatGlobal
@inline Prescan.e PSglobal
@inline VAST.e VASTglobal

/* MRIge66079 - ATV: RTIA3D/ftMRA */
static WF_PROCESSOR temp_wave_gen = XGRAD;
/* End RTIA3D/ftMRA */

/* 4dFLOW */
static LONG temp_trap_type = TRAP_ALL;

@inline T2Prep.e T2PrepGlobal 
@inline Tricks.e TricksGlobal
@inline Asset.e AssetGlobal

int pgen_for_dbdt_opt = 0;   /* 1: update waveform for dbdt optimization, 0: not update */

/* parameters to remove hysteresis in smart derating */
int apx_compatible = 0;         /* enable initialization only in APx-compatible protocol */
int initialize_gradOpt = 0;     /* flag to show if initialization method is applied */
int initialize_scale = 0;       /* flag to show gradOpt_scale is initialized in cveval() */

@inline ss.e ssGlobal
@inline Disco.e DiscoGlobal
@inline FastCINE3D.e fcine3d_global

@inline MSDE.e MSDE_Global
%define PSD_MSDE_PREP_SEQ

@ipgexport
/*********************************************************************
 *                  EFGRE3D.E IPGEXPORT SECTION                      *
 *                                                                   *
 * Standard C variables of _any_ type common for both the Host and   *
 * Tgt PSD processes. Declare here all the complex type, e.g.,       *
 * structures, arrays, files, etc.                                   *
 *                                                                   *
 * NOTE FOR Lx:                                                      *
 * Since the architectures between the Host and the Tgt sides are    *
 * different, the memory alignment for certain types varies. Hence,  *
 * the following types are "forbidden": short, char, and double.     *
 *********************************************************************/

@inline Prescan.e PSipgexport
@inline ss.e ssIPGexport
@inline MSDE.e MSDE_ipgexport
@inline RTIA.e realtime_ipgexport

/* Concat sat is not supported */
int off_rfcsz[1];
/* MRIhc08159 : Added initializations of complex structures and arrays of complex structures */
RF_PULSE_INFO rfpulseInfo[RF_FREE] = { {0,0} };

SLAB_OFF slab_off[SLTAB_MAX/MINSLQUANT3D] = { {0,0} };

float osfp_vfa[MAX_OSFP_VFA];
int ia_rf1_osfp[MAX_OSFP_VFA];

/* IR PREP (pjg) */
int volumetab[MAX_SLICE3D]; 
int volumetab2[MAX_SLICE3D]; /* refocus/encode and rewind /killer */
int arcPhaseRemapTable[ARC_YRES_MAX + 1];
int arcSliceRemapTable[MAX_SLICE3D];

int slicetab[MAX_SLICE3D]; /* VAST */

int sampledPoints = 0;
int calibrationPoints = 0;
int maskPoints = 0;

int zy_views;  /* Number of views used to fill ZY_EXPORT */
int zy_slices; /* Number of slice used to fill ZY_EXPORT */

CAL_PARAM calRegion = {0,0,0,0,0,0.0,0.0,0.0,0.0}; 

int phaseres;                 /* phase resolution for phase table */

int extraspecial_slice[MAX_SLICE3D] = {0}; /* Physical slices including dummy slices*/

@inline Tricks.e TricksIpgexport
@inline Disco.e DiscoIpgexport

@inline Monitor.e MonitorIpgexport

/* IFIR GRx */
@inline InversionGRx.e InversionGRxIpgexport

@cv
/*********************************************************************
 *                      EFGRE3D.E CV SECTION                         *
 *                                                                   *
 * Standard C variables of _limited_ types common for both the Host  *
 * and Tgt PSD processes. Declare here all the simple types, e.g,    *
 * int, float, and C structures containing the min and max values,   *
 * and ID description, etc.                                          *
 *                                                                   *
 * NOTE FOR Lx:                                                      *
 * Since the architectures between the Host and the Tgt sides are    *
 * different, the memory alignment for certain types varies. Hence,  *
 * the following types are "forbidden": short, char, and double.     *
 *********************************************************************/

@inline ChemSatSpecIR.e ChemSatCV
@inline Monitor.e MonitorCV
@inline SpSat.e SpSatCV
@inline loadrheader.e rheadercv
@inline Respgate.e RGcvs

@inline T2Prep.e T2PrepCV

@inline InversionGRx.e InversionGRxCV /* IFIR GRx */

@inline cal3d.e cal3d_cv

/* MRIge66079 - ATV: RTIA3D/ftMRA */
/* Needs the bore temp monitor CVs. */
@inline RT.e BTcvs
/* End RTIA3D/ftMRA */

/* SVBranch, Smart Burst Mode */
int enable_sbm = 0                        with {0, 1, 0, INVIS, "Flag to support SBM feature in different config. 1=support",};
int sbm_flag = 0                          with {0, 1, 0, INVIS, "Flag to turn on/off SBM: 0=OFF, 1=ON",};
int sbm_gradient_method = 1               with {0, 1, 1, INVIS, "Flag to switch thermal model for SBM: 0=DC, 1=AC",};
int sbm_debug = 0                         with {0, 1, 0, INVIS, "Debug flag for SBM: 0=OFF, 1=ON",};
int sbm_dda = 40                          with {0, , 40, INVIS, "Number of discard for waiting period",};
int sbm_dda_max = 60                      with {0, , 60, INVIS, "Maximal allowed discard number for waiting period",};
int sbm_dda_min = 2                       with {0, , 2, INVIS, "Minimal allowed discard number for waiting period",};
int sbm_z_num = 10                        with {0, 100, 10, INVIS, "Slice encoding amount for Heating calculation",};
int sbm_y_num = 10                        with {0, 100, 10, INVIS, "Phase encoding amount for Heating calculation",};
float sbm_gx1_scale = 1.0                 with {, , 1.0, INVIS, "Gx1 scale for heating calculation ",};
float sbm_gxw_scale = 1.0                 with {, , 1.0, INVIS, "Gxw scale for heating calculation ",};
float sbm_gxwex_scale = 1.0               with {, , 1.0, INVIS, "Gxwex scale for heating calculation ",};
float sbm_gy1_scale = 1.0                 with {, , 1.0, INVIS, "Gy1 scale for heating calculation ",};
float sbm_gy1r_scale = 1.0                with {, , 1.0, INVIS, "Gy1r scale for heating calculation ",};
float sbm_gzcomb_scale = 1.0              with {, , 1.0, INVIS, "Gzcomb scale for heating calculation ",};
float sbm_gzp_scale = 1.0                 with {, , 1.0, INVIS, "Gzp scale for heating calculation ",};
float sbm_sum_dummy = 0.0                 with {0.0, , 0.0, INVIS, "Total amount of TRs for waiting period",};
int sbm_dummy_num = 0                     with {0, , 0, INVIS, "Amount of TRs for one waiting period",};
float sbm_waiting_time = 0.0              with {0.0, , 0.0, INVIS, "Total waiting time",};
float sbm_margin = 1.0                    with {0.5, 2.0, 1.0, INVIS, "Margin factor for heating calculation",};
float sbm_time_limit = 1.0                with {0.0, , 1.0, INVIS, "Additional time needed to sink heat. Unit: s",};
float sbm_time_limit_max = 1.0            with {0.0, , 1.0, INVIS, "Maximal allowed additional time to let HW work. Unit s",};
float sbm_time_limit_min = 0.1            with {0.0, , 0.1, INVIS, "Minimal allowed additional time to let HW work. Unit s",};
float sbm_time_limit_ratio = 1.3          with {1.0, 2.0, 1.3, INVIS, "Ratio for allowed additional time",};
float sbm_smartderating_factor = 1.35     with {1.0, 5.0, 1.35, INVIS, "The target ration between min_seqgrad and tmin",};
int sbm_cvs_changed = 0                   with {0, 1, 0, INVIS, "Flag to check if get_cvs_changed_flag() changes from 1 to 0",};
int sbm_cvs_old = -1                      with {-1, 1, -1, INVIS, "To store old get_cvs_changed_flag()",};
int sbm_pitscan_changed = 0               with {0, 1, 0, INVIS, "Flag to check if pitscan is obviously changed",};
float sbm_pitscan_old = -1.0              with {-1.0, , -1.0, INVIS, "To store old pitscan",};
float sbm_bak_pitscan = -1.0              with {-1.0, , -1.0, INVIS, "To backup current pitscan",};
float sbm_pitscan_limit = 200000.0        with {0.0, , 200000.0, INVIS, "Maximal allowed scan time changed. Unit: us",};
int sbm_mps2_imaging_num= 1               with {1, , 1, INVIS, "Amount of imaging TRs between two waiting period for Scan TR",};



/*for dbdt opt*/
int dbdtlevel_opt = 0 with {0, 1, 0, VIS, "optimize dbdt level to get best performance", };
int debug_dbdt = 0 with {0, 1, 0, VIS, "print out dbdtlevel opt debug statement", };
/* added backward compatibility for 3.2 ms rfpulse - latha@mr */
int rf1_pulse_type = 0 with {0,14,1,INVIS, "rf1_type 0=3.2 ms, 1=1.6 ms, 2 = 0.8ms, 3/4/5/6 = 0.3ms, 7 = 0.6 ms, 8 = 0.5 ms",};
int rfconf=141;
int act_te = 0 with {0,,,INVIS, "actual te",};
int act_te2 = 0 with {0,,,INVIS, "actual te2",};

int act_tr = 0 with {0,,,INVIS, "actual tr",};
float area_gzrf0k = 0 with {0,,0,INVIS, "area of gzrf0k pulse",};
float a_gx1_frac = 0 with {,,,INVIS, " amplitude of gx1 pulse for frac. echo.",};
float a_gx1_full = 0 with {,,,INVIS, " amplitude of gx1 pulse for full echo.",};
float a_gxfc_frac = 0 with {,,,INVIS, " amplitude of gxfc pulse for frac. echo.",};
float a_gxfc_full = 0 with {,,,INVIS, " amplitude of gxfc pulse for full echo.",};

int dda = 4 with {0,,4,VIS," number of disdaqs in scan",};
/* MRIge57602 - added quiet delay */
int dda_trigger_delay_disdaqs = 0 with {0,,4,VIS," number of disdaqs in non-silent delay period ",};
int dda_trigger_delay_silent_countdown = 0 with {0,,,VIS," number of disdaqs for the silent period ",};
int dda_one_second = 0 with {0,,,VIS," number of disdaqs in 1 second ",};
int trigger_delay_wosp = 0 with {0,,,VIS," trigger delay w/o SmartPrep ",};
int trigger_delay_silent_countdown = 0 with {0,,,VIS," trigger delay silent countdown ",};
int debug = 0 with {0,1,0,INVIS,"1 if debug is on ",};
int decimation = 4 with {0,,,INVIS,"Decimation of a/d in filter",};
int dex = 0 with {,,0,INVIS, "num of discarded excitations",};
int gating = 0 with {0,,0,INVIS, "gating - TRIG_INTERN, TRIG_LINE, etc.",};
int ipg_trigtest = 1 with {0,1,0,INVIS, "if 0 use internal trig always",};
float echo1bw = 16 with {,,,INVIS, "Echo1 filter bw. in KHz",};
float echo2bw = 16 with {,,,INVIS, "Echo2 filter bw. in KHz",};
float tmpbw;
float irmsx = 0 with {0,,,INVIS, "",};
float irmsy = 0 with {0,,,INVIS, "",};
float irmsz = 0 with {0,,,INVIS, "",};
int min_tefe = 0 with {,,0,INVIS," minimum echo time w/ frac. echo",};
int min_tenfe = 0 with {,,0,INVIS," minimum echo time w/ full echo",};
int pre_pass = 0 with {0,,0,INVIS, "prescan slice pass number",};
int nreps = 1 with {0,,0,INVIS, " number of sequences played out",};
int sat_reps = 0 with {0,,0,INVIS, " number of sat seqs played out",};
int pos_start = 0 with {0,,,INVIS, "Start time for sequence. ",};
int ps2_dda = 0 with {0,,,INVIS," Number of disdaq in 2nd pass prescan.",};
int ps2_dda_cal3d = 0 with {0,,,INVIS," Number of disdaq in aps2 prescan for cal scan.",};
int ps2_dda_time_cal3d = 4s with {0,,4s,INVIS," Time of disdaq in 2nd pass prescan for 3D cal.",};
int fermr_coef_1024 = 38 with {0,64,38,INVIS,"Fermi coefficient for 1024 ZIP",}; /* pradeeps@wiproge */
/* MRIge51463 - changed the default value for ellipt_flag to 0, so that it does not 
   get turned on for non-TOF mode - latha@mr */
int ellipt_flag = 0 with {0,1,0,VIS, "Flag for elliptical-centric.",};
/* MRIge91683 */
int delay_ec_period = 6 with {0,6,5,INVIS, "Delay elliptical-centric.",};
int delay_ec_flag = 0 with {0,1,0,INVIS, "Delay elliptical-centric flag.",};
int delay_ec_frames = 0 with {0,10000,0,INVIS, "Delay elliptical-centric frames",};
/* MRIge57602 - added reverse elliptical centric, reverse centric phase encoding */
int reverse_ellipt_flag = 0 with {0,1,0,VIS, "Flag for reverse elliptical-centric.",};
int centric_flag = 0 with {0,1,0,VIS, "Flag for centric phase order.",};
int reverse_centric_flag = 0 with {0,1,0,VIS, "Flag for reverse centric phase order.",};
int smoothec = 0 with {0, 1, 0, VIS, "Smooth elliptical centric for reduced eddy currents",};
int ellipt_debug_files = 0 with {0, 1, 0, VIS, "Write playout structures to disk",};
/* x axis variables */
int pw_gx1_frac = 0 with {0,,,INVIS, " Width of gx1 pulse for frac. echo.",};
int pw_gx1a_frac = 0 with {0,,,INVIS, " Attact width of gx1 pulse for frac. echo.",};
int pw_gx1d_frac = 0 with {0,,,INVIS, " Decay width of gx1 pulse for frac. echo.",};
int pw_gx1_full = 0 with {0,,,INVIS, " Width of gx1 pulse for full echo.",};
int pw_gx1a_full = 0 with {0,,,INVIS, " Attack width of gx1 pulse for full echo.",};
int pw_gx1d_full = 0 with {0,,,INVIS, " Decay width of gx1 pulse for full echo.",};
int pw_gxfc_frac = 0 with {0,,,INVIS, " Width of gxfc pulse for frac. echo.",};
int pw_gxfca_frac = 0 with {0,,,INVIS, " Attact width of gxfc pulse for frac. echo.",};
int pw_gxfcd_frac = 0 with {0,,,INVIS, " Decay width of gxfc pulse for frac. echo.",};
int pw_gxfc_full = 0 with {0,,,INVIS, " Width of gxfc pulse for full echo.",};
int pw_gxfca_full = 0 with {0,,,INVIS, " Attack width of gxfc pulse for full echo.",};
int pw_gxfcd_full = 0 with {0,,,INVIS, " Decay width of gxfc pulse for full echo.",};
int pw_gxwl = 0 with {0,,,INVIS, " left wing of readout",};
int pw_gxwr = 0 with {0,,,INVIS, " right wing of readout",};
int pw_gxw_frac = 0 with {0,,,INVIS, " Width of gxw pulse for frac. echo.",};
int pw_gxwa_frac = 0 with {0,,,INVIS, " Width of gxw attact pulse for frac. echo.",};
int pw_gxwd_frac = 0 with {0,,,INVIS, " Width of gxw decay pulse for frac. echo.",};
int pw_gxw_full = 0 with {0,,,INVIS, " Width of 1st full echo if not truncated.",};
int pw_gxwa_full = 0 with {0,,,INVIS, " Width of gxw attact pulse for full echo.",};
int pw_gxwd_full = 0 with {0,,,INVIS, " Width of gxw decay pulse for full echo.",};
int pw_gxwexmax = 1ms with {0,,1ms,INVIS, " Max width of readout extender.",};
int pw_gxwd_temp = 0 with {0,,,INVIS, " Temporary width of decay ramp",};

/*MRIhc04779*/
int smartp_rtpend_wait = 200 with {1,3000,200, VIS,"waiting time for RtpEnd and CoilSwitch to complete in (ms)",};

/* x readout killer cv's */
float gxwex_target = 1.0 with {0.1,,1.0,INVIS, "Target amplitude of gxwex pulse",};
float area_gx1 = 0;
float area_gxwex = 0;
int gxwex_on = 1 with {0,1,0, VIS, "switch to turn on extra readout period",};
int gxwex_bridge = 1 with {0, 1, 1, INVIS, "Bridge gwx and gxwex pulses 0=OFF, 1=ON",};
float max_area_gxwex = 800.0 with {0.0,,800.0,INVIS, "max area of gxwex pulse",};

int derate_gxwex = 0;
float gxwex_target_hfdslite = 1.3;
float gxwex_target_hfdslite_value_3dde = 1.7;

/* ssc checking */
float total_area_gx = -1;
float total_area_gz = -1;
float area_gx2 = -100.0;
float area_gxfc = 0;
float area_gxw = 0;
float total_area_gxfc = -1;
float total_area_gzfc = -1;

/* int pw_gxwexmax = 1ms with {0,,1ms,INVIS, " Max width of readout extender.",};*/
int pw_gxwex1 = 0 with {0,,,INVIS, " Prelim width of readout extender.",};
/* int pw_gxwex = 0 with {0,1ms,,INVIS, " Width of readout extender.",}; */

/* y gradient variables */
int pw_gks = 0 with {0,,,INVIS, " Max width of x, y, and z sp sat crusher.",};
int pw_gyks = 0 with {0,,,INVIS, " Width of y sp sat crusher.",};
int pw_gyksa = 0 with {0,,,INVIS, " Width of y sp sat crusher attack.",};
int pw_gyksd = 0 with {0,,,INVIS, " Width of y sp sat crusher decay.",};
float a_gyks = 0 with {0,,,INVIS, " Amplitude of y sp sat crusher.",};


/* rf variables */
int res_dephase = 35 with {0,,35,INVIS, " Number of res points after rf1 peak.",};
int pw_rf1_pre = 0 with {0,,,INVIS, " Width of rf1 in PS1.",};
float cyc_rf1_pre = 0 with {0,,,INVIS, " Number of sinc cycles of rf in PS1.",};

float cyc_rf1_temp = 0 with {0,,,INVIS, " Temp sinc cycles of rf in PS2, SCAN.",};
int res_rf1_temp = 0 with {0,,,INVIS, " Temp resolution of rf in PS2, SCAN.",};

/* z gradient variables */
float a_comb = 0 with {,,,INVIS, " Lgest neg amp of comb refocus and slice select.",};
float a_base = 0 with {,,,INVIS, " Amp of the refocus only.",};
float a_end = 0 with {,,,INVIS, " Lgest pos amp of comb refocus and slice select.",};
float a_delta;  /* delta amplitude between slice encoding steps */
float a_gk = 0 with {0,,,INVIS, " Amplitude of z killer pulse.",};
float area_gzk = 0 with {0,,,INVIS, " Area of z killer pulse.",};
float a_comb2 = 0 with {,,,INVIS, " Lgest pos amp of comb killer and rewinder.",};
float a_base2 = 0 with {,,,INVIS, " Amp of the killer only.",};
float a_end2 = 0 with {,,,INVIS, " Lgest pos amp of comb killer and rewinder.",};
float a_delta2; /* delta amplitude between slice rewinding steps */
int pw_gzcomb_tot = 0 with {0,,,INVIS, " Time for rephaser / encoder pulse.",};
int gzptime = 0 with {0,,,INVIS, " Time for killer / rewinder pulse.",};
float a_gzrf1temp = 0 with {,,,INVIS, " Temp amp of slab select for scan.",};
int pw_gzrf1a_temp = 0 with {,,,INVIS, " Temp width of slab select attack for scan.",};
int pw_gzrf1d_temp = 0 with {,,,INVIS, " Temp width of slab select decay for scan.",};
float ia_rf1_temp = 0 with {,,,INVIS, ". Temp iamp of rf1 for scan.",};
float ia_gzrf1_temp = 0 with {,,,INVIS, ". Temp iamp of gzrf1 for scan.",};
float a_gzfc = 0 with {,,,INVIS,"",};
int pw_gzfca = 0 with {,,,INVIS,"",};
int pw_gzfc = 0 with {,,,INVIS,"",};
int pw_gzfcd = 0 with {,,,INVIS,"",};
float area_gzfc = 0 with {,,,INVIS,"",};

/* spatial sat variables */
int sp_sat = 0 with {0,,,INVIS, "Flag to indicate SAT on or off.",};
int sp_satend = 0 with {0,,,INVIS, "Time after sp sat crusher.",};
int satview = 12 with {0,,12, VIS, " Frequency of spatial SAT pulses.",}; 
int scansatint = 0 with {0,,,INVIS, " SAT interval used in scancore.",};
int scansat0 = 0 with {0,,,INVIS, " First slice for SAT in scancore.",};
int num_sats = 0 with {0,,,INVIS, " Number of sat and disdaq trs.",};
int sat_dda = 0 with {0,,,INVIS, " Number of sat and disdaq trs during disdaqs.",};


/* True min/max number of scan locations */
int min_slquant = 0;
int max_slquant = 0;


/* CVs for oddnex cases */
int oddnex_npw;         /* flag for oddnex and npw case */
/* truenex is now defined in epic.h */
/* float truenex; */    /* CV to store true nex for NPW oddnex */
int nex_save; /* VAL15 12/14/2004 YI */


int pw_drcv = 10 with {0,,10,INVIS, "width of the receiver packet",};
int sar_amp;  /* debug variable for power monitor */
int sar_cycle;
int sar_width;
int slquant_per_trig = 0 with {0,,0,INVIS, "slices in first pass or slices in first R-R for XRR scans",};
int rhmeth = 0 with {0,1,0,VIS, " 0=standard recon(key the filter size off x_acq_size, 1=homodyne recon (key the filter size off fft size)",}; 
int td0  = 4 with {0,,1,INVIS, "Init deadtime",};
int t_exa = 0 with {0,,0,INVIS,"time from start of 90 to mid 90"};
int t_exb = 0 with {0,,0,INVIS,"time from mid of 90 to end 90"}; 
int iso_delay = 0 with {0,,0,INVIS,"time from point of zero phase precession to end of 90"}; 
float iso_delay_frac = .109375;  /* ratio of iso_delay to pulse width */
int t_rd1a = 0 with {0,,0,INVIS,"time from start of readout to echo peak"};
int t_rd1a_frac = 0 with {0,,0,INVIS,"time from start of readout to echo peak for frac. echo"};
int t_rd1a_full = 0 with {0,,0,INVIS,"time from start of readout to echo peak for full echo"};
int t_rdb = 0 with {0,,0,INVIS,"time from echo peak to end of readout"};
int t_rdb_frac = 0 with {0,,0,INVIS,"time from echo peak to end of readout for frac. echo"};
int t_rdb_full = 0 with {0,,0,INVIS,"time from echo peak to end of readout for full echo"};
int tdaq = 0 with {0,,0,VIS,"time interval of data acquisition"}; 
int te_time = 0 with {0,,0,INVIS," te * opnecho ",};
int tr_pad = 0;
int tfe_extra = 0 with {0,,0,INVIS, "savings for fract echo ",};
int time_ssi = 80us with {0,,250ms,INVIS, "time from eos to ssi in intern trig",};
int time_ssi_pre = 400us with {0,,250ms,INVIS, "time from eos to ssi in intern trig for CFH, CFL, MPS1, and APS1",};
int time_seqwait = 300us with {200,,300,INVIS, "seq time for seqwait_dum",};
/* MRIge54218 - increased tlead to 56us from 12 us to avoid gradient overrange */
int tlead = 56us with {0,,24us,INVIS, "Init deadtime",}; 
int zoffs, zoffs1, zsign; /* slab offset CVs */

/* These CVs are used to override the triggering scheme in testing. */
int psd_mantrig = 0 with {0,1,0, INVIS, "manual trigger override",};
int trig_mps2 = TRIG_LINE with {0,,TRIG_LINE, INVIS, " mps2 trigger",};
int trig_aps2 = TRIG_LINE with {0,,TRIG_LINE, INVIS, " aps2 trigger",};
int trig_scan = TRIG_LINE with {0,,TRIG_LINE, INVIS, " scan trigger",};
int trig_prescan = TRIG_LINE with {0,,TRIG_LINE, INVIS, "prescan trigger",};

int tmin_reduced = 0 with {0,,0,INVIS, "It is used to shorten the TR based on waveforms",};
int tmin_satoff = 0 with {0,,0,INVIS, "Min time determined by waveforms when sp sat is off",};

int use_myscan = 0 with {0,,0,INVIS,"On(=1) to use my scan setup",};
float myslice_off = 0 with {0,,0,INVIS,"Slice offset for scan debug in mm",};
float myfreq_off  = 0 with {0,,0,INVIS,"Freq. offset for scan debug in mm",};
float myphase_off = 0 with {0,,0,INVIS,"Phase offset for scan debug in mm",};

int debug_scan = 0 with {0,,0,INVIS,"On(=1) to print scan & rsp info tables",};
int debug_order = 0 with {0,,0,INVIS,"On(=1) to print data acq order table",};
int debug_tdel = 0 with {0,1,0,VIS,"On(=1) to print ihtdeltab table",};
int isi_flag = 0 with {0,,1,INVIS,"on(=1) flag for isi interrupt routine",};
int spgr_flag = 0 with {0,,0,INVIS,"on(=1) if spoiled grass",};
int mph_flag = 0 with {0,,0,INVIS,"on(=1) flag for FAST Multi-Phase option",};
int cs_flag = 0 with {0,,0,INVIS,"on(=1) if fat or water sat is on.",};
int rewinder_flag = 1 with {0,1,0,INVIS,"on when PSD_CINE, opexor or !mpgr_flag",};
int ss_rewinder_flag = 1 with {0,1,1,INVIS,"Same shape rewinder flag: 0=OFF, 1=ON",};
int ssp_pwisi7 = 0 with {0,,0,INVIS," minimum ssp spacing for ISI7",};

int show_rtfilts = 0 with {0,1,0,INVIS,"Print real time filter specs(=1)",};
/* Allow 62.5 kHz receiver bandwidth */
int vrg_sat = 0 with {0,1,0,INVIS, "VRG SAT code",};

int opslblank = 2 with {0,,2,VIS, "Number of kiss-off slices per slab side",};

/* CVs for multi-phase */
int sldelay = 1s with {0,,0,INVIS,  "inter slice delay",};
int sldeltime = 0 with {0,,0,INVIS,  "actual wait time",};
int slicecnt; /* slices B4 pause */

/* view acquisition order control variables */
int phorder = 0 with {0,3,0,VIS, "phase/view ordering: 0=normal, 1=centric, 2=reverse centric, 3=reverse sequential",};

int viewoffs = 0 with {0,512,0,VIS, "Number of views to offset in centric mode",};
int slq_shots;

/* LAVA and LAVA-FLEX NEX mode, interleave or sequential */
int lava_ave_mode = 2 with {0,2,2,INVIS, "0 interleave 1 sequential 2 Off",};
int pcfiesta_rf = 0 with {0,1,0,INVIS,"fiesta-C Slab Excitation Mode 0: Conventional 1: better profile",};

/* encode_group: Grouping strategy for non-separable sampling patterns 
   ZY grouping (Try to group views along kz and then along ky) 
   YZ grouping (Try to group views along ky and then along kz) */
int encode_group = 0 with {0,2,0,VIS,"Phase encode grouping 0: None 1:ZY grouping 2: YZ grouping",};

/* HCSDM00241750 */
int pfkr_yz_flag = 0 with {0, 2, 0, VIS, "1=pfkr with kz, 2=pfkr with ky",};
int pfkr_yz_enable = 0 with {0, 1, 0, VIS, "Partial kr with sequential ky/kz enable flag: 0=OFF, 1=ON",};
int echo_sort_dir = -1 with {-1, 1, -1, VIS, "direction echoes are acquired within segmented views (1=ascending, -1=descending)",};
int seg_sort_dir = -1 with {-1, 1, -1, VIS, "direction segmented views are acquired within scan (1=ascending, -1=descending)",};
int num_dummy_segmentedTR = 3 with {0, 10, 3, VIS, "LAVA segmented TR disdacqs for centric_flag",};
int chemsat_acq = 0 with {0, 20, 0, VIS, "chemsat adjustment for optspecir()",};

int breastCoil_flag = 0 with {0, 1, 0, INVIS, "breast coil selected: 0=no, 1=yes", };

/* HCSDM00326359, HCSDM00359899 */
int turbo_cemra_enable = 0 with {0, 1, 0, VIS, "Turbo ceMRA enable flag: 0=OFF, 1=ON",};
int turbo_cemra_flag = 0 with {0, 1, 0, VIS, "Turbo ceMRA: 0=OFF, 1=ON",};

/* creating rf waveform directly, so need to declare these */
int pw_rf1; /* pulse width of rf pulse */

int off_rf1=0;
int ia_rf1;
float cyc_rf1;
float a_rf1;
float alpha_rf1=0.46;
float gscale_rf1=1.0;
float flip_rf1;
float thk_rf1;

/* more definition for SPSP pulse */
int res_gzrf1;
float a_thetarf1;
int ia_thetarf1;
int pw_thetarf1;
int res_thetarf1;
int off_thetarf1 = 0; 
float spsp_min_opvthick = 100.0 with { 3.0, 5000.0, 100.0, INVIS, "Minimum volume thickness in mm",};
int rftype = 1 with {0,1,1,VIS,"1=extern rfpulse, 0=sinc rfpulse",};
int thetatype = 1 with {0,1,0,VIS,"1=play extern theta pulse, 0=no theta",};
int gztype = 1 with {0,1,1,VIS,"1=extern grad, 0=create by macro",};
int zgmn_type;          /* specifies degree of FC on Z */
int pulsepos;           /* variables used in gradient moment nulling */
int invertphase;        /* variables used in gradient moment nulling */
int hrf1a, hrf1b;       /* location of rf1 center */
/* Omega Scale (8 bit shift = 256) */
float omega_scale= 256.0 with {1.0,4096.,256.,INVIS, "Instruction amplitude scaling",};

int rf0_pulse_type = 0 with {0,4,0,VIS,"0 = Nonselective IR; 1 = Adiabatic HS 20MS; 2 = Adiabatic HS; 3 = Adiabatic HS high bandwidth; 4 = Adiabatic tanh"};

@inline ss.e ssCV

/* MS Half alpha half TR ALP */
int pw_rf1htr;
float a_rf1htr;
int ia_rf1htr;
float cyc_rf1htr;

/* obloptimize */
int obl_debug = 0 with {0,1,0,INVIS,
                        "On(=1) to print messages for obloptimize",};
int obl_method = 1 with {0,1,1,INVIS,
    "On(=1) to optimize the targets based on actual rotation matrices",};
int initnewgeo; /* 3d oblique - latha@mr */
int fs_pi  = 32752 with {0,,32752,INVIS,"Phase board value for pi radians",};
int fs_2pi = 65504 with {0,,65504,INVIS,"Phase board value for 2pi radians",};
int seed   = 21001 with {0,,21001,INVIS,"Spoiled Grass seed value",};
int seeddef = 21001 with {0,,21001,INVIS,"Default SPGR seed value",};

int xres = 256 with {0,1024,256, VIS, "No. of points to recon",};

float area_gxks;                 /* Area of GXKS SAT killer */
float area_gyks;                 /* Area of GYKS SAT killer */
float area_gzks;                 /* Area of GZKS SAT killer */
float area_gz1; 
int avail_image_time;            /* act_tr for norm scans, */
                                 /* R_R avail time for cardiac */ 
int avail_temp;

/* creating rf waveform directly, so need to declare these */
int bw_rf1;      /* bandwidth of rf pulse */
float maxb1_rf1;

float encode, refocus, encode2;  /* volume encode and refocus area */

float cyc_rf2;
int pw2_eff;            /* effective pulse width of rf2 */

float fecho_factor;     /* percentage of the echo acquired */
int flow_comp_type;     /* on if flow comp */
int fullte_flag;        /* flag for full echo */
int max_bamslice;       /* max slices that can fit into bam */

/* min sequence times based on rf amp, sar, grad coil heating */
int max_seqsar;                 /* min tr based on sar */
int max_seqsar_orig;            /* used in COSMIC calculations- MRIhc16039 */
int max_regsar;			/* min tr based on reg sar */
int max_satsar;			/* min tr based on sat sar */
int min_seq2, min_seq1, min_seq3; /* advisory panel */
int min_seqx, min_seqxz;        /* used for min full echo calculation */
int min_seq2_echo2, min_seq2_echo3, min_seq2_echo4;

int non_tetime;
int rewinding_time;             /* gradient rewinding time */
int add_tetime;
int attenlength = 6;            /* length for attenuator. */
int tnslength = 4;
int slice_size;			/* bytes per slice */
float std_amp;			/* std amp of 1ms rect pulse */
float temp_float;		/* temp float value */

float xmtaddScan;

int dobaselines = 1;          /* switch for baselines */
int scptrg = 0 with {0,1,0,,"SCOPE TRIGGER TYPE",};
int dither_on = 0;		 /* 1 means turn dither on  */
int dither_value = 6 with {0,15,6,VIS, "Value for dither",};

/* cine CVs */
int choplet = 0 with {0,1,0,INVIS,"On chopper, scan lets pcm do chopping",};

int premid_rf90 = 0 with {0,,0, INVIS,"Time from beg. of seq. to mid 90", };

int field_strength;          /* for use in rsp */

   /* IR PREP (pjg) */
int min_ti;

int adj_act_tr;

/* fat, water in/out-of phase cvs */
int llimte1;
int llimte2;
int llimte3;
int ulimte1;
int ulimte2;
int ulimte3;

int maxx, maxy; /* maximum legal xres and yres for psd used by matrixcheck */

/* CVs for testing */
float profile_opvthick;
float slab_fact = 1.05 with {0,,,VIS, "factor to make 3D volume slab thinner",};
int product_rf = 1 with {0,1,0,VIS, "For 3200ms RF, use product parameters",};
int debug_viewtab = 0 with {0,1,0,VIS,"1 if debug viewtab is on",};

int pw_gy1_tot;       /* temp time accumulation */
int pw_gy1r_tot;       /* temp time accumulation */
float yfov_aspect = 1.0 with {0,,,INVIS, "acquired Y FOV aspect ratio to X",};
int pi_piphasfovnub; /* rectFOV&NPW  05/11/2005 YI */

   /* IR PREP (pjg) */
/* CVs for inversion pulses */
int irprep_flag = 0 with {0,,0,INVIS,"on(=1) flag for FAST IR PREP option",};
int irdisdacqs = 2 with {0,4,2,VIS,"Disdacqs after IR pulse",};
int slorder = 0 with {0,5,0,VIS,"Flag for type of centric slice order",};
int irfreq;
float irscale;
int bw_rf0;
int bw_rffrir;
float temp_factor = 1.0 with {0.0,,1.0,INVIS,"temp_factor",};
int tseq_irprep = 0 with {0,,,INVIS, "Sequence time for the prep section",};
int tseq_prep_frir = 0 with {0,,0,INVIS, "Sequence time for the FRIR prep section",};
int min_tseq_irprep = 0 with {0,,,INVIS, "Minimum Sequence time for the prep section",};
int pos_start_ir = 0 with {0,,,INVIS, "Start time for IR prep sequence. ",};
int pos_start_frir = 0 with {0,,0,INVIS, "Start time for FRIR prep sequence. ",};

int prep_dda = 4 with {0,,4,VIS," number of disdaqs in scan",};

int t2prep_flag = 0 with {0,1,0,INVIS,"on(=1) flag for T2PREP option",};

int num_filter_slots;
int filterslot1;
int filterslot2;

/* MRIhc16353 - RV: IDEAL change */
int ideal_flag = 0 with {0,1,0,INVIS, "IDEAL enabling flag",};
int ideal_debug = 0 with {0, 1, 0, INVIS, "IDEAL debug flag (0: off, 1:on)",};
int ideal_opt_te = 0 with {0,1,0,INVIS, "Flag for optimized TE for IDEAL (0: off, 1: on)",};
int ideal_te1 = 1000 with {0,,,INVIS, "Dixon IDEAL echo time setting for echo 1",};
int ideal_te2 = 2000 with {0,,,INVIS, "Dixon IDEAL echo time setting for echo 2",};
int ideal_te3 = 3000 with {0,,,INVIS, "Dixon IDEAL echo time setting for echo 3",};
/* MRIhc16353 - RV: ideal_shift[1-3] contain shift of echoes relative to shortest of 3 echo
times */
int ideal_shift1, ideal_shift2, ideal_shift3,ideal_shift_max;
int k_ideal_pi;
float dix_freq = FATWATER_DIXFREQ_1_5T with {0.0,,FATWATER_DIXFREQ_1_5T,INVIS, "dixon separation freq",};
int ideal_necho = 1 with {1,3,1,INVIS, "Number of dixon echoes",};
int ideal_pw, ideal_min, ideal_max;
int ideal_echo_mode = 1 with {0,1,1,INVIS, "Dixon sequential echo mode flag (0=interleaved echoes)",};
int seq_necho = 1 with {1,,,INVIS, "Number of Dixon echoes in sequential mode",};
int inter_necho = 1 with {1,,,INVIS, "Number of Dixon echoes in interleaved mode",};
int ideal_min_te;
int ideal_no_mag_im= 0 with {0,1,0,INVIS,"Turn off magntiude reconstruction",};
int ideal_max_im = 4000 with {0,12000,4000,INVIS,"Max number of images for IDEAL",};
int ideal_max_locs= 200 with {0,12000,200,INVIS,"Max number of slice locs for IDEAL",};

/* IDEAL IQ CVs */
int idealiq_flag = 0 with {0,1,0,INVIS, "IDEAL IQ enabling flag",};
int idealiq_enable_higher_flip = 0 with {0,1,0,INVIS, "1: Enable higher flip angle. Fat Fraction may be impacted.",};
int idealiq_pw = 0 with {0,,0,INVIS, "Maximum TE shift for interleaved echoes",};
int idealiq_esp = 0 with {0,,0,INVIS, "Effective echo spacing for IDEAL IQ",};
int idealiq_nshots = 1 with {1,,1,INVIS, "Number of TRs needed to acquire all echoes",};
int idealiq_ps_echo = 0 with {0,,0,INVIS, "Echo number to be used in scan TR",};

int idealiq_pc_flag = 1 with {0,1,1,INVIS, "IDEAL IQ Phase Correction enabling flag",};
int idealiq_pc_dimension = 1 with {1,2,1,INVIS, "IDEAL IQ Phase Correction Dimention",};
int idealiq_pc_ylines = 1 with {0,,1,INVIS, "IDEAL IQ Phase Correction number of reference ky lines",};
int idealiq_pc_zlines = 1 with {0,,1,INVIS, "IDEAL IQ Phase Correction number of reference kz lines",};
int idealiq_pc_ylower = 1 with {0,,1,INVIS, "IDEAL IQ Phase Correction reference region y lower limit",};
int idealiq_pc_yupper = 1 with {0,,1,INVIS, "IDEAL IQ Phase Correction reference region y upper limit",};
int idealiq_pc_zlower = 1 with {0,,1,INVIS, "IDEAL IQ Phase Correction reference region z lower limit",};
int idealiq_pc_zupper = 1 with {0,,1,INVIS, "IDEAL IQ Phase Correction reference region z upper limit",};
int idealiq_pc_extra_TR = 1 with {0,,1,INVIS, "IDEAL IQ Phase Correction number of extra TR",};
int idealiq_pc_dda = 2 with {0,,2, INVIS, "IDEAL IQ Phase Correction number of disdaq",};

/* IDEAL IQ CVs for auto flip angle */
float ff4error = 0.5 with {0,1.0,0.5,INVIS, "fat-fraction value used to calc flip angle ",};
float max_ff_error = 0.03 with {0,1.0,0.03,INVIS, "maximum T1-bias error allowed ",};
int idealiq_optfa = 3 with {1,,3,INVIS, "Optimized flip angle for IDEALIQ",};

@inline vmx.e SysCVs /* vmx 12/28/94 YI */

@inline Prescan.e PScvs

int endview_iamp; /* last instruction phase amp */
float endview_scale; /* ratio of last instruction amp to maximum value */
int endviewz_iamp; /* last instruction phase amp */
float endviewz_scale; /* ratio of last instruction amp to maximum value */
  
float dutycycle_scale; /* scale up dutycycle limit if sr17 to 
			  get TR's comparable to 5.4 */
			
/* Respiratory gating CV's */
int respgate_flag = 0 with {0,1,,VIS,"Resp. gate acquisition",};
int resp_dda = 0 with {0,16,,VIS,"Number of disdaqs for respiratory gating",};
float respdc = 1.0; 
/* Intermittant ChemSat and SpecIR CVs*/
int sl_per_chem;
int slfreq;
int chemfreq;
float chemscale;
int fatT1 = 260ms with {0,1s,,VIS,"Estimated T1 of fat (us)",};
int slice_dda = 0 with {0,10,0,INVIS, " Number of slice loop disdaqs.",};
int specirsol = 1 with {0,1,1,VIS,"1=Use improved SpecIR flip calc.",};
int specsolreps = 8 with {0,32,8,VIS,"Number of Bloch iterations for SpecIR flip calc",};

/* BBA - Improved Special CVs */
int extraspecial_flag = 0 with {
    0, 1, 0, VIS, "Flag to turn on Extra Special.",
};
int extraspecial_seq_order_flag = 1 with {
    0, 1, 1, VIS, "Use sequential k-space ordering for Extra Special (0=OFF, 1=ON).",
};
int nsegments;
int linestodiscard = 0;
int chemseq0 = 1;
int chemseqs = 8;

float act_echofrac = 1 with {,,,VIS, "Actual echo fraction acquired",};

/* Slice ZIP */
int hires_recon = 1 with {0,1,1,VIS,"Use 512 reconstruction.",};
int recon_1024 = 0 with {0,1,0,VIS,"Use 1024 reconstruction.",}; /* pradeeps@wiproge */
int slicezp =  1 with {0,4,1,INVIS,"Factor to increase slice Fourier transform.",};

int offset = 0 with {0,128,0,VIS,"Number of slices to shift fat null",};

float tsp = 5.0us;  /* sampling interval  */
int dab_packet = 1;
int dab_offset = 0;
int xtr_offset = 0;
int scanrcvr = TYPRECVALL;
float gldelayf = FREC_MIN_PROG_DEL with {-1.0ms,1.0ms, 0.0us,INVIS,
        "Logic delay fine (us).",};
float rbw; /* in Hz */
float valid_rbw,valid_max_rbw, valid_decimation;
int rcvr_ub_off = -100;  /* receiver unblank offset from beg of echo1 packet */
/* in Hz */
float avmaxrbw_system;  /* HCSDM00360543 */

int zrewind_flag = 1 with {0,1,0,INVIS,"slice-encode rewinder",};
int zkiller_flag = 1 with {0,1,0,INVIS,"slab killer",};
int turbo_flag = 0 with {0,2,0,VIS,"Turbo 3D",};
int vstrte_flag = 0 with {0,1,0,VIS,"VSTRTE",};
int rfupacv= 50 with {,250,50,VIS,"RF unblank time",};

int dummyrf_time = 30ms with {0,100ms,30ms,VIS,"Initial RF Unblank Check Sequence Time",};
int dummyrf_ssitime = 1ms with {0,2ms,1ms,VIS,"RF Unblank Check Sequence SSI Time",};
int minimize_RFunblank_time = PSD_ON with {PSD_OFF,PSD_ON,PSD_ON,VIS,"Flag to minimize RF Unblank",};

int use_ecg_scancore = 0 with {0,1,,VIS,"Use ecg_scancore()",}; 
int reverseLoopOrder_flag = 0 with {0,1,,VIS,"Reverse Loop Order flag",}; 
int ecg_dda = 1 with {0,,1,VIS,"number of ECGs used as disdaqs",};
int ecg_dda_delay = 0 with {0,,1,VIS,"number of disdaqs use for trigger delay",}; 
int ecg_cont_dda_flag = 1 with {0,1,,VIS,"Play out r.f. continously.",};

int rvssliceenc;

int firstSeriesFlag = TRUE;        /* Used to keep track of when the firstSeries */
                                   /* has been downloaded. */

/* MRIhc22324 Fast table movement with multi station */
int tablespeed = 0 with {0,,0,INVIS,"Table speed (um/sec) 0: default",};
int tableaccel = 0 with {0,,0,INVIS,"Table accel (um/sec^2) 0: default ",};
int tabledecel = 0 with {0,,0,INVIS,"Table decel (um/sec^2) 0: default",};

int seq3dtr = 16ms with {1ms, 1s, 16ms, VIS, "Duration of 3D packet sequence.",};
int threedpktdly = 1 with {0, ELLIPT_CEN_MAX, 0, VIS, "Number of TRs to delay the"
                           " 3D packet.",};;

int seq3ddummytr = 5ms with {0, 1s, 5ms, VIS, "Duration of dummy 3D plane packet sequence",};

int sep3d = 0;
int d3dtr = 16ms;
int old_phase = 1;

/* MRIge66079 - ATV: RTIA3D/ftMRA */
/* use same naming convention of RTIA/RTCA when possible */ 
int ftmra_flag = 0 with {0,1,0,VIS,"ftmra flag 0-disable, 1-enable",};
int ftmra_enable_flag = 0 with {0,1,0,VIS,"ftmra enable flag 0-disable, 1-enable",};
int maskv_ftmra_flag = 0 with {0,1,0,VIS,"Mask or Venous acq. w/FTMRA flag 0-false, 1-true",};
int ftmra_sat_flag = 0 with {0,1,0,VIS,"opsat(ftmra) 0-disable, 1-enable",};
int ftmra_exsat_flag = 0 with {0,1,0,VIS,"opexsatmask(ftmra) 0-disable, 1-enable",};
int ftmra_dfsat_flag = 0 with {0,1,0,VIS,"opsatz(ftmra) 0-disable, 1-enable",};
int ftmra_hard180_act;
int ftmra_debug = 1;
float rtca_min_fov;

float rtca_max_fov;
int rtca_insteps_fov;
float rtca_min_slthick;
float rtca_min_slabthick=20.0;
float rtia_satgapzpos = 30.0;
float rtia_satgapzneg = 30.0;
float rtca_max_slthick;
float rtca_insteps_slthick;
float rtca_min_flip;
float rtca_max_flip;
int rtca_insteps_flip;
int rtia3d_original_flip;
int rtia3d_original_slthick;
int rtia3d_original_fov;
float rtia3d_eff_slabthick;
float rtia3d_slice_thinning_factor;
int rtia3d_pass = 15ms;
int rtia3d_phorder = REVERSE_CENTRIC;
int rtia3d_sat_views  = 65;
int rtia3d_turbo = TRUE;
int rtia3d_buffers = 3;
int rtia3d_repeat_views; 
int rtia3d_thkslab_proj_enable_flag= 0 with {0, 1, 0, INVIS, "Thick Slab Projection Enable (0=off, 1=on)",};
int rtia3d_thkslab_proj_flag= 1 with {0, 1, 0, INVIS, "Thick Slab Projection (0=off, 1=on)",};
int rtia3d_irp_flag= 0 with {0, 1, 0, INVIS, "Real-time IRP (0=off, 1=on)",};
int rtia3d_restricted_nav_flag= 0 with {0, 1, 0, INVIS, "Restricted Real-time navigation (0=off, 1=on)",};
float zslab=3.0;
float area_de=0.0;
float a_base_proj_dephaser=0.0;
float a_base_max;
int ia_de=0;

/* End RITA3D/ftMRA */

/* ATV: flags to support FIESTA mode */
int ssfp_flag = 0 with {0, 1, 0, INVIS, "FIESTA Mode (0=off, 1=on)",};
int ssfp_symmetry_flag = 0; 
int higher_dbdt_flag = 0 with {0, 0, 0, VIS, "Higher dB/dt limit (0=off, 1=on)",};
int t_slice2read;
int t_slicereadgap;
int add_slicereadgap;

/* HK: addl flags for supporting Fiesta-C */
int pcfiesta_flag = 0 with {0, 1, 0, INVIS, "Phase Cycled FIESTA Mode (0=off, 1=on)",};
int phase_cycles = 1; /* Setting default value to 1 as it is incorporated in generic nreps calculation */

/* VAL15 12/14/2004 YI */
int pc_mode = PC_BASIC with {PC_APC, PC_BASIC, PC_BASIC, INVIS, "Phase Cycle Mode (0:APC 1:SGS 2:Basic)",};
/* FIESTA derating  05/16/2005 YI */
float acgd_lite_target = 1.7 with {
    0.5,, 1.7, INVIS, "Target amp(G/cm) for ACGD-lite duty optimization", 
};

/* YMSmr09956 09/11/2007 YI */
int monwritectrl = 0 with {0,3,0,VIS,"bit 1: save mon data, 2:long pass time",};

/* MS Half alpha half TR ALP */
int act_htr = 0 with {0,,,VIS, "half alpha sequence TR",};
int fiesta_rampup_type = 0 with {0,3,1,VIS,"enable ramp flip dda after fatsat 1:linear 2:fermi 3:sinusoidal",};
int debug_scale = 0 with {0,1,0,VIS,"1 if debug scaling is on",};
/* VAST CVs */
@inline VAST.e VASTcv
/* AP - Phase ASSET CVs */ 
@inline Asset.e AssetCVs

/* ASSET with TOF and Flip <= 15 flag */
int tof_lowflip_asset_flag = 0 with { 0, 1, 0, INVIS, "Flag for ASSET with TOF and flip <= 15.", };

/* Fatsat CVs for the high resolution fatsat crusher manipulation AC */
/* area of gy1 gradient at each step */
float area_gy1table;
/* area of gy1 grad */
float area_gy1grad;
/* fatkiller_flag is activated in ChemSatSpecIR.e file depending on the areagy1grad */  
int fatkiller_flag = 0 with {0, 1, 0, VIS, "Fat Sat Crusher Mode (0=off, 1=invscale 2=areaincrease)  ",};  
int gykcs_max   = 1 with {0, 1, 0, VIS, "Max amplitude for gykcs flag (0=off, 1=on)",};
int ia_gykcs_max = 0;

int slab_wrap_corr = 0 with {0,128,0, VIS,
      "Slab wrap correction",};
float ethick;   /* encoded volume thickness */
int equant = 32 with {1, MAX_SLICES_PER_PASS, 32, VIS, "number of slice encodes", };
int arc_equant; /* number of slice encodes after slice acceleration */
float assetsl_min_opvthick = 180.0; /* minimum opvthick for slice ASSET in mm */ 

@inline Tricks.e TricksCv
@inline Disco.e DiscoCv
@inline FastCINE3D.e fcine3d_cv

int cs_satstart_min;
int pos_start_ir_min;

int ir_seqtime_adjust = 0ms with {0ms,30s,0ms, VIS, "IR seqlength delta time",};

/* IR Prep */
float rf0_phase = 0 with {0.0,,0.0,INVIS,"Relative phase of 180 in cyc",}; /* for adiabatic pulse */
int use_slr_inv = 0 with {0,1,0,VIS,"1=Use SLR 180 inversion pulse instead of adiabatic",};
float rffrir_phase = 0 with {0.0,,0.0,INVIS,"Relative phase of 180 in cyc",};

/* IFIR */
int ifir_flag = 0 with {0,1,0,INVIS,"IFIR flag: 0=OFF, 1=ON",};
float ifir_vthick = 300 with {200,350,300,INVIS, "IR Slab thickness of IFIR",};
float ifir_position = 0 with {,,,INVIS, "IR rf position of IFIR",};
int fiesta_killer_flag = 0 with {0,1,0,INVIS,"fiesta killer flag: 0=OFF, 1=ON",};
int tseq_gzk = 0 with {0,,,INVIS, "Sequence time for the Gz Killer section",};
int pos_start_gzk = 0 with {0,,,INVIS, "Start time for Gz Killer sequence. ",};
int ifir_stir_flag = 0 with {0,1,0, VIS, "IFIR STIR flag: 0=OFF, 1=ON",};
int ifir_frir_flag= 0 with {0,1,0, VIS, "Fast recovery IR for STIR IFIR: 0=OFF, 1=ON",};

/* MRIge91682 */
int pfkz_flag = 0;
int pfkz_vps_max=18;
float pfkz_fraction = 1.0 with { 0.5, 1.0, 0.70, VIS, "Partial kz fraction (unaccelerated)", };
int pfkz_total_unaccel = MAX_SLICE3D with {0, , , VIS, "Partial kz threshold (unaccelerated)",};
float pfkz_fraction_min = 0.70 with { 0.5, 1.0, 0.70, VIS, "Minimum partial kz fraction (unaccelerated)", };
int pfkz_segments = 1;
int pfkz_views_per_segment = 18;
int pfkz_hnover = 0 with {0, , , VIS, "Partial kz overscans (accelerated)",};
int pfkz_reverse_seq=0;

float pfky_fraction = 1.0 with { 0.0, 1.0, 0.75, VIS, "Partial Ky Fraction", };
int pfky_total_unaccel = YRES_MAX with {0, , , VIS, "Unaccelerated Frac NEX threshold",};

int lava_flag = 0 with {0,1,0,INVIS,"Lava flag: 0=OFF, 1=ON",};
int brava_flag = 0 with {0,1,0,INVIS,"Axial Vibrant flag: 0=OFF, 1=ON",};
int vibrant_flag = 0 with {0,1,0,INVIS,"Sagittal Vibrant flag: 0=OFF, 1=ON",}; 

int aspir_override = 0 with {0,1,0,INVIS,"Forced ASPIR flag: 0=OFF, 1=ON",};

/* MRIge91683 */
int stre_flag= 1 with {0, 1, 0, INVIS, "stre flag (0=off, 1=on)",};
int count_rfupd = 0;
int count_grd_wait = 0;
int ns3d_flag= 0 with {0, 1, 0, INVIS, "ns3d flag (0=off, 1=on)",};
int quickstep_flag= 0 with {0, 1, 0, INVIS, "quickstep flag (0=off, 1=on)",};

/* MRIhc22600 -  since WARP has a lateny of about 16 us in processing the incoming data, with no deadtime,
gradient overrange errors occur when the rotation angle is changed during realtime acuqiestion. 
Following variable adds a deadtime (waitTime) when ftmra_flag or maskv_ftmra_flag is ON */
int waitTime = 16;

/* MRIge91684 */
@inline RFb1opt.e RFb1optCVs

int flextr_flag = 0 with {0,1,0,INVIS,"Flexible TR flag: 0=OFF, 1=ON",};
int flexte_flag = 0 with {0,1,0,INVIS,"Flexible TE flag: 0=OFF, 1=ON",};
int multiEcho_flag = 0 with {0,1,0,VIS,"ME flag: 0=OFF, 1=ON",};
int uniPolar_flag = 0 with {0,1,0,VIS,"uniPolar flag: 0=OFF, 1=ON",};
int merge_flag = 0 with {0,1,0,VIS,"MERGE flag: 0=OFF, 1=ON",};
int merge_min_echoes = 3 with {3,16,3,VIS,"MERGE minimum echoes",};
int merge_targetTE = 13ms with {,,,INVIS,"",};
int merge_defaultTE = 13ms with {,,,INVIS,"",};
int merge_mintr = 30ms with {,,,INVIS,"",};
float merge_satweight = 1.0 with {,,,INVIS,"",};
float merge_echoIndex = 1.0 with {,,,INVIS,"",};
int de3d_flag = 0 with {0,1,0,VIS,"3D Dual Echo flag: 0=OFF, 1=ON",};
int medal_flag = 0 with {0,1,0,VIS,"MEDAL flag: 0=OFF, 1=ON",};
int medal_autote_flag = 0 with {0,1,0,VIS,"MEDAL auto TE flag: 0=OFF, 1=ON",};
int medal_autotelock_flag = 1 with {0,1,1,INVIS,"MEDAL auto TE lock flag: 0=OFF, 1=ON",};
int medal_flexecho_order_flag = 0 with {0,1,0,VIS,"MEDAL flexible echo order flag: 0=OFF, 1=ON",};
int medal_multitr_flag = 0 with {0,1,0,VIS,"MEDAL multi-TR flag: 0=OFF, 1=ON",};
float medal_freq_min = 0 with {,,,INVIS,"",};
float medal_freq_max = 0 with {,,,INVIS,"",};
float medal_freq_ave = 0 with {,,,INVIS,"",};
float medal_fw_freq_ave = 210.0 with {,,,INVIS,"",};
float medal_fw_freq_ulimit = 240.0 with {,,,INVIS,"",};
float medal_fw_freq_llimit = 180.0 with {,,,INVIS,"",};
int medal_pi_min = 0 with {,,,INVIS,"",};
int medal_pi_max = 0 with {,,,INVIS,"",};
int medal_pi_ave = 0 with {,,,INVIS,"",};
int medal_oop_te_plus = 400us with {,,,INVIS,"",};
int medal_oop_te_minus = 200us with {,,,INVIS,"",};
int medal_ip_te_plus = 400us with {,,,INVIS,"",};
int medal_ip_te_minus = 200us with {,,,INVIS,"",};
int medal_oop_te = 0 with {,,,INVIS,"",};
int medal_oop_te_max = 0 with {,,,INVIS,"",};
int medal_oop_te_min = 0 with {,,,INVIS,"",};
int medal_ip_te = 0 with {,,,INVIS,"",};
int medal_ip_te_max = 0 with {,,,INVIS,"",};
int medal_ip_te_min = 0 with {,,,INVIS,"",};
int medal_k_oop_pi = 0 with {,,,INVIS,"",};
int medal_k_ip_pi = 0 with {,,,INVIS,"",};
int medal_pw, medal_min, medal_max;
int medal_shift1, medal_shift2, medal_shift_max;
int medal_necho = 1 with {1,2,1,INVIS, "Number of MEDAL echoes",};
int medal_te1 = 1000 with {0,,,INVIS, "MEDAL echo time setting for echo 1",};
int medal_te2 = 2000 with {0,,,INVIS, "MEDAL echo time setting for echo 2",};
int medal_te1_upper = 1000 with {0,,,INVIS, "MEDAL upper bound of 1st TE (us)",};
int medal_te2_upper = 2000 with {0,,,INVIS, "MEDAL upper bound of 2nd TE (us)",};
int medal_echo_mode = 0 with {0,1,0,INVIS, "MEDAL sequential echo mode flag (0=interleaved echoes)",};
int medal_etl = 2 with {1,16,1,INVIS, "MEDAL etl",};
int medal_enh_flag = 1 with {0,1,1,VIS, "MEDAL recon enhancement enabling flag",};
int medal_max_xres = 1024 with {128, 1024, 1024, INVIS, "MEDAL maximum xres to satisfy TE and TE2 condition",};
int pos_hard180 = 276;
float flip_hard180 = 100.0 ;
int hard180time = 10ms;

/* ARC CVs */
int vibrantxv_flag = 0 with {0,0,0,INVIS,"vibrant-xv flag: 0=OFF, 1=ON",};
int arc_research_flag = 0 with {0,1,0,INVIS,"ARC Research flag: 0=OFF, 1=ON",};
int bravo_flag = 0 with {0,1,0,INVIS,"BRAVO flag: 0=OFF, 1=ON",};
int bravo_fatsat = 0 with {0,1,0,INVIS,"BRAVO Fat Sat flag: 0=OFF, 1=ON",};

float arc_ph_maxnetaccel = 1.0 with {1.0, , 1.0, INVIS, "ARC Phase Max Net Acceleration",};
float arc_ph_netaccel = 1.0 with {1.0, , 1.0, INVIS, "ARC Phase Net Acceleration",};
float arc_sl_maxnetaccel = 1.0 with {1.0, , 1.0, INVIS, "ARC Slice Max Net Acceleration",};
float arc_sl_netaccel = 1.0 with {1.0, , 1.0, INVIS, "ARC Slice Net Acceleration",};

float arc_maxnetaccel = 1.0 with {1.0, , 1.0, INVIS, "ARC Total Max Net Acceleration",};
float arc_netaccel = 1.0 with {1.0, , 1.0, INVIS, "ARC Total Net Acceleration",};
float arc_recnetaccel = 1.0 with {1.0, , 1.0, INVIS, "ARC Total Recommended Acceleration",};
float arc_reclimnetaccel = 1.0 with {1.0, , 1.0, INVIS, "ARC Total Recommended Limit Acceleration",};

float arc_ph_maxstride = 1.0 with {1.0, MAX_ACCEL , 1.0, INVIS, "ARC Phase Max Outer Acceleration",};
float arc_ph_stride = 1.0 with {1.0, , 1.0, INVIS, "ARC Phase Outer Acceleration",};
float arc_ph_recstride = 1.0 with {1.0, , 1.0, INVIS, "ARC Phase Recommended Outer Acceleration",};
float arc_ph_userstride = 1.0 with {1.0, , 1.0, INVIS, "ARC Phase User prescribed  Outer Acceleration",};
float arc_ph_reclimstride = 1.0 with {1.0, , 1.0, INVIS, "ARC Phase Recommended Limit Outer Acceleration",};
int arc_ph_mincalwidth = 28 with {0, , 28, INVIS, "Minimum # of fully sampled phase encoding lines for ARC",};
int arc_ph_intaccel = 0 with {0, 1, 0, VIS, "Enforce integer phase acceleration",};

float arc_sl_maxstride = 1.0 with {1.0, MAX_ACCEL , 1.0, INVIS, "ARC Max Slice Outer Acceleration",};
float arc_sl_stride = 1.0 with {1.0, , 1.0, INVIS, "ARC Slice Outer Acceleration",};
float arc_sl_recstride = 1.0 with {1.0, , 1.0, INVIS, "ARC Slice Recommended Outer Acceleration",};
float arc_sl_userstride = 1.0 with {1.0, , 1.0, INVIS, "ARC Slice User prescribed Outer Acceleration",};
float arc_sl_reclimstride = 1.0 with {1.0, , 1.0, INVIS, "ARC Slice Recommended Limit Outer Acceleration",};
int arc_sl_mincalwidth = 24 with {0, , 24, INVIS, "Minimum # of fully sampled slice encoding lines for ARC",};
int arc_sl_intaccel = 0 with {0, 1, 0, VIS, "Enforce integer slice acceleration",};

int arc_syn_pts = 0 with {0,,0,INVIS,"Number of points to be synthesized by ARC",};
int arc_debug_files = 0 with {0, 1, 0, INVIS, "ARC debug flag: 0=OFF, 1=ON",};
int arc_cal_echo = -1 with {-1, , -1, VIS, "Echo to use for calibration: -1 self cal",};

int phasefovgt1_flag = 0 with {0, 1, 0, INVIS, "Enable pFOV > 1 support",};
int zy_export_debug_files = 0 with {0, 1, 0, INVIS, "readZyExport & writeZyExport debug flag: 0=OFF, 1=ON",};

int unaccel_rhnframes; /* Number of unaccelerated frames */
int cal_shape = 0 with {0, 2, 0, VIS, "Calibration Region Shape: 0: Cross, 1:Box, 2: Ellipse",};
int accel_phaseres; /* Number of accelerated frames without fractional NEX */;

/* "Packing" BAM refers to mapping the view/slice to the beginning of the set of views/slice
   "Reducing" BAM refers to reducing the allocation of BAM and sort/nex'ing into that smaller allocation
   BAM must be "Packed" in order to "Reduce" it */
int arc_pack_bam = 0 with {0, 15, 0, VIS, "BAM bitmask: 1-Pack Y, 2-Pack Z, 4-Reduce Y, 8-Reduce Z"};
int autocal_mode = ACCEL_ARC with {0, ACCEL_ARC, ACCEL_ARC , VIS, "Self-calibrated parallel imaging mode (4-GEM, 11-ARC)",};
int unaccel_dayres = 0;

int osfp_flag = 0 with {0,1,0,VIS,"OSFP flag: 0=OFF, 1=ON",};
int osfp_dda = 15 with {5,100,15,INVIS,"OSFP dda: 5-100",};
int osfp_debug = 0 with {0,1,0,INVIS,"OSFP debug: 0=OFF, 1=ON",};
int osfpsd_flag = 1 with {0,1,1,INVIS,"OSFP slowdown flag: 0=OFF, 1=ON",};
int osfpR_flag = 0 with {0,1,0,INVIS,"OSFP Rflag: 0=OFF, 1=ON",};
float osfp_weight = 1.0;
float osfp_weight_grad = 1.0;
float post_osfp_weight = 1.0;
float osfp_weight_act = 1.0;
float osfp_delay_factor = 0.75 with {0,10.0,0.75,INVIS,"OSFP delay factor: 0-10.0",};;

int segmented_flag = 0 with {0,1,0,INVIS,"Segmented flag: 0=OFF, 1=ON",};
int segment_tr = 2s;
int min_segment_tr = 2s;
int end_segment_delay = 0 with {0,10s,0,INVIS,"End segment delay: 0-10s",};
int min_end_segment_delay = 0 with {0,10s,0,INVIS,"End segment delay: 0-10s",};
int views_per_segment = 16;
int nr_of_segments = 1 with {1,,1,INVIS,"No. of segments:",};
int seg_vps_min = 192 with {8,2048,192,INVIS,"pfkr min vps",};
int seg_vps_max = 320 with {8,2048,320,INVIS,"pfkr max vps",};
int seg_vps_target = 256 with {8,2048,256,INVIS,"pfkr targ vps",};
int seg_vps_range = 32;
int seg_foundvps_flag = FALSE;
int seg_totalPEs;

int radfb_flag = 0 with {0,1,0,VIS,"Radial FB flag: 0=OFF, 1=ON",};
int delay3Drecon_flag = 0 with {0,1,0,INVIS,"Delay 3D recon flag : 0=OFF, 1=ON",};

int pfkr_flag = 0 with {0,1,0,INVIS,"Partial kr flag : 0=OFF, 1=ON",};

float pfkr_fraction = 0.7 with { 0.55, 1.0, 0.7, INVIS, "Partial Kr fraction", };
float pfkr_fraction_act = 0.7 with { 0.55, 1.0, 0.7, INVIS, "Partial Kr fraction", };
float krfermecorr_factor = 1.0;
int pfkyz2kr_flag = 1 with {0,1,1,INVIS,"Partial kyz2kr flag : 0=OFF, 1=ON",};

/* ungated FatSat FIESTA */
int allow_ugfsf = PSD_OFF with  {PSD_OFF, PSD_ON, PSD_OFF, VIS, "allow ungated FatSat FIESTA",""};
int ugfsf_flag = 0 with {0, 1, 0, VIS, "ungated FatSat FIESTA (0=off,1=on)",""};
int num_shot = 1 with  {1, 4, 2, VIS, "# of SpecIR per slice encode",""};
int view_per_shot;
int view_to_center;
int target_ti = 120ms with {50ms, , 120ms, VIS, "Target TI for ungated FatSat FIESTA",""};
int ugfsf_view_order_flag = 2 with {0, 2, 0, VIS, "view order (0=mod seq, 1=intlv rev seq, 2=centric)",""};
int ugfsf_slice_order_flag = 1 with  {0, 1, 1, VIS, "slice order (0=seq, 1=modified seq for breath-hold)",""};
int ugfsf_slice_dda = 1 with  {0, , 1, VIS, "slice dda",""};
int ugfsf_shot_delay = 0ms;
int ugfsf_ramp_dda = 0 with  {0, , 0, VIS, "# of dda with linear ramp up",""};
int ugfsf_flat_dda = 0 with  {0, , 0, VIS, "# of dda with amplitude of ia_rf1",""};
int ugfsf_linear_ramp_down = 20 with  {0, , 0, VIS, "# of linear ramp down after shot",""};
int resp_gate_trig_sw = 0 with {0, 1, 0, VIS, "0:resp trigger, 1:resp gating",""};

/* HDsv 03/16/2009 YI */
int fs_pcfiesta_flag = PSD_OFF with  {PSD_OFF, PSD_ON, PSD_OFF, VIS, "Flag for FatSat FIESTA-C support",""};

/* MRIhc15599 */
int swap_fat_cs = 0 with {0, 1, 0, VIS, "Flag for reversing chemical shift direction",""};

/* RF Safety Optimization */
int bf_rfscale = 0 with {0,, 0, INVIS, "BF Rf scale",""};
int rfsafetyopt_timeflag = PSD_OFF with {PSD_OFF, PSD_ON, PSD_OFF, VIS, "RF Safety Optimization time calculation flag",};

/* GEHmr02868: */
float ogsf_limit_Min = 0.005 with { 0.005, 1.0, 0.005, INVIS, "minimum allowed for ogsf* scaling factor", };
float ogsf_limit_Max = 1.0 with { 0.005, 1.0, 1.0, INVIS, "maximum allowed for ogsf* scaling factor", };
float ogsfX2_limit_Min = 0.7 with { 0.005, 1.0, 0.7, INVIS, "minimum allowed for ogsfX2 scaling factor", };

int aTEopt_flag = 0 with {0,1,0,INVIS,"Adaptive TE optimization flag: 0=OFF, 1=ON",};
int aTRopt_flag = 0 with {0,1,0,INVIS,"Adaptive TE+TR optimization flag: 0=OFF, 1=ON",};
float ogsfMax = 0.9 with { 0.1, 1.0, 0.9, INVIS, "Maximum gradient scaling factor", };
float ogsfMin = 0.2 with { 0.05, 1.0, 0.2, INVIS, "Minimum gradient scaling factor", };
float ogsfXw = 1.0 with { 0.1, 1.0, 1.0, INVIS, "Xw gradient scaling factor", }; 
float ogsfX1 = 1.0 with { 0.1, 1.0, 1.0, INVIS, "X1 gradient scaling factor", }; 
float ogsfX2 = 1.0 with { 0.1, 1.0, 1.0, INVIS, "X2 gradient scaling factor", }; 
float ogsfXwex = 1.0 with { 0.1, 1.0, 1.0, INVIS, "Xwex gradient scaling factor", };
float ogsfY = 1.0 with { 0.1, 1.0, 1.0, INVIS, "Y gradient scaling factor", }; 
float ogsfYk = 1.0 with { 0.1, 1.0, 1.0, INVIS, "Y rewinder gradient scaling factor", };
float ogsfZ = 1.0 with { 0.1, 1.0, 1.0, INVIS, "Z gradient scaling factor", }; 
float ogsfZk = 1.0 with { 0.1, 1.0, 1.0, INVIS, "Z killer gradient scaling factor", };

/* GEHmr02509: parameters used in smart derating */
int gradOpt_flag = 0              with {0, 1, 0, INVIS, "Flag to turn on/off Smart derating: 0=OFF, 1=ON",};
int gradOpt_TE = 0                with {0, 1, 0, INVIS, "Smart derating: 1=allow to longer TE, 0=don't allow",};
int gradOpt_GX2 = 0               with {0, 1, 0, INVIS, "Smart derating for GX2 pulse",};
int gradOpt_aTETR_method = 0      with {0, 1, 0, INVIS, "0=legacy adative TE/TR method; 1=new method",};
int gradOpt_powerOpt_flag = 1     with {0, 1, 0, INVIS, "Smart derating: 1=optimization based on Power; 0=don't optimize",};
int gradOpt_iter_count = 30;      /* the maximum iterative count */
int gradOpt_Piter_count = 20;     /* the maximum iterative count for optimizationi based on Power */
float gradOpt_scale = 1.0;        /* general derating factor */
float gradOpt_scale_Min = 0.1;    /* minimum allowed general derating factor */
float gradOpt_scale_Max = 1.0;    /* maximum allowed general derating factor */
float gradOpt_ratio = 1.0;        /* ratio of derating factor between TE group Pulse
                                     (gx1,gy1,gzcomb,gxfc,gz1) and TR group Pulse (gxwex,gy1r,gzp) */
float gradOpt_tor = 0.005;        /* allowed tolerance for difference between tmin and min_seqgrad */
float gradOpt_Ptor = 0.02;        /* allowed tolerance for ratio based on Power */
float gradOpt_weight = 0.9;       /* weighting used in gradOpt_scale iteration */
float gradOpt_Pweight = 0.9;      /* weighting used in gradOpt_ratio iteration */
float gradOpt_powerTE = 1.0;      /* power of TE group pulses (gx1,gy1,gzcomb,gxfc,gz1) */
float gradOpt_powerTR = 1.0;      /* power of TR group pulses (gxwex,gy1r,gzp) */
float gradOpt_TRfactor = 1.0;     /* additional derating factor for TR group pulses (gxwex,gy1r,gzp) */
float gradOpt_TEfactor = 1.0;     /* additional derating factor for TE group pulses (gx1,gy1,gzcomb,gxfc,gz1) */
float gradOpt_TEfactor_Max = 4.0; /* maximum allowed additional derating factor for TE group pulses */
float gradOpt_TEfactor_Min = 1.0; /* minimum allowed additional derating factor for TE group pulses */
float gradOpt_TRfactor_Max = 4.0; /* maximum allowed additional derating factor for TR group pulses */
float gradOpt_TRfactor_Min = 1.0; /* minimum allowed additional derating factor for TR group pulses */
float gradOpt_slewRate;           /* SlewRate after dbdt Optimization */

/* HCSDM00360543 */
int force_gradOpt_loop_break = 0  with {0, 1, 0, INVIS, "Flag to break smart derating loop",};
float save_gradOpt_scale = 1.0;
float save_gradOpt_ratio = 1.0;
float save_gradOpt_TEfactor = 1.0;
float save_gradOpt_TRfactor = 1.0;
float save_ogsfX1 = 1.0;
float save_ogsfY = 1.0;
float save_ogsfZ = 1.0;
float save_ogsfX2 = 1.0;
float save_ogsfXwex = 1.0;
float save_ogsfYk = 1.0;
int do_maxrbw_check_in_cveval = 0  with {0, 1, 0, VIS, "Flag to check max BW in cveval",};

/* HCSDM00392380 */
int run_eval_from_get_flag = 0 with {0, 1, 0, INVIS, "Flag to enable cveval call for getting variables op-code",};

/* SVBranch, HCSDM00092046 */
float gradOpt_slewRate_tmp;       /* temporal SlewRate after dbdt Optimization */
float gradOpt_slewRate_limit = 0.05;    /* allowed SlewRate difference */

/* SVBranch, HCSDM00100051 */
int gradOpt_convergence_flag = 1        with {0, 1, 1, INVIS, "Flag for convergence", };
float gradOpt_nonconv_tor = 0.01        with {0.0, , 0.01, INVIS, "allowed tolerance when convergence fails", };
float gradOpt_nonconv_tor_limit = 0.05  with {0.0, , 0.05, INVIS, "maximal allowed tolerance when convergence fails", };
int gradOpt_run_flag = 0                with {0, 1, 0, INVIS, "Flag to identify smart derating is running", };

int xlFOV_flag = 0 with {0, 1, 0, INVIS, "Enable eXtra Large FOV with BODY coil",};

int swanfirstTE = 0 with {,,,INVIS,"",};
int swan_flag = 0 with {0,1,0,VIS,"SWAN flag: 0=OFF, 1=ON",};
int phmask = 1 with {0,1,1,VIS,"SWAN phase masking: 0=OFF, 1=ON",};

int bridge_gxw2_gxwex_3dde = 0 with {0,1,0,INVIS,"Bridge gxw2 and gxwex flag for 3D DE: 0=OFF, 1=ON",};

/* SVBranch, HCSDM00102521, HCSDM00094105 */
float xfd_power_limit = 8.5 with { 2.0, 15.0, 8.5, INVIS, "XFD PS limitation", };
float xfd_temp_limit = 8.5  with { 2.0, 15.0, 8.5, INVIS, "XFA temperature power limitation", };
int elava_flag = 0 with {0, 1, 0, INVIS, "Using new ChemSat RF pulse for LAVA",};

int nav_avaiRRtime;
int max_navgate_tr = 200ms with {0ms, , 200ms, VIS, "Maximum Repetition time of navigator for gating",""};
int act_navgate_tr = 200ms with {0ms, , 200ms, INVIS, "Actual Repetition time of navigator for gating",""};
int navgate_dda = 4 with {0, , 4, VIS, "Disdaqs for navigator gating",""};
int nav_time_per_seg = 200ms with {0ms, , 200ms, VIS, "Navigator time per segment",""};
int num_views_per_nav_tr = 20 with {0, , 20, VIS, "Number of views per navigator",""};
int navky_segments = 1 with {0, , 1, VIS, "Number of segments per navigator",""};
int navky_views_per_segment = 20 with {0, , 20, VIS, "Number of ky views per navigator",""};
int navkz_views_per_segment = 20 with {0, , 20, VIS, "Number of kz views per navigator",""};
int nav_time_per_yview = 200ms with {0ms, , 200ms, VIS, "navigatgor time per yview",""};
int nav_time_per_zsegment = 200ms with {0ms, , 200ms, VIS, "navigatgor time per zsegment",""};
int navsegment_dda = 0 with {0, , 0, VIS, "Number of navigator disdacqs between segment",""};
int nav_nreps = 100 with {0, , 100, VIS, "Number of repetitions for navigator",""};
int nseg_per_nav_tr = -1 with {-1, , -1, VIS, "# kz segments per navigator TR period; negative until set",""};
/* ChemPrep in dda */
int nav_chemdda = 1 with {-1, , -1, VIS, "# kz segments per navigator TR period; negative until set",""};
float navseg_weight = 1.0 with {0.0, , 1.0, VIS, "first navigator segment weighting factor in Navigator Signal Enhancement",""};
int nav_linear_ramp_up = 0 with {0, , 0, VIS, "number of ramp up pulses in Navigator Signal Enhancemet",""};
int nav_linear_ramp_down = 0 with {0, , 0, VIS, "number of ramp down pulses in Navigator Signal Enhancemet",""};
float nav_1st_factor = 0.5 with {0.0, 1.0, 0.5, VIS, "factor of 1st pulse in Navigator Signal Enhancemet",""};
float nav_last_factor = 0.5 with {0.0, 1.0, 0.5, VIS, "factor of last pulse in Navigator Signal Enhancemet",""};
int nav_wait_flag = 0 with {0, 1, 0, VIS, "flag for wait sequence in Navigator Signal Enhancemet",""};
int ifir_dnav_flag = 0 with {0, 1, 0, VIS, "flag for dual navigator in IFIR Nav",""};
int debug_nav = 0 with {0,1,0,VIS,"debug print statements for nav",""};

/****************************/
/* Vessel Wall Imaging MSDE */
/****************************/
@inline MSDE.e MSDE_CVs
float msde_rate = 0.0625 with {0.0, 1.0, 0.0625, VIS, "MSDE pulse rate", ""};

float ave_grady_gy1_scale = 1.0 with {-1.0,1.0,1.0,VIS,"average gradient scale for gradient thermal calc",};
float ave_gradz_gzcomb_scale = 1.0 with {,,1.0,VIS,"average gradient scale for gradient thermal calc",};
float ave_gradz_gzp_scale = 1.0 with {,,1.0,VIS,"average gradient scale for gradient thermal calc",};

/* HCSDM00339164  Annefact Reduction */
int annefact_reduction_flag = PSD_OFF with {PSD_OFF,ANNEFACT_REDUCTION_HIGH,PSD_OFF,VIS,"Flag for annefact reduction",""};
int annefact_c3_recon_flag = PSD_OFF with {PSD_OFF,PSD_ON,PSD_OFF,VIS,"Flag for C3 recon for annefact reduction",""};
float fract_echo_annefact_reduction = 0.6 with {0.6,0.75,0.6,VIS,"Fractional echo factor for annefact reduction",""};
int xres_ann_off; /* xres for annefact reduction off */
int xres_ann_on; /* xres for annefact reduction on */

int headneck_pos_scan = 0 with {0,1,0,VIS,"Flag for headneck pos scan",""};

int channel_combine_mode = 1 with {0,1,1,VIS,"Channel combine method for MERGE. 0=SOS, 1=C3",""};

@host
/*********************************************************************
 *                      EFGRE3D.E HOST SECTION                       *
 *                                                                   *
 * Write here the code unique to the Host PSD process. The following *
 * functions must be declared here: cvinit(), cveval(), cvcheck(),   *
 * and predownload().                                                *
 *********************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/stat.h>

#include "epic_error.h"
#include "epic_iopt_util.h"
#include "printDebug.h"
#include "psdIF.h"
#include "psdopt.h"
#include "setPulseParams.h"
#include "ReconEngineSupport.h"
#include "recon_model_interface.h"
#include "sar_burst_api.h"
#include "sar_display_api.h"
#include "sar_limit_api.h"
#include "sokPortable.h"

#include "sar_pm.h"
#include "grad_rf_efgre3d.h"
#include "grad_navmonitor.h"

/* Needed for epic_warning() */
#include "epic_warning.h"

/* fec : Field strength dependency library */
#include "sysDep.h"
#include "sysDepSupport.h"      /* FEC : fieldStrength dependency libraries */
#include "psd.h"
#include "acoustic_reduction.h"

/* VAL15 12/14/2004 YI */
@inline vmx.e HostDef
@inline loadrheader.e rheaderhost
@inline MSDE.e MSDE_Host

#ifdef EMULATE_HW
#define checkOptionKey(x) 0
#endif

#define HEADNECK_SCAN_MATRIX 46

struct ramp {                                                                 
    int xrt;                                                                   
    int yrt;                                                                   
    int zrt;                                                                   

    int xft;                                                                   
    int yft;                                                                   
    int zft;                                                                   
} myhw; 

/* Private interface */
static STATUS set_gzrf1_params (void);
static STATUS set_gzcomb_params ( void );
static STATUS set_gzk_gzp_params (void );
static STATUS set_gy1_gy1r_params ( void );
static STATUS set_rdout_and_tmin (void );

/* MRIge66079 - ATV: RTIA3D/ftMRA */
STATUS ftmra_init (void);
STATUS ftmra_eval (void);
/* End RTIA3D/ftMRA */

char  estr[80];

int av_temp_int;                 /* temp placement for advisory 
                                    panel return values */
float av_temp_float;             /* temp placement for advisory 
                                    panel return values */
FILTER_INFO *echo1_filt ;        /* These will point to 
                                    a structure defining
                                    parameters of the filter
                                    used for the 1st echo
                                    and 2nd through N echos */


FILTER_INFO echo1_rtfilt, echo1_rtfilt_frac; 
/* for fgre3d use real time  filters,
   so allocate space for them 
   instead of trying to point to
   an infinite number of structures
   in filter.h. */

static char supfailfmt[] = "Support routine %s failed";

/* Variables that hold status for software option keys */
int SmartPrepKey;
int SPECIALKey;
int BREAST2Key;
int VIBRANTDEKey;
int MultiStationKey;
int UltraFastKey;
int FiestaKey;
int FiestaCKey;
int FSFiestaKey;
int ftMRAKey;
int ASSETKey;
int ARCKey;
int TRICKSKey;
int MDEKey;
int NavigatorKey;
int LAVAKey;
int LAVAXVKey;
int BRAVOKey;
int COSMICKey;
int SwiFTKey;
int LAVADEKey;
int QUICKSTEPKey;
int MERGEKey;
int IDEAL3DKey;
int DE3DKey;
int SWAN3DKey;
int Inh3DIFIRKey;
int Heart3DKey;
int IDEALIQKey;
int PhaseImageKey;
int SmartDerKey;
int BODYNAVKey;
int DISCOKey;
int mdeplusKey;
int VESSELVIEWKey;
int APXKey;
int cine3DKey;
int flow4DKey;

/* Added backward compatibility case for 3.2ms rf pulse - latha@mr */
int UnLocked;

/* Defines to simulate the protection of efgre vs fgre    */
#define Present 1
#define Absent 0

/* peak B1 amplitudes */
float maxB1[MAX_ENTRY_POINTS], maxB1Seq;

/* Loop counters */
int entry, pulse;

int nextemp; /* temp nex holder */

int temprfpw[RF_FREE];   /* temporary storage of pulse widths*/
float temprffa[RF_FREE]; /* temporary storage of flip angle */
int numgrads;            /* grad pulse in min_seqcoil calculation */
int numpulses;           /* rf pulse in host calculations */
float satweight;         /* weight for spatial sat pulses */
float chemweight;        /* weight for chemical sat pulses */
float regweight;         /* weight for regular pulses */

int ftmrasat_rf_act[NUMRFSAT];

/* IFIR GRx */
int temp_rfgir01pw;
float temp_rfgir01fa;
int temp_rfgir02pw;
float temp_rfgir02fa;

int tmin_total_temp;     

/* rf1 scaling for gated intermittent MDE */
int temp_rf1pw;
int temp_rf1fa;

static int plane_type;

/* Boolean variable to decide whether the opuser0 CV can be shown */
static short num_stations_flag = FALSE;
static short maskv_loadprotocol_flag = FALSE;

int maskval, venousval; 

/* MRIge54970 */
float maxhwrbw = PSD_MGD_BW1;   /* max receiver BW of cerd */
 

/* Global host variable to hold rise times to enable 
   different SlewRate estimation models eg: Most conservative, 
   (that from obloptimize) partially conservative (dbdtderate),
   based on actual pulse timing (calcOptimizedPulses) */ 

int xrt = 0;
int yrt = 0;
int zrt = 0;

double b1rms_eval;
/* Global flag for loop ordering */
static int reverseLoopOrder;
/* Generic return status variable */
static STATUS status;

/* For enabling more than 1024 im/ser -Venkat */
int enable_1024 = 0; 
int max_slice_limit = DATA_ACQ_MAX;

/* ARC parameters */
float arc_phmaxslreclim_netaccel = 1.0; /* ARC Max Phase Slice Recommended Limit Net Acceleration */ 
float arc_ph_recnetaccel = 1.0;         /* ARC Phase Recommended Net Acceleration */ 
float arc_sl_recnetaccel = 1.0;         /* ARC Slice Recommended Net Acceleration */
float arc_ph_reclimnetaccel = 1.0;      /* ARC Phase Recommended Limit Net Acceleration */
float arc_sl_reclimnetaccel = 1.0;      /* ARC Slice Recommended Limit Net Acceleration */


/* ARC Calibration parameters */
int arc_ph_callower; /* ARC phase dir cal region lower limit */
int arc_ph_calupper; /* ARC phase dir cal region upper limit */
int arc_sl_callower = 0; /* ARC slice dir cal region lower limit */
int arc_sl_calupper = MAX_SLICE3D;

int sampledPointsNoMask;

/* IDEAL parameters */
int ideal_pi;

/* IDEAL IQ parameters */
int idealiq_min_esp = 0; /* minimum echo spacing allowed (in usec) */
int idealiq_max_esp = 0; /* maximum echo spacing allowed (in usec) */
int idealiq_min_xres = 0; /* minimum xres estimated to satisfy esp condition */
int idealiq_max_xres = 0; /* maximum xres estimated to satisfy esp condition */
int idealiq_num_bad_region = 9; /* number of bad regions that would result in low SNR */
float dTE_lb[9] = {0.87, 0.89, 0.91, 0.93, 0.85, 0.87, 0.89, 0.91, 0.93}; /* esp lower limit in pi */
float dTE_ub[9] = {0.89, 0.91, 0.93, 0.95, 0.87, 0.89, 0.91, 0.93, 0.95}; /* esp upper limit in pi */
float TE1_lb[9] = {0.61, 0.55, 0.51, 0.45, 1.57, 1.51, 1.47, 1.43, 1.39}; /* TE1 lower limit in pi */
float TE1_ub[9] = {0.77, 0.79, 0.79, 0.77, 1.85, 1.85, 1.83, 1.81, 1.79}; /* TE1 upper limit in pi */

/* RF Safety Optimization host globals */
int whilecounter = 0;
int rfsafetyopt_timecountB;
int rfsafetyopt_timecountE;

/* MRIhc20325 Using WFM Multistation support */
int wfmMultistationFlag = -1;

static int etl_override = 0;

/* **********************
   Load up PSD header 
   ******************* */
psdname("EFGRE3D");
abstract("Enhanced Fast GR/SPGR/FIESTA 3D Database");

/* ****************************************
   MYSCAN
   myscan sets up the scan_info table for a hypothetical scan.
   It is controlled by the cv opslquant, and opslthick, and opfov. 
   ************************************** */
void myscan3d(void)
{
    int i,j;
    int num_slice;
    float t_delta;	
  
  
    num_slice = equant*exist(opvquant); 

    t_delta = exist(opslthick);

    scan_info[0].optloc = 0.5*t_delta*(num_slice-1)+myslice_off;
    scan_info[0].oprloc = myfreq_off;
    scan_info[0].opphasoff = myphase_off;

    for(i=1;i<num_slice;i++) {
        scan_info[i].optloc = scan_info[i-1].optloc - t_delta;
        scan_info[i].oprloc = myfreq_off;
        scan_info[i].opphasoff = myphase_off;
        for(j=0;j<9;j++)
            scan_info[i].oprot[j] = scan_info[0].oprot[j];
    }
  
}


/* ****************************************
   dump filters
   prints out the filter parameters
   ************************************** */
void dump_filter(PSD_FILTER_GEN	*spec)
{
    int i;

    for(i=0;i<4;i++) {
    
        if (spec[i].filter_slot==0) 
            printf ("Filter spec %d empty\n",i);
        else {
            printf ("Filter spec %d:\n",i);
      
            printf (" Parameter Specifications for slot %ld\n",spec[i].filter_slot);
      
            printf (" Number of taps = ");
            if (spec[i].taps == 0)
                printf ("1\n");
            else
                printf ("%ld\n", spec[i].taps);
            printf (" Number of outputs = %ld\n", spec[i].outputs);
            printf (" Number of taps to prefill = %ld\n", spec[i].prefills);
            printf ("\n Coefficient Specifications\n");
            printf (" Coefficient-based quadrature detection ");
            printf (" Frequency = +/- %f\n", spec[i].filfrq);
        }/* if slot!=0 */
        fflush(stdout);
    }/* for i*/
}

@inline Prescan.e PShostVars

@inline Tricks.e TricksHostVars
@inline Tricks.e TricksHostFunctions

@inline efgre3d_iopts.e AllSupportedIopts
@inline efgre3d_iopts.e ImagingOptionFunctions

@inline ARC.e ARCsetup /* MRIhc42465 for PIUI */
@inline Asset.e AssetDebug
/* ****************************************
   CVINIT
   cvinit is invoked once and only once when
   the psd host process is started up.  Place
   code here that is independent of any OPIO
   button operation.
   ************************************** */
STATUS
cvinit( void )
{
#ifdef PSD_HW
    SmartPrepKey = !checkOptionKey( SOK_SMARTPREP );
    SPECIALKey = !checkOptionKey( SOK_SPECIAL );
    BREAST2Key = !checkOptionKey( SOK_BREAST2 ); 
    VIBRANTDEKey = !checkOptionKey( SOK_VIBRANTDE );
    LAVAKey = !checkOptionKey( SOK_LAVA );
    LAVAXVKey = !checkOptionKey( SOK_LAVAXV );
    BRAVOKey = !checkOptionKey( SOK_BRAVO );
    COSMICKey = !checkOptionKey( SOK_COSMIC3D ); 
    LAVADEKey = !checkOptionKey( SOK_LAVADE );
    QUICKSTEPKey = !checkOptionKey( SOK_QUICKSTEP );
    MERGEKey = !checkOptionKey( SOK_MERGE3D );
    if(val15_lock)COSMICKey = Absent;  /* 07/019/2005 YI */
    UltraFastKey = !checkOptionKey( SOK_USHORTTR ); 
    ftMRAKey = !checkOptionKey( SOK_FTMRA );
    FiestaKey = !checkOptionKey( SOK_FIESTA3D ); 
    FiestaCKey = !checkOptionKey( SOK_FIESTAC );
    FSFiestaKey = !checkOptionKey( SOK_FIESTA3DFS );
    ASSETKey = !checkOptionKey( SOK_ASSET );
    ARCKey = !checkOptionKey( SOK_ARC ); 
    TRICKSKey = !checkOptionKey( SOK_TRICKS );
    SwiFTKey = !checkOptionKey( SOK_SWIFT );
    NavigatorKey = !checkOptionKey( SOK_NAVIGATOR );
    MDEKey = !checkOptionKey( SOK_DELENHMT3D );
    Heart3DKey = !checkOptionKey( SOK_HEART3D );
    SmartDerKey = !checkOptionKey( SOK_EXPGRAD );
    mdeplusKey = !checkOptionKey( SOK_MDEPLUS );
    cine3DKey = !checkOptionKey( SOK_CINE3D );
    flow4DKey = !checkOptionKey( SOK_FLOW4D );

    if((SmartPrepKey == Present) || (ftMRAKey == Present) || (QUICKSTEPKey == Present))
    { 
        MultiStationKey = !checkOptionKey( SOK_SPREP99 );
    } 
    else 
    {
        MultiStationKey = Absent;
    }

    if( PSD_ON == idealiq_flag )
    {
        IDEAL3DKey = Present;
    }
    else
    {
        IDEAL3DKey = !checkOptionKey( SOK_IDEAL );
    }

    DE3DKey = !checkOptionKey( SOK_DE3D );
    SWAN3DKey = !checkOptionKey( SOK_SWAN3D );
    Inh3DIFIRKey = !checkOptionKey( SOK_INHANIFIR );
    IDEALIQKey = !checkOptionKey( SOK_IDEALIQ );
    PhaseImageKey = !checkOptionKey(SOK_PHASEIMG);
    BODYNAVKey = !checkOptionKey( SOK_BODYNAV );
    DISCOKey = !checkOptionKey( SOK_DISCO );
    VESSELVIEWKey = !checkOptionKey( SOK_VESSELVIEW );
    APXKey = !checkOptionKey( SOK_APX );
#else /* !PSD_HW */
    SmartPrepKey = Present;
    SPECIALKey = Present;
    BREAST2Key = Present;
    VIBRANTDEKey = Present;
    LAVAKey = Present;
    LAVAXVKey = Present;
    BRAVOKey = Present;
    COSMICKey = Present;
    LAVADEKey = Present;
    QUICKSTEPKey = Present;
    MERGEKey = Present;
    MultiStationKey = Present;
    UltraFastKey = Present;
    ftMRAKey = Present;
    FiestaKey = Present;
    FiestaCKey = Present;
    FSFiestaKey = Present;
    ASSETKey = Present;
    ARCKey = Present;
    TRICKSKey = Present;
    SwiFTKey = Present;
    MDEKey = Present;
    NavigatorKey = Present;
    IDEAL3DKey = Present;
    DE3DKey = Present;
    SWAN3DKey = Present;
    Inh3DIFIRKey = Present;
    Heart3DKey = Present;
    IDEALIQKey = Present;
    SmartDerKey = Present;
    PhaseImageKey = Present;
    BODYNAVKey = Present;
    DISCOKey = Present;
    mdeplusKey = Present;
    VESSELVIEWKey = Present;
    APXKey = Present;
    cine3DKey = Present;
    flow4DKey = Present;

#endif /* PSD_HW */

#ifdef ERMES_DEBUG
    use_ermes = 0;
#else /* !ERMES_DEBUG */
    use_ermes = 1;
#endif /* ERMES_DEBUG */

    /* Added backward compatibility - latha@mr */
    UnLocked = ((SmartPrepKey==Present) || (ftMRAKey==Present) 
                || (SPECIALKey==Present) || (QUICKSTEPKey == Present)
                || (Heart3DKey==Present));

@inline vmx.e SysParmInit  /* vmx 12/28/94 YI */

    if((!strncmp("HNScout",psd_name,7)) || ADD_SCAN_HEADLOC_SCOUT == opheadscout)
    {
        headneck_pos_scan = 1;
    }
    else
    {
        headneck_pos_scan = 0;
    }
 
    if (UnLocked)
    {
        if (((lava_flag || brava_flag || vibrant_flag) && (Present == UltraFastKey)) ||
            medal_flag || disco_flag)
        {
            pfkr_yz_enable = PSD_ON;
        }
        else
        {
            pfkr_yz_enable = PSD_OFF;
            pfkr_yz_flag = PSD_OFF;
        }

        if (PSD_ON != ssfp_flag)
        {
            if (pfkr_yz_enable && (PSD_ON == exist(opuser6)))
            {
                pfkr_yz_flag = 1;
            }
            else
            {
                pfkr_yz_flag = 0;
            }
        }

        if ( disco_flag && (!opresearch) )
        {
            int tmp_acc = 0;
            tmp_acc = (int)(exist(opuser11));

            switch (tmp_acc)
            {
              case 0:
                pfkr_yz_flag = 0;
                break;
              default:
              case 1:
                pfkr_yz_flag = 1;
                break;
              case 2:
                pfkr_yz_flag = 1;
                break;
            }
        }

        if (!((VALUE_SYSTEM_SVEM == value_system_flag) || (VALUE_SYSTEM_SVDM == value_system_flag)) && 
            ((exist(oppseq) == PSD_TOF) || (exist(oppseq) == PSD_TOFSP)) &&
            (PSD_OFF == exist(opcgate)) && (PSD_OFF == exist(oprtcgate)) && 
            (PSD_OFF == exist(opirprep)) && (PSD_OFF == exist(opquickstep)) &&
            (PSD_OFF == exist(opfat)) && (PSD_OFF == exist(opspecir)) && (PSD_OFF == exist(opwater)))
        {
            turbo_cemra_enable = PSD_ON;
        }
        else
        {
            turbo_cemra_enable = PSD_OFF;
        }

        if (turbo_cemra_enable && (PSD_ON == exist(opuser5)))
        {
            turbo_cemra_flag = PSD_ON;
        }
        else
        {
            turbo_cemra_flag = PSD_OFF;
        }
    }

    /* GEHmr02509: smart derating */
    gradOpt_tor = 0.005;
    if( VALUE_SYSTEM_SVEM == value_system_flag ||
        VALUE_SYSTEM_SVDM == value_system_flag )
    {
        gradOpt_flag = PSD_ON;
        multiEcho_eval();
        if( de3d_flag || ideal_flag || flow4D_flag ||
            medal_flag || (((exist(oppseq) == PSD_TOFSP) || (exist(oppseq) == PSD_TOF)) && (PSD_OFF == exist(opquickstep))) ) /* SVBranch, HCSDM00272187 */
        {
            gradOpt_TE   = PSD_OFF;
        }
        else
        {
            gradOpt_TE   = PSD_ON;
        }
    }
    else if( idealiq_flag )
    {

        multiEcho_init();
        multiEcho_eval();
        if( (B0_30000 == (int)cffield) && (PSD_XRMB_COIL == cfgcoiltype) )
        {
            gradOpt_flag = PSD_OFF;
            gradOpt_TE   = PSD_OFF;
            gradOpt_GX2  = PSD_OFF;
        }
        else
        {
            gradOpt_flag = PSD_ON;
            gradOpt_TE   = PSD_OFF;
            gradOpt_GX2  = PSD_ON;
            gradOpt_iter_count = 30;   /* SVBranch, HCSDM00100051 */
        }
        if( (B0_15000 == (int)cffield) &&
            ( (PSD_XRMW_COIL == cfgcoiltype) || (PSD_XRMB_COIL == cfgcoiltype) || (PSD_VRMW_COIL == cfgcoiltype) ) )
        {
            gradOpt_tor = 0.05;
        }
    }
    else if( flow4D_flag )
    {
            gradOpt_flag = PSD_ON;
            gradOpt_TE   = PSD_OFF;
    }
    /* HCSDM00362877  Set K15 smart derating configuration same as SV */
    else if( (PSD_VRMW_COIL == cfgcoiltype) && (B0_15000 == (int)cffield) )
    {
        gradOpt_flag = PSD_ON;
        multiEcho_eval();
        if( de3d_flag || ideal_flag || flow4D_flag ||
            (((exist(oppseq) == PSD_TOFSP) || (exist(oppseq) == PSD_TOF)) && (PSD_OFF == exist(opquickstep))) )
        {
            gradOpt_TE   = PSD_OFF;
        }
        else
        {
            gradOpt_TE   = PSD_ON;
        }
    }
    else if( ( (PSD_XRMW_COIL == cfgcoiltype) || (PSD_VRMW_COIL == cfgcoiltype) ) &&
             ( ( Present == SmartDerKey ) || (B0_30000 == (int)cffield) ) )
    {
        multiEcho_init();
        multiEcho_eval();

        if(pcfiesta_flag || tricks_flag || vibrant_flag || cine3d_flag ||
           brava_flag || medal_flag || de3d_flag || ideal_flag || (lava_flag && pfkr_yz_flag))
        {
            gradOpt_flag = PSD_ON;
            if( medal_flag || de3d_flag || ideal_flag || flow4D_flag || (lava_flag && pfkr_yz_flag))
            {
                gradOpt_TE   = PSD_OFF;
            }
            else
            {
                gradOpt_TE   = PSD_ON;
            }
            gradOpt_GX2  = PSD_OFF;
        }
        /* HCSDM00088253 */
        else if(((PSD_GE == exist(oppseq)) || (PSD_SPGR == exist(oppseq))) && 
                !lava_flag && !merge_flag && !swan_flag && !bravo_flag)
        {
            if((PSD_ON==exist(opcgate)) || (PSD_ON==exist(oprtcgate)) || (PSD_ON==exist(opmultistation)) ||
               (PSD_ON==exist(opfluorotrigger)) || (PSD_ON==navtrig_flag) || (PSD_ON==navgate_flag) ||
               (PSD_ON==exist(opsmartprep)) || (PSD_ON==exist(opirprep)) || (PSD_ON==exist(opssrf)))
            {
                gradOpt_flag = PSD_OFF;
                gradOpt_TE   = PSD_OFF;
                gradOpt_GX2  = PSD_OFF;
            }
            else
            {
                gradOpt_flag = PSD_ON;
                gradOpt_TE   = PSD_OFF;
                gradOpt_GX2  = PSD_OFF;
                gradOpt_tor = 0.05;
            }
        }
        else
        {
            if (turbo_cemra_enable)
            {
                gradOpt_flag = PSD_ON;
                gradOpt_TE   = PSD_ON;
                gradOpt_GX2  = PSD_ON;
            }
            else
            {
                gradOpt_flag = PSD_OFF;
                gradOpt_TE   = PSD_OFF;
                gradOpt_GX2  = PSD_OFF;
            }
        }
    }
    else
    {
        gradOpt_flag = PSD_OFF;
        gradOpt_TE   = PSD_OFF;
        gradOpt_GX2  = PSD_OFF;
    }

    /* SVBranch, Disable medal_autotelock_flag in SV due to it does not work well when smart derating is on*/
    if( (PSD_ON == gradOpt_flag) && (VALUE_SYSTEM_SVEM == value_system_flag || VALUE_SYSTEM_SVDM == value_system_flag) )
    {
	medal_autotelock_flag = 0;
    }
    else
    {
        medal_autotelock_flag = 1;
    } 
    
    /* SVBranch, HCSDM00094105, HCSDM00092046*/
    if( VALUE_SYSTEM_SVEM == value_system_flag ||
        VALUE_SYSTEM_SVDM == value_system_flag )
    {
        fs_pcfiesta_flag = PSD_ON;
        elava_flag = PSD_ON;
        enable_sbm = PSD_ON;
    }
    else
    {
        fs_pcfiesta_flag = PSD_OFF;
        elava_flag = PSD_OFF;
        enable_sbm = PSD_OFF;
    }

    if(PSD_ON == minseqrf_cal)
    { 
        cvdef(rfb1opt_flag, 2); /* Default: 2: Use the non-Iterative B1 Opt Method.
                                        1: is the Iterative methods */
    }
    else
    {
        cvdef(rfb1opt_flag,1);
    }

    b1derate_flag = 1; /* Set the b1derate_flag to 1 to use System B1
			erating + 10% Safety margin. This is currently is
			supported for 3T ONLY in sysepsupport.c  */

    /*
     * Set the gradient calc mode here for selecting the right gradsafety
     * calc technique.
     * NOTE: The gradHeatMethod CV is used in minseq() to decide whether to call
     *       minseqseg() (gradHeatMethod = TRUE -> Linear Segment Method) or
     *       minseqgrad() (gradHeatMethod = FALSE -> Traditional Method).
     */
    gradHeatMethod = PSD_ON;

    /* MRIhc18005 */
    EpicConf();

    /* If minimize_RFunblanl_time, then set rfupa to the default   */
    /* value of rfupacv (50 us).  This will shorten the RF unblank */
    /* time of the sequence.  If this flag is  not enabled, then   */
    /* use the default RF unblank time cfrfupa*/
    if(PSD_ON != minimize_RFunblank_time) {
        rfupacv = -cfrfupa;
    } else {
        rfupacv = 50;
    }

    opautotr = PSD_OFF;
    opautote = PSD_OFF;
    opautoti = PSD_OFF;
    opautorbw = PSD_OFF;

    aTEopt_flag = PSD_OFF;

    /* Enable WFM Multistation support if using WFM.  Only check once */
    if ( -1 == wfmMultistationFlag )
    {
        struct stat tmpstat;
        if ( -1 == stat("/usr/g/wfprotocols", &tmpstat) )
        {
           wfmMultistationFlag = FALSE;
        }
        else
        {
           wfmMultistationFlag = TRUE;
        }
    }
   
    /* FIESTA3D - Check if running FIESTA.  Make sure to not allow
       the operator to change this even in Service/Research mode. */
    if( PSD_SSFP == exist(oppseq) )
    {
        /* Turn FIESTA mode ON */
        cvoverride(ssfp_flag, PSD_ON, PSD_OFF, PSD_OFF);
    }
    else
    {
        /* Turn FIESTA mode OFF */
        cvoverride(ssfp_flag, PSD_OFF, PSD_OFF, PSD_OFF);
    }
    /* FIESTA3D Phase Cycling, a.k.a. Fiesta-C - Make sure to not allow
       the operator to change this even in Service/Research mode. */
    if( PSD_ON == exist(opphasecycle) )
    {
        /* Turn FIESTA-C ON */
        cvoverride(pcfiesta_flag, PSD_ON, PSD_OFF, PSD_OFF);
    }
    else 
    {
        /* Turn FIESTA-C OFF */
        cvoverride(pcfiesta_flag, PSD_OFF, PSD_OFF, PSD_OFF);
    }

    /* ECTRICKS - Make sure to not allow the operator to change this
       even in Service/Research mode. */
    if( (exist(opectricks) == PSD_ON) || (exist(opswift) == PSD_ON) )
    {
        /* Turn ECTRICKS ON */
        cvoverride(tricks_flag, PSD_ON, PSD_OFF, PSD_OFF);
    }else {
        /* Turn ECTRICKS OFF */
        cvoverride(tricks_flag, PSD_OFF, PSD_OFF, PSD_OFF);
    }


    /* SWIFT :Set intslab_flag first based SWIFT application button*/
    if( exist(opswift) == PSD_ON )
    {
        /* Turn ECTRICKS ON */
        cvoverride(intslab_flag, PSD_ON, PSD_OFF, PSD_OFF);
    }else {
        /* Turn ECTRICKS OFF */
        cvoverride(intslab_flag, PSD_OFF, PSD_OFF, PSD_OFF);
    }

    /* Enable more than 1024 im/ser -Venkat */
    if( (exist(opmph) == PSD_ON) || (exist(opectricks) == PSD_ON) ||
            (exist(opswift) == PSD_ON) )
    {
        enable_1024 = PSD_ON;
    }
    else
    {
        enable_1024 = PSD_OFF;
    }


    /* IFIR */
    if (existcv(opinhance) && (PSD_ON==exist(opinhance)))
    {
        cvoverride(ifir_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
        cvoverride(ssfp_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
        if( ssfp_flag && (!pcfiesta_flag) && (!osfp_flag) )
        {     
            cvoverride(opirprep, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
        } 
    } else {
        cvoverride(ifir_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
    }

    if (use_slr_inv)
    {
        rf0_pulse_type = RF0_INVI0; /* 0 = Nonselective IR */
    }
    else
    {
        if (ifir_flag)
        {
            rf0_pulse_type = RF0_HS_20MS;  /* 1 = Hyperbolic Secant Inversion Pulse */
        }
        else
        {
            if (1 == (int)(exist(opuser1)))
            {
                    rf0_pulse_type = RF0_ADIABTAN; /* 4 = Adiabatic tanh */
            }
            else
            {
                /* MRIhc07580 HH May 2005 - Added an if loop for cffield <= 1.5T */
                if (cffield <= B0_15000)
                {
                    rf0_pulse_type = RF0_ADIABATIC; /* 2 = Adiabatic */
                }
                else
                {
                    rf0_pulse_type = RF0_HS_3T; /* 3 = HS1 pulse for 3.0 T */
                }
            }
        }
    }

    /*
     * Option key checks
     */
    if( (Absent == FiestaKey) && (Absent == FSFiestaKey) &&
        (PSD_ON == ssfp_flag) && (PSD_OFF == pcfiesta_flag) &&
        (PSD_OFF == osfp_flag) && (PSD_OFF == ifir_flag) )
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "3D FIESTA" );
        return FAILURE;
    }

    if( (Absent == FiestaCKey) && (PSD_ON == pcfiesta_flag) )
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "FIESTA-C" );
        return FAILURE;
    }

    if( (Absent == ASSETKey) && (exist(opasset) >= ASSET_SCAN) )
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "ASSET" );
        return FAILURE;
    }

    if( (Absent == BREAST2Key) && (vibrant_flag == PSD_ON || 
                                   brava_flag == PSD_ON ) )
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "VIBRANT" );
        return FAILURE;
    }

    if( (Absent == Heart3DKey) && ((Absent == MDEKey) && (PSD_ON == irprep_flag)) && (PSD_ON == heart3d_flag) )
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "3D Heart" );
        return FAILURE;
    }

    /* MRIhc22382 */
    if( (Absent == LAVAKey) && (Absent == LAVAXVKey) && (PSD_ON == lava_flag) )
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "LAVA");
        return FAILURE;
    }
    /* MRIhc41231 */
    if( (Absent == LAVAXVKey) && (PSD_ON == lava_flag) && (PSD_ON == exist(oparc)) )
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "LAVA-XV");
        return FAILURE;
    }
    /* MRIhc16236 */
    if( (Absent == COSMICKey) && (PSD_ON == osfp_flag) )
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "COSMIC");
        return FAILURE;
    }

    if( (Absent == BRAVOKey) && (PSD_ON == exist(opbravo)) )
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "BRAVO");
        return FAILURE;
    }

    if( (Absent == TRICKSKey) && (PSD_ON == tricks_flag) )
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "TRICKS");
        return FAILURE;
    }

    if( (Absent == SwiFTKey) && ( (PSD_ON == opswift) || (PSD_ON ==
                    intslab_flag)) )
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "SwiFT");
        return FAILURE;
    }

    if( (Absent == LAVADEKey) && (PSD_ON == exist(oplava)) && (PSD_ON == exist(opmedal)) )
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "LAVA-Flex");
        return FAILURE;
    }

    if( (Absent == VIBRANTDEKey) && (PSD_ON == exist(opvibrant)) && (PSD_ON == exist(opmedal)) )
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "VIBRANT-Flex");
        return FAILURE;
    }

    if( (Absent == QUICKSTEPKey) && (PSD_ON == exist(opquickstep)) )
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "QuickSTEP");
        return FAILURE;
    }
    
    if( (Absent == MERGEKey) && (PSD_ON == exist(opmerge)) )
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "3D MERGE");
        return FAILURE;
    }
  
    /* MRIhc32324 */ 
    if( (Absent == IDEAL3DKey) && exist(opdixon))
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "IDEAL");
        return FAILURE;
    }

    if( (Absent == SWAN3DKey) && (PSD_ON == exist(opswan)) )
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "SWAN");
        return FAILURE;
    }

    if( (Absent == Inh3DIFIRKey) && (PSD_ON == ifir_flag) )
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "Inh-3DIFIR");
        return FAILURE;
    }

    if( (Absent == IDEALIQKey) && exist(opidealiq) )
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "IDEAL IQ");
        return FAILURE;
    }

    if( (Absent == SmartDerKey) && ( PSD_ON == gradOpt_flag ) && 
        ( (PSD_OFF == idealiq_flag) && (PSD_OFF == flow4D_flag) && (PSD_OFF == cine3d_flag) &&
          !((PSD_XRMW_COIL == cfgcoiltype) && (B0_30000 == (int)cffield)) && (PSD_VRMW_COIL != cfgcoiltype) ) )
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "Smart Gradient Optimization");
        return FAILURE;
    }

    if( (Absent == PhaseImageKey) && (PSD_OFF != exist(opphaseimage)) && (PSD_ON == existcv(opphaseimage)))
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "SWAN: Phase Imaging");
        return FAILURE;
    }

    if( (Absent == DISCOKey) && exist(opdisco) )
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "DISCO");
        return FAILURE;
    }

    if( (Absent == VESSELVIEWKey) && (PSD_ON == exist(opmsde)) )
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "VESSELVIEW");
        return FAILURE;
    }

    if( (Absent == cine3DKey) && ((PSD_ON == exist(op3dcine_fiesta)) || PSD_ON == exist(op3dcine_spgr)) )
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "3DCINE");
        return FAILURE;
    }


    if( (Absent == flow4DKey) && (PSD_ON == exist(op4dflow)) )
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "4DFLOW");
        return FAILURE;
    }

    /* Vibrant initialization. Need to do this before Asset initialization.
    * Slice Asset has to be enabled only during Saggital Vibrant */
    labrava_init();

   /* Initialize cf cvs to avmin and avmax cvs for acceleration - 
    * MRIhc42465 for PIUI, in init, turn off if cvs are not ON
    * */ 
    if( arc_flag ) 
    { 
        init_arc_variables();
    }
    else if ( existcv(opasset) && (exist(opassetscan) == PSD_ON) ) 
    {
@inline Asset.e AssetEval

        /*Constrain asset factor selection to 2 if SWAN Phase Imaging is used*/
        if((PSD_OFF != exist(opphaseimage)) && (PSD_ON == existcv(opphaseimage))
           && (PSD_ON == exist(opswan)) && (ASSET_SCAN_PHASE == exist(opasset)))
        {
            piaccel_phedit = 0;
            piaccel_phnub = 3;
            piaccel_phval2 = 1.0;
            piaccel_phval3 = 2.0;
            piaccel_ph_step = 1.0;
            avmaxaccel_ph_stride = 2.0;
        }
        else
        {
            piaccel_phedit = 1;
        }
    }
    else  /* Put turnoff  conditions here  */
    {
        reset_accel_variables();
    }
    /* Set minimum sequence time options */

    /* MRIge66079 - ATV: RTIA3D/ftMRA */
    ftmra_init();
    cosmic_init(); /*MRIhc15780*/
    bravo_init();
    quickstep_init();
    disco_init();
    cine3d_init();
    multiEcho_init();
    arc_init(); 

    if ((existcv(opmultistation) && (PSD_ON==exist(opmultistation))) ||
	    (existcv(opquickstep) && (PSD_ON==exist(opquickstep))))
    {
        pidrivemodenub = 3;
    }
    else 
    {
        pidrivemodenub = 7; 
    }
    
    pidefexcitemode = SELECTIVE;
    cvdef(opexcitemode, SELECTIVE);
    piexcitemodenub = 1;

@inline MSDE.e MSDE_CVinit

    if (osfp_flag || msde_flag)
    {
        radfb_flag = PSD_ON;
    }
    else
    {
        radfb_flag = PSD_OFF;
    }

    if ( sp_sat && !ftmra_flag && !ugfsf_flag && !radfb_flag &&
         !vast_mode && !tricks_flag && (medal_flag || arc_flag) ) 
    {
        /* Don't enable it with other scancores: support is not implemented yet */
        encode_group = ENCODE_GROUP_ZY;
    }
    else
    {
        encode_group = ENCODE_GROUP_NONE;
    }

    if ((ENCODE_GROUP_NONE != encode_group) || radfb_flag || (pfkr_yz_flag && (!disco_flag)) || (disco_flag && navgate_flag))
    {
        segmented_flag = PSD_ON; 
    }
    else
    {
        segmented_flag = PSD_OFF; 
    }

    if( (Absent == ARCKey) && arc_flag && (ACCEL_ARC == autocal_mode) )
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "ARC");
        return FAILURE;
    }
  
    vstrte_init();

    /* Save configurable variables after conversion by setupConfig() */ /* VAL15 12/14/2004 YI */
    if(set_grad_spec(CONFIG_SAVE,glimit,srate,PSD_ON,debug_grad_spec) == FAILURE)
    {
        epic_error(use_ermes,"Support routine set_grad_spec failed",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG,"set_grad_spec");
        return FAILURE;
    }

    /* BJM - MRIge54970 check for cerdbw */
    /* RJF - Replaced with direct support routine call for MGD Bandwidth */
    maxhwrbw = get_max_rbw_hw();

    /*MRIhc18005 be_index and TARDIS_FREQ_OFFSET are now defined in
     * EpicConf*/

    if (exist(use_myscan)==1) myscan3d();
    /* 3d oblique - latha@mr */
    /* Always initialize assuming new geometrics the first time thru' in cvinit */
    initnewgeo = 1;

    if ( (exist(opfluorotrigger ) == PSD_ON) || ftmra_flag || maskv_ftmra_flag )  {
        plane_type = PSD_OBL;
    } else {
        plane_type = opphysplane;
    }

    if (obloptimize(&loggrd, &phygrd, scan_info, exist(opslquant)*exist(opvquant),
                    plane_type, exist(opcoax), obl_method, obl_debug,&initnewgeo,cfsrmode)==FAILURE)
    {
        epic_error(use_ermes,"obloptimize failed in cvinit()",
                   EM_PSD_FUNCTION_FAILURE,EE_ARGS(2),
                   STRING_ARG,"obloptimize",STRING_ARG,"cvinit()");
        return FAILURE; 

    }

    /* end 3d oblique */

    field_strength = cffield;

    /*
     * Set minimum SSI update time for FTMRA or all other cases.
     * This may be updated later in cveval(), if necessary.
     */
    if( (ftmra_flag) || (maskv_ftmra_flag) ) {
        time_ssi = 160;
        time_ssi_pre = 160;
    } else if (exist(opetl)==2) {
        time_ssi = 200;
        time_ssi_pre = 200;
    } else if (exist(opetl)>2) {
        time_ssi = 300;
        time_ssi_pre = 300;
    } else if (vstrte_flag) {
        if (B0_15000 == cffield) {
            time_ssi = 88;
            time_ssi_pre = 88;
        } else {
            time_ssi = 80;
            time_ssi_pre = 80;
        }
        /***
        SVBranch, HCSDM00112662 - WJZ
        Increase time_ssi for 16Beat system
        to avoid sequencer error under
        limiting TR/TE imaging conditions;
        ***/
        if ((PSDDVMR == psd_board_type) &&
            ((VALUE_SYSTEM_SVEM == value_system_flag) || (VALUE_SYSTEM_SVDM == value_system_flag)))
        {
            time_ssi = 160;
            time_ssi_pre = 160;
        }
        /**************************/
    } else {
        time_ssi = 160;
        time_ssi_pre = 160;
    }

    /* (MRIhc07226) move fix in (MRIge90759) to here so that 
     * MonitorCvEval will catch this and change mon_ssitime based on time_ssi */
    if( (PSD_ON == ssfp_flag) && (PSD_ON == vast_mode) ) {
        time_ssi = 200; 
    }

    TR_SLOP = 1ms;  /* redefine TR_SLOP for gradient echo sequence */

    /* Decrease TR_PASS from 550ms since this was now becoming a significant 
       fraction of the total scan time.
    */
    TR_PASS = 120ms;

    /* YMSmr09956  09/11/2007 YI */
    if(value_system_flag){
        {
            char *envvar; envvar = (char *)getenv("MONWRITECTRL");
            if(envvar)
            {
                int value = (int)atoi(envvar);
                monwritectrl = value;
            }
        }
        savedata = (int)(monwritectrl & 1);
        if(monwritectrl & 2) {
            char *envvar; envvar = (char *)getenv("MONTRPASS"); /* ms */
            if(envvar && smartprep_flag)
            {
                int value = (int)atoi(envvar);
                TR_PASS= value * 1000;
            }
        }
    }

    if (merge_flag)
       vrgsat = 3;
    else
       vrgsat = 2;

    if (SpSatInit(vrgsat) == FAILURE) {
        epic_error(use_ermes, "Support routine %s failed.",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "SpSatInit");
        return FAILURE;
    }
	
    if ( intslab_flag == PSD_ON ) {
	/* Override to no PRESS mode*/
	presscfh_override = PRESSCFH_NONE;
    } else {
	/* 0 means no override. Use the settings from Prescan.e */
	presscfh_override = 0;
    }

@inline ChemSatSpecIR.e ChemSatInit   /* latha@mr for MRIge41369 */
@inline Prescan.e PScvinit

/* MRIhc13144: Moved Rf pulse initializations up to overcome
   the problem with wrong initialization of res_dummyrf which
   was causing problems with efgre3d simulations in WTools */
/*************************************************************
      Rf pulse initializations
    ***************************************************************/
    gscale_rf1 = 1.0;                   /* Chun says it should be 1.0 */
    cyc_rf1 = 3.0;                      /* number of sinc cycles for RF1 */
    pw_rf1 = 3.2ms;                     /* width of RF1 */
    res_rf1 = 320;                      /* resolution of RF1 */
    flip_rf1 = exist(opflip);
    maxb1_rf1 = SAR_MAXB1_ALPHA1;

#include "cvinit.in"

    opimode = PSD_3D; 
    cvdef(opimode, PSD_3D);
    oppseq = PSD_GE;
    cvdef(oppseq, PSD_GE);

    /* IR PREP (pjg) */
    cvmax(opirprep, 1);
    cvdef(opirprep, 0);
    cvmin(opti, 0);
    cvmax(opti, TI_MAX);
    cvdef(opti, 125ms);
    opti = _opti.defval;

    cvmin(optr,8);
    cvmin(ihtr,8);

    cvmin(opte2,1ms);

@inline Asset.e AssetCVInit

    /* MRIge45285 */
    if ( ((PSD_ON==exist(opcgate)) && existcv(opcgate) && !(heart3d_flag || cine3d_flag)) || 
         (exist(opcosmic) == PSD_ON) || ifir_flag || headneck_pos_scan ) 
    {
        /* Turn OFF multislab Cardiac Gating is ON */
        pimultislab = PSD_OFF;
    } else {
        /* Turn ON multislab when Cardiac Gating is OFF */
        pimultislab = PSD_ON;
    }

    if ( ((assetph_flag == PSD_ON) || (assetsl_flag == PSD_ON)) && exist(oppomp) ) {
        epic_error( use_ermes,
                    "The POMP option is not compatible with ASSET.", 
                    EM_PSD_POMP_ASSET_INCOMPATIBLE, EE_ARGS(0) );
        return FAILURE;
    }
    if ( ((assetph_flag == PSD_ON) || (assetsl_flag == PSD_ON))  && exist(opsquare) ) {
        epic_error( use_ermes,
                    "The Square Pixel option is not compatible with ASSET.", 
                    EM_PSD_SQUARE_ASSET_INCOMPATIBLE, EE_ARGS(0) );
        return FAILURE;
    }
    if ( (assetph_flag == PSD_ON) && exist(opnopwrap) ) {
        epic_error( use_ermes,
                    "The No Phase Wrap option is not compatible with ASSET.", 
                    EM_PSD_NOPWRAP_ASSET_INCOMPATIBLE, EE_ARGS(0) );
        return FAILURE;
    }
    if ( ((assetph_flag == PSD_ON) || (assetsl_flag == PSD_ON)) && exist(opcmon) ) {
        epic_error( use_ermes,
                    "The Cardiac Compensation option is not compatible with ASSET.", 
                    EM_PSD_CMON_ASSET_INCOMPATIBLE, EE_ARGS(0) );
        return FAILURE;
    }
    if ( ((assetph_flag == PSD_ON) || (assetsl_flag == PSD_ON))  && exist(oprealtime) && (!ftmra_flag) ) {
        epic_error( use_ermes,
                    "The Realtime option is not compatible with ASSET.", 
                    EM_PSD_REALTIME_ASSET_INCOMPATIBLE, EE_ARGS(0) );
        return FAILURE;
    }

    if ( ((assetph_flag == PSD_ON) || (assetsl_flag == PSD_ON)) && (exist(opzip1024)==PSD_ON) ) {
        epic_error( use_ermes,
                    "1024 ZIP is not compatible with ASSET.",
                    EM_PSD_NO_1024_ZIP_ASSET, EE_ARGS(0) );
        return FAILURE;
    }

    if( PSD_ON == assetsl_flag ) {

        if( PSD_ON == exist(opfluorotrigger) ) {
            epic_error( use_ermes, "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "VIBRANT",
                        STRING_ARG, "Fluoro Trigger" );
            return FAILURE;
        }

        if( PSD_ON == exist(opmultistation) ) {
            epic_error( use_ermes, "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "VIBRANT",
                        STRING_ARG, "Multi Station" );
            return FAILURE;
        }

        if( PSD_ON == exist(oprtcgate) ) {
            epic_error( use_ermes, "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "VIBRANT",
                        STRING_ARG, "Respiratory Gating" );
            return FAILURE;
        }

        if( PSD_ON == exist(opcgate) ) {
            epic_error( use_ermes, "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "VIBRANT",
                        STRING_ARG, "Cardiac Gating" );
            return FAILURE;
        }

        if( PSD_ON == exist(opirprep) ) {
            epic_error( use_ermes, "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "VIBRANT",
                        STRING_ARG, "IR Prepared" );
            return FAILURE;
        }

        if( PSD_ON == exist(opslzip4) ) {
            epic_error( use_ermes, "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "VIBRANT",
                        STRING_ARG, "ZIP 4" );
            return FAILURE;
        }
    }

    /* Scan is returning PSD_3DM if you select 3D; so get back to PSD_3D */
    if (opimode == PSD_3DM) {
        cvoverride(opimode, PSD_3D, PSD_FIX_ON, PSD_EXIST_ON);
    }

    piovlnub = 0;  /* We don't want any overlap buttons */

    /* **********************************************
       Other initializations
       ********************************************** */

    acq_type = TYPGRAD;
    gating = TRIG_INTERN;

    if (exist(opfcomp) == PSD_ON)
    {
       if (flow4D_flag == PSD_ON) 
       {
           flow_comp_type = TYPNFC;
       }
       else
       {
           flow_comp_type = TYPFC;
       }
    } 
    else
    {
       flow_comp_type = TYPNFC;
    }
    avminsldelay = TR_PASS;

    act_te = 0;
    act_tr = 0;

    /* ungated FatSat FIESTA is allowed only on Value1.5T */
    if (value_system_flag)
        allow_ugfsf = PSD_ON;
    else
        allow_ugfsf = PSD_OFF;

    /* *************************************
       CV Min, CV Max, and CV Error Modification
       ************************************ */

    cvmax(opfast,1);
    cvdef(opfast,1); /* this is a FAST sequence */
    cvmin(opautote, 0);
    cvmax(opautote, 4);
    if(ideal_flag || medal_flag) {
       cvmax(opautote, 2);
    }

    if (medal_flag)
    {
        cvdef(opautote, PSD_MINTEFULL);	  /* default to min Full te selection */
    }
    else
    {
        cvdef(opautote, PSD_MINTE);	  /* default to minimum te selection */
    } 

    /*
     * Number of slices
     * (make the range wide enough so that the cvcheck() errrors are
     * shown instead of a generic psdIF "out of range" message.
     */
    cvmin(opslquant, 1);
    cvmax(opslquant, MAX_SLICES_PER_PASS);
    cvdef(opslquant, 32);

    cvmin(opsllocs, 1);
    cvmax(opsllocs, MAX_SLICES_PER_PASS);
    cvdef(opsllocs, 32);

    if (vast_mode || merge_flag)
    {
        if ( heart3d_flag ) {
             opslblank = ((turbo_flag>1)? 3:2);
        } else {
             opslblank = 1;
        }
    } else if (osfp_flag) {
        opslblank = (int) (exist(opsllocs)*0.225);
        if (opslblank < 4) opslblank = 4;
    } else if ((opasset == 3) || quickstep_flag) {
        opslblank = 0;
    } else {
        /* 2 kiss-off slices */
        opslblank = 2;
    }

    /* YMSmr07288 07/17/2005 YI */
    if(value_system_flag && ssfp_flag){
        opslblank = IMax(2, 2, (int)((float)(exist(opslquant))/8.0 + 0.5));
    }

    if (ns3d_flag) opslblank = 0;

    pislblank = opslblank;
    rhslblank = opslblank;

    /*
      MRIge45660
      SPECS state that min slthick is 0.2 for SR20 systems
      -Pradeep
    */

    /* MRIge57455 - AF - 031700 - Add SR50 to be the same as SR20 */

    if (( cfsrmode == PSD_SR20 )|| (cfsrmode == PSD_SR25 )|| ( cfsrmode == PSD_SR50 )) {
        cvmin(opslthick,0.2) ;
    } else {
        cvmin(opslthick,0.05);
    }

    cvmax(opslthick, 15.0); 

    /*
     * Set default, min and max for X res and Y res
     */
    cvmin(opxres, 32);
    cvmax(opxres, 1024);
    cvmin(opyres, 32);
    cvmax(opyres, 1024);

    if(PSD_ON == ideal_flag) {
       cvmin(opxres, 128);
       cvmin(opyres, 128);
    }

    if (idealiq_flag) {
        cvmin(opxres, 64);
        cvmin(opyres, 64);
        cvmax(opxres, 512);
        cvmax(opyres, 512);
        cvdef(opxres, 128);
        cvdef(opyres, 128);
    }

    if (lava_flag)  {
        cvmin(opxres, 128);
        cvmin(opyres, 128);
    }

    if (quickstep_flag) {
       cvmax(opxres, 512);
       cvmax(opyres, 512);
    }

    if (medal_flag) {
       cvmin(opxres, 128);
       cvdef(opxres, 128);
       cvmin(opyres, 128);
    }

    if (exist(opcosmic)== PSD_ON)  {
        cvmin(opxres, 192);
        cvmin(opyres, 192);
        cvmax(opxres, 512);
        cvmax(opyres, 512);
    }

    if (ifir_flag) {
        cvmin(opxres, 128);
        cvmin(opyres, 128);
        cvmax(opxres, 512);
        cvmax(opyres, 512);
        cvdef(opxres, 256);
        cvdef(opyres, 256);
    }

    /* MRIge81889 - Slice ASSET */
    if( PSD_ON == assetsl_flag ) {
        cvmin(opslthick, 0.8);
        cvdef(opslthick, 2.0);
        cvdef(opslquant, 92);
    } else {
        cvdef(opslthick, 5.0);    /* MRIge44700-changed to 5 -JFS */
    }

    cvmax(opmph,1);
    cvdef(opmph,0); /* default to MPH off */

    cvmin(opphasefov, 0.25);
    opphasefov = 1.0;

    if (lava_flag || brava_flag || medal_flag || ifir_flag || disco_flag)
    {
        phasefovgt1_flag = PSD_ON;
    }
    else
    {
        phasefovgt1_flag = PSD_OFF;
    }

    if( PSD_ON == phasefovgt1_flag ) {
        cvmax(opphasefov, MAX_PHASEFOV);
        cvmax(rhphasescale, 2 * MAX_PHASEFOV);
        avmaxphasefov = MAX_PHASEFOV;
    } else {
        cvmax(opphasefov, 1.0);
        cvmax(rhphasescale, 2.0);
        avmaxphasefov = 1.0;
    }

    cvmin(opte, 8);   
    cvdef(opte, 10ms);   
    opte = 10ms;
    cvmin(rhte, 8);  /* DCZ: allow rhte as small as minimum opte */

    if (flextr_flag) {
        cvdef(optr, avmintr);
        optr = avmintr;
    } else {
        cvdef(optr, 50ms);
        optr = 50ms;
    }

    avminnecho = 1;

@inline Tricks.e DefVals

@inline Tricks.e ReadKernelFileCvinit /* MRIhc13151 */

    cvmin(opfov, FOV_MIN);
    cvmax(opfov, FOV_MAX_EFGRE3D);   
    cvdef(opfov, cfsystemmaxfov);          /* max/selected rbw and gradient amp max */


    /* ATV: changed max flip angle to 90 only for FIESTA */
    /* MRIge91682 */
    if ( de3d_flag ) {
        /* YMSmr11783 - do not set opflip to 12 to catch error in cvcheck */
        avmaxflip =  15.0;
        avmaxflip =  (PSD_ON==exist(opresearch)) ? 40.0 : 15.0; 
        cvmax(opflip, avmaxflip);
        cvdef(opflip, 12.0);
    } else if( lava_flag || brava_flag || vibrant_flag || medal_flag ) {
        /* max flip for min phase rf */
        if ((PSD_ON == (((exist(oplava) && exist(opmedal)) || exist(opdisco)) && exist(opresearch))) ||
            (lava_flag && (opgradmode != TRM_ZOOM_COIL)))
        {
            avmaxflip = 40.0;

            /* HCSDM00342605 : Need to reduce FA of SPSP pulse for higher weight */
            if ( PSD_ON == exist(opssrf) )
            {
                if (opweight > 210)
                {
                    avmaxflip = 20.0;
                }
                else if (opweight > 150)
                {
                    avmaxflip = 25.0;
                }
                else if (opweight > 110)
                {
                    avmaxflip = 30.0;
                }
                else if (opweight > 85)
                {
                    avmaxflip = 35.0;
                }
            }

        }
        else if (exist(opdisco) && (PSD_OFF == exist(opresearch))) /* DISCO clinical mode */
        {
            avmaxflip = 25.0;
        }
        else
        {
            avmaxflip = 15.0;
        }
        cvmax(opflip, avmaxflip);
        cvdef(opflip, 12.0);
        opflip = 12;
    } else if ( irprep_flag && !osfp_flag && !ifir_flag) {
        avmaxflip =  25.0;           
        cvmax(opflip, 25.0);
        cvdef(opflip, 15.0);
        opflip = 15;
    } else if ( merge_flag && !swan_flag ) {
        avmaxflip =  15.0;          
        cvmax(opflip, 15.0);
        cvdef(opflip, 5.0);
        opflip = 5;
    } else if ( quickstep_flag ) {
        avmaxflip = 20.0;            
        cvmax(opflip, 20.0);
        cvdef(opflip, 20.0);
        opflip = 20.0;
    } else if( ssfp_flag ) {
        avmaxflip =  90.0;            
        cvmax(opflip, 90.0);
        cvdef(opflip, 40.0);
        opflip = 40;
        cvmax(opslthick, 15.0); /* MRIge6374- AC 01-23-2001 */
        cvdef(opslthick, 2.0);
        if (osfp_flag) {
           avmaxflip =  45.0;
           cvmax(opflip, 45.0);
           cvdef(opflip, 45.0);
           cvmax(opslthick, 4.0); 
           cvmin(opslthick, 0.5); 
           cvdef(opslthick, 3.0);
        }
        if (ifir_flag) {
           if (B0_30000 == (int)cffield)
           {
               avmaxflip =  90.0;            
               cvmax(opflip, 90.0);
               cvdef(opflip, 50.0);
               opflip = 50;
           } else {
               if (value_system_flag)
               {
                   avmaxflip =  130.0;
                   cvmax(opflip, 130.0);
               }
               else
               {
                   avmaxflip =  100.0;
                   cvmax(opflip, 100.0);
               }
               cvdef(opflip, 90.0);
               opflip = 90;
           }
        }
    } else if( swan_flag ) { /* MRIhc35438 */
        avmaxflip =  50.0;
        cvmax(opflip, 50.0);
        cvdef(opflip, 20.0);
        opflip = 20;
    } else if ( idealiq_flag ) {
        if( ((PSD_ON == exist(opresearch)) && (idealiq_enable_higher_flip)) || (PSD_ON == piautofa) )
        {
            avmaxflip = 25.0;            
            cvmax(opflip, 25.0);
            cvdef(opflip, 1.0);
            opflip = 1.0;
        }
        else
        {
            if (B0_30000 == (int)cffield)
            {
                avmaxflip = 3.0;            
                cvmax(opflip, 3.0);
                cvdef(opflip, 3.0);
                opflip = 3.0;
            }
            else
            {
                avmaxflip = 5.0;            
                cvmax(opflip, 5.0);
                cvdef(opflip, 5.0);
                opflip = 5.0;
            }
        }
    } else if ( cal3d_flag ) {
        if ((isDVSystem() || isKizunaSystem()) && (B0_30000 == cffield)) /* 3.0 T DV platform */
        {
            avminflip = 0.1;
            cvmin(opflip, 0.1);
            avmaxflip =  25.0;
            cvmax(opflip, 25.0);
            cvdef(opflip, 0.9);
            opflip = 0.9;
        }
        else
        {
            avmaxflip =  25.0;
            cvmax(opflip, 25.0);
            cvdef(opflip, 1.0);
            opflip = 1.0;
        }
    } else {
        avmaxflip = 60.0;            /* max flip for min phase rf */
        cvmax(opflip, 60.0);
        cvdef(opflip, 30.0);
        opflip = 30;
    }

    /* MRIhc35885*/
    if(medal_flag)
    {
        /* Setting the minimum slice thickness for MEDAL cases as 1mm*/
        cvmin(opslthick, 1.0);
    }

    cvmax(oprbw, maxhwrbw);

    /* MRIge91682 */
    if( lava_flag ) {
        if (cffield > B0_15000)
           pidefrbw = 83.33;
        else
           pidefrbw = 62.5;
    } else if( brava_flag ) {
        if (cffield > B0_15000)
           pidefrbw = 83.33;
        else
           pidefrbw = 41.67;
    } else if( vibrant_flag && aspir_override ) {
        if (cffield > B0_15000)
           pidefrbw = 83.33;
        else
           pidefrbw = 62.5;
    } else if (osfp_flag) {
        if (cffield > B0_15000)
           pidefrbw = 90.91;
        else
           pidefrbw = 62.5;
    } else if (merge_flag && !swan_flag) {
        if (cffield > B0_15000)
           pidefrbw = 41.67;
        else
           pidefrbw = 31.25;
    } else if (swan_flag) {
        if (cffield > B0_15000)
           pidefrbw = 62.5;
        else
           pidefrbw = 41.67;
    } else if (quickstep_flag) {
           pidefrbw = 125.0;
    } else if (headneck_pos_scan) {
           pidefrbw = 62.5;
    } else if (medal_flag) {
        if (cffield > B0_15000)
           pidefrbw = 166.67;
        else
           pidefrbw = 100.0;
    } else if (idealiq_flag) {
        if (cffield > B0_15000)
        {
            pidefrbw = 142.86;
        }
        else
        {
           pidefrbw = 125.0;
        }
    } else {
        pidefrbw = 31.25;             /* set default rbw to 31.25kHz */        
    }
    cvdef(oprbw, pidefrbw);
    oprbw = _oprbw.defval;


    /* MRIge52076 - For high X res values, e.g., 512, the value of 
       cerd_out_points will be more than the upper limit for rhdaxres */
    cvmax( rhdaxres, 1024 );

    /* HK for Fiesta-C */
    cvmax( rhfiesta, 512);

    /* SWAN : Phase Imaging */
    cvmax( ihnew_series, 15);

    if (UnLocked) {
        /* Initialise pimultistation */
        pimultistation = MultiStationKey; /* get the value from the option key */
        if ( PSD_ON == pimultistation ) {
            /* Allow selection of MultiStation Imaging Option */
            cvmax( opmultistation, 1 );
            cvmax( tablespeed, cftablemaxspeed );
            cvmax( tableaccel, cftablemaxaccel );
            cvmax( tabledecel, cftablemaxdecel );
        } else {
            /* Do NOT allow selection of MultiStation Imaging Option */
            cvmax( opmultistation, 0 );
            cvmax( tablespeed, 0 );
            cvmax( tableaccel, 0 );
            cvmax( tabledecel, 0 );
        }
    }

    /* Multi-phase */
    opacqo = 1;

    static int disco_init_flag = FALSE;

    if (disco_flag)
    {
        if (!disco_init_flag)
        {
            if (exist(opdynaplan))
            {
                cvdef(opfphases, PHASES_MIN);
                opfphases = _opfphases.defval;
            }
            else
            {
                _opfphases.fixedflag = 0;
                opfphases = num_sub_regions + (PSD_ON == mask_phase_flag);
                _opfphases.fixedflag = 1;

                cvdef(opfphases, num_sub_regions + (PSD_ON == mask_phase_flag));
            }
            disco_init_flag = TRUE;
        }
    }
    else
    {
        cvdef(opfphases, PHASES_MIN);

        disco_init_flag = FALSE;
    }

    cvmin(opsldelay,TR_PASS);
    opsldelay = TR_PASS;

    /* initialization for oddnex flags */
    oddnex_npw  = 0;
    truenex     = 0;

    /* MRIge46203 - Resp Triggering - set min value for BPM to 6 - latha@mr */
    cvmin(oprtrate, 6);

    /* *******************************************
       Scan Screen Control Initialization
       Standard initializations are listed in epic.h
       Screen values which don't match with epic.h 
       should be listed here.  Screen values that 
       are dependent on a operator input cv value
       should be listed in cveval. 

       pi<param>val1 is always reserved for the "other" button.
       ****************************************** */

    /* number of echoes - do not display since 1 echo is always used */
    piechnub = 0;

    piechval2 = 1;
    piechval3 = 2;
    piechval4 = 4;
    piechval5 = 8;
    piechval6 = MAX_ECHOES;

    /* Auto Flip angle support for IDEALIQ */
    if( idealiq_flag )
    {
        if((PSD_ON == exist(opresearch)) && (idealiq_enable_higher_flip))
        {
            piautofa = PSD_OFF;
        }
        else
        {
            piautofa = PSD_ON;
        }
    }
    else
    {
        piautofa = PSD_OFF;
    }

    /* ATV: flip angle - maximum flip angle is 60 for GRE/SPGR 
       - maximum flip angle is 90 for FIESTA */

    if (osfp_flag) {
       pifanub = 0;
       cvoverride(opflip, 45, PSD_FIX_ON, PSD_EXIST_ON);
    } else if (quickstep_flag) {
       pifanub = 0;
       cvoverride(opflip, 20, PSD_FIX_ON, PSD_EXIST_ON);
    } else if (idealiq_flag) {
       if((PSD_ON == exist(opresearch)) && (idealiq_enable_higher_flip)) {
           pifanub =  6;
           pifaval2 = 3;
           pifaval3 = 5;
           pifaval4 = 10;
           pifaval5 = 15;
           pifaval6 = 20;
       } else {
           if( PSD_ON == piautofa )
           {
               pifanub = 3; /* pifaval2 and pifaval3 are calculated in cveval() */
           }
           else
           {
               pifanub = 0;
               if ( B0_30000 == (int)cffield )
               {
                   cvoverride(opflip, 3, PSD_FIX_ON, PSD_EXIST_ON);
               }
               else
               {
                   cvoverride(opflip, 5, PSD_FIX_ON, PSD_EXIST_ON);
               }
           }
       }
    } else if (headneck_pos_scan) {
       pifanub = 0;
       cvoverride(opflip, 3, PSD_FIX_ON, PSD_EXIST_ON);
    } else {
        pifanub =  6;

        /* ATV: changed flip angle choices for FIESTA */
        if( PSD_ON == ssfp_flag ) {
            pifaval2 = 35;
            pifaval3 = 45;
            pifaval4 = 55;
            pifaval5 = 65;
            pifaval6 = 70;
            if (osfp_flag) {
                pifaval2 = 30;
                pifaval3 = 35;
                pifaval4 = 40;
                pifaval5 = 42;
                pifaval6 = 45;
            }
            if (ifir_flag) {
                pifanub = 3;
                if (B0_30000 == (int)cffield)
                {
                    pifaval2 = 50; 
                    pifaval3 = 70; 
                } else {
                    pifaval2 = 70; 
                    pifaval3 = 90; 
                }
            }
            /* MRIge91682 */
        } else if( lava_flag || brava_flag || vibrant_flag || medal_flag ||
                   msde_flag ||
                   ((specir_flag || irprep_flag) && !ssfp_flag) )  {
            pifaval2 = 9;
            pifaval3 = 10;
            pifaval4 = 11;
            pifaval5 = 12;
            pifaval6 = 15;
        } else if (merge_flag && !swan_flag) {
            pifaval2 = 5;
            pifaval3 = 6;
            pifaval4 = 7;
            pifaval5 = 8;
            pifaval6 = 9;
        } else if (swan_flag) {
            pifaval2 = 15;
            pifaval3 = 20;
            pifaval4 = 25;
            pifaval5 = 30;
            pifaval6 = 35;
        } else {
            pifaval2 = 10;
            pifaval3 = 12;
            pifaval4 = 20;
            pifaval5 = 30;
            pifaval6 = 45;
        }
    }
    /* te - turn the 2nd, 3rd, 4th, and 5th buttons on */
    /* MRIge91682 */
    if( lava_flag || brava_flag || bravo_flag || osfp_flag || ifir_flag ||
        quickstep_flag || (multiEcho_flag && !idealiq_flag) || (!merge_flag && (exist(opetl)>=2)) ) {
        pite1nub = 0;
    } else if(ideal_flag || medal_flag || idealiq_flag || cine3d_flag) {
        pite1nub = 6;
        pite1val2 = PSD_MINIMUMTE;
        pite1val3 = PSD_MINFULLTE;
    } else {
        pite1nub = 30 + flexte_flag;
        if (merge_flag)
        {
           pite1val2 = avminte;
           pite1val3 = PSD_MINFULLTE;
           pite1val4 = PSD_FWINPHASETE;
           pite1val5 = PSD_FWOUTPHASETE;
        }
        else
        {
           pite1val2 = PSD_MINIMUMTE;
           pite1val3 = PSD_MINFULLTE;
           pite1val4 = PSD_FWINPHASETE;
           pite1val5 = PSD_FWOUTPHASETE;
        }
    } 
    
       

    if (flextr_flag) {
       pitrnub = 6;
       pitrval2 = PSD_MINIMUMTR;
       pitrval3 = avmintr;
       pitrval4 = avmintr + 5ms;
       pitrval5 = avmintr + 10ms;
       pitrval6 = avmintr + 20ms;
    } else  {
    /* tr - do not display since minimum tr is always used */
      pitrnub = 0;
    }

    if(idealiq_flag)
    {
        pietlnub = 1+2+4+8+16+32;
        pietlval2 = 2;
        pietlval3 = 3;
        pietlval4 = 4;
        pietlval5 = 5;
        pietlval6 = 6;
        /* SVBranch, HCSDM00118534 */
        if( (VALUE_SYSTEM_SVEM == value_system_flag) ||
            (VALUE_SYSTEM_SVDM == value_system_flag) )
        {
            pietlnub = 32;
        }
    }
    else
    {
        pietlnub = 0;
    }

    /* ti - defaulted to 0 in epic.h */

    /* bandwidth is field strength dependent - handle in cveval */
    pirbwpage = 1;      /* always place rbw parameters on scan timing screen */
    pircbnub = 6;       /* allow rbw choices for all cases by default */
    pircb2nub = 0;      /* don't use second rbw by default */

    /* inter slice spacing - do not display since 3D */
    piisnub = 0; 

    /* xres, yres - use defaults in epic.h */
    /* nex is dependent of npw - handle in cveval */

    tfe_extra = 0;        /* init to 0 -- full echo case */


    /* ****************************************************
       Advisory Panel 

       If piadvise is 1, the advisory panel is supported.
       pimax and pimin are bitmaps that describe which
       advisory panel routines are supported by the psd.
       Scan Rx will activate cardiac gating advisory panel
       values if gating is chosen from the gating screen onward.
       Scan Rx will display the minte2 and maxte2 values 
       if 2 echos are chosen.

       Constants for the bitmaps are defined in epic.h
       *********************************************** */
    piadvise = 1; /* Advisory Panel Supported */

    /* bit mask for minimum adv. panel values.*/
    piadvmin = (1<<PSD_ADVECHO) +
        (1<<PSD_ADVTE) + (1<<PSD_ADVTR) + (1<<PSD_ADVFOV) ;
    piadvmax = (1<<PSD_ADVECHO) +
        (1<<PSD_ADVTE) + (1<<PSD_ADVTR) + (1<<PSD_ADVFOV) ;

    /* add rbw for first echo */
    piadvmin = (piadvmin | (1<<PSD_ADVRCVBW));
    piadvmax = (piadvmax | (1<<PSD_ADVRCVBW));

    /* bit mask for cardiac adv. panel values */
    piadvcard = 0;

    /* bit mask for scan time adv. panel values in epic.h */

    if (SDL_CheckValidFieldStrength(SD_PSD_EFGRE3D,cffield,use_ermes)==FAILURE) {
        return FAILURE;
    }
    /* Initialize phase/view acquisition order */

    phorder = SEQUENTIAL;  /* phase/view ordering: 0=normal, 1=centric */
    viewoffs = 0;          /* nomver of views to offset in centric mode */
    slorder = SEQUENTIAL;  /* slice ordering: 0=normal, 1,2,3,4,5=centric */

    /* NAV, RJF for MGD2 */
    if (FAILURE == Monitor_Cvinit(rfpulse))
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "Monitor_Cvinit");
        return FAILURE;
    }

    /* Set psd_rf_wait and psd_grd_wait for this system. */
    if (setsysparms() == FAILURE) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "setsysparms");
        return FAILURE;
    }

    if (GateCvinit() == FAILURE)
    {
        return FAILURE;
    }

@inline VAST.e VASTcvinit

@inline cal3d.e cal3d_cvinit

    rfsafetyopt_timecountB = 0;
    rfsafetyopt_timecountE = 0; 

    if( (PSD_OFF == pitrnub) && (PSD_OFF == exist(opautotr)) )
    {
        opautotr = PSD_ON;
    }

    if( (PSD_OFF == pircbnub) && (PSD_OFF == exist(opautorbw)) )
    {
        opautorbw = PSD_ON;
    }

    if (ifir_flag) {
        cvmax(oprtrep, 2);
        pinexnub = 0;
     	cvmax(opbsp, PSD_ON);
        cvoverride(opbsp, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
    } else {
        cvmax(oprtrep, 5);
        cvoverride(opbsp, PSD_OFF, PSD_FIX_OFF, PSD_EXIST_OFF);
        cvmax(opbsp, PSD_OFF);
    }
    
    ss_rf1 = exist(opssrf);

    /* insertion of code copied from EFFSLICESEL_SPSP */
    if (ss_rf1)
    {
        a_rf1 = flip_rf1/180;
        pw_gzrf1 = pw_rf1;
        res_gzrf1 = res_rf1;
        thk_rf1 = opvthick;
        a_thetarf1 = 0;
        res_thetarf1 = res_rf1;
        pw_thetarf1 = pw_rf1;
    }

    if(exist(opmedal)) {
       cvoverride(opnecho, (medal_necho*medal_etl), PSD_FIX_ON, PSD_EXIST_ON);
    } 

@inline FastCINE3D.e fcine3d_cvinit

    /* Set flags for scan volume scale */
    set_vol_scale_cvs(cfgcoiltype,
                      VOL_SCALE_FREQ_DIR_ALLOWED | VOL_SCALE_PHASE_DIR_ALLOWED,
                      VOL_SCALE_CONSTRAINT_NONE,
                      &vol_scale_type,
                      &vol_scale_constraint_type);

    return SUCCESS;
}   /* end cvinit() */

@inline SpSat.e SpSatInit
@inline SpSat.e SpSatCheck
@inline Monitor.e MonitorInit
@inline InitAdvisories.e InitAdvPnlCVs /* Init all new Advisory Cvs */
@inline T2Prep.e T2PrepEval
@inline InversionGRx.e InversionGRxInit /* IFIR GRx */
@inline ss.e ssInit

/* *********************************************
   CVEVAL
   cveval is called upon every OPIO button push
   which has a corresponding CV (95% of the buttons).
   Place only that code that has an effect on 
   advisory panel results to save on button to
   button time.  Other code can be placed in cvinit
   or predownload.

   VBW is always on for both 1.5T and 0.5T.  First echo
   is allowed to have bandwidths other than 16 kHz
   along with fractional echo.  Real time filter
   generation is also used.
   To support V6 1st echo vbw, all cveval code
   has been moved to cveval1 function, which
   is called upon entry into cveval.
   additional modifications are made to bw, % frac.
   echo, etc.
   ****************************************** */
STATUS
cveval( void )
{
    double ave_sar_eval;
    double peak_sar_eval;
    double cave_sar_eval;
    float round_factor = 2.0; /* MRIhc16225 */
    float segmented_tr_time  = (float)80ms;

@inline Tricks.e ReadKernelFileCveval /* MRIhc13151 */

    LONG start_time = 0;
    LONG end_time = 0;

    breastCoil_flag = ((NULL != strstr(coilInfo[0].coilName, "breast")) ||
                       (NULL != strstr(coilInfo[0].coilName, "Breast")) ||
                       (NULL != strstr(coilInfo[0].coilName, "Brst")));
    
    if (use_slr_inv)
    {
        rf0_pulse_type = RF0_INVI0; /* 0 = Nonselective IR */
    }
    else
    {
        if (ifir_flag)
        {
            rf0_pulse_type = RF0_HS_20MS;  /* 1 = Hyperbolic Secant Inversion Pulse */
        }
        else
        {
            if (1 == (int)(exist(opuser1)))
            {
                rf0_pulse_type = RF0_ADIABTAN; /* 4 = Adiabatic tanh */
            }
            else
            {
                /* MRIhc07580 HH May 2005 - Added an if loop for cffield <= 1.5T */
                if (cffield <= B0_15000)
                {
                    rf0_pulse_type = RF0_ADIABATIC; /* 2 = Adiabatic */
                }
                else
                {
                    rf0_pulse_type = RF0_HS_3T; /* 3 = HS1 pulse for 3.0 T */
                }
            }
        }
    }

    if((Present == PhaseImageKey) && (PSD_ON == exist(opswan)))
    {
        /* Enable phase image nub on the UI only if OptionKey Present */
        piphaseimagenub = 6;
    }
    else
    {
        piphaseimagenub = 0;
    }

    
    /* SVBranch, Smart Burst Mode */
    if( (PSD_ON == ssfp_flag) &&
        (PSD_OFF == specir_flag) &&
        (PSD_OFF == exist(opsat)) &&
        (PSD_OFF == exist(opcgate)) &&
        (PSD_OFF == exist(oprtcgate)) &&
        (PSD_OFF == exist(opnav)) &&
        (1 == exist(opfphases)) &&
        (PSD_OFF == exist(opfluorotrigger)) &&
        (PSD_OFF == osfp_flag) &&
        (PSD_OFF == pcfiesta_flag) &&
        (PSD_OFF == ifir_flag) &&
        (enable_sbm) )
    {
        if(existcv(opuser24) && exist(opuser24))
        {
            if(existcv(opnex) && (exist(opnex) <= SBM_MAX_NEX))
            {
                sbm_flag = PSD_ON;
            }
            else
            {
                sbm_flag = PSD_OFF;
                epic_error( 0, "Smart Burst Mode is incompatible with a NEX>%d prescription",
                            0, EE_ARGS(1),
                            INT_ARG, SBM_MAX_NEX);
                return FAILURE;
            }
        }
        else
        {
            sbm_flag = PSD_OFF;
        }
    }
    else
    {
        sbm_flag = PSD_OFF;
    }

    if(sbm_flag)
    {
        /* check if cv is changed. Because Smart derating etc will update key cvs, wait until they are stable
           pitscan will be calculated only when get_cvs_changed_flag() changes from 1 to 0  */
        if(get_cvs_changed_flag() == sbm_cvs_old)
        {
            sbm_cvs_changed = 0;
        }
        else
        {
           if(TRUE == sbm_cvs_old)
           {
               sbm_cvs_changed = TRUE;
           }
           else
           {
               sbm_cvs_changed = FALSE;
           }
        }
        sbm_cvs_old = get_cvs_changed_flag();

        /* compare difference of pitscan during stable condition
           if scan time difference is bigger than limitation,
           pitscan for SBM will be re-calculated */
        if(sbm_cvs_changed)
        {
            if( fabs(sbm_bak_pitscan-sbm_pitscan_old) > sbm_pitscan_limit )
            {
                sbm_pitscan_changed = 1;
            }
            sbm_pitscan_old = sbm_bak_pitscan;
        }

        sbm_gx1_scale = 1.0;
        sbm_gxw_scale = 1.0;
        sbm_gxwex_scale = 1.0;
        sbm_gy1_scale = 1.0;
        sbm_gy1r_scale = 1.0;
        sbm_gzcomb_scale = 1.0;
        sbm_gzp_scale = 1.0;
        sbm_smartderating_factor = exist(opuser21);
    }
    else
    {
        sbm_smartderating_factor = 1.0;
    }

    
    /* Turn ON and turn  off in Eval to ensure state of CVs are correct
     * MRIhc42465 - For PIUI
     * */
    initialize_arc_asset_variables();

    /*Constrain asset factor selection to 2 if SWAN Phase Imaging is used*/
    if((PSD_OFF != exist(opphaseimage)) && (PSD_ON == existcv(opphaseimage))
       && (PSD_ON == exist(opswan)) && (ASSET_SCAN_PHASE == exist(opasset)))
    {
        piaccel_phedit = 0;
        piaccel_phnub = 3;
        piaccel_phval2 = 1.0;
        piaccel_phval3 = 2.0;
        piaccel_ph_step = 1.0;
        avmaxaccel_ph_stride = 2.0;
    }
    else
    {
        piaccel_phedit = 1;
    }
    
    if ( !strncmp("efgre3darc",psd_name,10)
         && (ARCKey == Present) && (PSD_ON == exist(opresearch)) )
    {
        cvoverride(oparc, PSD_ON, PSD_FIX_OFF, PSD_EXIST_ON);
        cvmax(arc_flag, PSD_ON);
        cvoverride(arc_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
        cvoverride(arc_research_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);

        /* For efgre3darc type in PSD, we dont get limits from Host. We
         *          * set it here, accordingly set it for avmaxaccel
         *          variables too
         *                   * */
        
        autocal_mode = ACCEL_ARC;
    }
    else
    {
        cvoverride(arc_research_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
    }

    /* HCSDM00392380 */
    if(PSD_ON == exist(opdynaplan))
    {
        run_eval_from_get_flag = PSD_ON;
    }
    else
    {
        run_eval_from_get_flag = PSD_OFF;
    }
    set_run_eval_from_get_required(run_eval_from_get_flag);

    /* GEHmr02509: init setting for smart derating */
    if( PSD_ON == gradOpt_flag )
    {
        float tmpFloat;


        if( VALUE_SYSTEM_SVEM == value_system_flag ||
            VALUE_SYSTEM_SVDM == value_system_flag )
        {
            /* SVBranch, HCSDM00100058 */
            aTEopt_flag = PSD_ON;
            gradOpt_aTETR_method  = 1;      /* new method is used to get better result */
            if(gradOpt_GX2)
            {
                gradOpt_powerOpt_flag = PSD_OFF;
            }
            else
            {
                gradOpt_powerOpt_flag = PSD_ON; /* optimization based on Power */
            }
            /* SVBranch, Smart Burst Mode */
            if(sbm_flag)
            {
                gradOpt_weight = 0.15;
            }
            else
            {
                gradOpt_weight = 0.9;
            }
        }
        else
        {
            aTEopt_flag = PSD_ON;
            gradOpt_powerOpt_flag = PSD_OFF;

            if( gradOpt_TE )
            {
                gradOpt_aTETR_method  = 1;      /* new method is used to get better result */
            }
            else
            {
                gradOpt_aTETR_method  = 0;
            }
        }

        aTRopt_flag = PSD_ON;
        ogsfMax = 1.0;
        ogsfMin = 0.1;
        tmpFloat = gradOpt_scale_Min * ogsfMin;
        cvmin(ogsfX1,   tmpFloat);
        cvmin(ogsfX2,   tmpFloat);
        cvmin(ogsfY,    tmpFloat);
        cvmin(ogsfZ,    tmpFloat);
        cvmin(ogsfXwex, tmpFloat);
        cvmin(ogsfYk,   tmpFloat);
        cvmin(ogsfZk,   tmpFloat);

        /* SVBranch, HCSDM00114077 */
        /* HCSDM00114077: With InP and OutP, the TE may have bigger change.
                          Need bigger tolerance for pseudo convergence */
        if( (PSD_FWINPHS == exist(opautote)) || (PSD_FWOUTPHS == exist(opautote)) )
        {
            gradOpt_nonconv_tor_limit = 0.2;
        }
        else
        {
            gradOpt_nonconv_tor_limit = 0.05;
        }
    }
    else
    {
        float tmpFloat;
        gradOpt_aTETR_method  = 0;      /* legacy adaptive TE/TR method */
        aTRopt_flag           = PSD_OFF;

        /* SVBranch, HCSDM00293669 */   
        ogsfXwex              = 1.0;
        ogsfYk	              = 1.0;
        ogsfZk 		      = 1.0;

        tmpFloat              = 0.1;
        cvmin(ogsfX1,   tmpFloat);
        cvmin(ogsfX2,   tmpFloat);
        cvmin(ogsfY,    tmpFloat);
        cvmin(ogsfZ,    tmpFloat);
        cvmin(ogsfXwex, tmpFloat);
        cvmin(ogsfYk,   tmpFloat);
        cvmin(ogsfZk,   tmpFloat);
    }

    if ((existcv(opmultistation) && (PSD_ON==exist(opmultistation))) ||
        (existcv(opquickstep) && (PSD_ON==exist(opquickstep))))
    {
        pidrivemodenub = 3;
    }
    else
    {
        pidrivemodenub = 7;
    }

    if ((PSD_ON == aTRopt_flag) && (PSD_ON == ssfp_flag))
    {
        stre_flag = PSD_OFF;
    }
    else
    {
        stre_flag = PSD_ON;
    }

    ss_rf1 = exist(opssrf);

    /* insertion of code copied from EFFSLICESEL_SPSP */
    if (ss_rf1)
    {
        a_rf1 = flip_rf1/180;
        pw_gzrf1 = pw_rf1;
        res_gzrf1 = res_rf1;
        thk_rf1 = opvthick;
        a_thetarf1 = 0;
        res_thetarf1 = res_rf1;
        pw_thetarf1 = pw_rf1;
    }
    
    /* MRIhc55288 */
    if( (!strncmp("efgre3d_aspir", psd_name, 13)) || (pfkr_yz_flag && (brava_flag || vibrant_flag)) )
    {
       aspir_override = PSD_ON;
    }
    else{
       aspir_override = PSD_OFF;
    } 

    if ( (aspir_override || osfp_flag || ifir_flag || bravo_flag || msde_flag) &&
         (PSD_ON == exist(opspecir)) )
    {
        aspir_flag = PSD_ON;
    }
    else
    {
        aspir_flag = PSD_OFF;
    }

    /* IFIR GRx */
    piautoirbands = PSD_OFF;
    pigirscrn = PSD_OFF;

    if (ifir_flag == PSD_ON)
    {
        if(!strncmp("ifir_stir", psd_name, 9))
        {
            cvoverride(opspecir, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON); 

            ifir_stir_flag = PSD_ON;
            ifir_frir_flag = PSD_ON;
        }
        else
        {
            ifir_stir_flag = PSD_OFF;
            ifir_frir_flag = PSD_OFF;
        }

        piautoirbands = PSD_ON;
        if ((existcv(opplane) && (exist(opplane) == PSD_AXIAL))
            && (existcv(opgirmode) && (exist(opgirmode) == PSD_GIRAUTO)))
        {
            pigirscrn = PSD_OFF;
        }
        else
        {
            pigirscrn = PSD_ON;
        }
    }
 
    if(rfsafetyopt_timeflag)
    {
        struct timeval t;
        rfsafetyopt_timecountB++;
        gettimeofday(&t, NULL);
        start_time = ((LONG)(t.tv_sec)) * 1000000 + t.tv_usec;
    }

    b1derate_flag = 1; /* Set the b1derate_flag to 1 to use System B1
                          derating + 10% Safety margin. This is currently
                          supported for 3T ONLY in sysepsupport.c  */

    /* VAL15 12/14/2004 YI */
    /* Get gradient spec for silent mode *//* VAL15  04/04/2005 YI */ 
    if(!strncmp("efgre3d_silent",psd_name,14) || (PSD_ON == exist(opheadscout)))
    {
        if(PSD_ON == exist(opheadscout))
        {
            cvoverride(opsilentlevel, ART_SINGLEMODE, PSD_FIX_ON, PSD_EXIST_ON); 
        }
        getSilentSpec(PSD_ON, &grad_spec_ctrl, &glimit, &srate);    
        /* ensure that only slew rate is changed for silent mode */
        grad_spec_ctrl = grad_spec_ctrl & ~GMAX_CHANGE; 
    }
    else
    {
        getSilentSpec(exist(opsilent), &grad_spec_ctrl, &glimit, &srate); 
    }

    /* GEHmr01844 : SV derating */
    if( (cfgradamp == 8919) && (quickstep_flag == PSD_OFF) &&
        ((value_system_flag == VALUE_SYSTEM_SVEM) ||
         (value_system_flag == VALUE_SYSTEM_SVDM)) )
    {
        if(ssfp_flag && !osfp_flag && !ifir_flag)
        {
            grad_spec_ctrl |= GMAX_CHANGE;
            glimit = 1.7;
        }
        else if(tricks_flag || osfp_flag || vibrant_flag)
        {
            grad_spec_ctrl |= GMAX_CHANGE;
            glimit = 2.5;
        }
        else
        {
            grad_spec_ctrl &= ~GMAX_CHANGE;
            glimit = 3.3;
        }

        /* SVBranch, GEHmr04492 */
        if((opsilent == PSD_ON) && (opsilentlevel == 1))
        {
            if(swan_flag)
            {
                cfxfd_temp_limit = 2.7;
            }
            else if(tricks_flag)
            {
                cfxfd_temp_limit = 3.0;
            }
            else
            {
                cfxfd_temp_limit = 8.5;
            }
        }
        else if((opsilent == PSD_ON) && (opsilentlevel == 2))
        {
            if(swan_flag || osfp_flag || tricks_flag)
            {
                cfxfd_temp_limit = 2.5;
            }
            else if(pcfiesta_flag)
            {
                cfxfd_temp_limit = 2.4;
            }
            else if(!pcfiesta_flag && ssfp_flag && !ifir_flag)
            {
                cfxfd_temp_limit = 2.6;
            }
            else if(lava_flag)
            {
                cfxfd_temp_limit = 3.0;
            }
            else if(vibrant_flag || brava_flag || (exist(oppseq) == PSD_GE) || (exist(oppseq) == PSD_SPGR))
            {
                cfxfd_temp_limit = 2.8;
            }
            else
            {
                cfxfd_temp_limit = 8.5;
            }
        }
        else
        {
            cfxfd_temp_limit = 8.5;
        }

        /* GEHmr04440,GEHmr04553,GEHmr04632 */
        if(!vibrant_flag && !brava_flag && !tricks_flag && !ifir_flag)
        {
            if(osfp_flag)
            {
                    cfxfd_power_limit = 7.3;
            }
            else if(ssfp_flag)
            {
                if(pcfiesta_flag && (oprbw > 62))
                {
                    cfxfd_power_limit = 8.0;
                }
                else if(!pcfiesta_flag && (oprbw >=100))
                {
                    cfxfd_power_limit = 7.5;
                }
                else if(!pcfiesta_flag && ((oprbw > 83) || (((exist(opslquant)*exist(opnex)*nop)) >= 64)))
                {
                    cfxfd_power_limit = 8.0;
                }
                else
                {
                    cfxfd_power_limit = 8.5;
                }
            }
            else if (swan_flag)
            {
                if(oprbw >= 125)
                {
                    cfxfd_power_limit = 7.5;
                }
                else
                {
                    cfxfd_power_limit = 8.5;
                }
            }
            else if ((exist(oppseq) == PSD_TOF) || (exist(oppseq) == PSD_TOFSP))
            {
                if((oprbw >= 83) || ((exist(opslquant)*exist(opnex)*nop) >= 100))
                {
                    cfxfd_power_limit = 8.0;
                }
                else
                {
                    cfxfd_power_limit = 8.5;
                }
            }
            else if (idealiq_flag)
            {
                cfxfd_power_limit = 7.0;
            }
            else if (lava_flag)
            {
           	 if(PSD_OFF == exist(opspecir))
            	{
            		cfxfd_power_limit = 8.0;
            	}
            	else
            	{
                	cfxfd_power_limit = 8.5;
            	}
            }
            else if (medal_flag && exist(oplava))
            {
            	if(PSD_ON == medal_multitr_flag)
                {
                	cfxfd_power_limit = 8.0;
                }
                else
                {
                	cfxfd_power_limit = 8.5;
            	}                        
            }
            else
            {
                if((oprbw >= 100) || ((exist(opslquant)*exist(opnex)*nop) >= 100))
                {	
                    cfxfd_power_limit = 8.0;
                }
                else
                {
                    cfxfd_power_limit = 8.5;
                }
            }
        }
        else
        {
            cfxfd_power_limit = 8.5;
        }
    }


    /* FIESTA derating  05/16/2005 YI */
    if((value_system_flag == VALUE_SYSTEM_HDE) && ((cfgradamp == 8905)||(cfgradamp == 8907)||((int)(10000 * cfxfs / cfrmp2xfs)<70)) && ssfp_flag ) {
        if(exist(opplane) == PSD_OBL) { /* YMSmr07590  08/18/2005 YI */
        } else {
            grad_spec_ctrl |= GMAX_CHANGE;
            glimit = acgd_lite_target;
        }
    }

    if((value_system_flag == VALUE_SYSTEM_HDE) && ((cfgradamp == 8905)||(cfgradamp == 8907)||((int)(10000 * cfxfs / cfrmp2xfs)<70)) && !ssfp_flag
        && (exist(opuser6) != 0) && (exist(opplane) != PSD_OBL) && (exist(opautote) == PSD_MINTEFULL) ) {
        grad_spec_ctrl |= GMAX_CHANGE;
        glimit = acgd_lite_target;
        derate_gxwex = PSD_ON;
    } else if((value_system_flag == VALUE_SYSTEM_HDE) && lava_flag && turbo_flag) { /* for Oblique LAVA on HDe */
        derate_gxwex = PSD_ON;
    } else if((value_system_flag == VALUE_SYSTEM_HDE) && medal_flag) { /* for HDe 3D dual echo */
        derate_gxwex = PSD_ON;
    } else {
        derate_gxwex = PSD_OFF;
    }

    vstrte_init();

    /* GEHmr02509: turn off gradient spec. control for glimit */
    if( PSD_ON == gradOpt_flag )
    {
        grad_spec_ctrl &= ~GMAX_CHANGE;
    }

    if( (VALUE_SYSTEM_SVEM == value_system_flag) || (VALUE_SYSTEM_SVDM == value_system_flag) )
    {
        /* SVBranch, Smart Burst Mode */
        if(sbm_flag && sbm_gradient_method)
        {
            cfxfd_power_limit = 8.5;
            gradCoilMethod = 1;
        }
        else
        {
            gradCoilMethod = 0;
        }
        /* SVBranch, HCSDM00102521 */
        /* xfd_power/temp_limit has fix flag, but cfxfd_power/temp_limit has no.
           below code can let cfxfd_power/temp_limit has pseudo fix flag.
           cfxfd_power/temp_limit can be updated by modifying xfd_power/temp_limit*/
        xfd_power_limit = cfxfd_power_limit;
        xfd_temp_limit  = cfxfd_temp_limit;
        cfxfd_power_limit = xfd_power_limit;
        cfxfd_temp_limit  = xfd_temp_limit;
    }

    /* Update configurable variables */
    if(set_grad_spec(grad_spec_ctrl,glimit,srate,PSD_ON,debug_grad_spec) == FAILURE)
    {
        epic_error(use_ermes,"Support routine set_grad_spec failed",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG,"set_grad_spec");
        return FAILURE;
    }
    /* Skip setupConfig() if grad_spec_ctrl is turned on */
    if(grad_spec_change_flag) { /* YMSmr06931  07/10/2005 YI */
        if(grad_spec_ctrl)config_update_mode = CONFIG_UPDATE_TYPE_SKIP;
        else              config_update_mode = CONFIG_UPDATE_TYPE_ACGD_PLUS;
        inittargets(&loggrd, &phygrd);
    }

    /* Scan is returning PSD_3DM if you select 3D; so get back to PSD_3D*/
    if (opimode == PSD_3DM) {
        cvoverride(opimode, PSD_3D, PSD_FIX_ON, PSD_EXIST_ON);
    }

    /* PURE Mix */
    model_parameters.gre3d.de3d_flag = de3d_flag;
    model_parameters.gre3d.disco_flag = disco_flag;
    model_parameters.gre3d.irprep_flag = irprep_flag;
    model_parameters.gre3d.lava = exist(oplava);
    model_parameters.gre3d.phorder = phorder;
    model_parameters.gre3d.slorder = slorder;
    model_parameters.gre3d.spgr_flag = spgr_flag;
    model_parameters.gre3d.pfkz_hnover = pfkz_hnover;
    
@inline vmx.e SysParmEval  /* vmx 12/28/94 YI */

    if (pcfiesta_flag)
    {
        pipure &= ~PSD_PURE_COMPATIBLE_2;
    }

    /* IR PREP (pjg) */
    cvmin(opti, 0);
    cvmax(opti, TI_MAX);
    cvdef(opti, 125ms);
    opti = _opti.defval;

    /* HDe 11/22/2006 YI    Fixed the problem in switching plane Ax to Obl
                            on 3D FSPGR with 4CH breast coil. */
    labrava_init();

    /* 4/21/96 RJL: Init all new Advisory Cvs from InitAdvisories.e */
    InitAdvPnlCVs();

    /* Initializations for advisory panel */
    avmaxte = 1000ms;

    if( enable_1024 )
        max_slice_limit = RHF_MAX_IMAGES_MULTIPHASE;
    else
        max_slice_limit = DATA_ACQ_MAX;
/*        max_slice_limit = DATA_ACQ_MAX * SLICE_FACTOR; */ /* VAL15 2048slices  03/16/2005 YI */
        
    cvmod(rhnslices, 0, max_slice_limit, 1, "opslquant*optphases*opfphases.", 0, " ");


    /* Set IR Prep flag */
    irprep_flag = (existcv(opirprep) && (exist(opirprep) == PSD_ON));

    /* IFIR GRx : Set IR Prep flag to OFF if graphic IR mode is selected */
    if ((ifir_flag == PSD_ON) && (exist(opgirmode) == PSD_GIRMANUAL))
    {
        irprep_flag = PSD_OFF;
    }

    vast_mode = is_vast_on();  /* In efgre3d_iopts.e */

    if( (PSD_ON == ssfp_flag) && (PSD_ON == exist(opspecir)) && (PSD_OFF == exist(opcgate)) && (PSD_ON == allow_ugfsf) && !osfp_flag && !ifir_flag){
        /* ungated FatSat FIESTA */
        ugfsf_flag = PSD_ON;
    }
    else{
        ugfsf_flag = PSD_OFF;
    }

    /* ungated FatSat FIESTA */
    if( ugfsf_flag || ifir_flag || heart3d_flag ){
        /* 1: linear ramp up */
        /* 2: Fermi ramp up */
        /* 3: sinusoidal ramp up */
        fiesta_rampup_type = 3;
    } else {
        if(value_system_flag)
        {
            fiesta_rampup_type = 1;
        }
        else
        {
            fiesta_rampup_type = 0;
        }
    }

    if (ifir_flag) {
        fiesta_killer_flag = 1;
        ssfp_symmetry_flag = 1;
        enable_alpha = 0;
        fiesta_gated_dda = 10;
        /* YMSmr12248 : YS */
        if (value_system_flag)
        {
            fiesta_gated_dda = 6; 
        } 
    } else if (heart3d_flag) {
        fiesta_killer_flag = 1;
        ssfp_symmetry_flag = 0;
        enable_alpha = 0;
        fiesta_gated_dda = 10;
    } else {
        fiesta_killer_flag = 0;
        ssfp_symmetry_flag = 0;
        if(!value_system_flag)
        {
           enable_alpha = 1;
           fiesta_gated_dda = 20;
        }
    }

    if( PSD_ON == phasefovgt1_flag ) {
        cvmax(opphasefov, MAX_PHASEFOV);
        cvmax(rhphasescale, 2 * MAX_PHASEFOV);
        avmaxphasefov = MAX_PHASEFOV;
    } else {
        cvmax(opphasefov, 1.0);
        cvmax(rhphasescale, 2.0);
        avmaxphasefov = 1.0;
    }

    /* Note on support for opfreqfov (reduced FOV in freqeuncy direction):
       To enable opfreqfov support in PSD, opxres needs to be reduced using
       opfreqfov throughout the code (with proper rounding) */

@inline Tricks.e GenerateSchedule
@inline Disco.e GenerateSchedule

    multiEcho_eval();

    if(ideal_flag || medal_flag) {
       cvmax(opautote, 2);
       if( existcv(opmedal) && (PSD_ON == exist(opmedal)) ) 
       {
           if(!((exist(opautote) == PSD_MINTE) || (exist(opautote) == PSD_MINTEFULL)))
           {
               cvoverride(opautote, PSD_MINTE, PSD_FIX_ON, PSD_EXIST_ON);
           }
       }
       pite1nub = 6;
       pite1val2 = PSD_MINIMUMTE;
       pite1val3 = PSD_MINFULLTE;
    }

    /* We don't need optphases if this is not TRICKS
       So, just to make sure. -Venkat.
    */
    if( tricks_flag == PSD_OFF )
    {
        cvoverride(optphases, 1, PSD_FIX_ON, PSD_EXIST_ON);
    }

    if( !tricks_flag ) {
        if( brava_flag || vibrant_flag || heart3d_flag || headneck_pos_scan || cine3d_flag) {
            pimultigroup = PSD_OFF; 
        } 
    }

@inline MSDE.e MSDE_CVinit

    if (!osfp_flag && !idealiq_flag && !disco_flag && !msde_flag &&
        (lava_flag || brava_flag || vibrant_flag || tricks_flag || vast_mode
         || bravo_flag || specir_flag || irprep_flag 
         || (medal_flag && (PSD_OFF == exist(opvibrant)) && (exist(opnex) <= 1) )
         || (existcv(oprtcgate) && (PSD_ON == exist(oprtcgate)) )
         || (existcv(opcgate) && (PSD_ON == exist(opcgate)) )  
         || (arc_flag && (ACCEL_ARC == autocal_mode) && (0.5 == exist(opnex))))) 
    {
        if (pfkr_yz_flag || turbo_cemra_flag)
        {
            pfkyz2kr_flag = PSD_ON;
            pfkr_flag = PSD_ON;
        }
        else
        {
            pfkyz2kr_flag = PSD_OFF;
            pfkr_flag = PSD_OFF;
        }
    }
    else
    {
        pfkyz2kr_flag = PSD_ON;
        if (osfp_flag || merge_flag || medal_flag || multiEcho_flag ||
            quickstep_flag || disco_flag || msde_flag || turbo_cemra_flag)
        {
            pfkr_flag = PSD_ON;
        }
    }

    /*
     * MRIge82485 - Updated for Scan to read rhassetsl_R.  This was
     * originally only done in predownload.
     */ 
    if( existcv(opasset) && (exist(opasset) == ASSET_SCAN_SLICE) ) { 
        assetsl_factor = FMin(2, 1.0, 1.0/(exist(opaccel_sl_stride))); 
        cvmax(opslquant, 256);
        rhasset = ASSET_SCAN_SLICE;
        rhassetsl_R = assetsl_factor;
    } else {
        assetsl_factor = 1.0;
        rhassetsl_R = 1.0;
    }

    /* MRIge67181 */
    /* ATV - lock-out RT imaging option here to avoid problem with copy/paste 
       protocols that FTMRA enable. The oprealtime CV will be set to 1 for 
       FTMRA at predownload time to satisfy recon */
    cvmax(oprealtime, PSD_OFF);
    cvoverride(oprealtime, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);

    /*
     * Set maximum FOV
     */
    if( (cfgcoiltype != PSD_TRM_COIL) || (opgradmode != TRM_ZOOM_COIL) ) {
        if( (turbo_flag > 1) && (opyres < 128) ) {
            avmaxfov = 440;           /* DCZ: based on testing */
        } else {
            avmaxfov = cfsystemmaxfov;
        }
    }
    
    if (maxfov(&avmaxfov) == FAILURE) {
        epic_error(use_ermes, "%s failed", 
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "maxfov");
        return FAILURE;
    }

    if ((PSD_ON == exist(opresearch)) && 
        ( RX_COIL_BODY == getRxCoilType() ) && xlFOV_flag)
    { 
        avmaxfov = 700;
        cvmax(mpsfov, avmaxfov);
        cvmax(FTGfov, avmaxfov);
    }

    if (osfp_flag) {
       avmaxfov = 300;
    }

    /*
     * Set minimum/maximum TR
     */
    avmintr = 5ms;
    avmaxtr = 6000ms;
    if (maxtr(&avmaxtr) == FAILURE) {
        epic_error(use_ermes, "%s failed", 
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "maxtr");
        return FAILURE;
    }

    slq_shots = 1;

    /* isi interrupt information */
    if(cine3d_flag)
    {
        isi_flag = 1;
    } else {
        isi_flag = 0; 
    }


    /********************************************************************
     **Initialize RF System Safety Information. This must be re-initialized 
     in eval section since CV changes may lead to scaling of rfpulse
    *********************************************************************/
    for (pulse=0; pulse<RF_FREE; pulse++) {
        rfpulseInfo[pulse].change=PSD_OFF;
        rfpulseInfo[pulse].newres=0;
    }

    /*************************************************************
      Rf pulse initializations 
    ***************************************************************/
    gscale_rf1 = 1.0;			/* Chun says it should be 1.0 */
    cyc_rf1 = 3.0;			/* number of sinc cycles for RF1 */
    pw_rf1 = 3.2ms;			/* width of RF1 */
    res_rf1 = 320;			/* resolution of RF1 */
    flip_rf1 = exist(opflip);
    maxb1_rf1 = SAR_MAXB1_ALPHA1;

    /* The time from the end of the rf pulse back to the nutation
       reference, that is the point at which we reference the
       zero phase of the gradients after excitation, is equal to
       res_dephase samples of the rf1 pulse times the sampling
       period pw_rf1/res_rf1. */

    flip_rf0 = 180.0;

    if( irprep_flag == PSD_ON ) {
        rfpulse[RF0_SLOT].activity = PSD_SCAN_ON + PSD_APS2_ON + PSD_MPS2_ON;
    } else {
        rfpulse[RF0_SLOT].activity = 0;
    }

    /* IFIR GRx */
    if (InversionGRxInit() == FAILURE)
    {
        epic_error(use_ermes, "Support routine %s failed.",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "InversionGRxInit");
        return FAILURE;
    }

    if (ifir_frir_flag) 
    {
        rfpulse[RFFRIR_SLOT].activity = PSD_SCAN_ON + PSD_APS2_ON + PSD_MPS2_ON;
    }
    else
    {
        rfpulse[RFFRIR_SLOT].activity = 0;
    }

    switch (rf0_pulse_type)
    {
    case RF0_HS_20MS:
        /* Using CS_HS_20MS rf for selective IR */
        rfpulse[RF0_SLOT].abswidth = SAR_ABS_HS_20MS;
        rfpulse[RF0_SLOT].area = SAR_AHS_20MS;
        rfpulse[RF0_SLOT].effwidth = SAR_HS_EFF_WIDTH_20MS;
        rfpulse[RF0_SLOT].dtycyc = SAR_DTYCYC_HS_20MS;
        rfpulse[RF0_SLOT].maxpw = SAR_MAXPW_HS_20MS;
        rfpulse[RF0_SLOT].max_b1 = MAX_B1_HS_20MS;
        rfpulse[RF0_SLOT].nom_fa = NOM_FLIP_HS_20MS;  
        rfpulse[RF0_SLOT].act_fa = &flip_rf0;
        rfpulse[RF0_SLOT].nom_pw = NOM_PW_HS_20MS;
        rfpulse[RF0_SLOT].nom_bw = NOM_BW_HS_20MS;
        rfpulse[RF0_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_HS_20MS;
        rfpulse[RF0_SLOT].max_rms_b1 = MAX_RMS_B1_HS_20MS;

        flip_rf0 = 180.0;
        pw_rf0  = NOM_PW_HS_20MS;
        a_rf0   = 1.0;
        res_rf0 = RES_RFHS_20MS;
        bw_rf0 = (rfpulse[RF0_SLOT].nom_bw*rfpulse[RF0_SLOT].nom_pw)/(pw_rf0);
        gscale_rf0 = 1.0;
        pw_omega_ir0 = pw_rf0;
        res_omega_ir0 = res_rf0;
        a_omega_ir0 = -1.0;
        ia_omega_ir0 = -max_pg_iamp;
        rf0_phase = 0.25;
        break;

    case RF0_ADIABATIC:
        rfpulse[RF0_SLOT].abswidth = SAR_ABS_ADIABATIC;
        rfpulse[RF0_SLOT].area = SAR_A_ADIABATIC;
        rfpulse[RF0_SLOT].effwidth = SAR_ADIABATIC_EFF_WIDTH;
        rfpulse[RF0_SLOT].dtycyc = SAR_DTYCYC_ADIABATIC;
        rfpulse[RF0_SLOT].maxpw = SAR_MAXPW_ADIABATIC;
        rfpulse[RF0_SLOT].max_b1 = MAX_B1_ADIABATIC;
        rfpulse[RF0_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_ADIABATIC;
        rfpulse[RF0_SLOT].max_rms_b1 = MAX_RMS_B1_ADIABATIC;
        rfpulse[RF0_SLOT].nom_fa = NOM_FA_ADIABATIC;
        rfpulse[RF0_SLOT].act_fa = &flip_rf0;
        rfpulse[RF0_SLOT].nom_pw = NOM_PW_ADIABATIC;

        flip_rf0 = 180.0;
        pw_rf0 = NOM_PW_ADIABATIC; /* 8640 us pulse */
        /* Make the IR pulse non-selective for 3D Heart when both
        * irprep_flag and slabtracking_flag are ON. This will
        * eliminate the impact of IR pulse to the Navigator signal.
        */
        if (heart3d_flag && irprep_flag && slabtracking_flag)
        {
            gscale_rf0 = 0.01;
        } else {
            gscale_rf0 = 0.3;
        }
        cyc_rf0 = 2.0;
        bw_rf0 = 5.12*cyc_rf0/((FLOAT)pw_rf0/(FLOAT)1.0s);
        thk_rf0 = exist(opslthick);
        res_rf0 = RES_SILVER;
        pw_omega_ir0 = pw_rf0;
        res_omega_ir0 = res_rf0;
        a_omega_ir0 = -1.0;
        ia_omega_ir0 = -max_pg_iamp;
        rf0_phase = 0.25;
        break;

    case RF0_HS_3T:
        /* MRIhc07580 HH May 2005 - BB IR  for 3T and above */
        /* Select Silver Hoult Pulse to be 2 Khz BW pulse */

        rfpulse[RF0_SLOT].abswidth = 0.5390;
        rfpulse[RF0_SLOT].area = 0.5390;
        rfpulse[RF0_SLOT].effwidth = 0.3732;
        rfpulse[RF0_SLOT].dtycyc = 1.0;
        rfpulse[RF0_SLOT].maxpw = 1.0;
        rfpulse[RF0_SLOT].max_b1 = 0.013617;
        rfpulse[RF0_SLOT].nom_fa = 27.233;         /* Matlab simulation needs 0.09 gauss for 180.0 */
        rfpulse[RF0_SLOT].act_fa = &flip_rf0;
        rfpulse[RF0_SLOT].nom_pw = 16ms;
        rfpulse[RF0_SLOT].nom_bw = 2000;
        rfpulse[RF0_SLOT].max_int_b1_sq = 0.00110705;
        rfpulse[RF0_SLOT].max_rms_b1 = 0.0130766;

        flip_rf0 = 180.0;
        pw_rf0  = 16ms;
        a_rf0   = 1.0;
        res_rf0 = 400;
        bw_rf0 = (rfpulse[RF0_SLOT].nom_bw*rfpulse[RF0_SLOT].nom_pw)/(pw_rf0);
        /* Make the IR pulse non-selective for 3D Heart when both
          * irprep_flag and slabtracking_flag are ON. This will
          * eliminate the impact of IR pulse to the Navigator signal.
          */ 
        if (heart3d_flag && irprep_flag && slabtracking_flag)
        {
            gscale_rf0 = 0.01;
        } else {
            gscale_rf0 = 0.3;
        }
        pw_omega_ir0 = pw_rf0;
        res_omega_ir0 = res_rf0;
        a_omega_ir0 = -1.0;
        ia_omega_ir0 = -max_pg_iamp;
        rf0_phase = 0.25;
        break;

    case RF0_ADIABTAN:
        rfpulse[RF0_SLOT].abswidth = SAR_ABS_ADIABTAN;
        rfpulse[RF0_SLOT].area = SAR_A_ADIABTAN;
        rfpulse[RF0_SLOT].effwidth = SAR_ADIABTAN_EFF_WIDTH;
        rfpulse[RF0_SLOT].dtycyc = SAR_DTYCYC_ADIABTAN;
        rfpulse[RF0_SLOT].maxpw = SAR_MAXPW_ADIABTAN;
        rfpulse[RF0_SLOT].max_b1 = MAX_B1_ADIABTAN;
        rfpulse[RF0_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_ADIABTAN;
        rfpulse[RF0_SLOT].max_rms_b1 = MAX_RMS_B1_ADIABTAN;
        rfpulse[RF0_SLOT].nom_fa = NOM_FA_ADIABTAN;
        rfpulse[RF0_SLOT].act_fa = &flip_rf0;
        rfpulse[RF0_SLOT].nom_pw = NOM_PW_ADIABTAN;
        rfpulse[RF0_SLOT].nom_bw = NOM_BW_ADIABTAN;

        flip_rf0 = 180.0;
        pw_rf0 = NOM_PW_ADIABTAN;
        if ( heart3d_flag && irprep_flag )
        {
            gscale_rf0 = 0.01;
        } else {
            gscale_rf0 = 0.3;
        }
        cyc_rf0 = 1.0; /* do not scale bandwidth */
        a_rf0   = 1.0;
        res_rf0 = RES_ADIABTAN;
        bw_rf0 = (rfpulse[RF0_SLOT].nom_bw*rfpulse[RF0_SLOT].nom_pw)/(pw_rf0);
        pw_omega_ir0 = pw_rf0;
        res_omega_ir0 = res_rf0;
        a_omega_ir0 = -1.0;
        ia_omega_ir0 = -max_pg_iamp;
        rf0_phase = 0.25;
        break;

    case RF0_INVI0:
    default:
        if ( heart3d_flag && irprep_flag )
        {
            /* set rf0 pulse to non-selective if gated irprep acquisition MS/TKF */
            gscale_rf0 = 0.01;
        } else {
            gscale_rf0 = .9;
        }

        alpha_rf1 = 0.46;
        res_rf0 = RES_INVI0_RF0;

        pw_rf0 = 5ms;
        cyc_rf0 = 1;
        a_rf0 = 0.1312;

        /* MRIge57740 */
        bw_rf0 = 4*cyc_rf0/((FLOAT)pw_rf0/(FLOAT)1.0s);

        /* IR PREP (pjg) */
        rfpulse[RF0_SLOT].abswidth = SAR_ABS_INVI0;
        rfpulse[RF0_SLOT].area = SAR_AINVI0;
        rfpulse[RF0_SLOT].effwidth = SAR_PINVI0;
        rfpulse[RF0_SLOT].dtycyc = SAR_DTYCYC_INVI0;
        rfpulse[RF0_SLOT].maxpw = SAR_MAXPW_INVI0;
        rfpulse[RF0_SLOT].max_b1 = MAX_B1_INVI0_180;
        rfpulse[RF0_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_SINC1_180;
        rfpulse[RF0_SLOT].max_rms_b1 = MAX_RMS_B1_INVI0_180;
        rfpulse[RF0_SLOT].nom_fa = 178.0;
        rfpulse[RF0_SLOT].act_fa = &flip_rf0;
        rfpulse[RF0_SLOT].nom_pw = 5.0ms;
        break;
    } /* switch (rf0_pulse_type) */

    if( PSD_OFF == use_slr_inv && ifir_frir_flag )
    {
        flip_rffrir = 180.0;

        /* Using CS_HS_20MS rf for selective IR */
        rfpulse[RFFRIR_SLOT].abswidth = SAR_ABS_HS_20MS;
        rfpulse[RFFRIR_SLOT].area = SAR_AHS_20MS;
        rfpulse[RFFRIR_SLOT].effwidth = SAR_HS_EFF_WIDTH_20MS;
        rfpulse[RFFRIR_SLOT].dtycyc = SAR_DTYCYC_HS_20MS;
        rfpulse[RFFRIR_SLOT].maxpw = SAR_MAXPW_HS_20MS;
        rfpulse[RFFRIR_SLOT].max_b1 = MAX_B1_HS_20MS;
        rfpulse[RFFRIR_SLOT].nom_fa = NOM_FLIP_HS_20MS;
        rfpulse[RFFRIR_SLOT].act_fa = &flip_rffrir;
        rfpulse[RFFRIR_SLOT].nom_pw = NOM_PW_HS_20MS;
        rfpulse[RFFRIR_SLOT].nom_bw = NOM_BW_HS_20MS;
        rfpulse[RFFRIR_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_HS_20MS;
        rfpulse[RFFRIR_SLOT].max_rms_b1 = MAX_RMS_B1_HS_20MS;

        pw_rffrir  = NOM_PW_HS_20MS;
        a_rffrir   = 1.0;
        res_rffrir = RES_RFHS_20MS;
        bw_rffrir = (rfpulse[RFFRIR_SLOT].nom_bw*rfpulse[RFFRIR_SLOT].nom_pw)/(pw_rffrir);
        gscale_rffrir = 0.001;

        pw_omega_rffrir= pw_rffrir;
        res_omega_rffrir = res_rffrir;
        a_omega_rffrir = -1.0;
        ia_omega_rffrir = -max_pg_iamp;
        rffrir_phase = 0.25;

    }

    pw_hard180 = NOM_PW_FERMI124;
    rfpulse[HARD180_SLOT].abswidth = SAR_ABS_FERMI124;
    rfpulse[HARD180_SLOT].area = SAR_AFERMI124;
    rfpulse[HARD180_SLOT].effwidth = SAR_FERMI124_EFF_WIDTH;
    rfpulse[HARD180_SLOT].dtycyc = SAR_DTYCYC_FERMI124;
    rfpulse[HARD180_SLOT].maxpw = SAR_MAXPW_FERMI124;
    rfpulse[HARD180_SLOT].max_b1 = MAX_B1_FERMI124;
    rfpulse[HARD180_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_FERMI124;
    rfpulse[HARD180_SLOT].max_rms_b1 = MAX_RMS_B1_FERMI124;
    rfpulse[HARD180_SLOT].nom_fa = NOM_FA_FERMI124;
    rfpulse[HARD180_SLOT].act_fa = &flip_hard180;
    rfpulse[HARD180_SLOT].nom_pw = NOM_PW_FERMI124;
    rfpulse[HARD180_SLOT].nom_bw = NOM_BW_FERMI124;

    if( ftmra_flag && rtia3d_irp_flag ) {
        rfpulse[HARD180_SLOT].activity = PSD_SCAN_ON;
        rfpulse[HARD180_SLOT].num = 1;
    } else {
        rfpulse[HARD180_SLOT].activity = 0;
        rfpulse[HARD180_SLOT].num = 0;
    }

    /* Turn OFF user CV page */
    pititle = 0;

    /* Initialize user cvs */
    piuset = 0;

    if (UnLocked) {

        /*
         * Bolus Chasing CVs
         */

        /* Initialize opuser0, if necessary */
        /* MRIhc20325 Remove UserCV for Multi Station on DVMR or forward only */
        /* SVBranch, HCSDM00094105 */
        if ( (wfmMultistationFlag || (firstSeriesFlag && exist(opmultistation) == PSD_OFF) ) && (!lava_flag) )
        { 
            /* Make sure definition for opuser0, opuser17, and opuser18
               is "default" if MultiStation is OFF */
            cvmod( opuser0, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable  0", 0, "" );
            cvoverride(opuser0, _opuser0.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            cvmod( opuser17, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 17", 0, "" );
            cvoverride(opuser17, _opuser17.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            cvmod( opuser18, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 18", 0, "" );
            cvoverride(opuser18, _opuser18.defval, PSD_FIX_OFF, PSD_EXIST_OFF);

        }

        /* MRIge66833 - only show no. of station CV0 for 1st arterial station */

        /* Should the opuser0 CV show in the user CV page? */
        if ( wfmMultistationFlag )
        {
            /* MRIhc20325 Remove UserCV for Multi Station on DVMR or forward only */
            num_stations_flag = FALSE;
        }
        else
        {
            num_stations_flag = ( pimultistation &&
                                  existcv(opmultistation) &&
                                  (exist(opmultistation) == PSD_ON) &&
                                  (exist(opstation) == 1) &&
                                  (opmask == PSD_OFF) &&
                                  (opvenous == PSD_OFF) );
        }

        /* SVBranch, HCSDM00094105 */
        if ( num_stations_flag &&(!lava_flag)) {
            /* Activate User CV 0 only if this is the first Station
               (series) and the MultiStation Imaging Option has been
               selected */

            /* Set def. value and description for Number of Stations
               User CV */
            if ( (exist(oploadprotocol) == PSD_OFF) && firstSeriesFlag ) {
                cvmod( opuser0, 1.0, 4.0, 1.0, "Number of Stations (1..4)", 0, "" );
                opuser0 = _opuser0.defval;
                piuset |= use0;
                /* Set local CV for the Number of Stations */
                opnostations = (int)exist(opuser0);
            }

            /* MRIge66833 - only show mask/venous CV for 1st arterial station */
            piuset |= use17 | use18;

            /* Activate Mask Acquisition User CV */
            cvmod( opuser17, 0.0, 1.0, 0.0, "Mask Acquisition (0=off, 1=on)",0,"Select 0 or 1" );
            opuser17 = _opuser17.defval;

            /* Activate Venous Acquisition User CV */
            cvmod( opuser18, 0.0, 1.0, 0.0, "Venous Acquisition (0=off, 1=on)",0,"Select 0 or 1" );
            opuser18 = _opuser18.defval;

        } else {
            /* Deactivate Number of Stations User CV */
            piuset &= ~use0 & ~use17 & ~use18;
        }

        /* MRIhc20325 Remove UserCV for Multi Station on DVMR or forward only */
        /* SVBranch, HCSDM00094105 */
        if ( !wfmMultistationFlag &&(!lava_flag) )
        {
            if ( (exist(oploadprotocol) == PSD_ON) && (exist(opmultistation) == PSD_ON) ) {
                opnostations = (int)exist(opuser0);
                cvmin(opuser0, (float)opnostations);
                cvmax(opuser0, (float)opnostations);
                _opnostations.fixedflag = 1;
                _opnostations.existflag = 1;

                if ( (exist(opstation) > 1) && (maskv_loadprotocol_flag == FALSE) ) {
                    maskval = (int)exist(opuser17);
                    cvmin(opuser17, (float)maskval);
                    cvmax(opuser17, (float)maskval);
                    venousval = (int)exist(opuser18);
                    cvmin(opuser18, (float)venousval);
                    cvmax(opuser18, (float)venousval);
                    maskv_loadprotocol_flag = TRUE;
                }
            }
        }

        /* Activate AutoStep option */
        piautostep = (pimultistation && opmultistation);


        /* Activate ZIP Features CVs */
        opzip512 = 0.0;
        cvmod( opzip512, 0.0, 1.0, 0.0, "512 ZIP (0=off  1=on)",0,"512 ZIP must be 0 or 1." );
        cvmax(opzip1024, 1);
        opslzip2 = 0;
        cvmod( opslzip2, 0, 1, 0, "Slice ZIP x 2 (0=off 1=on)", 0, "Slice ZIP x 2 must be 0 or 1." );
        opslzip4 = 0;
        cvmod( opslzip4, 0, 1, 0, "Slice ZIP x 4 (0=off 1=on)", 0, "Slice ZIP x 4 must be 0 or 1." );

        hires_recon = ((opzip512 != 0.0) ? 1 : 0);
        recon_1024 = ((opzip1024 != 0.0) ? 1 : 0);

        slicezp = 1;
        if (exist(opslzip2)) {
            slicezp = 2;
        }
        if (exist(opslzip4)) {
            slicezp = 4;
        }


        /* Auto Voice   04/12/2005 YI
           Scan needs to change opuser4 for auto voice but this is not good way.
           When scan puts opinittrigdelay PSD substitutes opuser4 with it and
           when user changed opuser4 PSD substitutes opinittrigdelay with it.
           Finally both user and scan control opuser4.                        */
        if( epic_findputcvnum( "opuser4" ) == SUCCESS ) {
            cvoverride(opinittrigdelay,opuser4,PSD_FIX_ON,PSD_EXIST_ON);
        }
        if( epic_findputcvnum( "opinittrigdelay" ) == SUCCESS ) {
            cvoverride(opuser4,opinittrigdelay,PSD_FIX_ON,PSD_EXIST_ON);
        }

        if (FAILURE == Monitor_CvevalInit(rfpulse))
        {
            epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "Monitor_CvevalInit");
            return FAILURE;
        }

        if (FAILURE == NavigatorCvevalInit())
        {
            epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "NavigatorCvevalInit");
            return FAILURE;
        }

        if (FAILURE == t2prep_cvevalinit())
        {
            epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "t2prep_cvevalinit");
            return FAILURE;
        }

@inline FastCINE3D.e fcine3d_cvevalinit

        if ((PSD_ON == navgate_flag) && (PSD_ON == enhanced_nav_flag)) 
        {
            nav_wait_flag = 1;
            navend_time = 20ms;
            nav_linear_ramp_up = 4;
            nav_linear_ramp_down = 2;
            if (exist(opflip) < 10.0 || (navkz_views_per_segment == pfkz_views_per_segment)) {
                navseg_weight = 1.0;
            } else if (exist(opflip) > 50.0) {
                navseg_weight = 0.6;
            } else {
                navseg_weight = 1 - (exist(opflip)-10)*0.01;
            }
        } else {
            nav_wait_flag = 0;
            nav_linear_ramp_up = 0;
            nav_linear_ramp_down = 0;
            navseg_weight = 1.0;
        }

        if ((PSD_ON == ifir_flag) && (PSD_ON == navtrig_flag) && (PSD_ON == slabtracking_flag)) {
            ifir_dnav_flag = 1;
        } else {
            ifir_dnav_flag = 0;
        }

        /* MRIge92645: Disable sat page for 3D PC_FIESTA and non-gated 3D Fiesta. For all
         * other cases the SAT page is ON. */
        /* HDsv 03/16/2009 YI */
        if ( (ssfp_flag == PSD_ON) && (osfp_flag == PSD_OFF) && (ifir_flag == PSD_OFF) )
        {
            /* allow ungated FatSat FIESTA */
            if (((pcfiesta_flag == PSD_ON) && !fs_pcfiesta_flag) || ((pcfiesta_flag == PSD_OFF) && ((existcv(opcgate)) && (opcgate ==PSD_OFF)) && (allow_ugfsf == PSD_OFF)) || cine3d_flag )
            {
                pisatnub = 0;
            }
            else
            {
                pisatnub = 1;
            }
        }
        /* MRIhc46858 */
        else if ((irprep_flag && !ifir_flag && !(bravo_flag && bravo_fatsat)) || ifir_stir_flag || cine3d_flag)
        {
            pisatnub = 0;
        }
        else if ((ellipt_flag || reverse_ellipt_flag) && !ftmra_flag)
        {
            pisatnub = 0;
        }
        else
        {
            pisatnub = 1;
        }

        pc_mode = PC_BASIC; /* VAL15 12/14/2004 YI */

        if (((lava_flag || brava_flag || vibrant_flag) && (Present == UltraFastKey)) ||
            medal_flag || disco_flag)
        {
            pfkr_yz_enable = PSD_ON;
        }
        else
        {
            pfkr_yz_enable = PSD_OFF;
            pfkr_yz_flag = PSD_OFF;
        }

        pidefexcitemode = SELECTIVE;
        cvdef(opexcitemode, SELECTIVE);
        piexcitemodenub = 1;

        /* Activate the rest of User CVs */
        if( PSD_ON == ssfp_flag ) {

            /* Allow arrhythmia enhancements for 3D FIESTA Gated */
            if(( (PSD_ON == vast_mode) && (PSD_OFF == ifir_flag)) || cine3d_flag ){
                piuset |= use3;
                cvmod( opuser3, 0.0, 1.0, 0.0, "Arrhythmia Check (0=off, 1=on)", 0, "" );
                if (cine3d_flag)
                {
                    cvdef(opuser3, 1.0);   /* default Arrythmia Rejection ON */
                }
                opuser3 = _opuser3.defval;
            } else {
                /* Turn off user CV 3 */
                piuset &= ~use3;
                cvmod( opuser3, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable  3", 0, "" );
                cvoverride(opuser3, _opuser3.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            }

            if( PSD_ON == pcfiesta_flag ) {
                piuset |= use16;
                cvmod( opuser16, 2.0, 8.0, 2.0, "Slices to discard", 0, " " );
                opuser16 = _opuser16.defval;
            } 
            else if (cine3d_flag)
            {
                  cvmod(opuser16,1.0,100.0,10.0,"Respiratory compensation (%kspace-compensated)",0," ");
                  opuser16 = _opuser16.defval;
                  if (exist(opnex) > 1 )
                  {
                       piuset |= use16;
                  }
                  else
                  {
                       piuset &= ~use16;
                  }
            }
            else
            {
                piuset &= ~use16;
                cvmod( opuser16, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable  16", 0, "" );
                cvoverride(opuser16, _opuser16.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            }

            /* Initialize incompatible User CVs.  User CVs 2 and 4 are
               taken care of above as part of the Monitor/SmartPrep setup.
               User CVs 0, 17, and 18 are taken care of above as part of
               the Multistation setup.  */

            piuset &= ~use6;
            cvmod( opuser6, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable  6", 0, "" );      
            cvoverride(opuser6, _opuser6.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            piuset &= ~use11;
            cvmod( opuser11, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 11", 0, "" );      
            cvoverride(opuser11, _opuser11.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            piuset &= ~use12;
            cvmod( opuser12, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 12", 0, "" );      
            cvoverride(opuser12, _opuser12.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            piuset &= ~use13;
            cvmod( opuser13, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 13", 0, "" );      
            cvoverride(opuser13, _opuser13.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            piuset &= ~use14;
            cvmod( opuser14, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 14", 0, "" );      
            cvoverride(opuser14, _opuser14.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            piuset &= ~use19;
            cvmod( opuser19, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 19", 0, "" );      
            cvoverride(opuser19, _opuser19.defval, PSD_FIX_OFF, PSD_EXIST_OFF);          

            /* SVBranch, Smart Burst Mode */
            if( (PSD_ON == ssfp_flag) &&
                (PSD_OFF == specir_flag) &&
                (PSD_OFF == exist(opsat)) &&
                (PSD_OFF == exist(opcgate)) &&
                (PSD_OFF == exist(oprtcgate)) &&
                (PSD_OFF == exist(opnav)) &&
                (1 == exist(opfphases)) &&
                (PSD_OFF == exist(opfluorotrigger)) &&
                (PSD_OFF == osfp_flag) &&
                (PSD_OFF == pcfiesta_flag) &&
                (PSD_OFF == ifir_flag) &&
                (enable_sbm) )
            {
                cvmod( opuser24, 0, 1.0, 0.0, "Smart Burst Mode: 0- Off, 1-On ", 0, "" );
                piuset |= use24;
                if ( (_opuser24.minval > exist(opuser24)) ||
                     (_opuser24.maxval < exist(opuser24)) )
                {
                    if(exist(opuser24) < _opuser24.minval)
                    {
                        cvoverride(opuser24, _opuser24.minval, PSD_FIX_ON, PSD_EXIST_ON);
                    }
                    if(exist(opuser24) > _opuser24.maxval)
                    {
                        cvoverride(opuser24, _opuser24.maxval, PSD_FIX_ON, PSD_EXIST_ON);
                    }
                    epic_error( use_ermes, "%s must be set to 0-1.",
                                EM_PSD_CV_0_OR_1, EE_ARGS(1), STRING_ARG, "Smart burst mode" );
                    return FAILURE;
                }
                if(sbm_flag)
                {
                    cvmod( opuser21, 1.0, 2.0, 1.35, "Effect of TR reduction ", 0, "" );
                    opuser21 = _opuser21.defval;
                    piuset |= use21;
                }
                else
                {
                    piuset &= ~use21;
                    cvmod( opuser21, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 21", 0, "" );
                    cvoverride(opuser21, _opuser21.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
                }
            }
            else
            {
                piuset &= ~use24;
                cvmod( opuser24, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 24", 0, "" );
                cvoverride(opuser24, _opuser24.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            }
        } else {
            if ((value_system_flag != VALUE_SYSTEM_HDE) && !quickstep_flag && !headneck_pos_scan && 
                ((exist(opplane) == PSD_SAG) || (exist(opplane) == PSD_COR))) {
               piexcitemodenub = 1 + 2;
               cvmax(opexcitemode, NON_SELECTIVE);
            }
            else
            {
               /* The Excitation Mode is set to Selective greyed out on
                * the UI */  
               piexcitemodenub = 1;
               cvmax(opexcitemode, SELECTIVE);
            }

            /* Allow arrhythmia check for 3D Cardiac Gated */
            if( PSD_ON == exist(opcgate) ) {
                piuset |= use3;
                cvmod( opuser3, 0.0, 1.0, 0.0, "Arrhythmia Check (0=off, 1=on)", 0, "" );
                opuser3 = _opuser3.defval;
            } else {
                /* Turn off user CV 3 */
                piuset &= ~use3; 
                cvmod( opuser3, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable  3", 0, "" );
                cvoverride(opuser3, _opuser3.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            }

            /* Activate Turbo Mode User CV */
            if ((UltraFastKey == Present) && (!pfkr_yz_enable) &&
                (PSD_OFF == exist(opcgate) ||
                 ((PSD_ON == exist(opcgate)) && ((PSD_OFF == navgate_flag) || (PSD_ON == heart3d_flag)))))
            {
                if (ss_rf1)
                {
                    cvmod( opuser6, 0.0, 2.0, 1.0, "Turbo Mode (0=off, 1=Faster, 2=Fastest)", 0, "" );
                }
                else
                {
                    cvmod( opuser6, 0.0, 2.0, 2.0, "Turbo Mode (0=off, 1=Faster, 2=Fastest)", 0, "" );
                }
            } else {
                if (disco_flag)
                {
                    cvmod( opuser6, 0.0, 1.0, 1.0, "Turbo Mode (0=off, 1=Turbo)", 0, "" );
                }
                else
                {
                    cvmod( opuser6, 0.0, 1.0, 0.0, "Turbo Mode (0=off, 1=Turbo)", 0, "" );
                }
            }

            /* MRIge51626 - Enabling turbo only when SGD perf key is present and
               when grad amp is 8651. - latha@mr */
            /* MRIge56509 - Enabled turbo mode when SGD perf key is present and when
               grad amp is 8651 or 8915 - AF 120199 */

            if (turbo_cemra_enable)
            {
                piuset &= ~use6;
                setexist(opuser6, PSD_OFF);
                setfix(opuser6, PSD_OFF);
            }
            else
            {
                piuset |= use6;
            }

            /* Set defaults for all k-space ordering CVs */
            if ( !disco_flag )
            {
                cvmod( opuser11, 0.0, 1.0, 0.0, "Reverse Elliptical Centric (0=off, 1=on)",0,"Select 0 or 1" );
                opuser11 = _opuser11.defval;

                cvmod( opuser12, 0.0, 2.0, 0.0, "Elliptical Centric (0=off, 1=std, 2=delay)",0,"Select 0 or 1" );
                opuser12 = _opuser12.defval;

                cvmod( opuser13, 0.0, 1.0, 0.0, "Centric (0=off, 1=on)",0,"Select 0 or 1" );
                opuser13 = _opuser13.defval;

                cvmod( opuser14, 0.0, 1.0, 0.0, "Reverse Centric (0=off, 1=on)",0,"Select 0 or 1" );
                opuser14 = _opuser14.defval;
            }

            /* The Elliptic Centric User CV is available to all
               Fast 3D TOF GRE/SPGR scans */
            if ( ( (exist(oppseq) == PSD_TOF) || (exist(oppseq) == PSD_TOFSP) || medal_flag ) && (PSD_OFF == gate_on) && !disco_flag)
            {
                /* Activate Elliptic Centric User CV */
                piuset |= use11 | use12 | use13 | use14;
#ifdef UNDEF
                /* The Reverse Elliptic Centric, Centric, and Reverse Centric
                   phase encoding User CVs are available only if the SmartPrep or FTMRA
                   key is present */
                if( (SmartPrepKey == Present) || (ftMRAKey == Present) || (QUICKSTEPKey == Present) ) {
                    /* Activate Reverse Elliptic Centric, Centric,
                       and Reverse Centric User CVs */
                    piuset |= use11 | use13 | use14;
                } else {
                    piuset &= ~use11 & ~use13 & ~use14;
                    cvmod( opuser11, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 11", 0, "" );
                    cvoverride(opuser11, _opuser11.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
                    cvmod( opuser13, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 13", 0, "" );
                    cvoverride(opuser13, _opuser13.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
                    cvmod( opuser14, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 14", 0, "" );
                    cvoverride(opuser14, _opuser14.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
                }
#endif
                if(PSD_ON == navgate_flag)
                {
                    piuset &= ~use11 & ~use12;
                    cvmod( opuser11, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 11", 0, "" );
                    cvoverride(opuser11, _opuser11.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
                    cvmod( opuser12, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 12", 0, "" );
                    cvoverride(opuser12, _opuser12.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
                }
            }
            else if (!disco_flag)
            {
                if (lava_flag)
                {
                    piuset |= use13;
                }
                else
                {
                    piuset &= ~use13;
                    cvmod( opuser13, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 13", 0, "" );
                    cvoverride(opuser13, _opuser13.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
                }

                piuset &= ~use11 & ~use12 & ~use14;
                cvmod( opuser11, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 11", 0, "" );
                cvoverride(opuser11, _opuser11.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
                cvmod( opuser12, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 12", 0, "" );
                cvoverride(opuser12, _opuser12.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
                cvmod( opuser14, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 14", 0, "" );
                cvoverride(opuser14, _opuser14.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            }

            if (multiEcho_flag) {
               if (idealiq_flag)
               {
                   piuset &= ~use16;
                   cvmod( opuser16, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable  16", 0, "" );
                   cvoverride(opuser16, _opuser16.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
                   uniPolar_flag = PSD_ON;
               }
               else
               {
                   piuset |= use16;
                   cvmod( opuser16, 0.0, 1.0, 0.0, "Uni-polar echoes (0=off, 1=on)", 0, "" );
                   opuser16 = _opuser16.defval;
                   uniPolar_flag = exist(opuser16);
               }
            }
            else if (swan_flag) {
               piuset |= use16;
               cvmod( opuser16, 0.0, 200.0, 0.0, "1st echo TE (ms): (0=Auto)", 0, "" );
               opuser16 = _opuser16.defval;
               if (exist(opuser16)==0) {
                  swanfirstTE = (int) (B0_30000*SWAN_1ST_TE_3T/cffield);
               }
               else {
                  swanfirstTE = (int) (exist(opuser16)*1ms);
               }
            }
            else if (medal_flag && (arc_research_flag || (PSD_ON == exist(opresearch)) || (PSD_ON == exist(opvibrant)) || (PSD_ON == exist(oplava)) || (PSD_ON == exist(opdisco))))
            {
               piuset |= use16;
               cvmod( opuser16, 0.0, 1.0, 0.0, "Multiple TR acquisition (0=off, 1=on)", 0, "" );
               opuser16 = _opuser16.defval;
               medal_multitr_flag = exist(opuser16);
               if (PSD_ON == medal_multitr_flag)
               {
                   /* MRIhc38426 */ 
                   if ((PSD_ON == exist(oplava)) || (PSD_ON == exist(opdisco)))
                   {
                       medal_autote_flag = PSD_OFF;
                       medal_flexecho_order_flag = PSD_OFF;
                   }
                   else
                   {
                       medal_autote_flag = PSD_ON;
                       medal_flexecho_order_flag = PSD_ON;
                   }
               }
               else
               {
                   medal_autote_flag = PSD_OFF;
                   medal_flexecho_order_flag = PSD_OFF;
               }
            }
            else if (cine3d_flag)
            {
                  cvmod(opuser16,1.0,100.0,10.0,"Respiratory compensation (%kspace-compensated)",0," ");
                  opuser16 = _opuser16.defval;
                  if (exist(opnex) > 1 )
                  {
                       piuset |= use16;
                  }
                  else
                  {
                       piuset &= ~use16;
                  }
                  /* Set opuser defaults for cine3d */
                  cvdef(opuser3, 1.0);   /* default Arrythmia Rejection ON */
                  opuser3 = _opuser3.defval;

                  if (UltraFastKey == Present)
                  {
                      cvdef(opuser6, 2.0);
                  }
                  else
                  {
                      cvdef(opuser6, 1.0);
                  }
                  opuser6 = _opuser6.defval;
            }
            else
            {
               piuset &= ~use16;
               cvmod( opuser16, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable  16", 0, "" );
               cvoverride(opuser16, _opuser16.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            }

            /* Real-time SAT User CVs should be active only with FTMRA */
            /* MRIge91683 */
            cvmod( opuser19, 0.0, 3.0, 0.0, "Real-time SAT (0=NON-axial, 1=Axial, 2=In-plane, 3=IRP)",0,"Select 0-3" );
            opuser19 = _opuser19.defval;

            cvmod( opuser20, 0.0, 1.0, 0.0, "Thick Slab Projection (0=Off, 1=On)",0,"Select 0 or 1" );
            opuser20 = _opuser20.defval;

            cvmod( opuser21, 0.0, 1.0, 0.0, "Restricted Real-time Navigation (0=Off, 1=On)", 0, "Select 0 or 1" );
            opuser21 = _opuser21.defval;

            /* MRIge91682 */
            cvmod( opuser24, 0.0, 8.0, 0.0, "LA(BRA)VA FATSAT segments: (0=Auto)",0,"" );
            opuser24 = _opuser24.defval;

            if( PSD_ON == exist(opfluorotrigger) ) {
                piuset |= use19 | use21;

                if( (quickstep_flag) && (PSDDVMR != psd_board_type) ) {
                    rtia3d_thkslab_proj_enable_flag = PSD_ON;
                } else {
                    rtia3d_thkslab_proj_enable_flag = PSD_OFF;
                }

                if( rtia3d_thkslab_proj_enable_flag ) {
                    piuset |= use20;
                } else { 
                    piuset &= ~use20;
                    cvmod( opuser20, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 20", 0, "" );
                    cvoverride(opuser20, _opuser20.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
                }
                if (exist(opuser19)==2) {
                    cvoverride(opuser20, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
                }

                if ( (exist(opuser19)==3) ) {
                   rtia3d_irp_flag = PSD_ON;
                } else {
                   rtia3d_irp_flag = PSD_OFF;
                }

            } else {
                piuset &= ~use19 & ~use21;
                cvmod( opuser19, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 19", 0, "" );
                cvoverride(opuser19, _opuser19.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
                cvmod( opuser21, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 21", 0, "" );
                cvoverride(opuser21, _opuser21.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            }

            rtia3d_thkslab_proj_flag= exist(opuser20);
            rtia3d_restricted_nav_flag = exist(opuser21);

            zslab = 1.0 * exist(opslthick);

            if (zslab > 3.0) { 
                zslab = 3.0;
            } 
            if (zslab < 1.5) {
                zslab = 1.5;
            }

            area_de = (1e6) * (FLOAT)rtia3d_thkslab_proj_flag / ((FLOAT)GAM * zslab);

        } /* end ssfp_flag */

        /* ARC Coil accel factors research */
        if (arc_flag) {
            if (arc_research_flag || medal_flag || disco_1echo_flag) /* disco_1echo needs to show this opusercv */
            {
                if(  (!(navgate_flag && !disco_flag)) && (PSD_OFF == pfkr_yz_flag) &&
                    !(disco_flag && !exist(opresearch)) ) /* do not show in Disco clinical mode */
                {
                    piuset |= use15;
                    cvmod( opuser15, 0, 2, cal_shape, "Turbo ARC (0=off, 1=Faster, 2=Fastest)",0,"Select 0-2" );
                    opuser15 = _opuser15.defval;
                }
                else
                {
                    piuset &= ~use15;
                    cvmod( opuser15, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 15", 0, "" );
                    cvoverride(opuser15, 0, PSD_FIX_OFF, PSD_EXIST_OFF);
                }

                if (pfkr_yz_flag)
                {
                    cvoverride(opuser15, 2, PSD_FIX_OFF, PSD_EXIST_ON);
                }

                if( existcv(opuser15) && ((_opuser15.minval > exist(opuser15)) || (_opuser15.maxval < exist(opuser15))) )
                {
                    /* Set "good" default value */
                    cvoverride(opuser15, _opuser15.defval, PSD_FIX_ON, PSD_EXIST_ON);
                    /* Display an error message */
                    epic_error( use_ermes, "%s is out of range.",
                            EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "Calibration Shape");
                    return FAILURE;
                }

                if (BOX_CAL  == exist(opuser15))
                {
                    arc_ph_mincalwidth = 36;
                    arc_sl_mincalwidth = (arc_sl_stride >= 3) ? 28 : 24;
                }
                else if (ELLIPTICAL_CAL  == exist(opuser15))
                {
                    if (pfkr_yz_flag)
                    {
                        arc_ph_mincalwidth = 24;
                        arc_sl_mincalwidth = 24;
                    }
                    else
                    {
                        arc_ph_mincalwidth = 32;
                        arc_sl_mincalwidth = 32;
                    }
                }
                else 
                {
                    arc_ph_mincalwidth = (arc_ph_stride >= 3) ? 28 : 24;
                    arc_sl_mincalwidth = (arc_sl_stride >= 3) ? 28 : 24;
                }
                
                if(PSD_ON == exist(opresearch))
                {
                    piuset |= use9 | use10;
                    cvmod( opuser9, 10, 128, arc_ph_mincalwidth, "Minimum ARC Phase overscans (10..48)",0,"Select 10-128" );
                    opuser9 = _opuser9.defval;
                    cvmod( opuser10, 10, 128, arc_sl_mincalwidth, "Minimum ARC Slice overscans (10..48)",0,"Select 10-128" );
                    opuser10 = _opuser10.defval;
                }
                else
                {
                    piuset &= ~use9 & ~use10;
                    cvmod( opuser9, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 9", 0, "" );
                    cvoverride(opuser9, 0, PSD_FIX_OFF, PSD_EXIST_OFF);
                    cvmod( opuser10, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 10", 0, "" );
                    cvoverride(opuser10, 0, PSD_FIX_OFF, PSD_EXIST_OFF);
                }
            }
            else
            {
                piuset &= ~use9 & ~use10 & ~use15;
                cvmod( opuser9, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 9", 0, "" );
                cvoverride(opuser9, 0, PSD_FIX_OFF, PSD_EXIST_OFF);
                cvmod( opuser10, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 10", 0, "" );
                cvoverride(opuser10, 0, PSD_FIX_OFF, PSD_EXIST_OFF);
                cvmod( opuser15, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable  15", 0, "" );
                cvoverride(opuser15, _opuser15.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            }
        } else {
            piuset &= ~use7 & ~use8 & ~use9 & ~use10 ;

            cvmod( opuser7, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 7", 0, "" );
            cvoverride(opuser7, 1.0, PSD_FIX_OFF, PSD_EXIST_OFF);
            cvmod( opuser8, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 8", 0, "" );
            cvoverride(opuser8, 1.0, PSD_FIX_OFF, PSD_EXIST_OFF);
            cvmod( opuser9, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 9", 0, "" );
            cvoverride(opuser9, 0, PSD_FIX_OFF, PSD_EXIST_OFF);
            cvmod( opuser10, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 10", 0, "" );
            cvoverride(opuser10, 0, PSD_FIX_OFF, PSD_EXIST_OFF);
            if ( !( exist(opcgate) && (PSD_OFF == vast_mode)) ) 
            {
                piuset &= ~use15;  
                cvmod( opuser15, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 15", 0, "" );
                cvoverride(opuser15, 0, PSD_FIX_OFF, PSD_EXIST_OFF);
            }
        }

        /* MRIge91683 */
        cvmod( opuser23, 70.0, 100.0, 100.0, "Slice Resolution (70%-100%)", 0, "" );
        opuser23 = _opuser23.defval;

        /* Arrhythmia Check */
        arr_check = exist(opuser3);

        /* MRIge91682 */
        if( lava_flag || brava_flag || vibrant_flag || tricks_flag ||
            disco_flag || bravo_flag || ifir_flag || msde_flag ||
            (PSD_ON == exist(opcgate)) || specir_flag || osfp_flag || 
            (PSD_ON == pfkyz2kr_flag && PSD_ON == opnopwrap) ||
            (PSD_ON == pfkyz2kr_flag && exist(opnex) < 1.0) ) 
        {
            if (turbo_cemra_flag)
            {
                piuset |= use23;
                cvmod( opuser23, 70.0, 100.0, 100.0, "Slice Resolution (70%-100%)", 0, "" );
                opuser23 = _opuser23.defval;
            } else if ( heart3d_flag ) {
                /* enable pfkz support only for full nex and full echo case */
                piuset |= use23;
                cvmod( opuser23, 80.0, 100.0, 100.0, "Slice Resolution (80%-100%)", 0, "" );
                opuser23 = _opuser23.defval;
            } else {
                piuset &= ~use23;
                cvoverride(opuser23,_opuser23.defval,PSD_FIX_ON,PSD_EXIST_ON);
            }
        } else {
            piuset |= use23;
        }

        if(headneck_pos_scan)
        {
            piuset &= ~use23;
            cvoverride(opuser23,_opuser23.defval,PSD_FIX_ON,PSD_EXIST_ON);
        }

        if (pfkr_yz_enable && (PSD_ON == exist(opuser6)))
        {
            pfkr_yz_flag = 1;
        }
        else
        {
            pfkr_yz_flag = 0;
        }

        lava_ave_mode = 2;

        if( (PSD_ON == ssfp_flag) && (pcfiesta_flag == PSD_ON) && value_system_flag ) {
            piuset |= use1;
            cvmod( opuser1,0.0,2.0,2.0, "Processing 0:APC 1:SGS 2:Basic",0," " );
            opuser1 = 0.0;
            pc_mode = (int)exist(opuser1);
        } else if ( (PSD_ON == exist(oplava)) &&
                    (exist(opnex) > 1) && (PSD_OFF == exist(opnav)) && !disco_flag)
        {
            piuset |= use1;
            cvmod( opuser1, 0.0, 1.0, 0.0, "NEX Mode (0=short term, 1=long term)",0," " );
            opuser1 = 0.0;
            lava_ave_mode = (int)exist(opuser1);
        } else if( heart3d_flag && irprep_flag &&
                   ((B0_30000==(int)cffield) || (exist(opresearch))) &&
                   ((Present == Heart3DKey) || (Present == MDEKey)) && (Present == mdeplusKey) ) {
            cvmod( opuser1, 0.0, 1.0, 1.0, "IR prep pulse type (0=Legacy, 1=Enhanced)",0," " );
            if  ( B0_30000==(int)cffield )
            {
                piuset &= ~use1;
                cvdef(opuser1, 1.0);
            }
            else
            {
                piuset |= use1;
                cvdef(opuser1, 0.0);
            }
            opuser1 = _opuser1.defval;
        } else {
            piuset &= ~use1;
            cvmod( opuser1, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 1", 0, "" );
            cvoverride(opuser1, _opuser1.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
        }

        if( (PSD_ON == ssfp_flag) && (pcfiesta_flag == PSD_ON) ) {
            piuset |= use5;
            cvmod( opuser5, 0.0, 1.0, 0.0, "RF1 Type 0: Legacy 1: New",0," " );
            opuser5 = 0.0;
            pcfiesta_rf = (int)exist(opuser5);
        } else if (PSD_ON == turbo_cemra_enable) {
            cvmod( opuser5, 0.0, 1.0, 0.0, "Turbo Mode (0=off, 1=Turbo)", 0, "" );
            if( quickstep_flag )
            {
                piuset &= ~use5;
                cvoverride(opuser5, 1.0, PSD_FIX_ON, PSD_EXIST_ON);
            }
            else
            {
                piuset |= use5;
                opuser5 = 0.0;
            }
        } else if ( (PSD_ON == cine3d_flag) && ((INT)arr_check == PSD_ON) )  {
            piuset |= use5;
            cvmod(opuser5,1.0,75.0,50.0,"Scan Abort Threshold (%heartbeats-rejected)",0," ");
            opuser5 = _opuser5.defval;
        } else {
            piuset &= ~use5;
            cvmod( opuser5, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 5", 0, "" );
            cvoverride(opuser5, _opuser5.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
        }

        if (turbo_cemra_enable && (PSD_ON == exist(opuser5)))
        {
            turbo_cemra_flag = PSD_ON;
        }
        else
        {
            turbo_cemra_flag = PSD_OFF;
        }

        regViewOrderMode = REGULAR;
        if (disco_flag)
        {
            pfkr_flag = PSD_ON;
            pfkr_fraction = 0.7;
            pfkz_flag = PSD_OFF;
            pfkz_fraction = 1.0;

            if (!opresearch)
            {
                piuset &= ~use6 & ~use12 & ~use13 & ~use14;
                piuset |= use11;

                cvmod(opuser11, 0, 2, 2, "Temporal acceleration (0=Fast, 1=Faster, 2=Fastest)", 0, "");
                opuser11 = _opuser11.defval;

                switch ((int)opuser11)
                {
                case 0:
                    aregion_fraction = 0.16;
                    num_sub_regions = 3;
                    pfkr_yz_flag = 0;
                    break;
                default:
                case 1:
                    aregion_fraction = 0.16;
                    num_sub_regions = 3;
                    pfkr_yz_flag = 1;
                    break;
                case 2:
                    aregion_fraction = 0.16;
                    num_sub_regions = 4;
                    pfkr_yz_flag = 1;
                    break;
                }

                if (exist(opdynaplan) && existcv(opdynaplan_nphases))
                {
                    int max_num_sub_regions = num_sub_regions;
                    if (!existcv(opvsphases))
                    {
                        max_num_sub_regions = exist(opdynaplan_nphases);
                    }
                    else
                    {
                        max_num_sub_regions = IMin(2, exist(opvsphases), exist(opdynaplan_nphases));
                    }
                    if(num_sub_regions > max_num_sub_regions)
                    {
                    	num_sub_regions = max_num_sub_regions;
                    }
                }
                else if (existcv(opfphases) && (exist(opfphases) < (num_sub_regions + mask_phase_flag)) && (exist(opfphases) > (1 + mask_phase_flag)))
                {
                    num_sub_regions = opfphases - mask_phase_flag;
                }
            }
            else
            {
                piuset &= ~use11;
                piuset |= use12 | use13 | use14;

                cvmod(opuser12, 0.05, 0.50, 0.16, "A region fraction", 0, "");
                opuser12 = _opuser12.defval;
                aregion_fraction = exist(opuser12);

                cvmod(opuser13, 2, 8, 3, "Number of B regions", 0, "");
                opuser13 = _opuser13.defval;
                num_sub_regions = (1 > exist(opuser13)) ? 1 : exist(opuser13);

                cvmod(opuser14, 0, 2, 0, "View sharing (0=bkwd, 1=nearest, 2=fwd)", 0, "");
                opuser14 = _opuser14.defval;
                combo_mode = exist(opuser14);
            }

            if (pfkr_yz_flag)
            {
                pfkr_fraction = 0.78; /* ratio to no corner removal sampling. circle area is pi/4 */
                pfkz_flag = PSD_ON;
                pfkz_fraction = 0.7;
            }

            if (breastCoil_flag && (exist(opnopwrap) == PSD_ON))
            {
                cvmin(pfkr_fraction_act,0.5); 
                if (pfkr_yz_flag)
                {
                    pfkr_fraction = 0.7; 	
                }
                else 
                { 					
                    pfkr_fraction = (PSD_MINTE == (exist(opautote))) ? 0.7 : 0.6; 
                }
            }        

            if (segmented_flag)
            {
                regViewOrderMode = INTERLEAVE;
            }
            else
            {
                regViewOrderMode = REGULAR; /* non-interleave */
            }

            if (exist(opdynaplan))
            {
                /* For DISCO DynaPlan, PSD always set up everything assuming there is a mask phase.
                 * Note opdynaplan_nphases will be incremented by 1 if Mask Phase is ON.
                 */
                disco_nphases = exist(opdynaplan_nphases) + (PSD_OFF == exist(opdynaplan_mask_phase));
                _opfphases.defval = PHASES_MIN;
                cvoverride(opfphases, _opfphases.defval, PSD_FIX_ON, PSD_EXIST_ON);
                _opvsphases.defval = disco_nphases;
                peakPhaseIndex = exist(opvsphases) + 1 + mask_phase_flag; /* 1-based */
            }
            else
            {
                disco_nphases = exist(opfphases);
                peakPhaseIndex = exist(opfphases) + 1; /* 1-based */
            }
        } else if( lava_flag ) {
            pfkz_flag = PSD_ON;
            cvoverride(opautote, PSD_MINTEFULL, PSD_FIX_ON, PSD_EXIST_ON);
            if(UltraFastKey == Present)
            {   /* YMSmr07067  Jul/10/2005 YI */
                if (pfkr_yz_enable == PSD_ON)
                {
                    if (ss_rf1)
                    {
                        turbo_flag = 1;
                    }
                    else
                    {
                        if (existcv(opflip) && (15.0<exist(opflip)))
                        {
                            turbo_flag = 0;
                        }
                        else
                        {
                            turbo_flag = 2;
                        }
                    }
                }
                else
                {
                    if (ss_rf1)
                    {
                        cvoverride(opuser6, 1, PSD_FIX_ON, PSD_EXIST_ON);
                    }
                    else
                    {
                        if (existcv(opflip) && (15.0<exist(opflip)))
                        {
                            cvoverride(opuser6, 0, PSD_FIX_ON, PSD_EXIST_ON);
                        }
                        else
                        {
                            cvoverride(opuser6, 2, PSD_FIX_ON, PSD_EXIST_ON);
                        }
                    }
                    piuset &= ~use6;
                }
            }

            piuset &= ~use11 & ~use12 & ~use14;

            if (pfkr_yz_flag)
            {
                pfkr_flag = PSD_ON;
                pfkr_fraction = 0.78; /* ratio to no corner removal sampling. circle area is pi/4 */
            }
            else
            {
                pfkr_flag = PSD_OFF;
            }

         } else if( brava_flag ) {
            pfkz_flag = PSD_ON;
            if (pfkr_yz_flag)
            {
                pfkr_flag = PSD_ON;
                pfkr_fraction = 0.78; /* ratio to no corner removal sampling. circle area is pi/4 */
            }
            else
            {
                pfkr_flag = PSD_OFF;
            }
		
            if (B0_30000 == (int)cffield) {
                cvoverride(opautote, PSD_FWINPHS, PSD_FIX_ON, PSD_EXIST_ON); 
            } else {
                cvoverride(opautote, PSD_MINTEFULL, PSD_FIX_ON, PSD_EXIST_ON);
            }
            if(UltraFastKey == Present) {  /* YMSmr07067  Jul/10/2005 YI */
                if(!ss_rf1)
                {
                    if (pfkr_yz_enable) 
                    {		    
                        piuset |= use6;
                    }
                    else
                    {
                        piuset &= ~use6;
                        cvoverride(opuser6, 2, PSD_FIX_ON, PSD_EXIST_ON);
                    }
                }
                else
                {
                    piuset &= ~use6;
                    cvoverride(opuser6, 1, PSD_FIX_ON, PSD_EXIST_ON);
                }
            }
            piuset &= ~use11 & ~use12 & ~use13 & ~use14;
        } else if (osfp_flag) {
            if (cffield <= B0_15000) {
               cvoverride(opautote, PSD_MINTEFULL, PSD_FIX_ON, PSD_EXIST_ON);
            } else {
               if (!medal_flag) {
                  cvoverride(opautote, PSD_MINTE, PSD_FIX_ON, PSD_EXIST_ON);
               } else {
                  cvoverride(opautote, PSD_MINTEFULL, PSD_FIX_ON, PSD_EXIST_ON);
               }
            }
            pfkz_flag = PSD_OFF;
            pfkz_fraction = 1.0;
            pfkr_flag = PSD_ON;
            pfkr_fraction = 0.7;
        } else if (ifir_flag) {
            cvoverride(opautote, PSD_MINTEFULL, PSD_FIX_ON, PSD_EXIST_ON);
            pfkz_flag = PSD_OFF;
            pfkz_fraction = 1.0;
            pfkr_flag = PSD_OFF;
            pfkr_fraction = 1.0;
        } else if (merge_flag) {
            if(!ss_rf1)
            {
                cvoverride(opuser6,0,PSD_FIX_ON,PSD_EXIST_ON);
            }
            else
            {
                cvoverride(opuser6, 1, PSD_FIX_ON, PSD_EXIST_ON);
            }
            pfkr_flag = PSD_ON;
            pfkr_fraction = 0.7;
            if ( (exist(opnopwrap) == PSD_ON) ) {
	       cvmin(pfkr_fraction_act,0.5); /* MRIhc20624 */
               pfkr_fraction = 0.6;
            }
            pfkz_flag = PSD_OFF;
            pfkz_fraction = 1.0;
            piuset &= ~use4 &  ~use6 & ~use11 & ~use12 & ~use13 & ~use14 & ~use23;
        } else if (idealiq_flag) {
            pfkz_flag = PSD_OFF;
            pfkz_fraction = 1.0;
            /* Initialize pfkr_flag and pfkr_fraction here. */
            /* They will be changed in cveval1() if fn < 1. */
            pfkr_flag = PSD_OFF;
            pfkr_fraction = 1.0;
            piuset &=  ~use6 & ~use11 & ~use14 & ~use23;
        } else if (multiEcho_flag) {
            cvoverride(opautote,PSD_MINTEFULL,PSD_FIX_ON,PSD_EXIST_ON);
            pfkr_flag = PSD_ON;
            pfkr_fraction = 0.7;
            if ( (exist(opnopwrap) == PSD_ON) ) {
	       cvmin(pfkr_fraction_act,0.5); /* MRIhc20624 */
               pfkr_fraction = 0.6; 
            }
            pfkz_flag = PSD_OFF;
            pfkz_fraction = 1.0;
            if(ss_rf1)
            {
               cvoverride(opuser6, 1, PSD_FIX_ON, PSD_EXIST_ON);
            }
            piuset &= ~use6 & ~use11 & ~use14 & ~use23;
        } else if (medal_flag) {
            
            if (PSD_ON == exist(opvibrant))
            {
                pfkr_flag = PSD_ON;
                pfkr_fraction = (pfkr_yz_flag) ? 0.78 : 0.7;
                if ( (exist(opnopwrap) == PSD_ON) ) 
                {
                    cvmin(pfkr_fraction_act,0.5); 
                    if (pfkr_yz_flag)
                    {
                        pfkr_fraction = 0.7; 	
                    }
                    else 
                    { 					
                        pfkr_fraction = (PSD_MINTE == (exist(opautote))) ? 0.7 : 0.6; 
                    }
                }

                pfkz_flag = (pfkr_yz_flag) ? PSD_ON : PSD_OFF;
                pfkz_fraction = (pfkr_yz_flag) ? 0.7 : 1.0;
            }
            else if (exist(opnex) > 1)
            {
                if (pfkr_yz_flag)
                {
                    pfkr_flag = PSD_ON;
                    pfkr_fraction = 0.78; /* ratio to no corner removal sampling. circle area is pi/4 */
                    pfkz_flag = PSD_ON;
                    pfkz_fraction = 0.70;
                    pfkyz2kr_flag = PSD_ON;
                }
                else
                {
                    pfkr_flag = PSD_ON;
                    pfkr_fraction = exist(opnopwrap) ? 0.7 : PI/4;
                    pfkz_flag = PSD_OFF;
                    pfkz_fraction = 1.0;
                }
            }
            else
            {
                pfkz_flag = PSD_ON;
                pfkz_fraction = 0.70;

                if (pfkr_yz_flag)
                {
                    pfkr_flag = PSD_ON;
                    pfkr_fraction = 0.78; /* ratio to no corner removal sampling. circle area is pi/4 */
                    pfkyz2kr_flag = PSD_ON;
                }
                else
                {
                    pfkr_flag = PSD_OFF;
                    pfkr_fraction = 1.0;
                }
            }
            piuset &= ~use11 & ~use14 & ~use23;

            if (pfkr_yz_enable == PSD_OFF)
            {
                piuset &= ~use6;
            }

            if (pfkr_yz_flag)
            {
                piuset &= ~use12;
                cvoverride(opuser12, PSD_OFF, PSD_FIX_OFF, PSD_EXIST_OFF);
            }
        } else if (quickstep_flag) {
            cvoverride(opautote,PSD_MINTE,PSD_FIX_ON,PSD_EXIST_ON);
            pfkr_flag = PSD_ON;
            pfkr_fraction = 0.7;
            if (turbo_cemra_flag) {
                pfkz_fraction = exist(opuser23) / 100.0;
                if (pfkz_fraction > ((float)(arc_equant-1.0)/(float) arc_equant))
                    pfkz_fraction = 1.0;
                if( pfkz_fraction < 1.0 ) {
                    pfkz_flag = PSD_ON;
                }
                else
                {
                    pfkz_flag = PSD_OFF;
                    pfkz_fraction = 1.0;
                }
                piuset &=  ~use6;
            }
            else
            {
                pfkz_flag = PSD_OFF;
                pfkz_fraction = 1.0;
                cvoverride(opuser6, 2, PSD_FIX_ON, PSD_EXIST_ON);
                piuset &=  ~use6 & /*~use11 & ~use12 & ~use13 & ~use14 &*/ ~use23;
            }
        } else if (cal3d_flag) {
            pfkz_flag = PSD_OFF;
            pfkz_fraction = 1.0;
            pfkr_flag = PSD_ON;
            pfkr_fraction = PI/4;
            piuset &= ~use4;
        }
        else if (msde_flag)
        {
            pfkz_flag = PSD_OFF;
            pfkz_fraction = 1.0;
            pfkr_flag = PSD_ON;
            pfkr_fraction = 0.7;

            if (cffield > B0_15000) {
                /* Turbo mode is 1 on 3T */
                cvoverride(opuser6, 1, PSD_FIX_ON, PSD_EXIST_ON);
                piuset &= ~use6;
            }
        } 
        else if (headneck_pos_scan)
        {
            cvoverride(opautote, PSD_FWINPHS, PSD_FIX_ON, PSD_EXIST_ON); 
            pfkz_flag = PSD_OFF;
            pfkz_fraction = 1.0;
            pfkr_flag = PSD_ON;
            pfkr_fraction = 0.7;
        } 
        else 
        {
            pfkz_fraction = exist(opuser23) / 100.0;
            if (pfkz_fraction > ((float)(arc_equant-1.0)/(float) arc_equant))
                pfkz_fraction = 1.0;
            if( pfkz_fraction < 1.0 ) {
                if (turbo_cemra_flag) {
                   pfkz_flag = PSD_ON;
                } else if (pfkyz2kr_flag) {
                   pfkr_flag = PSD_ON;
                   pfkz_flag = PSD_OFF;
                   pfkr_fraction = pfkz_fraction;
                   pfkz_fraction = 1.0;
                } else {
                  pfkz_flag = PSD_ON;
                  pfkr_flag = PSD_OFF;
                  pfkr_fraction = 1.0;
                }
            } else {
                pfkz_flag = PSD_OFF;
                pfkz_fraction = 1.0;
                pfkr_flag = PSD_OFF;
                pfkr_fraction = 1.0;
            }
            if(ss_rf1)
            {
               cvoverride(opuser6,1,PSD_FIX_ON,PSD_EXIST_ON);
               piuset &= ~use6;
            }
        }
        if(bravo_flag == PSD_ON) {
            cvoverride(opautote, PSD_MINTEFULL, PSD_FIX_ON, PSD_EXIST_ON);
            cvoverride(opuser6, 0, PSD_FIX_ON, PSD_EXIST_ON);
            piuset &= ~use6;
        }

        if (lava_flag|| (!medal_flag && !flexte_flag && !idealiq_flag && (exist(opetl)>=2)) ) {
           cvoverride(opautote, PSD_MINTEFULL, PSD_FIX_ON, PSD_EXIST_ON);
        }

        /* HCSDM00416801:3D calibration has longer TR after re-selecting
           coil mode when pre-saved coil is not in existed coil database.
           Because 3D calibration need turbo_flag =2 to use a shorter RF.
           For 3D calibration, opuser6 is not exist, so turbo_flag shouldn't
           be decided by the value of opuser6 */

        /* Turbo 3D */
        if ((turbo_cemra_flag == PSD_ON) || (PSD_ON == cal3d_flag))
        {
            turbo_flag = 2;
        }
        else if ((turbo_cemra_enable == PSD_ON) && (turbo_cemra_flag == PSD_OFF))
        {
            turbo_flag = 1;
        }
        else if (pfkr_yz_enable == PSD_OFF)
        {
            turbo_flag = exist(opuser6);
        }
        
        if(value_system_flag == VALUE_SYSTEM_HDE) { /* YMSmr08165  11/18/2005 YI */
            if( (exist(oprbw) > 83) && ((exist(opfov))/(float)(exist(opxres)) <= 0.75)  )
                turbo_flag = PSD_OFF;
        }
        
        rf1_pulse_type = turbo_flag + 1;

        if( 2  == turbo_flag ) {
            if (opflip <= 15.0) {
                rf1_pulse_type = RF_TBW8;
            } else {
                rf1_pulse_type = RF_TBW6;
            }
        }

        if (merge_flag)
           rf1_pulse_type = RF_TBW24;

        if (medal_flag)
           rf1_pulse_type = RF_TBW8;

        if (quickstep_flag)
           rf1_pulse_type = RF_HARD100;

        ns3d_flag = ( exist(opexcitemode) || vstrte_flag );

        if (ns3d_flag)
        {
            rf1_pulse_type = RF_HARD100;
        }

        /* MRIge91683 */ 
        if (stre_flag)
        {
            tlead = 4us;
            count_rfupd = 0;
            count_grd_wait = 0;
        }
        else
        {
            tlead = 56us;
            count_rfupd = 1;
            count_grd_wait = 1;
        } 

        /* MRIhc20976 gradient overrange error during realtime acquistion  of FTMRA scan */
        if ( (ftmra_flag == 1) || (maskv_ftmra_flag == 1) )
            waitTime = 16;
        else
            waitTime = 0; 

        /* MRIge66887 */
        vstrte_init(); 

        if (!vstrte_flag) {
            /* MRIhc46084 */
            if (((IMax(2, 1, exist(opslquant) - 2*(opslblank)))*exist(opslthick)) < 8.0)
            {
                rfb1opt_flag = 0;
            }            
            else if (PSD_ON == minseqrf_cal)
            {
                rfb1opt_flag = 2;  /* 1: Iterative model 
                                      2: non-Iterative model (rfsafetyopt.c) */
            }
            else if (irprep_flag || t2prep_flag)
            {
                rfb1opt_flag = 1;
            }
            else
            {
                rfb1opt_flag = 1;
            }
        }

        if( (vibrant_flag == PSD_ON) && (cffield > B0_15000) ) {
            rfb1opt_flag = PSD_OFF;
        }

        /* SPECIAL (SPEC IR) */
        specir_flag = (exist(opspecir));
        
        if ( osfp_flag && (PSD_ON == exist(opfat)))
        {
            aspir_flag = PSD_OFF;
            specir_flag = PSD_ON;
        }

        /* 
           Ignore turbo mode based RF pulse selection for 3d special Fiesta.
           No turbo mode is available for fiesta mode. Based on FatSat 
           and regular ungated fiesta, choose the appropriate RF pulse. 
           - RJF
        */
        if( PSD_ON == ssfp_flag ) {
            if ( ((exist(opcgate) == PSD_ON) && (PSD_ON == specir_flag)) || ifir_flag ) {
                rf1_pulse_type = RF_3D_600US_01P_01S_10KHZ;
            } else if (vstrte_flag) {
                rf1_pulse_type = RF_HARD24;
            } else if ( PSD_ON == pcfiesta_flag ) {
                if ( 0 == pcfiesta_rf ) {
                    rf1_pulse_type = RF_TB3_01_001_250;
                } else {
                    rf1_pulse_type = RF_E3DFGRE;
                }
            } else if ( PSD_ON == cine3d_flag) {
                 if(B0_15000 == (int)cffield)
                 {
                    rf1_pulse_type = RF_3D_600US_01P_01S_10KHZ;
                 }
                 else
                 {
                    rf1_pulse_type = RF_TB3_01_001_250;
                 }
            } else { 
                rf1_pulse_type = RF_TB3_01_001_250;
            }

            if ( osfp_flag )
            {
               if (cffield < B0_30000)
                  rf1_pulse_type = RF_TBW8_001_001_200LP;
               else
                  rf1_pulse_type = RF_TBW8_001_001_200;
            }

        }

        /* HK for Fiesta-C */
        /* PHASE CYCLED FIESTA */
        if( pcfiesta_flag == PSD_ON ) {
            phase_cycles = 2;
            if(pc_mode < PC_BASIC)phase_cycles = 1; /* VAL15 12/14/2004 YI */
        }
        else {
            phase_cycles = 1;
        }

        /* Phase Encoding Ordering */
        if ( !disco_flag )
        {
            reverse_ellipt_flag = (exist(opuser11) == 1.0);
            /* MRIge91683 */
            ellipt_flag = (exist(opuser12) >= 1.0);
            delay_ec_flag = (exist(opuser12) == 2.0);
            centric_flag = (exist(opuser13) == 1.0);
            reverse_centric_flag = (exist(opuser14) == 1.0);
        }
        else
        {
            /* DISCO - force elliptical centric */
            ellipt_flag = 1;
            delay_ec_flag = 0;
            centric_flag = 0;
            reverse_centric_flag = 0;
        }

@inline Tricks.e PhaseorderFlag

        /* Manage the SPECIAL fatSat button - RJF */
        /* HK - MRIge85189  */
        /* No SPECIAL for Ungated FIESTA -Venkat */
        pichemsatopt = 2; 

        /* allow ungated FatSat FIESTA *//* HDsv 03/16/2009 YI */
        if( (ellipt_flag == 1) || (reverse_ellipt_flag == 1) || (turbo_cemra_flag) ||
            (irprep_flag && !((bravo_flag && bravo_fatsat) || ifir_flag)) ||
            (ifir_stir_flag) || (PSD_ON == tricks_flag) ||
            ((PSD_ON == pcfiesta_flag) && !fs_pcfiesta_flag) ||
            disco_flag ||
            (PSD_ON == medal_flag) ||
            (PSD_ON == ideal_flag) ||
            (idealiq_flag) ||
            (PSD_ON == ss_rf1) || 
            ((ssfp_flag == PSD_ON) && (exist(opcgate) == PSD_OFF) && 
             (osfp_flag == PSD_OFF) && (allow_ugfsf == PSD_OFF) &&
             (ifir_flag == PSD_OFF))  ) {
            pichemsatopt = 0;
        }

        if( PSD_ON == turbo_cemra_flag ) {
            if ( (PSD_ON == exist(opfat)) || (PSD_ON == exist(opspecir)) ) {
                epic_error(use_ermes,
                           "%s is incompatible with %s.",
                           EM_PSD_INCOMPATIBLE,EE_ARGS(2),STRING_ARG, "Fat Suppression",
                           STRING_ARG,"Turbo Mode");
                return FAILURE;
            }

            if ( PSD_ON == exist(opwater) ) {
                epic_error(use_ermes,
                           "%s is incompatible with %s.",
                           EM_PSD_INCOMPATIBLE,EE_ARGS(2),STRING_ARG, "Water Suppression",
                           STRING_ARG,"Turbo Mode");
                return FAILURE;
            }
        }

        if( (Present == FiestaKey) && (Absent == FSFiestaKey) &&
            (PSD_ON == ssfp_flag) && (PSD_OFF == pcfiesta_flag) &&
            (PSD_OFF == osfp_flag) && (PSD_OFF == ifir_flag) )
        {
            pichemsatopt = 0;
        }

        /* HCSDM00363811 */
        if ( (sp_sat == PSD_ON) &&
             (!ifir_flag) && (!osfp_flag) && (ftmra_flag == PSD_OFF) && (maskv_ftmra_flag == PSD_OFF) )
        {
            pichemsatopt = 0;
        }
        
        if (bravo_flag && (!bravo_fatsat))
        {
            pisupnub = 0;
        }

        /* turn ChemSAT menu off for TRICKS and SwiFT */
        if( (tricks_flag == 1) || (intslab_flag == 1) )
        {
            pisupnub = 0;
        }

        /* BBA - Improved SPECIAL */
        /* RJF - For single or dual breast coil, specIR is defaulted to the
           improved version */ 
        if( (vibrant_flag && !aspir_override) && specir_flag ) {
            extraspecial_flag = PSD_ON;
        } else {
            extraspecial_flag = PSD_OFF;
        }

        /* Initialize intermittent chemsat to OFF, and override 
           this with 1 for SPECIAL selections - RJF */
        intermittant_chemsat = PSD_OFF;

        if( specir_flag ) {
            intermittant_chemsat = PSD_ON;

            /* Display the value of auto TI in pitival2 */
            if (aspir_flag)
                pitival2 = specir_ti;
            else
                pitival2 = min_specirti;

            /* BBA - improved SPECIAL */
            if( extraspecial_flag == PSD_ON ) {
                specir_ti = 8000;

                /* MRIge89078  - Set a user CV for sequential ordering for Extraspecial defaulted to 0 (ON) */
                piuset |= use22;
                cvmod( opuser22, 0.0, 1.0, 0.0, "Classic Sequential Ordering (0=OFF, 1=ON)", 0, "" );
                opuser22 = _opuser22.defval;
            } else if( exist(opautoti) == PSD_ON ) {
                avminti = min_specirti;
                if (aspir_flag)
                {
                   cvoverride(opti, specir_ti, PSD_FIX_ON, PSD_EXIST_ON);
                   cvdef(opti, specir_ti);
                } else {
                   cvoverride(opti, avminti, PSD_FIX_ON, PSD_EXIST_ON);
                   cvdef(opti, avminti);
                }
                /* Turn OFF extra special user CV */
                piuset &= ~use22;
                cvmod( opuser22, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 22", 0, "" );
                cvoverride(opuser22, _opuser22.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            } else {
                if (aspir_flag && irprep_flag)
                {
                    int aspir_ti;
                    int aspirTI = (int)(-fatT1 * log(0.5 * (1 + 2*exp(-exist(opti)/fatT1)) ));
                    aspir_ti = IMax(2,min_specirti,aspirTI); 
                    cvoverride(specir_ti, aspir_ti, PSD_FIX_OFF, PSD_EXIST_ON); 
                } 
                else {
                    specir_ti = exist(opti);
                }
                /* Turn OFF extra special user CV */
                piuset &= ~use22;
                cvmod( opuser22, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 22", 0, "" );
                cvoverride(opuser22, _opuser22.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            }
        } else {
            if (PSD_ON == swan_flag)
            {
               if((PSD_OFF != exist(opphaseimage)) && (PSD_ON == existcv(opphaseimage)))
               {
                  piuset |= use22;
                  cvmod( opuser22, 0.0, 1.0, 1.0, "SWAN phase background removal: (0=off, 1=on)", 0, "" );
                  opuser22 = _opuser22.defval;
                  if (exist(opuser22)==1)
                  {
                     phmask=1;
                  }
                  else
                  {
                     phmask=0;
                  }
               }
            }
            else
            {
               /* Turn OFF extra special user CV */
               piuset &= ~use22;
               cvmod( opuser22, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 22", 0, "" );
               cvoverride(opuser22, _opuser22.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            }
        }
        cvoverride(extraspecial_seq_order_flag, !((int)exist(opuser22)), PSD_FIX_ON, PSD_EXIST_ON); 

        /* Respiratory Gating */
        respgate_flag = exist(oprtcgate);

    }/* unlocked*/ 

    if ( existcv(opasset) && (exist(opasset) == ASSET_SCAN_PHASE) ) 
    { 
        int temp_nframes;
        asset_factor = FMin(2, 1.0, 1.0/(exist(opaccel_ph_stride)));
        round_factor = (fn == 0.75) ? 6.0 : 2.0;
        temp_nframes = (int)(ceil( eg_phaseres * fn * yfov_aspect * asset_factor /
                                   round_factor ) * round_factor);
        
        /* Avoid line artifacts in SWAN Phase Imaging when opaccel_ph_stride = 2 */
        if ( (PSD_OFF != exist(opphaseimage)) && existcv(opphaseimage) 
             && exist(opswan) && (2 == exist(opaccel_ph_stride)) ) 
        {
            asset_factor = FMin(2, 1.0, 1.0/(exist(opaccel_ph_stride)));
        }
        else
        {
            asset_factor = FMin(2, 1.0, floorf(temp_nframes*1.0e5/(eg_phaseres * fn * yfov_aspect))/1.0e5);
        }

    }
    else 
    {

        asset_factor = 1.0;
    }

    /* MRIge66079 - ATV: RTIA3D/ftMRA */
    ftmra_eval();
    /* End RTIA3D/ftMRA */

    /* Turn SpSAT flag ON */
    if( (existcv(opsat) && exist(opsat)) &&
        (exist(opsatx) || exist(opsaty) || exist(opsatz) || exist(opexsatmask)) &&
        ( (smartprep_flag == PSD_OFF) || (monitor_page == PSD_ON) ) ) {
        sp_sat = 1;
    } else {
        sp_sat = 0; /* Make sure Sat is turned off if SmartPrep is being
                       used and we aren't using the Monitor page */
    }

    /* Set Cardiac Gating parameters */
    if (!arc_flag) {
        if ( exist(opcgate) && (PSD_OFF == vast_mode) && !cine3d_flag )
        { 
            piuset |= use15;

            /* MRIge81523 - UI for loop order support */
            cvmod( opuser15, 0.0, 1.0, 0.0, "Reverse loop order", 0, "Please enter 0 or 1" );
            opuser15 = _opuser15.defval;
            reverseLoopOrder = (exist(opuser15) == 1.0 ? 1 : 0);

            if( (exist(opuser15) > _opuser15.maxval) || (exist(opuser15) < _opuser15.minval ) ) { 
                /* Set a "good" default */
                cvoverride(opuser15, _opuser15.defval, PSD_FIX_ON, PSD_EXIST_ON);
                /* Display an error message */
                epic_error( use_ermes, "%s must be set to either 0 or 1.",
                            EM_PSD_CV_0_OR_1, EE_ARGS(1),
                            STRING_ARG, "Reverse loop order" );
                reverseLoopOrder = -1;
            }
        } else {
            /* Disable and reset user CV */
            piuset &= ~use15;
            cvmod( opuser15, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 15", 0, "" );
            cvoverride(opuser15, _opuser15.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            reverseLoopOrder = 0;
        }
    }

    /* HCSDM00339164 *//* HCSDM00370378 *//* HCSDM00375610 *//* HCSDM00367499 */
    if(  ( ((PSD_SAG == exist(opplane)) || ((PSD_OBL == exist(opplane)) && (PSD_SAG == exist(opobplane)))) ||
           ((PSD_COR == exist(opplane)) || ((PSD_OBL == exist(opplane)) && (PSD_COR == exist(opobplane)))) ) &&
         ( (PSD_GE == exist(oppseq)) || (PSD_SPGR == exist(oppseq)) || (PSD_TOF == exist(oppseq)) || (PSD_TOFSP == exist(oppseq)) ) &&
         ( !tricks_flag && !lava_flag && !brava_flag && !vibrant_flag && !bravo_flag && !medal_flag && !merge_flag && !multiEcho_flag &&
           !disco_flag && !ideal_flag && !idealiq_flag && !de3d_flag && !swan_flag && !intslab_flag ) &&
         ( ((PSD_MINTE == exist(opautote)) && (PSD_OFF == exist(opspf))) ||
           ((PSD_MINTEFULL == exist(opautote)) && (PSD_ON == exist(opspf)) && (exist(opnex)/(float)nop >= 0.75) &&
            (PSD_OFF == exist(opmph)) && (PSD_OFF == exist(opdynaplan)) && (PSD_OFF == exist(opmultistation)) && (PSD_OFF == exist(opzip1024)) && (PSD_OFF == exist(opassetscan)) && (cfrecvend > cfrecvst)) ||
           (0 == exist(opautote)) ) &&
         (PSD_VRMW_COIL == cfgcoiltype)  )
    {
        piuset |= use25;
        nextemp = exist(opnex);
        if ( ((((exist(opnex) - nextemp))||((PSD_ON == exist(opnopwrap))&&(exist(opnex) < 2.0)))&&(PSD_MINTE == exist(opautote))) ||
             (PSD_MINTEFULL == exist(opautote)) )
        {
            cvmod( opuser25, 0.0, 1.0, 0.0, "Annefact Reduction (0=Off, 1=Mid)", 0, "Please enter 0 or 1" );
            if(PSD_ON == exist(opmultistation))
            {
                opuser25 = 1.0;
            }
            else
            {
                opuser25 = 0.0;
            }
        }
        else
        {
            cvmod( opuser25, 0.0, 2.0, 0.0, "Annefact Reduction (0=Off, 1=Mid, 2=High)", 0, "Please enter 0 - 2" );
            if(PSD_ON == exist(opmultistation))
            {
                opuser25 = 2.0;
            }
            else
            {
                opuser25 = 0.0;
            }
        }
        /* HCSDM00370378 */
        if( (PSD_MINTEFULL == exist(opautote)) && (1 == (int)(exist(opuser25))) )
        {
            annefact_reduction_flag =  PSD_OFF;
            annefact_c3_recon_flag = PSD_ON;
        }
        else
        {
            annefact_reduction_flag = (int)(exist(opuser25));
            annefact_c3_recon_flag = PSD_OFF;
        }
    }
    else
    {
        piuset &= ~use25;
        cvmod( opuser25, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 25", 0, "" );
        cvoverride(opuser25, _opuser25.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
        annefact_reduction_flag = PSD_OFF;
        annefact_c3_recon_flag = PSD_OFF;
    }

    /* Fermi filer optimization */
    if ((PSD_ON == exist(opmerge)) || (PSD_ON == exist(opbravo)))
    {
        piuset |= use30;
        cvmod( opuser30, 0.0, 2.0, 1.0, "Apodization Level: 0=Weak, 1=Medium, 2=Strong", 0, "" );
        opuser30 = _opuser30.fixedflag ? opuser30 : _opuser30.defval;
        if( existcv(opuser30) && ((exist(opuser30) < _opuser30.minval) || (exist(opuser30) > _opuser30.maxval)) )
        {
            epic_error(use_ermes,"%s is out of range",EM_PSD_CV_OUT_OF_RANGE,
                       EE_ARGS(1),STRING_ARG,"UserCV30");
            return FAILURE;
        }
        apodize_level_flag = (int)exist(opuser30);
    }
    else
    {
        piuset &= ~use30;
        cvmod( opuser30, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 30", 0, "" );
        cvoverride(opuser30, _opuser30.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
        apodize_level_flag = APODIZE_WEAK;
    } 

    
    /* C3 recon for MERGE */
    char attribute_result[ATTRIBUTE_RESULT_SIZE] = "";
    getAnatomyAttributeCached(exist(opanatomy), ATTRIBUTE_CATEGORY, attribute_result);
    int mergeC3_enable_anatomy = PSD_OFF;
    if ((strstr(attribute_result, "Spine")) || (strstr(attribute_result, "LowerExtremities")))
    {
        mergeC3_enable_anatomy = PSD_ON;
    }
    else
    {
        mergeC3_enable_anatomy = PSD_OFF;
    }

    if ((PSD_ON == exist(opmerge)) && (PSD_OFF == exist(opassetscan)) && 
        (PSD_OFF == annefact_c3_recon_flag) && (fn > 0.9999) && (PSD_ON == mergeC3_enable_anatomy))
    {
        piuset |= use27;

        if (strstr(attribute_result, "Spine"))
        {
            cvmod( opuser27, 0.0, 1.0, 1.0, "Background suppression: 0=Off, 1=On", 0, "" );
        }
        else
        {
            cvmod( opuser27, 0.0, 1.0, 0.0, "Background suppression: 0=Off, 1=On", 0, "" );
        }

        opuser27 = _opuser27.fixedflag ? opuser27 : _opuser27.defval;

        if( existcv(opuser27) && ((exist(opuser27) < _opuser27.minval) || (exist(opuser27) > _opuser27.maxval)) )
        {
            epic_error(use_ermes,"%s is out of range",EM_PSD_CV_OUT_OF_RANGE,
                       EE_ARGS(1),STRING_ARG,"UserCV27");
            return FAILURE;
        }

        channel_combine_mode = (int)exist(opuser27);
    }
    else
    {
        piuset &= ~use27;
        cvmod( opuser27, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 27", 0, "" );
        cvoverride(opuser27, _opuser27.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
        channel_combine_mode = PSD_OFF;
    } 


    /* MRIge45634 - opuser15 must be 0 or 1 */
    if( reverseLoopOrder < 0 ) {
        epic_error( use_ermes, "%s must be set to either 0 or 1.",
                    EM_PSD_CV_0_OR_1, EE_ARGS(1),
                    STRING_ARG, "Reverse loop order" );
        return FAILURE;
    }
    /* If VASTing, use VAST core sequences MS */
    use_ecg_scancore = (((PSD_ON == exist(opcgate)) || reverseLoopOrder) &&
                        (!cine3d_flag) && (vast_mode == PSD_OFF));
    if( use_ecg_scancore ) {
        /* Make sure the image acq. delay user CV is not available */
        piuset &= ~use4;
        cvmod( opuser4, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable  4", 0, "" );
        cvoverride(opuser4, _opuser4.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
    }

    /* Dynamic Plan  03/22/2005 YI */
    if( exist(opdynaplan) && !smartprep_flag && (exist(opfluorotrigger)==PSD_OFF) ) {
        piuset &= ~use4;
        cvmod( opuser4, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable  4", 0, "" );
        cvoverride(opuser4, _opuser4.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
    }
    /* YMSmr07640  Auto voice support on TRICKS. TRICKS does not use CV4. */
    if(tricks_flag) {
        piuset &= ~use4;
        cvmod( opuser4, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable  4", 0, "" );
        cvoverride(opuser4, _opuser4.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
    }

    /* turn off elliptical centric/reverse elliptical centric when
       sat on and ftmra off */
    if (existcv(opsat) && exist(opsat)==PSD_ON && ftmra_flag==PSD_OFF) {
        piuset &= ~use11 & ~use12;
    }

    /* Auto Voice  04/12/2005 YI    Notice scan PSD does not use opuser4. */
    if(!(piuset & use4)) {
        setexist(opinittrigdelay,PSD_OFF);
    }

    /* Turn ON User CV page - MRIge80453  */
    pititle = (piuset != 0);

    if (!existcv(opautote)) setexist(opte, PSD_OFF);

    if (exist(use_myscan)==1) { 
        myscan3d();
    }

    /* Always force obloptimize in cveval. Needed for correct calculation
       of db/dt optimized ramp times  - RJF./ZY */
    opnewgeo = 1;

    if ( (exist(opfluorotrigger ) == PSD_ON) || ftmra_flag || maskv_ftmra_flag )  {
        plane_type = PSD_OBL;
    } else {
        plane_type = opphysplane;
    }

    if (obloptimize(&loggrd, &phygrd, scan_info,
                    exist(opslquant)*exist(opvquant), 
                    plane_type, exist(opcoax), 
                    obl_method, obl_debug, 
                    &opnewgeo, cfsrmode)==FAILURE)  {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "obloptimize");
        return FAILURE; 
    }
    myhw.xrt = (loggrd.opt.xrt);                                              
    myhw.yrt = (loggrd.opt.yrt);                                              
    myhw.zrt = (loggrd.opt.zrt);                                              
    myhw.xft = (loggrd.opt.xft);                                              
    myhw.yft = (loggrd.opt.yft);                                              
    myhw.zft = (loggrd.opt.zft);      

    /* reinit the Sat pulses and prescan vars in case loggrd structure changed*/

    if (SpSatInit(vrgsat) == FAILURE) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "SpSatInit");
        return FAILURE;
    }

    /* Initialize chemSatPulse to type of chemsat pulse */
    /* Currently using a 8ms maximum phase pulse */
    ChemSatPulse = CSMIN8_PULSE;

    if( (PSD_ON == specir_flag) && (!aspir_flag) ) {
        ChemSatPulse = CSMIN_INV16_PULSE;
    } 

    /* SVBranch, HCSDM00094105, HCSDM00118536, change elava active method from type-in PSD to CV control. opuser0 is reused to control elava */
    if ((lava_flag) && ((PSD_ON == specir_flag) && (!aspir_flag)) && (elava_flag))
    {
        piuset |= use0;
        cvmod( opuser0, 0, 1, 0, "Image Uniformity Optimization 0:OFF, 1:ON", 0, "" );
        if(PSD_ON == exist(opuser0))
        {
            ChemSatPulse = CSM_PULSE;
        }
    } 

@inline ChemSatSpecIR.e ChemSatInit    /* latha@mr for MRige41369 */
    
    if ( intslab_flag == PSD_ON ) {
	/* Override to no PRESS mode*/
	presscfh_override = PRESSCFH_NONE;
    } else {
	/* 0 means no override. Use the settings from Prescan.e */
	presscfh_override = 0;
    }

    if ( exist(opvibrant) && (PSD_OFF == exist(opmedal)) && (B0_30000 == (int)cffield) ) {
        cfh_steam_flag = PSD_ON;
    }
    else {
        cfh_steam_flag = PSD_OFF;
    }
 
@inline Prescan.e PScvinit

    /* if sr17 mode, increase the dutycycle limit by 20%
       in order to be compatible with 5.4 and to get
       min TR values equivalent to 5.4 */
    if (psd_getgradmode() == PSD_SR17) { 
        dutycycle_scale = 1.2;
    }  else {
        dutycycle_scale = 1.0;
    }  

    if ( (exist(opmask)==PSD_ON) || (exist(opvenous)==PSD_ON) ) {
       cvoverride(opmph,PSD_OFF,PSD_FIX_ON, PSD_EXIST_ON);
    }

    /* added backward compatibility - latha@mr */
    if( UnLocked ) {
        mph_flag = (exist(opmph)==PSD_ON ? PSD_ON : PSD_OFF); 
    } else {
        mph_flag = PSD_OFF;
    }

    if ( (exist(opautote) == PSD_MINTEFULL) 
         || (exist(opautote) == PSD_MINTE)
         || (exist(opautote) == PSD_FWINPHS)
         || (exist(opautote) == PSD_FWOUTPHS) ) {
        setexist(opte,PSD_OFF);
        _opte.fixedflag = 0;
    }

    if ( (!UnLocked) ||
            ((value_system_flag == VALUE_SYSTEM_HDE) && lava_flag) ||
            (PSD_ON == exist(opmedal)) || (PSD_ON == exist(opdisco)) ||
            brava_flag || vibrant_flag ||
            (PSD_ON == exist(opmsde)) || msde_flag ||
            ideal_flag || (idealiq_flag && ((PSD_OFF == exist(opresearch)) || (strncmp("idealiq_mslab",psd_name,13)))) ||
            (existcv(opcgate) && (PSD_ON == exist(opcgate)) && (!heart3d_flag) && (!cine3d_flag)) )
    {
        avmaxvquant = 1;
    }
    else
    {
        avmaxvquant = MAXVQUANT;
    }

    /* Use pislqval for number of locations per slab */
    pislqnub = 31;
    pislqval2 = 16;
    pislqval3 = 32;
    pislqval4 = 64;
    pislqval5 = 128;

    pidefslq = 32;  /* default no. of slice/slab to 16 */

    if(idealiq_flag)
    {
        pislqval2 = 16;
        pislqval3 = 24;
        pislqval4 = 32;
        pislqval5 = 40;

        pidefslq = 24;  /* default no. of slice/slab to 24 */
    }

    pipctovl = 25;  /* default to 25 percent overlap */
    pidefovl = 0;
    opovl = 0;

    /* Initialize kiss-off slices */
    if (vast_mode || merge_flag) {
        if ( heart3d_flag ) {
             opslblank = ((turbo_flag>1)? 3:2);
        } else {
             opslblank = 1;
        }
    } else if (osfp_flag) {
        opslblank = (int) (exist(opsllocs)*0.225);
        if (opslblank < 4) opslblank = 4;
    } else if (quickstep_flag || (opasset == 3)) {
        opslblank = 0;
    } else {
        /* 2 kiss-off slices */ 
        opslblank = 2;
    }

    /* YMSmr07288 07/17/2005 YI */
    if(value_system_flag && ssfp_flag){
        opslblank = IMax(2, 2, (int)((float)(exist(opslquant))/8.0 + 0.5));
    }

    if(pcfiesta_flag)
    {
        opslblank = (int)exist(opuser16);
    }
    
    if (ns3d_flag) opslblank = 0;

    pislblank = opslblank;
    rhslblank = opslblank; 

    if (exist(opnopwrap) == PSD_ON) {
        nop = 2.0;
    } else { 
        nop = 1.0;
    }

    if ((B0_30000 == (int)cffield) && brava_flag && arc_flag && !aspir_override) 
    {
        /* Axial VIBRANT+ARC enables VIBRANT-XV */
        cvoverride(vibrantxv_flag, PSD_ON, PSD_FIX_OFF, PSD_EXIST_ON);
    }
    else
    {
        cvoverride(vibrantxv_flag, PSD_OFF, PSD_FIX_OFF, PSD_EXIST_ON);
    }

    if (arc_flag)
    { 
        int ctrl_calparams_flag = (arc_research_flag || medal_flag );
        float fullPhase = (float)eg_phaseres * exist(opphasefov) * nop;
        float fullSlice = (float)IMax(2, opsllocs + 2*opslblank, opslquant);
        CAL_PARAM calMinRegion;
        float arcPhLimit, arcSlLimit;  /* coil acceleration limits */
        
        if (!arc_research_flag &&
            (((rhdab0e - rhdab0s + 1) <= 4) && (arc_ph_maxstride > 1) && (arc_sl_maxstride > 1)))
        {
            /* Limit 4 or fewer channel coils to phase acceleration
               Override slice acceleration capabilities sent by scan */ 
            avmaxaccel_sl_stride = 1.0;
            arc_sl_maxstride =  avmaxaccel_sl_stride;
            cvoverride(opaccel_sl_stride, avmaxaccel_sl_stride, PSD_FIX_ON, PSD_EXIST_ON);
            piaccel_slnub = 0;
        }

        if ((osfp_flag || pcfiesta_flag) && arc_flag && (cfaccel_sl_maxstride > 1)  && 
            (cfaccel_sl_maxstride <= 2) &&  (cfaccel_ph_maxstride == 1) )
        {
            /* MRIhc47151: Switch COSMIC and FIESTA-C to phase acceleration when only 
               slice accel capability in Axial or Oblique Axial plane.
               This is needed to have ARC in Axial c-spine: slice coverage is short for PI */

            avmaxaccel_ph_stride = FMin(2, 2.0, avmaxaccel_sl_stride); 
            arc_ph_maxstride = avmaxaccel_ph_stride;
            accel_ph_defstride =  arc_ph_maxstride;
            piaccel_phnub = (arc_ph_maxstride >= 1.99) ? 6 : 4;
            piaccel_phval2 = 1.0;
            piaccel_phval3 = 1.25;
            piaccel_phval4 = 1.50;
            piaccel_phval5 = 1.75;
            piaccel_phval6 =  arc_ph_maxstride;
            piaccel_ph_step =0.25;

            avmaxaccel_sl_stride = 1.0;
            arc_sl_maxstride =  avmaxaccel_sl_stride;
            arc_sl_stride = 1.0; 
            piaccel_sl_stride = 1.0;
            piaccel_slnub = 0;
        }
   
        arcPhLimit = (arc_ph_intaccel) ?  floor(arc_ph_maxstride) : arc_ph_maxstride;
        arcSlLimit = (arc_sl_intaccel) ?  floor(arc_sl_maxstride) : arc_sl_maxstride;

        if (CROSS_CAL == cal_shape)
        {
            if (1.0 == arcSlLimit)
            {   
                arc_sl_mincalwidth = (int)fullSlice;
                arc_ph_mincalwidth = (arcPhLimit >= 3.0) ? 28: 24;
            }
            if (1.0 == arcPhLimit)
            {
                arc_ph_mincalwidth = (int)fullPhase;
                arc_sl_mincalwidth = (arcSlLimit >= 3.0) ? 28: 24;
            }
        }

        setArcCalParams(&calMinRegion, &cal_shape, &arc_ph_mincalwidth, &arc_sl_mincalwidth,
                        &arc_ph_calwidth, &arc_sl_calwidth,
                        &arc_ph_callower, &arc_ph_calupper, 
                        &arc_sl_callower, &arc_sl_calupper,
                        arcPhLimit, arcSlLimit, (int)floor(opuser9), 
                        (int)floor(opuser10), (int)floor(opuser15), 
                        ctrl_calparams_flag, (int)fullPhase, (int)fullSlice,exist(opresearch)); 
    }

    /* Number of scan locations menu */
    /* opslquant = locval + rhslblank */
    if( PSD_ON == vast_mode ) { 
        pilocnub = 4;
        pilocval2 = 8;
        pilocval3 = 10;
        pilocval4 = 12;
        pilocval5 = 16;
        if (ifir_flag)
        {
            pilocnub = 4;
            pilocval2 = 24;
            pilocval3 = 32;
            pilocval4 = 48;
            pilocval5 = 64;
        }
    } else if (osfp_flag || merge_flag) {
        pilocnub = 4;
        pilocval2 = 30;
        pilocval3 = 32;
        pilocval4 = 36;
        pilocval5 = 40;
    } else if (cal3d_flag) {
        pilocnub = 1;
        pilocval2 = 32;
    } else {
        pilocnub = 4;
        pilocval2 = 12;
        pilocval3 = 28;
        pilocval4 = 60;
        pilocval5 = 124;
    }

    /* Initialize min/max number of slices */
    if( (PSD_ON == exist(opcgate)) && (PSD_ON == navgate_flag) ) { 
        min_slquant = NAV_MIN_SLICES;
    } else { 
        /* MRIge81889 - Slice ASSET - set min number of locs/slab based on opslthick and assetsl_min_opvthick */ 
        if(assetsl_flag == PSD_ON) {
            min_slquant = 4 * (int)ceil( (double)(assetsl_min_opvthick / (4 * exist(opslthick))) );
        } else if (ss_rf1) {
            min_slquant = 2 * (int)ceil( (double)(spsp_min_opvthick / (2 * exist(opslthick))) );
        } else {
            min_slquant = MINSLQUANT3D;
        }
    }
    if( pcfiesta_flag && (min_slquant < (MINSLQUANT3D+2*(opslblank-2))) )
    {
        min_slquant = MINSLQUANT3D + 2*(opslblank-2);
    }
    /* MRIge83165 : corrected bounds for slquant for TRICKS -Venkat */ 
    if( !UnLocked ||
        (existcv(opcgate) && (PSD_ON == exist(opcgate)) && (!heart3d_flag)) ||
        (tricks_flag == PSD_ON) ) {
        avminslquant = min_slquant - DISCARDSLICE;
    } else {
        avminslquant = min_slquant;
    }

    if (arc_flag && (arc_sl_stride > 1.0)) {
        min_slquant = IMax(2, arc_sl_mincalwidth, avminslquant);
        avminslquant = min_slquant;
    } else if (cine3d_flag)
    {
        min_slquant =  IMax(2, cine3d_minslquant, avminslquant);
        avminslquant = min_slquant;
    }

    /* Initialize opslquant only when it does not exist, PH 8/13/96 */
    if( !existcv(opslquant) ) {
        cvunlock(opslquant);
        opslquant = _opslquant.defval;
    } 
    /* added backward compatibility - latha@mr */
    if( !UnLocked ) {
        if( existcv(opslquant) && (_opslquant.fixedflag == 0) &&
            (exist(opslquant) < min_slquant) ) {
            opslquant = min_slquant;
        }
    }
    cvdef(opvthick,exist(opslquant)*exist(opslthick));

    if (!flextr_flag) {
       setexist(optr,PSD_OFF);
       _optr.fixedflag = 0;
    }

    /* **************************************************************
       RF1  parameters - Minimum Phase RF1 for PS2 and SCAN
       ************************************************************* */

    gscale_rf1 = 1.0;
    flip_rf1 = exist(opflip);
    /* MRIge75871 */
    cvoverride(opvthick, exist(opslthick)*exist(opslquant), PSD_FIX_ON, PSD_EXIST_ON);

    /* Set the encoded slab thickness and number of encodes.  If number
       of encodes is odd, it is rounded up to the next even.  */ 
    ethick = exist(opslthick) * exist(opslquant) * assetsl_factor;
    equant = 2 * (int) ( (exist(opslquant) * assetsl_factor * 0.5 )  + 0.5 );
    pfkz_total_unaccel = IMin(2, pfkz_total_unaccel, equant);
    arc_sl_callower = IMax(3, 0, (INT)floorf((FLOAT)((equant - 1) - arc_sl_calwidth) / 2.0 + 0.5),arc_sl_callower);
    arc_sl_calupper = IMin(3, equant - 1, arc_sl_callower + arc_sl_calwidth - 1,arc_sl_calupper);  

    if( assetsl_factor != 0.5 ) {
        assetsl_factor = FMin(2, 1.0, (float)equant / (float)exist(opslquant));
    }

    /* MRIhc16225: Introducing round_factor for rounding rhnframes & endview() call argument
                   to nearest even number */
    phaseres = (int)(ceil( eg_phaseres * yfov_aspect * asset_factor / 2.0) * 2.0);
    
    if (arc_flag)
    {
        zy_views = phaseres;
        zy_slices = equant;
    }
    else
    {
        zy_views = rhnframes + rhhnover;
        zy_slices = pfkz_total;
    }

    if (arc_flag) 
    {
        arc_ph_callower = IMax(2, 0, (INT)floorf((FLOAT)((phaseres - 1) - arc_ph_calwidth) / 2.0 + 0.5));
        if (0.5 == fn)
        {
            arc_ph_calupper = IMin(2, phaseres - 1, unaccel_rhnframes + rhhnover - 1);
            arc_ph_calwidth = arc_ph_calupper - arc_ph_callower + 1;
        }
        else
        {
            arc_ph_calupper = IMin(2, phaseres - 1, arc_ph_callower + arc_ph_calwidth - 1);
        }

        if ( arc_ph_stride > 1.0) 
        {
            accel_phaseres = calcAccelEncodeNum(arc_ph_callower, arc_ph_calupper,
                                                phaseres, arc_ph_stride);

            cvoverride(arc_ph_netaccel, (float) phaseres / (float) accel_phaseres, 
                       PSD_FIX_OFF, PSD_EXIST_ON);
        }
        else
        {
            accel_phaseres = phaseres;
            arc_ph_netaccel = 1.0;
            if (CROSS_CAL == cal_shape)
            {
                arc_ph_callower = 0;
                arc_ph_calupper = phaseres - 1;
                arc_ph_calwidth = phaseres;
            } 
        }

        /* Pack cal region parameters into a structure to pass them into a function easily */
        calRegion.shape = cal_shape;
        calRegion.phaseCutoffUpper = arc_ph_calupper;
        calRegion.phaseCutoffLower = arc_ph_callower;
        calRegion.sliceCutoffUpper = arc_sl_calupper;
        calRegion.sliceCutoffLower = arc_sl_callower;
        calRegion.phaseOrigin = (float)(phaseres-1)/2.0;
        calRegion.phaseRadius = (float)(calRegion.phaseOrigin - arc_ph_callower + 1);
        calRegion.sliceOrigin = (float)(equant-1)/2.0;
        calRegion.sliceRadius = (float)(calRegion.sliceOrigin - arc_sl_callower + 1);
        
        if (arc_sl_stride > 1.0)
        {
            arc_equant = calcAccelEncodeNum(arc_sl_callower, arc_sl_calupper,
                                            equant, arc_sl_stride);

            cvoverride(arc_sl_netaccel, (float) equant / (float) arc_equant, 
                       PSD_FIX_OFF, PSD_EXIST_ON);
        }
        else
        {
            arc_equant = equant;
            arc_sl_netaccel = 1.0;
            if (CROSS_CAL == cal_shape)
            {
                arc_sl_callower = 0;
                arc_sl_calupper = pfkz_total_unaccel - 1;
                arc_sl_calwidth = pfkz_total_unaccel;
            }
        }

        if (CROSS_CAL == cal_shape)
        {  
            piaccel_total_stride = arc_ph_netaccel * arc_sl_netaccel;
        }
        else 
        {
            float fullSize = (float)(phaseres * equant);
            float accelSize = (float)sampledPointsNoMask; 
            piaccel_total_stride = fullSize/accelSize;       
        }  

        rhassetsl_R = 1.0 / arc_sl_stride;
        if( (arc_sl_stride > 1.0) || (arc_ph_stride > 1.0) ) 
        {
            rhasset = ( (15 == arc_pack_bam) ? ACCEL_DVCARC : autocal_mode );
        }
        else
        {
            rhasset = 0; /* Disable parallel imaging recon for R=1 */
        }

        /* Set default BAM model based on parallel imaging recon */
        /* Full sort/nex mode */
            arc_pack_bam = 0;

       /* Compress BAM in phase and pack in slice HDx default: Not used with ARC as of 20.1 */
       /* arc_pack_bam = BAM_PACK_Y | BAM_PACK_Z | BAM_REDUCE_Y; */
    }
    else
    {
        arc_equant = equant;
        arc_sl_netaccel = 1.0; 
        accel_phaseres = phaseres;
        arc_ph_netaccel = 1.0;
        piaccel_total_stride = 1.0;
        reset_accel_variables();
    }
     
    if (ss_rf1)  
    {

        if ( B0_30000 == (int)cffield ) {
            switch (turbo_flag) {
                default:
                case 0:
                    cvoverride(ss_override,30104235,PSD_FIX_OFF, PSD_EXIST_ON);
                    break;
                case 1:
                    cvoverride(ss_override,30104234,PSD_FIX_OFF, PSD_EXIST_ON);
                    break;
                case 2:
                    cvoverride(ss_override,30104233,PSD_FIX_OFF, PSD_EXIST_ON);
                    break;
            }
            spsp_min_opvthick = 50.0;
        }
        else if (B0_15000 == (int)cffield) {
            switch (turbo_flag) {
                default:
                case 0:
                    cvoverride(ss_override,15048235,PSD_FIX_OFF, PSD_EXIST_ON);
                    break;
                case 1:
                    cvoverride(ss_override,15048234,PSD_FIX_OFF, PSD_EXIST_ON);
                    break;
                case 2:
                    cvoverride(ss_override,15048233,PSD_FIX_OFF, PSD_EXIST_ON);
                    break;
            }
            spsp_min_opvthick = 50.0;
        }
        else
        {
            cvoverride(ss_override,0,PSD_FIX_OFF, PSD_EXIST_ON);
        }

        if (ssInit() == FAILURE)
            return FAILURE;


        if (flow_comp_type == TYPFC) {
            zgmn_type = CALC_GMN1;
        } else {
            zgmn_type = NO_GMN;
        }

        if (ssEval1() == FAILURE)
            return FAILURE;

        if (ssEval2() == FAILURE)
            return FAILURE;

        iso_delay = hrf1b;
        t_exb = hrf1b;

    } 
    else 
    {

        rfpulse[RF1_SLOT].extgradfile = PSD_OFF;

        if( ssfp_flag == PSD_ON ) {
            /* ATV: added linear phase excitation r.f. for FIESTA */
            switch (rf1_pulse_type) {
                case RF_3D_600US_01P_01S_10KHZ:
                    pw_rf1 = 600us;                  /* width of RF1 */
                    res_rf1 = 300;                   /* resolution of RF1 */
                    slab_fact = 1.04;
                    rfpulse[RF1_SLOT].abswidth = SAR_ABS_RF3D600LIN;
                    rfpulse[RF1_SLOT].area     = SAR_AREA_RF3D600LIN;
                    rfpulse[RF1_SLOT].effwidth = SAR_EFFW_RF3D600LIN;
                    rfpulse[RF1_SLOT].dtycyc   = SAR_DTYCYC_RF3D600LIN;
                    rfpulse[RF1_SLOT].maxpw    = SAR_MAXPW_RF3D600LIN;
                    rfpulse[RF1_SLOT].max_b1   = SAR_MAXB1_RF3D600LIN;
                    rfpulse[RF1_SLOT].max_int_b1_sq = SAR_MAX_INT_B1_SQ_RF3D600LIN;
                    rfpulse[RF1_SLOT].max_rms_b1 = SAR_MAX_RMS_B1_RF3D600LIN;
                    rfpulse[RF1_SLOT].nom_pw   = 600.0;
                    rfpulse[RF1_SLOT].nom_bw   = NOM_BW_RF3D600LIN;
                    rfpulse[RF1_SLOT].nom_fa   = 45.0;
                    rfpulse[RF1_SLOT].isodelay = ISO_DELAY_RF3D600LIN;
                    break;

                case RF_TBW8_001_001_200LP:
                    pw_rf1 = 800us;
                    res_rf1 = 200;
                    if (osfp_flag)
                        slab_fact = 1.25;
                    else
                        slab_fact = 1.05;
                    rfpulse[RF1_SLOT].abswidth = 0.1822;
                    rfpulse[RF1_SLOT].area     = 0.1263;
                    rfpulse[RF1_SLOT].effwidth = 0.1146;
                    rfpulse[RF1_SLOT].dtycyc   = 1.0;
                    rfpulse[RF1_SLOT].maxpw    = 1.0;
                    rfpulse[RF1_SLOT].max_b1   = 0.290517;
                    rfpulse[RF1_SLOT].max_int_b1_sq = 0.00774077;
                    rfpulse[RF1_SLOT].max_rms_b1 = 0.0983665;
                    rfpulse[RF1_SLOT].nom_pw   = 800us;
                    rfpulse[RF1_SLOT].nom_bw   = 10000.0;
                    rfpulse[RF1_SLOT].nom_fa   = 45;
                    rfpulse[RF1_SLOT].isodelay = 400us;
                    break;

                case RF_TBW8_001_001_200:
                    pw_rf1 = 800us;
                    res_rf1 = 200;
                    if (osfp_flag)
                        slab_fact = 1.25;
                    else
                        slab_fact = 1.05;
                    rfpulse[RF1_SLOT].abswidth = 0.2378;
                    rfpulse[RF1_SLOT].area     = 0.1395;
                    rfpulse[RF1_SLOT].effwidth = 0.1400;
                    rfpulse[RF1_SLOT].dtycyc   = 1.0;
                    rfpulse[RF1_SLOT].maxpw    = 1.0;
                    rfpulse[RF1_SLOT].max_b1   = 0.263001;
                    rfpulse[RF1_SLOT].max_int_b1_sq = 0.00774844;
                    rfpulse[RF1_SLOT].max_rms_b1 = 0.0984152;
                    rfpulse[RF1_SLOT].nom_pw   = 800us;
                    rfpulse[RF1_SLOT].nom_bw   = 10000.0;
                    rfpulse[RF1_SLOT].nom_fa   = 45;
                    rfpulse[RF1_SLOT].isodelay = 160us;
                    break;

                case RF_HARD24:

                    pw_rf1 = 24us;                  /* width of RF1 */
                    res_rf1 = 12;                   /* resolution of RF1 */
                    slab_fact = 1.0;
                    rfpulse[RF1_SLOT].abswidth = 0.6445;
                    rfpulse[RF1_SLOT].area     = 0.6445;
                    rfpulse[RF1_SLOT].effwidth = 0.6001;
                    rfpulse[RF1_SLOT].dtycyc   = 1.00;
                    rfpulse[RF1_SLOT].maxpw    = 1.00;
                    rfpulse[RF1_SLOT].max_b1   = 0.210914;
                    rfpulse[RF1_SLOT].max_int_b1_sq = 0.000640634;
                    rfpulse[RF1_SLOT].max_rms_b1 = 0.16338;
                    rfpulse[RF1_SLOT].nom_pw   = 24.0;
                    rfpulse[RF1_SLOT].nom_bw   = 50000.0;
                    rfpulse[RF1_SLOT].nom_fa   = 1.0;
                    rfpulse[RF1_SLOT].isodelay = 12us;

                    if (ns3d_flag)
                    {
                        rfpulse[RF1_SLOT].nom_bw   = 100.0;
                        rfpulse[RF1_SLOT].isodelay = 0;
                    }

                    break;

                case RF_E3DFGRE:
                    pw_rf1 = 1600us;                  /* width of RF1 */
                    res_rf1 = 800;                    /* resolution of RF1 */
                    slab_fact = 1.05;
                    rfpulse[RF1_SLOT].abswidth = SAR_ABS_RF3D16MIN;
                    rfpulse[RF1_SLOT].area     = SAR_AREA_RF3D16MIN;
                    rfpulse[RF1_SLOT].effwidth = SAR_EFFW_RF3D16MIN;
                    rfpulse[RF1_SLOT].dtycyc   = SAR_DTYCYC_RF3D16MIN;
                    rfpulse[RF1_SLOT].maxpw    = SAR_MAXPW_RF3D16MIN;
                    rfpulse[RF1_SLOT].max_b1   = SAR_MAXB1_RF3D16MIN;
                    rfpulse[RF1_SLOT].max_int_b1_sq = SAR_MAX_INT_B1_SQ_RF3D16MIN;
                    rfpulse[RF1_SLOT].max_rms_b1 = SAR_MAX_RMS_B1_RF3D16MIN;
                    rfpulse[RF1_SLOT].nom_pw   = 1600.0;
                    rfpulse[RF1_SLOT].nom_bw   = NOM_BW_RF3D16MIN;
                    rfpulse[RF1_SLOT].nom_fa   = 45.0;
                    rfpulse[RF1_SLOT].isodelay = ISO_DELAY_RF3D16MIN;
                    break;

                case RF_TB3_01_001_250: 
                default:
                    pw_rf1 = 500us;                  /* width of RF1 */
                    res_rf1 = 250;                    /* resolution of RF1 */
                    slab_fact = 1.05;
                    rfpulse[RF1_SLOT].abswidth = 0.4121;
                    rfpulse[RF1_SLOT].area     = 0.4112;
                    rfpulse[RF1_SLOT].effwidth = 0.3;
                    rfpulse[RF1_SLOT].dtycyc   = 1.0;
                    rfpulse[RF1_SLOT].maxpw    = 1.0;
                    rfpulse[RF1_SLOT].max_b1   = 0.142811;
                    rfpulse[RF1_SLOT].max_int_b1_sq = 0.00305924;
                    rfpulse[RF1_SLOT].max_rms_b1 = 0.0782207;
                    rfpulse[RF1_SLOT].nom_pw   = 500.0;
                    rfpulse[RF1_SLOT].nom_bw   = 6000;
                    rfpulse[RF1_SLOT].nom_fa   = 45.0;
                    rfpulse[RF1_SLOT].isodelay = 250us;
                    break;
            } /* end switch */ 
        } else {
            /* ATV: not FIESTA i.e. GRE/SPGR */
            switch (rf1_pulse_type) {
                case RF_3DFGRE:                      /* backward compatibility - latha@mr */
                    {
                        cyc_rf1 = 3.0;                    /* number of sinc cycles for RF1 */
                        pw_rf1 = 3.2ms;                   /* width of RF1 */
                        res_rf1 = 320;                    /* resolution of RF1 */
                        slab_fact = 1.0;
                        rfpulse[RF1_SLOT].abswidth = SAR_ABS_ALPHA1;
                        rfpulse[RF1_SLOT].area     = SAR_AALPHA1;
                        rfpulse[RF1_SLOT].effwidth = SAR_PALPHA1;
                        rfpulse[RF1_SLOT].dtycyc   = SAR_DTYCYC_ALPHA1;
                        rfpulse[RF1_SLOT].maxpw    = SAR_MAXPW_ALPHA1;
                        rfpulse[RF1_SLOT].max_rms_b1 = SAR_MAX_RMS_B1_ALPHA1;
                        rfpulse[RF1_SLOT].nom_pw   = 3200us;
                        rfpulse[RF1_SLOT].nom_fa   = 30.0;
                        /* JP Changed max_b1 and b1_sq based on rfstat output for 30
                           degree flip and 3200 ms duration */
                        if (product_rf) {
                            rfpulse[RF1_SLOT].max_b1 = SAR_MAXB1_ALPHA1;
                            rfpulse[RF1_SLOT].max_int_b1_sq = SAR_MAX_INT_B1_SQ_ALPHA1;
                            rfpulse[RF1_SLOT].nom_bw = 4*cyc_rf1/((FLOAT)pw_rf1/(FLOAT)1.0s);/* pw_rf1 =3.2 ms */
                            rfpulse[RF1_SLOT].isodelay= RUP_GRD((int)(iso_delay_frac* pw_rf1)); /* pw_rf1 =3.2 ms */
                        } else {
                            rfpulse[RF1_SLOT].max_b1   = SAR_MAXB1_NEWALPHA1;
                            rfpulse[RF1_SLOT].max_int_b1_sq = SAR_MAX_INT_B1_SQ_NEWALPHA1;
                            rfpulse[RF1_SLOT].nom_bw   =  NOM_BW_ALPHA1;
                            rfpulse[RF1_SLOT].isodelay = ISO_DELAY_ALPHA1;
                        }
                    }
                    break;

                case RF_E3DFGRE:
                    pw_rf1 = 1600us;                  /* width of RF1 */
                    res_rf1 = 800;                    /* resolution of RF1 */
                    slab_fact = 1.05;
                    rfpulse[RF1_SLOT].abswidth = SAR_ABS_RF3D16MIN;
                    rfpulse[RF1_SLOT].area     = SAR_AREA_RF3D16MIN;
                    rfpulse[RF1_SLOT].effwidth = SAR_EFFW_RF3D16MIN;
                    rfpulse[RF1_SLOT].dtycyc   = SAR_DTYCYC_RF3D16MIN;
                    rfpulse[RF1_SLOT].maxpw    = SAR_MAXPW_RF3D16MIN;
                    rfpulse[RF1_SLOT].max_b1   = SAR_MAXB1_RF3D16MIN;
                    rfpulse[RF1_SLOT].max_int_b1_sq = SAR_MAX_INT_B1_SQ_RF3D16MIN;
                    rfpulse[RF1_SLOT].max_rms_b1 = SAR_MAX_RMS_B1_RF3D16MIN;
                    rfpulse[RF1_SLOT].nom_pw   = 1600.0;
                    rfpulse[RF1_SLOT].nom_bw   = NOM_BW_RF3D16MIN;
                    rfpulse[RF1_SLOT].nom_fa   = 45.0;
                    rfpulse[RF1_SLOT].isodelay = ISO_DELAY_RF3D16MIN;
                    break;

                case RF_TURBO:
                    pw_rf1 = 800us;                  /* width of RF1 */
                    res_rf1 = 400;                   /* resolution of RF1 */
                    slab_fact = 1.0;
                    rfpulse[RF1_SLOT].abswidth = SAR_ABS_RF3D8MIN;
                    rfpulse[RF1_SLOT].area     = SAR_AREA_RF3D8MIN;
                    rfpulse[RF1_SLOT].effwidth = SAR_EFFW_RF3D8MIN;
                    rfpulse[RF1_SLOT].dtycyc   = SAR_DTYCYC_RF3D8MIN;
                    rfpulse[RF1_SLOT].maxpw    = SAR_MAXPW_RF3D8MIN;
                    rfpulse[RF1_SLOT].max_b1   = SAR_MAXB1_RF3D8MIN;
                    rfpulse[RF1_SLOT].max_int_b1_sq = SAR_MAX_INT_B1_SQ_RF3D8MIN;
                    rfpulse[RF1_SLOT].max_rms_b1 = SAR_MAX_RMS_B1_RF3D8MIN;
                    rfpulse[RF1_SLOT].nom_pw   = 800.0;
                    rfpulse[RF1_SLOT].nom_bw   = NOM_BW_RF3D8MIN;
                    rfpulse[RF1_SLOT].nom_fa   = 30.0;
                    rfpulse[RF1_SLOT].isodelay = ISO_DELAY_RF3D8MIN;
                    break;

                case RF_TBW3_005_01:
                    pw_rf1 = 300us;                  /* width of RF1 */
                    res_rf1 = 150;                   /* resolution of RF1 */
                    slab_fact = 1.05;
                    rfpulse[RF1_SLOT].abswidth = 0.4196;
                    rfpulse[RF1_SLOT].area     = 0.3318;
                    rfpulse[RF1_SLOT].effwidth = 0.2894;
                    rfpulse[RF1_SLOT].dtycyc   = 1.00;
                    rfpulse[RF1_SLOT].maxpw    = 1.00;
                    rfpulse[RF1_SLOT].max_b1   = 0.117962;
                    rfpulse[RF1_SLOT].max_int_b1_sq = 0.00120791;
                    rfpulse[RF1_SLOT].max_rms_b1 = 0.0634538;
                    rfpulse[RF1_SLOT].nom_pw   = 300.0;
                    rfpulse[RF1_SLOT].nom_bw   = 10000.0;
                    rfpulse[RF1_SLOT].nom_fa   = 18.0;
                    rfpulse[RF1_SLOT].isodelay = 102us;
                    break;

                case RF_TBW3_005_01_48:
                    pw_rf1 = 96us;                  /* width of RF1 */
                    res_rf1 = 48;                   /* resolution of RF1 */
                    slab_fact = 1.0;
                    rfpulse[RF1_SLOT].abswidth = 0.4147;
                    rfpulse[RF1_SLOT].area     = 0.3276;
                    rfpulse[RF1_SLOT].effwidth = 0.2854;
                    rfpulse[RF1_SLOT].dtycyc   = 1.00;
                    rfpulse[RF1_SLOT].maxpw    = 1.00;
                    rfpulse[RF1_SLOT].max_b1   = 0.103738;
                    rfpulse[RF1_SLOT].max_int_b1_sq = 0.0002948;
                    rfpulse[RF1_SLOT].max_rms_b1 = 0.0554151;
                    rfpulse[RF1_SLOT].nom_pw   = 96.0;
                    rfpulse[RF1_SLOT].nom_bw   = 31250.0;
                    rfpulse[RF1_SLOT].nom_fa   = 5.0;
                    rfpulse[RF1_SLOT].isodelay = 30us;
                    break;

                case RF_TBW6:
                    pw_rf1 = 300us;                  /* width of RF1 */
                    res_rf1 = 150;                   /* resolution of RF1 */
                    slab_fact = 1.05;
                    rfpulse[RF1_SLOT].abswidth = 0.2880;
                    rfpulse[RF1_SLOT].area     = 0.1870;
                    rfpulse[RF1_SLOT].effwidth = 0.1784;
                    rfpulse[RF1_SLOT].dtycyc   = 1.00;
                    rfpulse[RF1_SLOT].maxpw    = 1.00;
                    rfpulse[RF1_SLOT].max_b1   = 0.174412;
                    rfpulse[RF1_SLOT].max_int_b1_sq = 0.00162796;
                    rfpulse[RF1_SLOT].max_rms_b1 = 0.0736649;
                    rfpulse[RF1_SLOT].nom_pw   = 300.0;
                    rfpulse[RF1_SLOT].nom_bw   = 20000.00;
                    rfpulse[RF1_SLOT].nom_fa   = 15.0;
                    rfpulse[RF1_SLOT].isodelay = 78us;
                    break;

                case RF_TBW8:
                    pw_rf1 = 300us;                  /* width of RF1 */
                    res_rf1 = 150;                   /* resolution of RF1 */
                    if (vibrant_flag) 
                        slab_fact = 1.0;
                    else
                        slab_fact = 1.05;
                    rfpulse[RF1_SLOT].abswidth = 0.2495;
                    rfpulse[RF1_SLOT].area     = 0.1473;
                    rfpulse[RF1_SLOT].effwidth = 0.1458;
                    rfpulse[RF1_SLOT].dtycyc   = 1.00;
                    rfpulse[RF1_SLOT].maxpw    = 1.00;
                    rfpulse[RF1_SLOT].max_b1   = 0.221475;
                    rfpulse[RF1_SLOT].max_int_b1_sq = 0.00214499;
                    rfpulse[RF1_SLOT].max_rms_b1 = 0.0845575;
                    rfpulse[RF1_SLOT].nom_pw   = 300.0;
                    rfpulse[RF1_SLOT].nom_bw   = 26666.67;
                    rfpulse[RF1_SLOT].nom_fa   = 15.0;
                    rfpulse[RF1_SLOT].isodelay = 62us;
                    break;

                case RF_HARD100:
                    pw_rf1 = 100us;                  /* width of RF1 */
                    res_rf1 = 50;                   /* resolution of RF1 */
                    slab_fact = 1.0;
                    rfpulse[RF1_SLOT].abswidth = 0.6865;
                    rfpulse[RF1_SLOT].area     = 0.6865;
                    rfpulse[RF1_SLOT].effwidth = 0.6374;
                    rfpulse[RF1_SLOT].dtycyc   = 1.00;
                    rfpulse[RF1_SLOT].maxpw    = 1.00;
                    rfpulse[RF1_SLOT].max_b1   = 0.142549;
                    rfpulse[RF1_SLOT].max_int_b1_sq = 0.00129516;
                    rfpulse[RF1_SLOT].max_rms_b1 = 0.113805;
                    rfpulse[RF1_SLOT].nom_pw   = 100.0;
                    rfpulse[RF1_SLOT].nom_bw   = 12000.0;
                    rfpulse[RF1_SLOT].nom_fa   = 15.0;
                    rfpulse[RF1_SLOT].isodelay = 50us;

                    if (ns3d_flag)
                    {
                        rfpulse[RF1_SLOT].nom_bw   = 100.0;
                        rfpulse[RF1_SLOT].isodelay = 0;
                    }

                    break;

                case RF_HARD24:

                    pw_rf1 = 24us;                  /* width of RF1 */
                    res_rf1 = 12;                   /* resolution of RF1 */
                    slab_fact = 1.0;
                    rfpulse[RF1_SLOT].abswidth = 0.6445;
                    rfpulse[RF1_SLOT].area     = 0.6445;
                    rfpulse[RF1_SLOT].effwidth = 0.6001;
                    rfpulse[RF1_SLOT].dtycyc   = 1.00;
                    rfpulse[RF1_SLOT].maxpw    = 1.00;
                    rfpulse[RF1_SLOT].max_b1   = 0.210914;
                    rfpulse[RF1_SLOT].max_int_b1_sq = 0.000640634;
                    rfpulse[RF1_SLOT].max_rms_b1 = 0.16338;
                    rfpulse[RF1_SLOT].nom_pw   = 24.0;
                    rfpulse[RF1_SLOT].nom_bw   = 50000.0;
                    rfpulse[RF1_SLOT].nom_fa   = 1.0;
                    rfpulse[RF1_SLOT].isodelay = 12us;

                    if (ns3d_flag)
                    {
                        rfpulse[RF1_SLOT].nom_bw   = 100.0;
                        rfpulse[RF1_SLOT].isodelay = 0;
                    }

                    break;

                case RF_TBW12:
                    pw_rf1 = 300us;                  /* width of RF1 */
                    res_rf1 = 150;                   /* resolution of RF1 */
                    slab_fact = 1.0;
                    rfpulse[RF1_SLOT].abswidth = 0.1898;
                    rfpulse[RF1_SLOT].area     = 0.0957;
                    rfpulse[RF1_SLOT].effwidth = 0.1027;
                    rfpulse[RF1_SLOT].dtycyc   = 1.00;
                    rfpulse[RF1_SLOT].maxpw    = 1.00;
                    rfpulse[RF1_SLOT].max_b1   = 0.340776;
                    rfpulse[RF1_SLOT].max_int_b1_sq = 0.00357702;
                    rfpulse[RF1_SLOT].max_rms_b1 = 0.109194;
                    rfpulse[RF1_SLOT].nom_pw   = 300.0;
                    rfpulse[RF1_SLOT].nom_bw   = 36800.0;
                    rfpulse[RF1_SLOT].nom_fa   = 15;
                    rfpulse[RF1_SLOT].isodelay = 42;
                    break;

                case RF_TBW24:
                    pw_rf1 = 400us;
                    res_rf1 = 200;
                    slab_fact = 1.0;
                    rfpulse[RF1_SLOT].abswidth = 0.1247;
                    rfpulse[RF1_SLOT].area     = 0.0502;
                    rfpulse[RF1_SLOT].effwidth = 0.0583;
                    rfpulse[RF1_SLOT].dtycyc   = 1.00;
                    rfpulse[RF1_SLOT].maxpw    = 1.00;
                    rfpulse[RF1_SLOT].max_b1   = 0.162557;
                    rfpulse[RF1_SLOT].max_int_b1_sq = 0.000616038;
                    rfpulse[RF1_SLOT].max_rms_b1 = 0.039244;
                    rfpulse[RF1_SLOT].nom_pw   = 400.0;
                    rfpulse[RF1_SLOT].nom_bw   = 60000;
                    rfpulse[RF1_SLOT].nom_fa   = 5.0;
                    rfpulse[RF1_SLOT].isodelay = 30;
                    break;
            }
        }

    }

    /* Half alpha half TR - MS */
    if( (ssfp_flag == PSD_ON) && (vast_mode == PSD_ON) ) {
        res_rf1htr = res_rf1;
        pw_rf1htr = pw_rf1;
        cyc_rf1htr = cyc_rf1;
    }

    /* Check to see if rf pw's need scaling for large patients */
    for ( entry = 0 ; entry < MAX_ENTRY_POINTS ; entry ++ ) {
        /* MRIge91684 */
@inline RFb1opt.e RFb1optscalerf
        if( 1 != rfb1opt_flag )
        {
            scalerfpulses( opweight, cfgcoiltype, RF_FREE, rfpulse, entry, rfpulseInfo );
        }
    }

@inline MSDE.e MSDE_RFDerate

    /* ensure pw_gzrf0 and pw_omega_ir0 equal pw_rf0 after stretching */
    pw_gzrf0     = pw_rf0;
    pw_omega_ir0 = pw_rf0;
    res_omega_ir0 = res_rf0;

    if (ifir_frir_flag)
    {
        pw_gzrffrir     = pw_rffrir;
        pw_omega_rffrir = pw_rffrir;
        res_omega_rffrir = res_rffrir;
    }

    /* Half alpha half TR: redo pw/res after scaling */
    if ( (ssfp_flag == PSD_ON) && (vast_mode == PSD_ON) ) {
        if (rfpulseInfo[RF1_SLOT].change==PSD_ON) {     
            res_rf1htr = res_rf1;
            pw_rf1htr = pw_rf1;
        }
    }


    /*
     * Call cveval1() to set SAR, gradient heating, power monitor
     * limits, and min TR.
     */

    /* Limit to SSSD for now. Need to update minseqseg.c to support other gradamp */
    if ((5550 == cfgradamp) && (PSD_ON == exist(opfluorotrigger)))
    {
        set_realtime_rotmat = PSD_ON;
        skip_rotmat_search = PSD_ON;
    }
    else
    {
        set_realtime_rotmat = PSD_OFF;
    }

    if( (status = cveval1()) != SUCCESS ) {
        /* HCSDM00360543 */
        if( (PSD_ON == gradOpt_flag) && (PSD_ON == force_gradOpt_loop_break) )
        {
            initialize_scale = 1;
            do_maxrbw_check_in_cveval = PSD_ON;
            if( (status = cveval1()) != SUCCESS )
            {
                do_maxrbw_check_in_cveval = PSD_OFF;
                return status;
            }
            do_maxrbw_check_in_cveval = PSD_OFF;
        }
        else
        {
            return status;
        }
    }

    if( PSD_ON == gradOpt_flag )
    {
        if(1 == apx_compatible)
        {
            initialize_gradOpt = 1;
            gradOpt_tor = FMax(2, gradOpt_tor, 0.02);
        }
        else
        {
            initialize_gradOpt = 0;
        }

        if( initialize_gradOpt && (FALSE == skip_minseqseg) )
        {
            initialize_scale = 1;
            gradOpt_scale = 1.0;

            if( (status = cveval1()) != SUCCESS )
            {
                return status;
            }
        }
        else
        {
            initialize_scale = 0;
        }
    }

    if (2 == rfb1opt_flag)
    {
        int   rfscale_flag       = PSD_OFF;
        whilecounter = 0;
        float rfavail_RRtime;
        float opt_deratingfactor = 1.0;
        float orig_rfscale       = 1.0;
        float limit_scale_seed   = 1.0;

        /* In Case of Scale is depend on the maximum limit */ 
        if ( (exist(opcgate) == PSD_ON) && (vast_mode == PSD_ON) )
        {
            rfscale_flag = 1;
            rfavail_RRtime  =  (60.0 / (FLOAT)(exist(ophrate))) * 1000000.0; 
            limit_scale_seed = (float)((max_pencodes + ssfp_flag
                                  * (enable_alpha + fiesta_gated_dda)) /  (float)rfavail_RRtime);
        }
        /* In case of Linear Scale */
        else if (osfp_flag)
        {
            rfscale_flag = 2;
            limit_scale_seed = 1.0;
        }
        else
        {
            rfscale_flag = 0;
            limit_scale_seed = 1.0;
        }

        do
        {    
            if (1 == rfscale_flag)
            {
                orig_rfscale = (float)IMax(2, max_seqsar, min_seqrfamp) / (float)bf_rfscale; 
            }
            else if (2 == rfscale_flag)
            {
                orig_rfscale = (float)osfp_weight;
            }
            else
            {
                orig_rfscale = 1.0;
            }

            if ( SUCCESS != rfsafetyopt( &opt_deratingfactor, rfscale_flag, &orig_rfscale, &limit_scale_seed,
                                        RF1_SLOT, rfpulse, rfpulseInfo) )
            {
                epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                           EE_ARGS(1),STRING_ARG,"rfsafetyopt");
                return FAILURE;                    
            }
        
            if ( (ssfp_flag == PSD_ON) && (vast_mode == PSD_ON) ) 
            {
                if (rfpulseInfo[RF1_SLOT].change==PSD_ON)
                {     
                    res_rf1htr = res_rf1;
                    pw_rf1htr = pw_rf1;
                }
            }

            bf_rfscale = 0;
            if ( (status = cveval1()) != SUCCESS )
            {
                /* HCSDM00360543 */
                if( (PSD_ON == gradOpt_flag) && (PSD_ON == force_gradOpt_loop_break) )
                {
                    initialize_scale = 1;
                    do_maxrbw_check_in_cveval = PSD_ON;
                    if( (status = cveval1()) != SUCCESS )
                    {
                        do_maxrbw_check_in_cveval = PSD_OFF;
                        return status;
                    }
                    do_maxrbw_check_in_cveval = PSD_OFF;
                }
                else
                {
                    return status;
                }
            }
            
            if (osfp_flag)
            {
                if ((opt_deratingfactor < 0.95) && (whilecounter < 2))     
                {
                    max_seqsar = max_seqsar_orig*post_osfp_weight;
                }
            }

            if (psddebugcode)
            {
FILE *fp;
#ifdef PSD_HW
    fp = fopen("/usr/g/service/log/rfsafetyopt_result.log", "a");
#else
    fp = fopen("rfsafetyopt_result.log", "a");
#endif
                fprintf(fp, "\n-------------------------------------\n");
                fprintf(fp, "whilecounter    =\t%d\n", whilecounter);
                fprintf(fp, "deratingfactor  =\t%f\n", opt_deratingfactor);
                fprintf(fp, "pw_rf1          =\t%d\n", pw_rf1);
                fprintf(fp, "pw_gzrf1a       =\t%d\n", pw_gzrf1a);
                fprintf(fp, "a_gzrf1         =\t%f\n", a_gzrf1);
                fprintf(fp, "tmin            =\t%d\n", tmin);
                fprintf(fp, "max_seqsar      =\t%d\n", max_seqsar);
                fprintf(fp, "min_rfavgpow    =\t%d\n", min_rfavgpow);
                fprintf(fp, "min_rfrmsb1     =\t%d\n", min_rfrmsb1);
                fprintf(fp, "min_rfampcpblty =\t%d\n", min_rfampcpblty);
                fprintf(fp, "minseqcoil_t    =\t%d\n", minseqcoil_t);
                fprintf(fp, "minseqgrddrv_t  =\t%d\n", minseqgrddrv_t);
                fprintf(fp, "minseqgpm_t     =\t%d\n", minseqgpm_t);
                fprintf(fp, "osfp_weight     =\t%f\n", osfp_weight);
                fprintf(fp, "post_osfp_weight=\t%f\n", post_osfp_weight);
                fprintf(fp, "max_seqsar_orig =\t%d\n", max_seqsar_orig);
                fprintf(fp, "tmin_total      =\t%d\n", tmin_total);
                fprintf(fp, "\n-------------------------------------\n\n\n");
                fclose(fp);
            }

            whilecounter++;
        } while ( (opt_deratingfactor < 0.95) && (whilecounter < 3) );

    } /* End of rfsafetyopt */

    /* GEHmr02509: smart derating */
    if( PSD_ON == gradOpt_flag )
    {

        int tmp_con = 0;
        int tmin_total_temp1 = 0;
        float tmp_weight = 0.0;
        
        /* SVBranch, HCSDM00100051 */
        int tmp_min_seqgrad = 0;
        float min_tor = 0.0;
        float min_tor_scale = 0.0;
        float tmp_tor = 0.0;

        min_tor = 10000000.0;  /* Set big value to min_tor to ensure tmp_tor < min_tor */

        /* tmp_weight can be optimized to converge quickly and avoid oscillating */
        if( PSD_ON == gradOpt_TE )
        {
            tmp_weight = gradOpt_weight;
        }
        else
        {
            tmp_weight = gradOpt_weight * 2;
            tmp_weight = FMin(2,tmp_weight,1.0);
        }
 
        /* iteration to get optimal gradOpt_scale */
        do
        {
            /* SVBranch, Smart Burst Mode */
            if(sbm_flag)
            {
                tmin_total_temp  = IMax( 3, (int)(min_seqgrad / sbm_smartderating_factor), min_seqrfamp, max_seqsar ) - tmin_reduced;
                tmp_min_seqgrad  = (int)(min_seqgrad / sbm_smartderating_factor) - tmin_reduced;
            }
            else
            {
                tmin_total_temp  = IMax( 3, min_seqgrad, min_seqrfamp, max_seqsar ) - tmin_reduced;
                tmp_min_seqgrad  = min_seqgrad - tmin_reduced;
            }
            tmp_min_seqgrad  = (tmp_min_seqgrad > 0) ? tmp_min_seqgrad : GRAD_UPDATE_TIME;
            tmin_total_temp1 = IMax( 2, tmin, tmin_total_temp);

            /* SVBranch, HCSDM00100051 */
            if ( ((tmin_total_temp1 == tmin) || (tmin_total_temp1 == tmp_min_seqgrad)) &&
                 (((fabs((float)tmin/(float)tmp_min_seqgrad - 1.0) > gradOpt_tor) && (gradOpt_convergence_flag)) ||
                  ((fabs((float)tmin/(float)tmp_min_seqgrad - 1.0) > gradOpt_nonconv_tor) &&
                   (PSD_OFF == gradOpt_convergence_flag))) )
            {
                gradOpt_convergence_flag = PSD_ON;  /* set convergence flag to 1 first */

                if( ((tmin >= tmp_min_seqgrad) && (gradOpt_scale >= (gradOpt_scale_Max - gradOpt_tor))) ||
                    ((tmp_min_seqgrad >= tmin) && (gradOpt_scale <= (gradOpt_scale_Min + gradOpt_tor))) )
                {
                    break;
                }
                else
                {
                    gradOpt_scale = gradOpt_scale * (((float)tmin/(float)tmp_min_seqgrad-1.0)*tmp_weight+1.0);
                    gradOpt_scale = FMin(2, gradOpt_scale, gradOpt_scale_Max);
                    gradOpt_scale = FMax(2, gradOpt_scale, gradOpt_scale_Min);
                }

                /* set gradOpt_run_flag=PSD_ON to update gradOpt_TEfactor, gradOpt_TRfactor etc. */
                /* SVBranch, HCSDM00100051 */
                gradOpt_run_flag = PSD_ON;

                if ( (status = cveval1()) != SUCCESS )
                {
                    /* HCSDM00360543 */
                    if(PSD_ON == force_gradOpt_loop_break)
                    {
                        RestoreGradOptCoefficients();
                        if ( (status = cveval1()) != SUCCESS )
                        {
                            initialize_scale = 1;
                            do_maxrbw_check_in_cveval = PSD_ON;
                            if ( (status = cveval1()) != SUCCESS )
                            {
                                do_maxrbw_check_in_cveval = PSD_OFF;
                                return status;
                            }
                            else
                            {
                                do_maxrbw_check_in_cveval = PSD_OFF;
                                break;
                            }
                        }
                        else
                        {
                            break;
                        }
                    }
                    else
                    {
                        return status;
                    }
                }

                /* SVBranch, HCSDM00100051 */
                gradOpt_run_flag = PSD_OFF;

                /* SVBranch, HCSDM00114077 */
                /* backup best gradOpt_scale to offer minimal tolerance */
                tmp_tor = FMax(2, (float)tmin/1000000.0, (float)tmp_min_seqgrad/1000000.0);
                if( tmp_tor < min_tor )
                {
                    min_tor = tmp_tor;
                    min_tor_scale = gradOpt_scale;
                }

            }
            else
            {
                break;
            }
            SaveGradOptCoefficients();  /* HCSDM00360543 */

            tmp_con++;
        } while(tmp_con < gradOpt_iter_count); 

        /* SVBranch, HCSDM00100051 */
        /* when tmp_con == gradOpt_iter_count, convergence failed
           set gradOpt_scale to best value*/
        if(tmp_con == gradOpt_iter_count)
        {
            gradOpt_convergence_flag = PSD_OFF;
            gradOpt_scale = min_tor_scale;

            /* set gradOpt_run_flag=PSD_ON to update gradOpt_TEfactor, gradOpt_TRfactor etc. */
            gradOpt_run_flag = PSD_ON;

            if ( (status = cveval1()) != SUCCESS )
            {
                return status;
            }

            gradOpt_run_flag = PSD_OFF;

            gradOpt_nonconv_tor = fabs((float)tmin/(float)tmp_min_seqgrad - 1.0) * 1.01;

            /* when tolerance is too big, run smart derating again to get better result*/
            if(gradOpt_nonconv_tor > gradOpt_nonconv_tor_limit)
            {
                gradOpt_nonconv_tor = gradOpt_nonconv_tor_limit;
            }
        }
 
    }
    else
    {
        gradOpt_scale = 1.0;
        gradOpt_ratio = 1.0;
        gradOpt_TEfactor = 1.0;
        gradOpt_TRfactor = 1.0;
    }

    if (PSD_ON == exist(opfluorotrigger))
    {
        skip_rotmat_search = PSD_OFF;
        skip_waveform_rotmat_check = PSD_ON;

        if ( (status = cveval1()) != SUCCESS )
        {
            return status;
        }

        skip_waveform_rotmat_check = PSD_OFF;
    }

    /* MRIhc46445, MRIhc49891 */
    if (medal_flag && medal_autotelock_flag && (!medal_autote_flag))
    {
        /* Set maximum TE values. */
        if (B0_30000 == (int)cffield)
        {
            if ((exist(opvibrant) || (exist(opdisco) && breastCoil_flag)) &&
                (PSD_AXIAL == opplane) && (!medal_multitr_flag)) /* 3 T axial bipolar VIBRANT-Flex */
            {
                medal_te1_upper = IMax(2, 1300, medal_oop_te_max);
                medal_te2_upper = IMax(2, 2500, medal_ip_te_max );
            }
            else if (PSD_MINTE == opautote)
            {
                medal_te1_upper = IMax(2, 1300, medal_oop_te_max);
                medal_te2_upper = IMax(2, 2600, medal_ip_te_max );
            }
            else
            {
                medal_te1_upper = IMax(2, 1500, medal_oop_te_max);
                medal_te2_upper = IMax(2, 2800, medal_ip_te_max );
            }
        }
        else /* (B0_15000 == (int)cffield) */
        {
            if (PSD_MINTE == opautote)
            {
                medal_te1_upper = 2700;
                medal_te2_upper = 5100;
            }
            else
            {
                medal_te1_upper = 2700;
                medal_te2_upper = 5300;
            }
        }

        medal_max_xres = avmaxxres;

        /* calculate maximum xres for APx, and return ADVISORY_FAILURE when TE is out of range */
        if ((act_te > medal_te1_upper) || (act_te2 > medal_te2_upper) || (PSD_ON == isProtocolOptimizing()))
        {
            float duration_constant; /* total duration of constant gradients with variable duration */
            float duration_ramp; /* total duration of ramp gradients with variable duration */
            float sum; /* variable for intermediate calculations of xres_max */
            float xres_max; /* variable for intermediate calculations of avmaxxres */
            const int TIME_BUFFER = 100; /* time buffer (us) */
            const int XRES_BUFFER = 4; /* xres buffer */

            /* limitation from TE of first echo */
            if ((act_te > medal_te1_upper) || (PSD_ON == isProtocolOptimizing()))
            {
                if (EQUAL_TOL(ogsfY, 1.0, 0.01) || EQUAL_TOL(ogsfZ, 1.0, 0.01)) /* Minimum readout start time is limited by y or z axis. */
                {
                    duration_constant = (float)(((fecho_factor-0.5)/fecho_factor)*pw_gxw);
                    duration_ramp = 0.0;
                }
                else /* Minimum readout start time is limited by x axis. */
                {
                    duration_constant = (float)(pw_gx1+(((fecho_factor-0.5)/fecho_factor)*pw_gxw));
                    duration_ramp = (float)(pw_gx1a+pw_gx1d-pw_gxwa);
                }

                sum = duration_constant+duration_ramp+medal_te1_upper-TIME_BUFFER-act_te;
                if (sum < 0.0)
                {
                    sum = 0.0;
                }
                xres_max = exist(opxres)*pow((-duration_ramp+sqrt(pow(duration_ramp, 2)+(4*duration_constant*sum)))/(2*duration_constant), 2);

                xres_max = xres_max-XRES_BUFFER;
                medal_max_xres = IMin(2, medal_max_xres, (int)xres_max);
            }

            /* limitation from TE of second echo */
            if ((act_te2 > medal_te2_upper) || (PSD_ON == isProtocolOptimizing()))
            {
                if (EQUAL_TOL(ogsfY, 1.0, 0.01) || EQUAL_TOL(ogsfZ, 1.0, 0.01)) /* Minimum readout start time is limited by y or z axis. */
                {
                    duration_constant = (float)(pw_gxw+((0.5/fecho_factor)*pw_gxw2));
                    duration_ramp = 0.0;
                }
                else /* Minimum readout start time is limited by x axis. */
                {
                    duration_constant = (float)(pw_gx1+pw_gxw+((0.5/fecho_factor)*pw_gxw2));
                    duration_ramp = (float)(pw_gx1a+pw_gx1d-pw_gxwa);
                }

                sum = duration_constant+duration_ramp+medal_te2_upper-TIME_BUFFER-act_te2;
                if (sum < 0)
                {
                    sum = 0;
                }
                xres_max = exist(opxres)*pow((-duration_ramp+sqrt(pow(duration_ramp, 2)+(4*duration_constant*sum)))/(2*duration_constant), 2);

                xres_max = xres_max-XRES_BUFFER;
                medal_max_xres = IMin(2, medal_max_xres, (int)xres_max);
            }

            medal_max_xres = ((int)(medal_max_xres/4.0))*4;

            if ( ((act_te > medal_te1_upper) || (act_te2 > medal_te2_upper)) &&
                 existcv(opautote) && existcv(opte) && existcv(oprbw) &&
                 existcv(opfov) && existcv(opxres) && existcv(opslquant) ) 
            {
                if (medal_max_xres < avminxres)
                {
                    medal_max_xres = ((int)(avminxres/4.0))*4;
                }
                avmaxxres = medal_max_xres;

                /* For other than APx, do not return FAILURE, and cvcheck handles the error accordingly. */
                if ( TRUE == isProtocolOptimizing() )
                {
                    epic_error(use_ermes,
                               "The frequency encodings must be decreased to %d for the current prescription.",
                               EM_PSD_XRES_OUT_OF_RANGE, EE_ARGS(1), INT_ARG, avmaxxres);
                    return ADVISORY_FAILURE;
                }
            }
        }
    }

    if (flextr_flag) {
       if (exist(opautotr)==PSD_ON)
       {
          setexist(optr,PSD_OFF);
          setfix(optr, PSD_OFF);
          optr = avmintr;
          setexist(optr,PSD_ON);
       }
    } else {
       setexist(optr,PSD_ON);
       optr = avmintr;
       avmaxtr = avmintr;
    }

    if (navgate_flag && pfkz_flag) { /* HCSDM00181166 */
        pfkz_vps_max = floor((float)(max_navgate_tr - (mon_tr + act_tr * navsegment_dda + nav_wait_flag * navend_time) -
                                                      (irprep_flag * (tseq_irprep + time_ssi + optr * irdisdacqs)) -
                                                      (specir_flag * (cs_sattime + cs_satstart + time_ssi + act_tr * chemsat_dda)))
                                    / (float)optr);
        if(pfkz_vps_max < 1) {
            pfkz_vps_max = 1;
        }
    }
    else if (aspir_override && aspir_flag && pfkz_flag) {
        pfkz_vps_max = 32;
    }
    else{
        /* MRIge91682 */
        if( lava_flag ) {
            pfkz_vps_max = 18;
        }
        if( brava_flag ) {
            if (oprbw > 60) {
                pfkz_vps_max = (pfkr_yz_flag && aspir_flag) ? 32 : 14;  
            } else {
                pfkz_vps_max = (pfkr_yz_flag && aspir_flag) ? 32 : 8; 
            }
        }
    }

    if( (lava_flag || brava_flag) && !disco_flag ) 
    {
        if( (exist(opuser24) < 1) || navgate_flag )
        {
            /* Acquire at least pfkz_fraction_min of the total number of
               unaccelerated slice encodes.  Calculate the necessary  number
               of slice encodes after acceleration and pfkz to achieve this.
               Assumes that pfkz does not enter calibration region, which 
               is enforced below */
            int fractional_equant = arc_equant  - 
                (int)floor((float)equant * (1.0 - pfkz_fraction_min) /
                           arc_sl_stride + 0.5); /* Added 0.5 to fix rounding issue */

            pfkz_segments = (int) floor((fractional_equant - 1)/pfkz_vps_max) + 1;
            pfkz_segments = IMin(2, pfkz_segments, 15);  
        }
        else
        {
            pfkz_segments = (int) exist(opuser24);
        }
    }
    else 
    {
        /* NOTE: pfkz does not currently support IRPrep segmentation */  
        pfkz_segments = 1;
    }

    if ( pfkz_flag )
    {
        int unaccel_pfkz_hnover;

        if( lava_flag || brava_flag ) {
            pfkz_fraction_min = 0.70;
        } else {
            pfkz_fraction_min = pfkz_fraction;
        }

        /* Keep pfkz fraction, shrink upper calibration region if necessary */
        unaccel_pfkz_hnover = (int)floor( ((pfkz_fraction_min - 0.5) * (float)equant + 0.5 ));
        pfkz_total_unaccel = unaccel_pfkz_hnover + equant/2;
        pfkz_fraction = (float)pfkz_total_unaccel/ (float)equant;

        if (arc_flag && (arc_sl_stride > 1.0))
        {
            arc_sl_calupper = IMin(2, arc_sl_calupper, pfkz_total_unaccel - 1);
            arc_equant = calcAccelEncodeNum(arc_sl_callower, arc_sl_calupper, equant, arc_sl_stride);
            cvoverride(arc_sl_netaccel, (float) equant / (float) arc_equant, PSD_FIX_OFF, PSD_EXIST_ON);
        }
        /* Adding 0.5 in the calculation of pfkz_total to fix rounding
         * issue which was causing scan time problem */
        pfkz_total = arc_equant - (int)floor((float)equant * (1.0 - pfkz_fraction) / arc_sl_stride + 0.5);
        pfkz_views_per_segment = (int)ceil((float)pfkz_total / (float)pfkz_segments);
        pfkz_total = pfkz_views_per_segment * pfkz_segments;
        pfkz_hnover = (pfkz_total - arc_equant/2);

        if (arc_flag && (arc_sl_stride > 1.0))
        {
            /* Recalculate pfkz_total_unaccel to get exactly pfkz_total encodes
               after acceleration */
            pfkz_total_unaccel = calcPfkyzTotalUnaccel(pfkz_total,
                                                       arc_sl_callower,
                                                       arc_sl_calupper,
                                                       arc_sl_stride);
        }
        else
        {
            pfkz_total_unaccel = pfkz_total; 
        }

        pfkz_fraction = (float)pfkz_total_unaccel / (float)equant;
    } 
    else 
    {
        pfkz_segments = 1;
        pfkz_fraction = 1.0;
        pfkz_total = arc_equant;  /*MRIhc14652 */
        pfkz_total_unaccel = equant;
        pfkz_hnover = 0;
    }

    if (arc_flag)
    {
        pfky_total_unaccel = calcPfkyzTotalUnaccel(rhnframes + rhhnover,
                                                   arc_ph_callower, 
                                                   arc_ph_calupper,
                                                   arc_ph_stride);
    }
    else
    {
        pfky_total_unaccel = rhnframes + rhhnover;
    }

    if (arc_flag || pfkr_flag || pfkr_yz_flag)
    { 
        if (FAILURE == walkSamplingPattern(&sampledPoints,
                                           &sampledPointsNoMask,
                                           &calibrationPoints,
                                           &maskPoints,
                                           zy_views, zy_slices,
                                           fn, pfky_total_unaccel,
                                           pfkz_fraction, pfkz_total_unaccel,
                                           pfkr_fraction,
                                           get_act_phase_fov() * nop, ethick,
                                           phaseres, equant,
                                           arc_flag, calRegion,
                                           arc_ph_stride, arc_sl_stride))
        {
            epic_error(use_ermes, "%s failed",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "walkSamplingPattern");
            return FAILURE;
        }
        seg_totalPEs = sampledPoints;
        /* ARC Synthesis points = full size - sampled - mask */
        arc_syn_pts = zy_views*zy_slices - sampledPoints - maskPoints; 
    }
    else
    {
        seg_totalPEs = (rhnframes+rhhnover)*(pfkz_total+linestodiscard);
    }
    
    if ( segmented_flag && (ENCODE_GROUP_NONE != encode_group) && !osfp_flag && !radfb_flag )
    {
        if (sp_sat) {
            views_per_segment = 12; 
        } 
        
        if (specir_flag) {
            views_per_segment = pfkz_total; 
        } 

        if (irprep_flag)
        {
            views_per_segment = IMax(2, arc_equant, (int) ((2.5*exist(opti)/act_tr)) );
        }
    }                
    else if (segmented_flag) {
       views_per_segment = (rhnframes+rhhnover);

       if (msde_flag)
       {
           /* Veiws_per_segment is reduced to 32 for SpSp RF in 1.5T, because TR is long. */
           seg_vps_target = ((cffield < B0_30000) && ss_rf1) ? 32 : 64;
           seg_vps_range = 8;
       }
       else if (osfp_flag || radfb_flag)
       {
           seg_vps_target = 256;
           seg_vps_range = 32;
       }
       else
       {
           seg_vps_target = (rhnframes+rhhnover);
           seg_vps_range = 32;
       }

       seg_vps_min = IMax(2,(seg_vps_target-seg_vps_range),8);
       seg_vps_max = IMin(2,(seg_vps_target+seg_vps_range),2048);

       if (views_per_segment != seg_vps_target)
       {
          int vps;
          seg_foundvps_flag = FALSE;
          for (vps = seg_vps_max; vps >= seg_vps_min; vps--) {
              if ( (seg_totalPEs % vps)==0 ) 
              {
                 if ( (abs(vps-seg_vps_target)) < (abs(views_per_segment-seg_vps_target)) ) {
                    views_per_segment = vps;
                    seg_foundvps_flag = TRUE; 
                 }
              }
          }
          if (!seg_foundvps_flag)
          {
              if (arc_flag || msde_flag)
              {
                  views_per_segment = seg_vps_target;
              }
              else
              {
                  views_per_segment = rhnframes+rhhnover;
              }
          }
       } 
    } else {
       views_per_segment = (rhnframes+rhhnover);
    }

    nr_of_segments = seg_totalPEs / views_per_segment;

    if (pfkr_yz_flag && !disco_flag)
    {
        if (lava_flag)
        {
            if (navgate_flag || aspir_flag)
            {
                segmented_tr_time = 120ms; /* navigator and aspir need the longer tr_time */
                chemsat_acq = 4; /*adjustment to fat null point for opspecir()*/
            }
            else
            {
                segmented_tr_time = 80ms; /* better fat sat & less fluctuation signal */
                chemsat_acq = 2; /*adjustment to fat null point for opspecir()*/
            }
        }
        else if (brava_flag || vibrant_flag)
        {
            float temp_pfkz_segment_tr = pfkz_views_per_segment*act_tr; 	
            segmented_tr_time = 150ms;
            if (segmented_tr_time < temp_pfkz_segment_tr) {
                segmented_tr_time = temp_pfkz_segment_tr;
            }
            chemsat_acq = 4; 
        }
        else if (medal_flag)
        {
            segmented_tr_time = 240ms; /* recommened value for navigator */
            chemsat_acq = 0;
        }
        else
        {
            chemsat_acq = 0;
        }

        views_per_segment = (int)(segmented_tr_time/act_tr);
        if (views_per_segment%2==1)
        {
            views_per_segment = views_per_segment + 1;
        }
        nr_of_segments = (int)ceil(((double)sampledPoints/(double)views_per_segment));
        segmented_tr_time = views_per_segment * act_tr;
    }
    else
    {
        chemsat_acq = 0;
    }

    if (disco_flag && segmented_flag && navgate_flag)
    {
        segmented_tr_time = max_navgate_tr - mon_tr - act_tr*navsegment_dda;

        views_per_segment = (int)(segmented_tr_time / (act_tr * exist(opnex) * inter_necho * exist(opvquant)));
        if (views_per_segment%2 == 1)
        {
            views_per_segment = views_per_segment + 1;
        }
        nr_of_segments = (int)ceil(((double)sampledPoints/(double)views_per_segment));

        nr_of_segA = (int)ceil((sampledPoints*aregion_fraction)/(double)views_per_segment);
        if (num_regions == 2)
        {
            int tmp_mod = (nr_of_segments - nr_of_segA) % num_sub_regions;
            /* If number of segments in B regions is not divisible, increase segments */
            if (tmp_mod > 0)
            {
                nr_of_segments += num_sub_regions - tmp_mod;
            }
            int oldsampledPoints = sampledPoints;
            sampledPoints = views_per_segment * nr_of_segments;
            maskPoints -= sampledPoints - oldsampledPoints;
            arc_syn_pts = zy_views*zy_slices - sampledPoints - maskPoints;
        }
    }

    if( specir_flag == PSD_ON ) {
        /* MRIge91682 */
        if( B0_30000 == (int)cffield ) {
            fatT1 = 367ms;
        } else {
            fatT1 = 260ms;
        }

        if ((PSD_ON == osfp_flag) || (PSD_ON == navgate_flag) || msde_flag)
        {
            slice_dda = 0; 
        }
        else
        {
            slice_dda = 2;
        }

        /* BBA - improved SPECIAL */
        if ((extraspecial_flag == PSD_ON) || (osfp_flag == PSD_ON) || msde_flag)
        {
            chemsat_dda = 0;
            /* ASPIR FA is calculated in ChemSatSpecIR.e considering
               excessive power for having heavy mass */
            if (!aspir_fa_scaling_flag)
            {
                flip_rfcssat = 180.0;
            }
            else
            {
                flip_rfcssat_noscale = 180.0;
                flip_rfcssat = *rfpulse[RFCSSAT_SLOT].act_fa;
            }
        } else {
            /* save current dda value */
            int old_chemsat_dda = chemsat_dda;

            /* MRIge91682 */
            if( pfkz_flag ) {
                if( lava_flag || pfkz_flag ) {
                    chemsat_dda = 0;
                }

                if( brava_flag ) {
                    if (oprbw > 60 ) {
                        chemsat_dda = 2;
                    } else {
                        chemsat_dda = 1;
                    } 
                    if (aspir_override && aspir_flag)
                    {
                        chemsat_dda = 0;
                    }
                }

                if( pfkz_reverse_seq ) {
                    offset = pfkz_views_per_segment - (pfkz_hnover / pfkz_segments);
                } else {
                    offset = pfkz_hnover / pfkz_segments;
                }
            }

            if (pfkr_yz_flag)
            {
                offset = 0;
            }

            /* update dda with offset; this value is used in the
               optspecir() function */
            chemsat_dda = chemsat_dda + offset;
            if (!aspir_flag)
            {
                if (pfkr_yz_flag)
                {
                    if ( cffield > B0_15000 )
                    {
                        flip_rfcssat = 160.0; /* Less TR due to SAR than 180deg */
                    }
                    else
                    {
                        if ((PSD_ON == navgate_flag) && (PSD_ON == enhanced_nav_flag))
                        {
                            flip_rfcssat = 100.0;
                        }
                        else
                        {
                            optspecir( &flip_rfcssat, &avmaxti, specirsol );
                        }
                    }
                }
                else
                {
                    optspecir( &flip_rfcssat, &avmaxti, specirsol );
                }
            }
            else
            {
                /* HCSDM00264804: initial Flip Angle for ASPIR */
                if (!aspir_fa_scaling_flag)
                {
                    flip_rfcssat = 100.0;
                }
                else
                {
                    flip_rfcssat_noscale = 100.0;
                    flip_rfcssat = *rfpulse[RFCSSAT_SLOT].act_fa;
                }
            }

            /* MRIhc11441: Ignore flip_rfcssat calculated from optspecir and
               set flip_rfcssat to 180 for Axial VIBRANT with field strength
               greater than 1.5T. */
            /* ASPIR FA is calculated in ChemSatSpecIR.e considering
               excessive power for having heavy mass - Ax VIBRANT with efgre3d_aspir */
            if ( brava_flag && (cffield > B0_15000) && (!aspir_fa_scaling_flag) ) {
                flip_rfcssat = 180.0;
            }

            /* recover old dda value */
            chemsat_dda = old_chemsat_dda;
        }
        if(vast_mode) {
            if (aspir_flag)
            {
                /* ASPIR FA is calculated in ChemSatSpecIR.e considering 
                   excessive power for having heavy mass */
                if (!aspir_fa_scaling_flag)
                {
                    flip_rfcssat = 180;
                }
                else
                {
                    flip_rfcssat_noscale = 180;
                    flip_rfcssat = *rfpulse[RFCSSAT_SLOT].act_fa;
                }
                avmaxti = ASPIR_TI_MAX;
            } else { 
                if (heart3d_flag)
                {
                    flip_rfcssat = 90;
                } else if (ssfp_flag) {
                    flip_rfcssat = 179;
                }
                avmaxti = specir_ti+avmaxtdel1-avmintdel1;
            }
        }
        /* ungated FatSat FIESTA */
        if( PSD_ON == ugfsf_flag ){
            flip_rfcssat = 179;
            avmaxti = avminti;
        }

        /* ATV - Post contrast T1 liver imaging with 
           SPECIAL might use TI close to 40 ms. */       
        if( avmaxti < 50ms ) {
            avmaxti = 50ms; 
        }

        advrounddown(&avmaxti);

        /* Check for bad max TI */
        if( avmaxti < avminti ) {
            avmaxti = avminti;
        }

        if (aspir_flag)
        {
            /* ASPIR FA is calculated in ChemSatSpecIR.e considering
               excessive power for having heavy mass */
            if (!aspir_fa_scaling_flag)
            {
                flip_rfcssatcfh = 180.0;
            }
            else
            {
                flip_rfcssatcfh = *rfpulse[RFCSSAT_CFH_SLOT].act_fa;
            }
        }
        else
        {
            flip_rfcssatcfh = 90.0;
        }         

        /* MRIge45847: make sure _opti.defval<=avmaxti */
        if( _opti.defval > avmaxti ) {
             cvdef(opti, avmaxti);
        }
    } else {
        slice_dda = 0;

        /* MRIge45847: reset exist flag of opti */
        if( irprep_flag != PSD_ON ){
            setexist(opti, PSD_OFF);
            setfix(opti, PSD_OFF);
        }  /* MRIge45847 */
    }

    if ((PSD_OFF == exist(opcgate)) && ((PSD_ON == navgate_flag) || (PSD_ON == navtrig_flag)))
    {
        if (PSD_ON == ifir_flag) {
            nav_nreps = arc_equant * num_outer_loops;
        } else if (disco_flag) {
            nav_nreps = nr_of_segments; /* number of mask segments */
            num_views_per_nav_tr = views_per_segment;
            act_navgate_tr = act_tr*(num_views_per_nav_tr+navsegment_dda) + mon_tr;
            nseg_per_nav_tr = 1;
        } else if (pfkz_flag && (!pfkr_yz_flag)) {
            nav_time_per_yview = act_tr * pfkz_total; /* supports pfkz only */

            if (PSD_ON == irprep_flag) {
                nav_time_per_yview = nav_time_per_yview + (tseq_irprep + time_ssi + act_tr * irdisdacqs) * pfkz_segments;
            }
          
            if (PSD_ON == specir_flag) {
                nav_time_per_yview = nav_time_per_yview + (cs_sattime + cs_satstart + time_ssi + act_tr * chemsat_dda) * pfkz_segments;
            }
      
            nav_time_per_zsegment = act_tr * pfkz_views_per_segment
                   + (irprep_flag * (tseq_irprep + time_ssi + act_tr * irdisdacqs))
                   + (specir_flag * (cs_sattime + cs_satstart + time_ssi + act_tr * chemsat_dda));

            navky_views_per_segment = IMin(2, 1, (INT)(max_navgate_tr-mon_tr-act_tr*navsegment_dda-nav_wait_flag*navend_time)/nav_time_per_yview);
            if (navky_views_per_segment == 0) {
                act_navgate_tr = IMax(2, max_navgate_tr, mon_tr+act_tr*navsegment_dda+nav_wait_flag*navend_time+nav_time_per_zsegment);
                nseg_per_nav_tr = ((INT)(act_navgate_tr-mon_tr-nav_wait_flag*navend_time-act_tr*navsegment_dda)/nav_time_per_zsegment);
                navkz_views_per_segment = nseg_per_nav_tr * pfkz_views_per_segment;
                act_navgate_tr = nav_time_per_zsegment*nseg_per_nav_tr +mon_tr + nav_wait_flag*navend_time + act_tr*navsegment_dda;
                if (arc_flag && ((ELLIPTICAL_CAL == cal_shape) || (BOX_CAL == cal_shape)))
                    nav_nreps = (int)ceil((float)sampledPoints/navkz_views_per_segment);
                else
                    nav_nreps = (rhnframes + rhhnover) * (int)ceil((float)pfkz_total/navkz_views_per_segment);
            } else {
                navkz_views_per_segment = pfkz_views_per_segment * pfkz_segments * navky_views_per_segment;
                act_navgate_tr = navky_views_per_segment * nav_time_per_yview + mon_tr + act_tr*navsegment_dda + nav_wait_flag*navend_time;
                if (arc_flag && ((ELLIPTICAL_CAL == cal_shape) || (BOX_CAL == cal_shape)))
                    navky_segments = (int)ceil((float)(sampledPoints/pfkz_total/navky_views_per_segment));
                else
                    navky_segments = (int)ceil((float)(rhnframes + rhhnover) / navky_views_per_segment);
                nav_nreps = navky_segments;
                nseg_per_nav_tr = navky_views_per_segment*pfkz_segments; /* for NavigatorPlaySPGR */
            }
            num_views_per_nav_tr = navkz_views_per_segment;
        }
        else /* !pfkz_flag */
        {
            if (segmented_flag) {

                nav_time_per_seg = act_tr * views_per_segment;
                if (specir_flag == PSD_ON) {
                    nav_time_per_seg += (cs_sattime + cs_satstart + time_ssi + act_tr * chemsat_dda);
                }
                nseg_per_nav_tr = IMax(2, (INT)(max_navgate_tr-act_tr*navsegment_dda)/nav_time_per_seg, 1);
                navky_views_per_segment = nseg_per_nav_tr;
                act_navgate_tr = nav_time_per_seg*nseg_per_nav_tr + mon_tr + act_tr*navsegment_dda;
                num_views_per_nav_tr = nseg_per_nav_tr*views_per_segment;
                nav_nreps = (int)ceil((float)sampledPoints/num_views_per_nav_tr);

            } else { /* !segmented */

                nav_time_per_yview = act_tr * arc_equant;

                if (irprep_flag == PSD_ON ) {
                    nav_time_per_yview = nav_time_per_yview + (tseq_irprep + time_ssi + act_tr * irdisdacqs) * (int)ceil((float)arc_equant/slfreq);
                }

                if (specir_flag == PSD_ON) {
                    nav_time_per_yview = nav_time_per_yview + (cs_sattime + cs_satstart + time_ssi + act_tr * chemsat_dda) * (int)ceil((float)arc_equant/slfreq);
                }

                navky_views_per_segment = IMax(2,(INT)(max_navgate_tr-mon_tr-act_tr*navsegment_dda-nav_wait_flag*navend_time)/nav_time_per_yview,1); /* at least 1 yview per nav */
                act_navgate_tr = navky_views_per_segment * nav_time_per_yview + mon_tr + act_tr*navsegment_dda + nav_wait_flag*navend_time;
                navky_segments = (int)ceil((float)zy_views/navky_views_per_segment);
                nav_nreps = navky_segments;
                nseg_per_nav_tr = 1; /* for PlaySPGR */
                navkz_views_per_segment = navky_views_per_segment * arc_equant;
                num_views_per_nav_tr = navkz_views_per_segment;
            }
        }
        if ((acqs > 1) && (PSD_OFF == disco_flag))
            nav_nreps = nav_nreps * acqs;

    }

    /* HCSDM00153381 */
    if ((PSD_OFF == exist(opcgate)) && (PSD_ON == navgate_flag))
    {
        float nav_eff = calc_nav_eff(nav_window);

        if (disco_flag)
        {
            /* DISCO scan time has been calculated in Disco.e, we need to account for nav_eff here */
            float b_eff = calc_nav_eff(nav_window * dnav_win_BAratio); /* efficiency for B regions */
            float comb_eff = act_aregion_fraction * nav_eff + (1 - act_aregion_fraction) * b_eff;
            nav_eff = comb_eff;

            float eff = ((float)act_tr*num_views_per_nav_tr) / (float)act_navgate_tr;

            pimscan /= (eff*nav_eff);
            pivsscan /= (eff*nav_eff);
            avmintscan /= (eff*nav_eff);
            pitres /= (eff*nav_eff);
        }
        else
        {
            avmintscan = (float)act_navgate_tr*nav_nreps/nav_eff;
        }
    }

    pitscan = avmintscan;               /* Value shown on the clock */
    pisctim1= pitscan;

    /* APx activation */
    if(Present == APXKey)
    {
        float temp_tscan = pitscan;
        int anatomy_apx_bh_enable = PSD_OFF;

#ifndef SIM
        anatomy_apx_bh_enable = isApplicationAllowedForAnatomy(opanatomy, ATTRIBUTE_APX_BH);
#else
        anatomy_apx_bh_enable = PSD_ON;
#endif

        if( (PSD_ON == exist(opmph)) && !disco_flag )
        {
            temp_tscan = (temp_tscan - passtime) / (float)exist(opfphases);
        }

        if( (1 == exist(opnumgroups)) && (0 != exist(opcoax)) && (1 == exist(opvquant)) &&
            (PSD_OFF == exist(oprtcgate)) && (PSD_OFF == exist(opnav)) && (PSD_OFF == exist(opcgate)) &&
            ( (PSD_ON == exist(oplava)) || (PSD_ON == exist(opidealiq)) ||
              ( ( ((PSD_ON == exist(oplava)) && (PSD_ON == exist(opmedal))) || (PSD_ON == de3d_flag) || (PSD_ON == exist(opdisco)) ) &&
                  (PSD_OFF == medal_flexecho_order_flag) ) ) &&
            (PSD_ON == anatomy_apx_bh_enable) )
        {
            apx_compatible = 1;
        }
        else
        {
            apx_compatible = 0;
        }

        if( (1 == apx_compatible) &&
            ( (APX_T_MIN_BH < temp_tscan + 500ms) && (temp_tscan - 500ms < APX_T_MAX_BH) ) )
        {
            piapx = PSD_ON;
        }
        else
        {
            piapx = PSD_OFF;
        }

        /* APx preference window setting */
        piapxprfstepnub = 2;
        piapxprfres = PSD_ON;
        piapxprfacc = PSD_ON;
    }
    else
    {
        piapx = PSD_OFF;

        piapxprfstepnub = 0;
        piapxprfres = PSD_OFF;
        piapxprfacc = PSD_OFF;
    }

    /* ave_sar and peak_sar:
       If spatial sat is on
       the spatial sat pulses must be weighted by (1/(satview+2)),
       the chem sat pulses must be weighted by ((satview+1)/(satview+2)), and
       the regular pulses must be weighted by ((satview+1)/(satview+2)).

       One way to accomplish this is to set the num field of the pulses to
       these various weights.  However, in the 5.3 release the num field is
       an integer.  To create the same effect,both the act fa and the pw
       fields of the pulses are multiplied by the appropriate weight. */

    if ( ((exist(opsatx))||(exist(opsaty))||(exist(opsatz))||(exist(opexsatmask))) &&
         (PSD_OFF == vast_mode) )  {
        /* copy the pw and act fa values of all the pulses into temp vars */
        for (numpulses = 0; numpulses < RF_FREE; numpulses++) {
            temprfpw[numpulses] = *rfpulse[numpulses].pw;
            temprffa[numpulses] = *rfpulse[numpulses].act_fa;
        }

        /* weight the pw and act fa value of all the sat pulses */
        for (numpulses = 0; numpulses < NUMRFSAT; numpulses++) {
            *rfpulse[numpulses].pw *= satweight;
            *rfpulse[numpulses].act_fa *= satweight;
        }

        if ( fatFlag == PSD_ON || opwater == PSD_ON) {
            /* weight the pw and act fa value of all the chem sat pulses */
            for (numpulses = NUMRFSAT; numpulses < NUMRFSAT + 1; numpulses++) { 
                *rfpulse[numpulses].pw *= chemweight;
                *rfpulse[numpulses].act_fa *= chemweight;
            }
        }

        /* weight the pw and act fa value of all the reg pulses */
        for (numpulses = NUMRFSAT + 1; numpulses < NUMRFSAT + 2; numpulses++) {
            *rfpulse[numpulses].pw *= regweight;
            *rfpulse[numpulses].act_fa *= regweight;
        }
    }

    adj_act_tr = act_tr;

    /* IR PREP (pjg) */
    if( irprep_flag == PSD_ON ) {
        temprfpw[RF0_SLOT] = *rfpulse[RF0_SLOT].pw;
        temprffa[RF0_SLOT] = *rfpulse[RF0_SLOT].act_fa;
        *rfpulse[RF0_SLOT].pw *= irscale;
        *rfpulse[RF0_SLOT].act_fa *= irscale;
        if( vast_mode == PSD_OFF ) 
        {
            adj_act_tr = act_tr + ((exist(opti) - irdisdacqs*act_tr)/
                                   (irfreq + irdisdacqs));
        }
    }

    /* IFIR GRx */
    if (ifir_flag == PSD_ON)
    {
        /* Copy the pw and fa values of the pulses into temp vars */
        if (exist(opgirmode) == PSD_GIRMANUAL)
        {
            temp_rfgir01pw = *rfpulse[RFGIR01_SLOT].pw;
            temp_rfgir01fa = *rfpulse[RFGIR01_SLOT].act_fa;

            temp_rfgir02pw = *rfpulse[RFGIR02_SLOT].pw;
            temp_rfgir02fa = *rfpulse[RFGIR02_SLOT].act_fa;

            if(exist(opnumgir) >= 1)
            {
                *rfpulse[RFGIR01_SLOT].act_fa *= irscale;
                *rfpulse[RFGIR01_SLOT].pw *= irscale;

                *rfpulse[RFGIR02_SLOT].act_fa *= irscale;
                *rfpulse[RFGIR02_SLOT].pw *= irscale;
            }
            
        }
    }

    if (ifir_flag && sp_sat) 
    {
        /* copy the pw and act fa values of all the pulses into temp vars */
        for (numpulses = 0; numpulses < NUMRFSAT; numpulses++) {
            temprfpw[numpulses] = *rfpulse[numpulses].pw;
            temprffa[numpulses] = *rfpulse[numpulses].act_fa;
            *rfpulse[numpulses].pw *= 1.0/(max_pencodes+ssfp_flag*fiesta_gated_dda);
            *rfpulse[numpulses].act_fa *= 1.0/(max_pencodes+ssfp_flag*fiesta_gated_dda);
        }
    } 

    if (osfp_flag)
    {
        temp_rf1pw = *rfpulse[RF1_SLOT].pw;
        temp_rf1fa = *rfpulse[RF1_SLOT].act_fa;
        *rfpulse[RF1_SLOT].act_fa *= osfp_weight;
        *rfpulse[RF1_SLOT].pw *= osfp_weight;
    }

    /*43788*/
    /* Intermittant chem sat is handled just like IR prep */
    if (intermittant_chemsat == PSD_ON) {
        if ( ((exist(opsatx)) || (exist(opsaty)) || (exist(opsatz)) || (exist(opexsatmask))) &&
             (PSD_OFF == vast_mode) )
        {
            /* Restore original pw/fa before scaling */
            *rfpulse[RFCSSAT_SLOT].pw = temprfpw[RFCSSAT_SLOT];
            *rfpulse[RFCSSAT_SLOT].act_fa = temprffa[RFCSSAT_SLOT];
        }
        temprfpw[RFCSSAT_SLOT] = *rfpulse[RFCSSAT_SLOT].pw;
        temprffa[RFCSSAT_SLOT] = *rfpulse[RFCSSAT_SLOT].act_fa;
        *rfpulse[RFCSSAT_SLOT].pw *= chemscale;
        *rfpulse[RFCSSAT_SLOT].act_fa *= chemscale;

        /* MRIge71791 */
        if (!vast_mode) {
            adj_act_tr = adj_act_tr + ((specir_ti - chemsat_dda*act_tr)/
                                       (chemfreq + chemsat_dda));
        } else {
            adj_act_tr = act_tr;
        }
    } /* JAH/DCZ: MRIge62874: fix adj_act_tr. */

    if(exist(opcgate) && (irprep_flag || navsat_flag) && slabtracking_flag)
    {
        if(navigatorCYL_flag)
        {
            temprfpw[RFCYLRTIPUP_SLOT] = *rfpulse[RFCYLRTIPUP_SLOT].pw;
            temprffa[RFCYLRTIPUP_SLOT] = *rfpulse[RFCYLRTIPUP_SLOT].act_fa;
            *rfpulse[RFCYLRTIPUP_SLOT].pw *= navscale;
            *rfpulse[RFCYLRTIPUP_SLOT].act_fa *= navscale;
        } else {
            temprfpw[RFMONTIPUP_SLOT] = *rfpulse[RFMONTIPUP_SLOT].pw;
            temprffa[RFMONTIPUP_SLOT] = *rfpulse[RFMONTIPUP_SLOT].act_fa;
            *rfpulse[RFMONTIPUP_SLOT].pw *= navscale;
            *rfpulse[RFMONTIPUP_SLOT].act_fa *= navscale;
        }
    }

    if(exist(opcgate) && (irprep_flag || navsat_flag))
    {
        if(navigatorCYL_flag)
        {
            temprfpw[RFCYLR_SLOT] = *rfpulse[RFCYLR_SLOT].pw;
            temprffa[RFCYLR_SLOT] = *rfpulse[RFCYLR_SLOT].act_fa;
            *rfpulse[RFCYLR_SLOT].pw *= navscale;
            *rfpulse[RFCYLR_SLOT].act_fa *= navscale;
        } else {
            temprfpw[RF1MON_SLOT] = *rfpulse[RF1MON_SLOT].pw;
            temprffa[RF1MON_SLOT] = *rfpulse[RF1MON_SLOT].act_fa;
            *rfpulse[RF1MON_SLOT].pw *= navscale;
            *rfpulse[RF1MON_SLOT].act_fa *= navscale;
            temprfpw[RF2MON_SLOT] = *rfpulse[RF2MON_SLOT].pw;
            temprffa[RF2MON_SLOT] = *rfpulse[RF2MON_SLOT].act_fa;
            *rfpulse[RF2MON_SLOT].pw *= navscale;
            *rfpulse[RF2MON_SLOT].act_fa *= navscale;
        }
    }

    if( t2prep_flag ) 
    {
        int tmppw;
        temprfpw[RF90_SLOT] = *rfpulse[RF90_SLOT].pw;
        temprffa[RF90_SLOT] = *rfpulse[RF90_SLOT].act_fa;
        temprfpw[RF180_SLOT] = *rfpulse[RF180_SLOT].pw;
        temprffa[RF180_SLOT] = *rfpulse[RF180_SLOT].act_fa;
        temprfpw[RFTIPUP_SLOT] = *rfpulse[RFTIPUP_SLOT].pw;
        temprffa[RFTIPUP_SLOT] = *rfpulse[RFTIPUP_SLOT].act_fa;

        tmppw = RUP_RF((int)ceil(*rfpulse[RF90_SLOT].pw * t2prep_rate));
        *rfpulse[RF90_SLOT].pw = tmppw;
        *rfpulse[RF90_SLOT].act_fa = temprffa[RF90_SLOT]/temprfpw[RF90_SLOT]*tmppw;
        tmppw = RUP_RF((int)ceil(*rfpulse[RF180_SLOT].pw * t2prep_rate));
        *rfpulse[RF180_SLOT].pw = tmppw;
        *rfpulse[RF180_SLOT].act_fa = temprffa[RF180_SLOT]/temprfpw[RF180_SLOT]*tmppw;
        tmppw = RUP_RF((int)ceil(*rfpulse[RFTIPUP_SLOT].pw * t2prep_rate));
        *rfpulse[RFTIPUP_SLOT].pw = tmppw;
        *rfpulse[RFTIPUP_SLOT].act_fa = temprffa[RFTIPUP_SLOT]/temprfpw[RFTIPUP_SLOT]*tmppw;
    }

    if (msde_flag)
    {
        int tmppw;

        msde_rate = (views_per_segment >= 1.0) ? (1.0 / views_per_segment) : 1.0;

        temprfpw[RFFLP90_SLOT]  = *rfpulse[RFFLP90_SLOT].pw;
        temprffa[RFFLP90_SLOT]  = *rfpulse[RFFLP90_SLOT].act_fa;
        temprfpw[RFFLP180_SLOT] = *rfpulse[RFFLP180_SLOT].pw;
        temprffa[RFFLP180_SLOT] = *rfpulse[RFFLP180_SLOT].act_fa;
        temprfpw[RFFLP90R_SLOT] = *rfpulse[RFFLP90R_SLOT].pw;
        temprffa[RFFLP90R_SLOT] = *rfpulse[RFFLP90R_SLOT].act_fa;

        tmppw = RUP_RF((int)ceil(*rfpulse[RFFLP90_SLOT].pw * msde_rate));
        *rfpulse[RFFLP90_SLOT].pw = tmppw;
        *rfpulse[RFFLP90_SLOT].act_fa = temprffa[RFFLP90_SLOT]/temprfpw[RFFLP90_SLOT]*tmppw;

        tmppw = RUP_RF((int)ceil(*rfpulse[RFFLP180_SLOT].pw * msde_rate));
        *rfpulse[RFFLP180_SLOT].pw = tmppw;
        *rfpulse[RFFLP180_SLOT].act_fa = temprffa[RFFLP180_SLOT]/temprfpw[RFFLP180_SLOT]*tmppw;

        tmppw = RUP_RF((int)ceil(*rfpulse[RFFLP90R_SLOT].pw * msde_rate));
        *rfpulse[RFFLP90R_SLOT].pw = tmppw;
        *rfpulse[RFFLP90R_SLOT].act_fa = temprffa[RFFLP90R_SLOT]/temprfpw[RFFLP90R_SLOT]*tmppw;
    }

    /* adjust SAR if gated 3D MDE  TKF/MS */
    /* Need to do the scaling of RF pulse only for SAR calculations, hence kludge here
       by calling function to set the sar values with the right scale, then calling routine
       again with temp sar variables so that the power monitor estimation is correct ALP */
    if( ((PSD_ON == exist(opcgate)) || ifir_flag) && (PSD_ON == vast_mode) ) {
        temp_rf1pw = *rfpulse[RF1_SLOT].pw;
        temp_rf1fa = *rfpulse[RF1_SLOT].act_fa;

        /* adj_act_tr should be scaled (increased) to account for the TR scale
         * factor (scale_tr) calculated in VAST.e (VAST_scaleTR). This scale
         * factor depends on the Gating Dead time. */
        adj_act_tr = RUP_GRD((int)(ceilf(act_tr/scale_tr)));

        /* MRIhc15630: scale_tr accounts for the scaling coming from Gated/vast
         * mode scans. temp_factor checks if additional scaling is required.
         * This additional scaling can come from tmin_reduced calculations with
         * irprep ON in this mode. With the new SAR model given by Joe S
         * (systems Team) in the low mass region, it is now possible with
         * VAST mode and Irprep mode ON, that max_seqsar calculated in cveval1
         * (even after TR scaling by VAST.e) can be a number larger than act_tr.
         * Act_tr being lower than max_seqsar can be due to the tmin_reduced scaling.
         * This difference is now accounted here in adj_act_tr so that similar
         * TR scaling goes in powermon estimations. This resolves the SAR
         * exceeded messages in the low mass region. After accounting for these
         * two we do not need additional RF scaling from VAST_scaleRF*/
        temp_factor = (float)(act_tr)/((float)((IMax( 2,max_seqsar, min_seqrfamp))));
        if ( temp_factor < 1.0 ) {
            adj_act_tr = RUP_GRD((int)(ceilf((float)(adj_act_tr)/temp_factor)));
        }
    }

    /*
     * Calculate SAR values with powermon() before restoring the RF pulses.
     * SAR would be incorrectly calculated if we try to do powermon() after
     * restoring the RF pulses.
     */
    if( peakAveSars( &ave_sar_eval, &cave_sar_eval, &peak_sar_eval, &b1rms_eval,
                     (int)RF_FREE, rfpulse, L_SCAN, (int)(adj_act_tr) ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "peakAveSars");
        return FAILURE;  
    }

    piasar = (float)ave_sar_eval;     /* average SAR report to UI */
    picasar = (float)cave_sar_eval;   /* average coil SAR report to UI */
    pipsar = (float)peak_sar_eval;    /* peak SAR report to UI */
    pib1rms = (float)b1rms_eval;      /* Report predicted b1rms value on the UI */

    /* Report the greater of the scan and Smartprep SAR values */
    if ((PSD_ON == navtrig_flag) || (PSD_ON == smartprep_flag))
    {
        if (monave_sar > piasar) {
            piasar = monave_sar;
        }
        if (moncave_sar > picasar) {
            picasar = moncave_sar;
        }
        if (monpeak_sar > pipsar) {
            pipsar = monpeak_sar;
        }
    }

    if ( exist(opfluorotrigger) == PSD_ON ) {
        ftmra_satact_on();
    }

    if( irprep_flag == PSD_ON ) {
        *rfpulse[RF0_SLOT].pw = temprfpw[RF0_SLOT];
        *rfpulse[RF0_SLOT].act_fa = temprffa[RF0_SLOT];
    }

    /* IFIR GRx */
    if (ifir_flag == PSD_ON)
    {
        /* Restore the pw and act fa values of all the pulses from temp vars */
        if (exist(opgirmode) == PSD_GIRMANUAL)
        {
            *rfpulse[RFGIR01_SLOT].pw = temp_rfgir01pw;
            *rfpulse[RFGIR01_SLOT].act_fa = temp_rfgir01fa;

            *rfpulse[RFGIR02_SLOT].pw = temp_rfgir02pw;
            *rfpulse[RFGIR02_SLOT].act_fa = temp_rfgir02fa;
        }
    }

    if (ifir_flag && sp_sat) {
        /* copy the pw and act fa values of all the pulses into temp vars */
        for (numpulses = 0; numpulses < NUMRFSAT; numpulses++) {
            *rfpulse[numpulses].pw = temprfpw[numpulses];
            *rfpulse[numpulses].act_fa = temprffa[numpulses];
        }
    }

    /* 43788 */
    if (intermittant_chemsat == PSD_ON) {
        *rfpulse[RFCSSAT_SLOT].pw = temprfpw[RFCSSAT_SLOT];
        *rfpulse[RFCSSAT_SLOT].act_fa = temprffa[RFCSSAT_SLOT];
    }

@inline cal3d.e cal3d_cveval

    if(exist(opcgate) && (irprep_flag || navsat_flag) && slabtracking_flag)
    {
        if(navigatorCYL_flag)
        {
            *rfpulse[RFCYLRTIPUP_SLOT].pw = temprfpw[RFCYLRTIPUP_SLOT];
            *rfpulse[RFCYLRTIPUP_SLOT].act_fa = temprffa[RFCYLRTIPUP_SLOT];
        } else {
            *rfpulse[RFMONTIPUP_SLOT].pw = temprfpw[RFMONTIPUP_SLOT];
            *rfpulse[RFMONTIPUP_SLOT].act_fa = temprffa[RFMONTIPUP_SLOT];
        }
    }

    if(exist(opcgate) && (irprep_flag || navsat_flag))
    {
        if(navigatorCYL_flag)
        {
            *rfpulse[RFCYLR_SLOT].pw = temprfpw[RFCYLR_SLOT];
            *rfpulse[RFCYLR_SLOT].act_fa = temprffa[RFCYLR_SLOT];
        } else {
            *rfpulse[RF1MON_SLOT].pw = temprfpw[RF1MON_SLOT];
            *rfpulse[RF1MON_SLOT].act_fa = temprffa[RF1MON_SLOT];
            *rfpulse[RF2MON_SLOT].pw = temprfpw[RF2MON_SLOT];
            *rfpulse[RF2MON_SLOT].act_fa = temprffa[RF2MON_SLOT];
        }
    }

    if( t2prep_flag ) 
    {
        *rfpulse[RF90_SLOT].pw = temprfpw[RF90_SLOT];
        *rfpulse[RF90_SLOT].act_fa = temprffa[RF90_SLOT];
        *rfpulse[RF180_SLOT].pw = temprfpw[RF180_SLOT];
        *rfpulse[RF180_SLOT].act_fa = temprffa[RF180_SLOT];
        *rfpulse[RFTIPUP_SLOT].pw = temprfpw[RFTIPUP_SLOT];
        *rfpulse[RFTIPUP_SLOT].act_fa = temprffa[RFTIPUP_SLOT];
    }

    if (msde_flag)
    {
        *rfpulse[RFFLP90_SLOT].pw      = temprfpw[RFFLP90_SLOT];
        *rfpulse[RFFLP90_SLOT].act_fa  = temprffa[RFFLP90_SLOT];
        *rfpulse[RFFLP180_SLOT].pw     = temprfpw[RFFLP180_SLOT];
        *rfpulse[RFFLP180_SLOT].act_fa = temprffa[RFFLP180_SLOT];
        *rfpulse[RFFLP90R_SLOT].pw     = temprfpw[RFFLP90R_SLOT];
        *rfpulse[RFFLP90R_SLOT].act_fa = temprffa[RFFLP90R_SLOT];
    }

    /* Restore settings after calculating SAR - MS/TKF*/
    if( ((PSD_ON == exist(opcgate)) && (PSD_ON == vast_mode)) || osfp_flag || ifir_flag) {
        *rfpulse[RF1_SLOT].pw = temp_rf1pw;
        *rfpulse[RF1_SLOT].act_fa = temp_rf1fa;
    }

    /* EB: Move SpSAT restoring at the very end. If IR/ChemSat pulses areapplied in conjuction 
       with SpSAT then we have incorrect scaling due to multiple scaling */

    if ( ((exist(opsatx))||(exist(opsaty))||(exist(opsatz))||(exist(opexsatmask))) &&
         (PSD_OFF == vast_mode) ) {
        /* restore the pulse width and flip angle value of all the pulses */
        for (numpulses = 0; numpulses < RF_FREE; numpulses++) {
            *rfpulse[numpulses].pw = temprfpw[numpulses];
            *rfpulse[numpulses].act_fa = temprffa[numpulses];
        }
    }

    /*
     * MRIhc42752 - Use the setupPowerMonitor function so we can pass
     * the established average SAR for pulse monitor guard band calculations. 
     */
    if( setupPowerMonitor( &entry_point_table[L_SCAN], L_SCAN, (int)RF_FREE,
                           rfpulse, (int)(adj_act_tr),
                           (double)piasar, (double)picasar, (double)pipsar )
        != SUCCESS)
    { 
        epic_error(use_ermes, "%s failed",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "setupPowerMonitor");
        return FAILURE;  
    }

    reverseLoopOrder_flag = reverseLoopOrder;

    /* SNR monitor */
    _pifractecho.fixedflag = 0;
    pifractecho = fecho_factor;
    setexist(pifractecho,_opte.existflag);
    _pifractecho.fixedflag = _opte.fixedflag;


    arc_cal_echo = -1; /* Default to self cal */
    /* Could calibrate from one of the two echoes. Not used with ARC */
    /* arc_cal_echo = (rhmedal_echo_order == 0) ? 1 : 0;  */
   
    if (rfsafetyopt_timeflag)
    {      
        int diff;
        FILE *fp;
        struct timeval t;
#ifdef PSD_HW
        fp = fopen("/usr/g/service/log/rfsafetyopt_time.log", "a");
#else
        fp = fopen("rfsafetyopt_time.log", "a");
#endif

        rfsafetyopt_timecountE++;
        gettimeofday(&t, NULL);
        end_time = ((LONG)(t.tv_sec)) * 1000000 + t.tv_usec;
        diff = end_time - start_time;        
        if(rfsafetyopt_timecountE == rfsafetyopt_timecountB)
        {
            fprintf(fp, "%d\t\t%10d\n",rfsafetyopt_timecountE, diff);
        }

        fclose(fp);
    }

    if( (PSD_OFF == pitrnub) && (PSD_OFF == exist(opautotr)) )
    {
        opautotr = PSD_ON;
    }

    if( (PSD_OFF == pircbnub) && (PSD_OFF == exist(opautorbw)) )
    {
        opautorbw = PSD_ON;
    }

    if(((PSD_ON == exist(opswan)) && (PSD_ON == existcv(opswan)) &&
       (PSD_OFF != exist(opphaseimage))&& (PSD_ON == existcv(opphaseimage))) )
    {
        pi3dgradwarpnub = 0;
    }
    if ( (flow4D_flag)  ) {
        pi3dgradwarpnub = 0;
        opauto3dgradwarp = PSD_OFF;
        op3dgradwarp = PSD_ON;
    }

    /* HCSDM00155192 */
    if( (PSD_ON == bravo_flag) ||
        ((PSD_ON == irprep_flag) && (PSD_OFF == exist(opcgate)) && (PSD_OFF == ifir_flag)) )
    {
        picontrastwarning = EM_PSD_IR_CONTRAST_INCOMPATIBLE;
    }
    else
    {
        picontrastwarning = 0;
    }

    if( (PSD_ON == exist(oprtcgate)) || (PSD_ON == exist(opnav)) )
    {
        piautovoice = 0;
    }
    else
    {
        piautovoice = 1;
    }

    /* SVBranch, Smart Burst Mode */
    if(sbm_flag)
    {
        sbm_bak_pitscan = pitscan; /* backup pitscan for imaging time to set sbm_pitscan_changed flag */

        if(sbm_cvs_changed && sbm_pitscan_changed)
        {
            predownload();    /* call predownload() to get sbm_waiting_time. It is only for pitscan update */
            pitscan = sbm_bak_pitscan + sbm_waiting_time;
            avmintscan = pitscan;
            sbm_pitscan_changed = 0;
        }
        else
        {
            if(sbm_waiting_time > 0)  /* waiting time is calculated by predownload() */
            {
                pitscan = sbm_bak_pitscan + sbm_waiting_time;
                avmintscan = pitscan;
            }
        }
    }

    info_fields_display(&piinplaneres,&pirbwperpix,&piesp,&ihinplanexres,
                        &ihinplaneyres,&ihrbwperpix,&ihesp,
                        DISP_INPLANERES|DISP_RBWPERPIX,
                        NO_ESP_DEFAULT_VALUE,
                        NOSCALE_INPLANEYRES_SQP);

    return SUCCESS;
}   /* end cveval() */


/*
 * cveval1
 */
STATUS
cveval1( void )
{
    FLOAT use_tr = 0.0;		/* Use the proper tr value for pisctimx.*/
    int irseqs = 0;                 /* IR PREP (pjg) */
    int slfreq0 = 1;
    int tempslfreq0 = 1;
    int tempslfreq = 8;
    const CHAR funcName[] = "cveval1";

    /* Previous values for AutoTI */
    int keep_opti1;
    int keep_optifixedflag;
    int keep_optiexistflag;
    int keep_opautotifixedflag;
    int keep_opautotiexistflag;

    static int unscaled_minseqgpm_t = -1;
    static int unscaled_minseqcoil_t = -1; 
    static int unscaled_minseqcable_t = -1; 
    static int unscaled_minseqbusbar_t = -1; 
    static int unscaled_minseqchoke_t = -1; 
    static int unscaled_minseqgrddrv_case_t = -1; 
    static int unscaled_minseqcable_maxpow_t = -1; 
    static float old_osfp_weight_grad= -1.0;

    force_gradOpt_loop_break = PSD_OFF;  /* HCSDM00360543 */

    /* ******************************
       Screen Control - that not done in cvinit
       ****************************** */
    /*
     * Vascular Screen options
     */
    if ( ((exist(oppseq) == PSD_TOF) || (exist(oppseq) == PSD_TOFSP)) &&
         (exist(opmph) == PSD_OFF) && (opquickstep == PSD_OFF) ) {
        pivascop = 1;       /* vascular options screen is required */
        piprojnub = 15;     /* initialize to allow collapse and 3 proj buttons */
        /* defaults to collapse on and 19 projections */
        cvdef(opcollapse, 1);
        cvdef(opproject, 1);
        opcollapse = 1;
        opproject = 1;

        /* restore defaults from epic.h */
        piflanub = 0;
        pivelnub = 0;
        piaddinub = 0;
        piflrcnub = 0;

        cvdef(opflaxall, 0);
        _opflaxall.fixedflag = 0;
        opflaxall = 0;

        cvdef(opvenc, 50.0);
        _opvenc.fixedflag = 0;
        opvenc = 50.0;

    } else if (flow4D_flag)
    {
       pivascop = 1;
       piprojnub = 0;      /* initialize to allow no collapse and no projs */
       /* defaults have no affect - no buttons */
       cvdef(opcollapse, 0);
       cvdef(opproject, 0);
        _opcollapse.fixedflag = 0;
        opcollapse = 0;
        _opproject.fixedflag = 0;
        opproject = 0;

       piflrcnub = 0; 
       pidefflrc = FLOWANALYS;
       piflanub =  8 ;  

       pidefflax = 8;

       piaddinub = 0; 

       cvdef(opflrecon, 2);
       cvmin(opflrecon, 0);
       cvmax(opflrecon, 2);

       cvoverride(opflaxall, PSD_ON,  PSD_FIX_ON, PSD_EXIST_ON);
       pivelnub = 1;

       avminvenc = 5.0;
       avmaxvenc = 5500.0; 
       cvmax(opvenc, 5500.0);
       cvmin(opvenc, 5.0);

     }
     else
     {
        pivascop = 0;       /* vascular options screen is not required */
        piprojnub = 0;      /* initialize to allow no collapse and no projs */

        /* restore defaults from epic.h */
	piflanub = 0;
	pivelnub = 0; 
	piaddinub = 0; 
	piflrcnub = 0;
 
        cvdef(opflaxall, 0);
        _opflaxall.fixedflag = 0;
        opflaxall = 0;

        cvdef(opvenc, 50.0);
        _opvenc.fixedflag = 0;
        opvenc = 50.0;

        cvdef(opcollapse, 0);
        _opcollapse.fixedflag = 0;
        opcollapse = 0;

        cvdef(opproject, 0);
        _opproject.fixedflag = 0;
        opproject = 0;
    }

    /* IR PREP / SPEC IR */

    piautoti = PSD_OFF;

    /* MRIge91682 */
    if( (irprep_flag || specir_flag) &&
        !extraspecial_flag && !lava_flag && !brava_flag && !ifir_flag && (bravo_flag || !aspir_flag) ) {
        /* Activate advisory panel checks for TI */
        piadvmin = (piadvmin | (1<<PSD_ADVTI));
        piadvmax = (piadvmax | (1<<PSD_ADVTI));

        /* Set TI annotation */
        pititype = PSD_LABEL_TE_PREP;

        /* Only show Auto TI */
        if( vast_mode && specir_flag ) {
            pitinub = 2;
        } else {
            pitinub = 6;
        }
        if( PSD_ON == irprep_flag ) {
            if (bravo_flag)
            {
                pitidefval = 450ms;
                pitival2 = 200ms;
                pitival3 = 300ms;
                pitival4 = 400ms;
                pitival5 = 500ms;
                pitival6 = 600ms;
            }
            else
            {
                pitival2 = 175ms;
                pitival3 = 200ms;
                pitival4 = 225ms;
                pitival5 = 250ms;
                pitival6 = 275ms;
            }
        } else {
            if (osfp_flag)
            {
                /* MRIhc47617 */
                piautoti = PSD_ON;  /* show Auto as an option */
                pitival3 = 100ms;
                pitival4 = 140ms;
                pitival5 = 180ms;
                pitival6 = 220ms;
            }
            else
            {
                piautoti = PSD_ON;  /* show Auto as an option */
                pitival3 = 30ms;
                pitival4 = 35ms;
                pitival5 = 40ms;
                pitival6 = 50ms;
            }
        }
    } else if (aspir_flag) {
        /* Activate advisory panel checks for TI */
        piadvmin = (piadvmin | (1<<PSD_ADVTI));
        piadvmax = (piadvmax | (1<<PSD_ADVTI));

        /* Set TI annotation */
        pititype = PSD_LABEL_TE_PREP;

        /* Only show Auto TI */
        pitinub = 2;
        piautoti = PSD_ON;  /* show Auto as an option */
    } else {
        /* Reset to default values */
        piadvmin = (piadvmin & (~(1<<PSD_ADVTI)) ); 
        piadvmax = (piadvmax & (~(1<<PSD_ADVTI)) );
        pititype   = PSD_LABEL_TI_IR;
        setexist(opti, PSD_OFF);   /* MRIge84938 */
        setfix(opti, PSD_OFF);     /* MRIge84938 */
        pitinub    = 0;  /* do not display any TI values */
        pitidefval = 0;
        pitival2   = 50ms;
        pitival3   = 130ms;
        pitival4   = 200ms;
        pitival5   = 300ms;
        pitival6   = 400ms;

        if (specir_flag && (brava_flag || lava_flag) )
        {
            pitinub = -1; /* Set Gray Out TI field */
            piautoti = PSD_ON; 
        }
    }

    if (ifir_flag)
    {
        pibsptinub = 4;
        pibsptidefval = 1200ms;
        pibsptival2 = 1100ms;
        pibsptival3 = 1200ms;
        pibsptival4 = 1400ms;
        avminbspti = 1000ms;
        avmaxbspti = 2000ms;
        cvdef(opbspti,1200ms);
    } else {
        pibsptinub = 0;
        pibsptidefval = 0;
        pibsptival2 = 0;
        pibsptival3 = 0;
        pibsptival4 = 0;
        pibsptival5 = 0;
        pibsptival6 = 0;
        avminbspti = 0;
        avmaxbspti = 0;
        cvdef(opbspti,TI_MIN);
    }

    if ( ifir_flag && existcv(opbspti) && (exist(opbspti) < avminbspti)) {
        epic_error(use_ermes, "The selected BSP TI must be increased to %d ms for the current prescription.",
                   EM_PSD_BSPTI_OUT_OF_RANGE1, EE_ARGS(1), INT_ARG, (int)(avminbspti/1ms));
        return FAILURE;
    }    

    if ( ifir_flag && existcv(opbspti) && (exist(opbspti) > avmaxbspti)) {
        opbspti = avmaxbspti;
        epic_error(use_ermes, "The selected BSP TI must be decreased to %d ms for the current prescription.",
                   EM_PSD_BSPTI_OUT_OF_RANGE2, EE_ARGS(1), INT_ARG, (int)(avmaxbspti/1ms));
        return FAILURE;
    }    

    /* MRIge86743 -- Default opautoti ON for FS FIESTA */    
    /* MRIge91682 */  
    if(specir_flag && (ssfp_flag || lava_flag || brava_flag || aspir_flag))
    {
        cvdef(opautoti, PSD_ON);
    } else {
        cvdef(opautoti, PSD_OFF);
    }

    opautoti = _opautoti.defval;

    if (PSD_OFF == specir_flag)
    {
        cvoverride(opautoti, PSD_OFF, PSD_FIX_OFF, PSD_EXIST_OFF);
    }

    /* MRIhc47617 */
    if (specir_flag && !irprep_flag)
    {
        avmaxti = IMin(2, avmaxti, 1000ms);
    }
    
    /*
     * Multi-Phase Screen options
     */
    pivsphasenub = 0;
    if ((mph_flag == PSD_ON) || disco_flag) {
        pimphscrn = 1;   /* display the Multi-Phase Parameter screen */
        pifphasenub = 6;
        pifphaseval2 = 1;
        pifphaseval3 = 2;
        pifphaseval4 = 5;
        pifphaseval5 = 10;
        pifphaseval6 = 15;

        pisldelnub = 6;
        pisldelval3 = 1s;
        pisldelval4 = 2s;
        pisldelval5 = 5s;
        pisldelval6 = 10s;

        /* DISCO phases, for now, no mask phase */
        if (disco_flag)
        {
            piserperph = 1;
            avminfphases = num_sub_regions + (PSD_ON == mask_phase_flag);

            pifphaseval2 = num_sub_regions + (PSD_ON == mask_phase_flag);
            pifphaseval3 = num_sub_regions+1 + (PSD_ON == mask_phase_flag);
            pifphaseval4 = num_sub_regions+2 + (PSD_ON == mask_phase_flag);
            pifphaseval5 = 2 * num_sub_regions + (2 == num_sub_regions) + (PSD_ON == mask_phase_flag);
            pifphaseval6 = 3 * num_sub_regions + (PSD_ON == mask_phase_flag);

            if (PSD_ON == exist(opdynaplan))
            {
                avminfphases = 0;

                if (exist(opresearch))
                {
                    avmindphases = num_sub_regions; /* minimal # of phases (not including Mask) */
                    avminvsphases = num_sub_regions;
                }
                else
                {
                    avmindphases = 2;
                    avminvsphases = 2;
                }
                avmaxvsphases = exist(opdynaplan_nphases) - (PSD_ON == exist(opdynaplan_mask_phase)); /* not including Mask */

                pivsphasenub = 2 + 4 + 8 + 16 + 32;
                pivsphaseval2 = avminvsphases;
                pivsphaseval3 = avminvsphases + 1;
                if (pivsphaseval3 >= avmaxvsphases)
                {
                    pivsphasenub -= 4;
                }
                pivsphaseval4 = avminvsphases + 2;
                if (pivsphaseval4 >= avmaxvsphases)
                {
                    pivsphasenub -= 8;
                }
                pivsphaseval5 = avminvsphases + 3;
                if (pivsphaseval5 >= avmaxvsphases)
                {
                    pivsphasenub -= 16;
                }
                pivsphaseval6 = avmaxvsphases;
                if (pivsphaseval6 == avminvsphases)
                {
                    pivsphasenub -= 32;
                }
            }
            else
            {
                pivsphasenub = 0;
                pisldelnub = 0;
            }
        }

        piacqnub = 0;
        setexist(opacqo,1);
        pihrepnub = 0;  /* no XRR gating */
    } else {
        _opfphases.fixedflag = 0;
        opfphases = 1;
        _opfphases.fixedflag = 1;
        setexist(opfphases,PSD_ON);
        pimphscrn = 0;   /* do not display the Multi-Phase Parameter screen */
        piserperph = 0;
    }

@inline cal3d.e cal3d_cveval1_opfphases

    /*
     * Receiver Bandwidth options
     */
    if( ssfp_flag == PSD_ON ) {
        pircbval2 = 125.0;
        pircbval3 = 100.0;
        pircbval4 = 83.33;
        pircbval5 = 62.5;
        pircbval6 = 41.67;
        pidefrbw = 125.0;                 /* default to 125kHz */
        if (osfp_flag) {
           if (cffield > B0_15000)
           {
              pircbval2 = 125.0;
              pircbval3 = 111.11;
              pircbval4 = 100.00;
              pircbval5 = 90.91;
              pircbval6 = 83.33;
              pidefrbw = 90.91;
           }
           else
           {
              pircbval2 = 125.0;
              pircbval3 = 100.0;
              pircbval4 = 90.91;
              pircbval5 = 83.33;
              pircbval6 = 62.5;
              pidefrbw = 62.5;
           }
        }
        /* ungated FatSat FIESTA */
        if( (ugfsf_flag == PSD_ON) && (value_system_flag) )
          pidefrbw = 83.3;
    } else if (bravo_flag == PSD_ON) {
        pircbval2 = 15.63;
        pircbval3 = 25.00;
        pircbval4 = 31.25;
        pircbval5 = 41.67;
        pircbval6 = 62.5;
        pidefrbw = 31.25;
    } else if (quickstep_flag) {
        pidefrbw = 125.0;
    } else if (medal_flag) {
        if (cffield > B0_15000) 
        {
           pircbnub = 5;
           pircbval2 = 142.86;
           pircbval3 = 166.67;
           pircbval4 = 200.0;
           pircbval5 = 250.0;
           pidefrbw = 166.67;
        }
        else 
        {
           pircbval2 = 62.5;
           pircbval3 = 83.33;
           pircbval4 = 90.91;
           pircbval5 = 100.0;
           pircbval6 = 125.0;
           pidefrbw = 100.0;
        }
    } else if (idealiq_flag) {
        if (cffield > B0_15000)
        {
            pircbval2 = 100.0;
            pircbval3 = 125.0;
            pircbval4 = 142.86;
            pircbval5 = 166.67;
            pircbval6 = 200.0;
            pidefrbw = 142.86;
        }
        else
        {
            pircbval2 = 62.5;
            pircbval3 = 83.33;
            pircbval4 = 100.0;
            pircbval5 = 125.0;
            pircbval6 = 142.86;
            pidefrbw = 125.00;
        }
    } else if (merge_flag && !swan_flag) {
        if (cffield > B0_15000)
        {
           pircbval2 = 41.67;
           pircbval3 = 50.0;
           pircbval4 = 62.5;
           pircbval5 = 83.33;
           pircbval6 = 90.91;
           pidefrbw = 41.67;
        }
        else
        {
           pircbval2 = 31.25;
           pircbval3 = 41.67;
           pircbval4 = 50.0;
           pircbval5 = 62.5;
           pircbval6 = 83.33;
           pidefrbw = 31.25;
        }
    } else if (swan_flag) {
        pircbval2 = 31.25;
        pircbval3 = 41.67;
        pircbval4 = 50.0;
        pircbval5 = 62.5;
        pircbval6 = 83.33;
        if (cffield > B0_15000)
           pidefrbw = 62.5;
        else
           pidefrbw = 41.67;
    } else {
        if( turbo_flag > 1 ) {
            /* MRIge91682 */
            if( lava_flag ) {
                pircbval2 = 62.5;
                pircbval3 = 83.3;
                pircbval4 = 90.91;
                pircbval5 = 100.0;
                pircbval6 = 125.0;
                pidefrbw = 62.5;
            } else if( brava_flag ) {
                if (cffield > B0_15000) {
                    pircbval2 = 125.0;
                    pircbval3 = 100.0;
                    pircbval4 = 90.91;
                    pircbval5 = 83.33;
                    pircbval6 = 62.5;
                    pidefrbw = 83.33;
                } else { 
                    pircbval2 = 100.0;
                    pircbval3 = 83.3;
                    pircbval4 = 62.5;
                    pircbval5 = 50.0;
                    pircbval6 = 41.67;
                    pidefrbw = 41.67;
                }
            } else {
                pircbval2 = 125.0;
                pircbval3 = 62.5;
                pircbval4 = 31.25;
                pircbval5 = 15.63;
                pircbval6 = 7.81;
                if ( vibrant_flag ) {
                    pidefrbw = 31.25; 
                } else { 
                    pidefrbw = 62.5;             
                }
            }
        } else if( B0_15000 == (int)cffield || B0_10000 == (int)cffield ||
                   B0_7000 == (int)cffield || B0_30000 == (int)cffield ||
                   B0_40000 == (int)cffield ) {
            pircbval2 = 125.0;            /* 1.5 T values */
            pircbval3 = 83.33;
            pircbval4 = 62.5;           
            pircbval5 = 31.25;
            pircbval6 = 15.63;
            pidefrbw = 31.25;             /* default to 31kHz */     
            if(lava_flag || (brava_flag && aspir_override)) { /* YMSmr07320  11/25/2005 YI */
                pircbval2 = 62.5;
                pircbval3 = 83.3;
                pircbval4 = 90.91;
                pircbval5 = 100.0;
                pircbval6 = 125.0;
                pidefrbw = 62.5;
            }    
        } else if( B0_2000 == (int)cffield ) {
            pircbval2 = 16.0;             /* 0.2 T values */
            pircbval3 = 12.0;
            pidefrbw = 8.0;               /* default to 8kHz */
        } else if( B0_5000 == (int)cffield ) {
            pircbval2 = 16.0;             /* 0.5 T values */
            pircbval3 = 12.0;
            pidefrbw = 8.0;               /* default to 8kHz */
        }
    }
    cvdef(oprbw, pidefrbw);
    oprbw = _oprbw.defval;

    /*
     * FOV options
     */
    if( RX_COIL_BODY == getRxCoilType() ) {
        pifovval2 = avmaxfov - 280;
        pifovval3 = avmaxfov - 240;
        pifovval4 = avmaxfov - 160;
        pifovval5 = avmaxfov - 80;
        pifovval6 = avmaxfov;
        if((cfgradcoil == GCOIL_HGC)||(cfgradcoil == GCOIL_VECTRA)) {
            pifovval6 = 450;  
        }
    } else {
        /* Currently the same FOV buttons are used for heads & surface coils */
        if( assetph_flag == PSD_ON ) { /* ASSET */
            pifovval2 = avminfov;
            pifovval3 = avminfov + (avmaxfov - avminfov)/4.0;
            pifovval4 = avminfov + (avmaxfov - avminfov)/2.0;
            pifovval5 = avminfov + 3.0*(avmaxfov - avminfov)/4.0;
            pifovval6 = avmaxfov;
        } else {
            pifovval2 = 200; 
            pifovval3 = 220;
            pifovval4 = 240;
            pifovval5 = 260;
            pifovval6 = 280;
        }
    }

    if (osfp_flag || merge_flag) {
        pifovval2 = 160;
        pifovval3 = 180;
        pifovval4 = 200;
        pifovval5 = 220;
        pifovval6 = 250;
    }

    if (medal_flag || lava_flag) {
        pifovval2 = 240;
        pifovval3 = 350;
        pifovval4 = 400;
        pifovval5 = 450;
        pifovval6 = cfsystemmaxfov;
    } else if (quickstep_flag || idealiq_flag) {
        pifovval2 = 350;
        pifovval3 = 380;
        pifovval4 = 420;
        pifovval5 = 450;
        pifovval6 = cfsystemmaxfov;
    }

    /* AMR - begin MRIge73713 */

    /*
     * Set the Minimum RBW
     */
    if( vast_mode == PSD_ON ) {
        avminrbw = 31.25;
        cvdef(ophrep, 2);
    } else {
        avminrbw = 2.0;
        cvdef(ophrep, 1);
    }
    /* MRIge91682 */
    if( lava_flag ) {
        avminrbw = 31.25;
    }

    if( brava_flag && (PSD_SAG != exist(opplane)) ) {
        if (cffield > B0_15000) 
        {
           pidefrbw=62.5;
           cvdef(oprbw, 62.5);
           avminrbw = 62.5;
        }
        else
        {
           pidefrbw = 41.67;
           cvdef(oprbw, 41.67);
           avminrbw = 41.67;
        }
    }

    if (osfp_flag) {
        if (cffield > B0_15000)
           avminrbw = 83.33;
        else
           avminrbw = 50.0;
    }

    if (merge_flag && !swan_flag) {
        if (cffield > B0_15000)
           avminrbw = 41.67;
        else
           avminrbw = 31.25;
    }

    if (swan_flag) {
        avminrbw = 31.25;
    }

    if (medal_flag) {
        /* MRIhc38426 */  
        if (exist(opvibrant) || (exist(opdisco) && breastCoil_flag)) { 
            if (medal_multitr_flag)   {
                if (cffield > B0_15000)
                {
                    avminrbw = 62.5;
                }
                else
                    avminrbw = 31.25;
            }
            else {
                if (cffield > B0_15000)
                    avminrbw = 142.86;
                else
                    avminrbw = 62.5;
            }
        }  
        else { 
            if(medal_autote_flag) {
                if (medal_multitr_flag) {
                    avminrbw = 31.25;
                } else {
                    if (cffield > B0_15000)
                        avminrbw = 83.33;
                    else
                        avminrbw = 31.25;
                }
            } else {
                if (medal_multitr_flag && (exist(oplava) || exist(opdisco))) {
                     if (cffield > B0_15000)
                        avminrbw = 83.33;
                     else
                        avminrbw = 31.25;
                } else {
                     if (cffield > B0_15000)
                        avminrbw = 142.86;
                     else
                        avminrbw = 62.5;
                }
            }
        }
    }

    /*
     * Set the Maximum RBW
     */
    avmaxrbw = maxhwrbw;
    /* Set CV maximum to HW limit */
    cvmax(oprbw, avmaxrbw);
    cvmin(oprbw, avminrbw);

    /*
     * MRIge88935/MRIge75735
     * Set the Maximum RBW for 3D FIESTA based on the prescribed FOV to
     * prevent high RBW + low FOV combinations that could cause SGA-PS
     * OverCurrent Faults (Power Supply Undervoltage) which may require
     * the SGA-PS to be replaced.  This limitation should be removed as
     * soon as the hardware fix is found.
     */

    /* MRIhc35885*/
    if( lava_flag || brava_flag || vibrant_flag || osfp_flag || merge_flag || (medal_flag && (cffield < B0_30000))) {
        avmaxrbw = 125.0;
    }

    avmaxrbw_system = avmaxrbw;  /* HCSDM00360543 */

    /* BSA - MRIge61973:  Calculate a viable avmaxrbw based on system's
       maxfov and Gx strength.  Round to nearest oprbw value. This check was
       necessary to avoid avminfov > avmaxfov for maximum rbw in some image
       orientations.  The while loop is valid because the fractional
       decimations option is always ON in this PSD */
    /* minimum FOV at maximum RBW */
    av_temp_float = (20000.0 *  avmaxrbw_system) / (GAM * ogsfXw * loggrd.tx_xyz);
    av_temp_int = 0;
    while( av_temp_float > avmaxfov ) {
        avmaxrbw_system = (maxhwrbw / (1.0 + 0.25 * av_temp_int));
        if( SUCCESS != calcvalidrbw( avmaxrbw_system, &valid_rbw, &valid_max_rbw,
                                     &valid_decimation, OVERWRITE_NONE, 0 ) ) {
        epic_error(use_ermes, "%s failed",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "calcvalidrbw");
            return FAILURE;
        }
        avmaxrbw_system = valid_rbw;
        av_temp_float = (20000.0 *  avmaxrbw_system) / (GAM * ogsfXw * loggrd.tx_xyz);
        ++av_temp_int;
    }

    /* HCSDM00360543 */
    av_temp_float = (20000.0 *  avmaxrbw) / (GAM * loggrd.tx_xyz);
    av_temp_int = 0;
    while( av_temp_float > exist(opfov) ) {
        avmaxrbw = (maxhwrbw / (1.0 + 0.25 * av_temp_int));
        if( SUCCESS != calcvalidrbw( avmaxrbw, &valid_rbw, &valid_max_rbw,
                                     &valid_decimation, OVERWRITE_NONE, 0 ) ) {
        epic_error(use_ermes, "%s failed",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "calcvalidrbw");
            return FAILURE;
        }
        avmaxrbw = valid_rbw;
        av_temp_float = (20000.0 *  avmaxrbw) / (GAM * loggrd.tx_xyz);
        ++av_temp_int;
    }

    if( SUCCESS != calcvalidrbw( exist(oprbw), &valid_rbw, &valid_max_rbw,
                                 &valid_decimation, OVERWRITE_OPRBW, 0 ) ) {
        epic_error(use_ermes, "%s failed",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "calcvalidrbw");
        return FAILURE;
    }

    /* HCSDM00360543 */
    if( (existcv(oprbw)) && (exist(oprbw) > avmaxrbw) && (PSD_ON == do_maxrbw_check_in_cveval) ) {
        epic_error(use_ermes, "The maximum bandwidth is %4.2f KHz.",
                   EM_PSD_MAX_RBW, 1, FLOAT_ARG, avmaxrbw);
        return FAILURE;
    }

    if( lava_flag || brava_flag || vibrant_flag )
    {
        if( (existcv(oprbw)) && (exist(oprbw) > avmaxrbw) ) {
            epic_error(use_ermes, "The maximum bandwidth is %4.2f KHz.",
                    EM_PSD_MAX_RBW, 1, FLOAT_ARG, avmaxrbw);
            return ADVISORY_FAILURE;
        }
    }

    /* MRIhc08023 - This Patch will report an error msg when oprbw is greater than the
    avmaxrbw rathan than reduce the oprbw automatically. The original code was removed!! */

    /* Set the Min and Max RBW values for bandwidth 2 */
    /* MRIge61973:avmaxrbw2 is not used, but these values are displayed in 
       the insensitive field of bandwidth2 - BSA */
    avminrbw2 = avminrbw;
    avmaxrbw2 = avmaxrbw;

    /* AMR - end MRIge73713 */

    /* Put slice locations in cveval, since it depends on slicezp cv */
    switch ( slicezp ) { 
    case 2 : 
        pistval2 = 0.8;
        pistval3 = 1;
        pistval4 = 1.6;
        pistval5 = 2;
        pistval6 = 3;
        break;
    case 4:
        pistval2 = 1.2;
        pistval3 = 1.6;
        pistval4 = 2.0;
        pistval5 = 2.4;
        pistval6 = 2.8;
        break;
    default:
        pistval2 = 0.7;
        pistval3 = 1;
        pistval4 = 1.5;
        pistval5 = 2;
        pistval6 = 3;
        break;
    }
    if( vast_mode ) {
        if( ssfp_flag ) {
            pistval2 = 2.0;
            pistval3 = 2.2;
            pistval4 = 2.4;
            pistval5 = 2.6;
            pistval6 = 2.8;
        } else if( irprep_flag ) {
            pistval2 = 2.0;
            pistval3 = 3.0;
            pistval4 = 5.0;
            pistval5 = 7.0;
            pistval6 = 8.0;
        }
    }
    
    if(medal_flag || lava_flag) {
        pistval2 = 1.6;
        pistval3 = 2;
        pistval4 = 3;
        pistval5 = 4;
        pistval6 = 5;
    }

    if(idealiq_flag) {
        pistval2 = 4;
        pistval3 = 6;
        pistval4 = 7;
        pistval5 = 8;
        pistval6 = 10;
    }

    /* aquisition matrix */
    maxx = 512; /* maximum xres for this psd */
    maxy = 512; /* maximum yres for this psd */

    /* ATV: added more hi-res choices for FIESTA */
    if (osfp_flag || merge_flag || ideal_flag) {
       pixresnub =  63;
       pixresval2 = 192;
       pixresval3 = 224;
       pixresval4 = 256;
       pixresval5 = 288;
       pixresval6 = 320;

       piyresval2 = 192;
       piyresval3 = 224;
       piyresval4 = 256;
       piyresval5 = 288;
       piyresval6 = 320;
       
       if (swan_flag) {
          pixresval2 = 256;
          pixresval3 = 288;
          pixresval4 = 320;
          pixresval5 = 384;
          pixresval6 = 448;

          piyresval2 = 224;
          piyresval3 = 256;
          piyresval4 = 288;
          piyresval5 = 320;
          piyresval6 = 384;
       }
    } else if (ifir_flag) {
       pixresnub =  63;
       pixresval2 = 160;
       pixresval3 = 192;
       pixresval4 = 224;
       pixresval5 = 256;
       pixresval6 = 288;

       piyresval2 = 160;
       piyresval3 = 192;
       piyresval4 = 224;
       piyresval5 = 256;
       piyresval6 = 288;
    } else if (idealiq_flag) {
       pixresnub =  63;
       pixresval2 = 160;
       pixresval3 = 192;
       pixresval4 = 224;
       pixresval5 = 256;
       pixresval6 = 288;

       piyresval2 = 160;
       piyresval3 = 192;
       piyresval4 = 224;
       piyresval5 = 256;
       piyresval6 = 288;
    }  else { 
       pixresnub =  63;       
       pixresval2 = 160;
       pixresval3 = 256;
       pixresval4 = 320;
       pixresval5 = 384;
       pixresval6 = 512;
    }

    piyresnub = 63;	/* epic.h sets this for 4 buttons, we need all 6 */

    /* Variable FOV buttons on or off depending on square pixels */
    /* backward compatibility - latha@mr *//* rectFOV&NPW  05/11/2005 YI */
    if (UnLocked) {
        piphasfovnub = 0;
        if (exist(opsquare) == PSD_ON) {
            piphasfovnub2 = 0;
        } else if(exist(opnopwrap) == PSD_ON) {
            if(rectfov_npw_support) {
                if(phasefovgt1_flag) {
                    piphasfovnub2 = 63;
                    piphasfovval2 = FMin(2, floor(10.0*(avmaxfov/(exist(opfov))))/ 10.0 , MAX_PHASEFOV); 
                    piphasfovval3 = floor(5.0*(1.0 + piphasfovval2)) / 10.0;
                    piphasfovval4 = 1.0;
                    piphasfovval5 = 0.8;
                    piphasfovval6 = 0.7;
                } else {
                    piphasfovnub2 = 63;
                    piphasfovval2 = 1.0;
                    piphasfovval3 = 0.9;
                    piphasfovval4 = 0.8;
                    piphasfovval5 = 0.75;
                    piphasfovval6 = 0.7;
                }
            } else { 
                piphasfovnub2 = 0;
            }
        } else {
            if(phasefovgt1_flag) {
                piphasfovnub2 = 63;
                piphasfovval2 = FMin(2, floor(10.0*(avmaxfov/(exist(opfov))))/ 10.0 , MAX_PHASEFOV); 
                piphasfovval3 = floor(5.0*(1.0 + piphasfovval2)) / 10.0;
                piphasfovval4 = 1.0;
                piphasfovval5 = 0.8;
                piphasfovval6 = 0.7;
            } else {
                piphasfovnub2 = 63;  /* changed from 7 to 63 MRIge42048 */
                piphasfovval2 = 1.0;
                piphasfovval3 = 0.9;
                piphasfovval4 = 0.8;
                piphasfovval5 = 0.75;
                piphasfovval6 = 0.7;
                /* End MRIge42048 */
            }
        }
    } else {
        if (exist(opsquare) == PSD_ON) {
            piphasfovnub = 0;
        } else if (exist(opnopwrap) == PSD_ON) {
            if(rectfov_npw_support) {
                piphasfovnub = 7;
            } else {
                piphasfovnub = 0;
            }
        } else { 
            piphasfovnub = 7;
        }
    }

    if(phasefovgt1_flag) {
        cvmax(opphasefov, MAX_PHASEFOV);
        cvmax(rhphasescale, 2 * MAX_PHASEFOV);
        avmaxphasefov = MAX_PHASEFOV;
    } else {
        cvmax(opphasefov, 1.0);
        cvmax(rhphasescale, 2.0);
        avmaxphasefov = 1.0;
    }

    /* MRIge91682 */
    if( ( (lava_flag && (exist(opasset) == ASSET_SCAN_PHASE)) || 
        ((!disco_flag) && arc_flag && (lava_flag || medal_flag || quickstep_flag || bravo_flag)) ) ||
        ( brava_flag && ((ASSET_SCAN_PHASE == exist(opasset)) || vibrantxv_flag) ) )
    {
        /* LAVA or VIBRANT with phase asset and ARC applications */

        if( PSD_ON == opsquare)
        {
            piphasfovnub2 = 0;
        }
        else if(exist(opnopwrap) == PSD_ON)
        {
            if(rectfov_npw_support)
            {
                if (phasefovgt1_flag)
                {
                    piphasfovnub2 = 1+2+4+8+16+32;
                    piphasfovval2 = FMin(2, floor(10.0*(avmaxfov/(exist(opfov))))/ 10.0 , MAX_PHASEFOV); 
                    piphasfovval3 = floor(5.0*(1.0 + piphasfovval2)) / 10.0;
                    piphasfovval4 = 1.0;
                    if ( brava_flag && ((ASSET_SCAN_PHASE == exist(opasset)) || vibrantxv_flag) )
                    {
                        piphasfovval5 = 0.95;
                        piphasfovval6 = 0.9;
                        cvmin(opphasefov, 0.9);
                        cvmax(opphasefov, 3.0);
                        cvdef(opphasefov, 0.9); 
                    }
                    else
                    {
                        piphasfovval5 = 0.9;
                        piphasfovval6 = 0.8;
                        cvmin(opphasefov, 0.8);
                        cvmax(opphasefov, 3.0);
                        cvdef(opphasefov, 0.9); 
                    }
                }
                else
                {
                    piphasfovnub2 = 1+2+4+8;
                    piphasfovval2 = 1.0;
                    if ( brava_flag && ((ASSET_SCAN_PHASE == exist(opasset)) || vibrantxv_flag) )
                    {
                        piphasfovval3 = 0.95;
                        piphasfovval4 = 0.9;
                        cvmin(opphasefov, 0.9);
                        cvmax(opphasefov, 1.0);
                        cvdef(opphasefov, 0.9); 
                    }
                    else
                    {
                        piphasfovval3 = 0.9;
                        piphasfovval4 = 0.8;
                        cvmin(opphasefov, 0.8);
                        cvmax(opphasefov, 1.0);
                        cvdef(opphasefov, 0.9);
                    }
                }
            }
            else
            { 
                piphasfovnub2 = 0;
            }
        }
        else
        {
            if (phasefovgt1_flag)
            {
                piphasfovval2 = FMin(2, floor(10.0*(avmaxfov/(exist(opfov))))/ 10.0 , MAX_PHASEFOV); 
                piphasfovval3 = floor(5.0*(1.0 + piphasfovval2)) / 10.0;
                piphasfovval4 = 1.0;
                if ( brava_flag && ((ASSET_SCAN_PHASE == exist(opasset)) || vibrantxv_flag) )
                {
                    if ( piphasfovval3 > 1.0 ) {
                       piphasfovnub2 = 1+2+4+8+16+32;
                    } else if ( piphasfovval2 > 1.0 ) {
                       piphasfovnub2 = 1+2+8+16+32;
                    } else {
                       piphasfovnub2 = 1+8+16+32;
                    }

                    piphasfovval5 = 0.95;
                    piphasfovval6 = 0.9;
                    cvmin(opphasefov, 0.9);
                    cvmax(opphasefov, 3.0);
                    cvdef(opphasefov, 0.9); 
                }
                else
                {
                    if ( piphasfovval3 > 1.0 ) {
                       piphasfovnub2 = 1+2+4+8+16+32;
                    } else if ( piphasfovval2 > 1.0 ) {
                       piphasfovnub2 = 1+2+8+16+32;
                    } else {
                       piphasfovnub2 = 1+8+16+32;
                    }
                    
                    piphasfovval5 = 0.9;
                    piphasfovval6 = 0.8;
                    cvmin(opphasefov, 0.8);
                    cvmax(opphasefov, 3.0);
                    cvdef(opphasefov, 0.9); 
                }
            }
            else
            {
                piphasfovnub2 = 1+2+4+8;
                piphasfovval2 = 1.0;
                if ( brava_flag && ((ASSET_SCAN_PHASE == exist(opasset)) || vibrantxv_flag) )
                {
                    piphasfovval3 = 0.95;
                    piphasfovval4 = 0.9;
                    cvmin(opphasefov, 0.9);
                    cvmax(opphasefov, 1.0);
                    cvdef(opphasefov, 0.9); 
                }
                else
                {
                    piphasfovval3 = 0.9;
                    piphasfovval4 = 0.8;
                    cvmin(opphasefov, 0.8);
                    cvmax(opphasefov, 1.0);
                    cvdef(opphasefov, 0.9);
                }
            }
        }
    }
 
    if (ifir_flag)
    {
        if (PSD_ON == opsquare) 
        {
            piphasfovnub2 = 0;
        } 
        else 
        {
           cvmin(opphasefov, 0.75);
           cvdef(opphasefov, 0.9);
           if(PSD_OFF == phasefovgt1_flag)
           {
                piphasfovnub2 = 1+2+4+8+16;
                piphasfovval2 = 1.0;
                piphasfovval3 = 0.9;
                piphasfovval4 = 0.8;
                piphasfovval5 = 0.75;
                cvmax(opphasefov, 1.0);
           }
           else
           {
                piphasfovval6 = 0.75;
           }
        }
    }

    if (headneck_pos_scan)
    {
        piphasfovnub = 0;
        piphasfovnub2 = 0;
        cvoverride(opphasefov,1.0,PSD_FIX_ON,PSD_EXIST_ON);

        piyresnub = 0;
        cvdef(opyres, HEADNECK_SCAN_MATRIX);
        cvoverride(opyres,HEADNECK_SCAN_MATRIX,PSD_FIX_ON,PSD_EXIST_ON);
    }

    pi_piphasfovnub = piphasfovnub + piphasfovval2; /* rectFOV&NPW  05/11/2005 YI */

    /* Asymmetric FOV */
    /* handling for phase (y) resolution and recon scale factor */
    eg_phaseres = exist(opyres);

    if (vstrte_flag) {
        eg_phaseres = IMin (2, eg_phaseres, 40);
    }

    pfky_fraction = (float) eg_phaseres/exist(opyres);

    /* In cvcheck() NPW and Square Pixel are mutually exclusive so
       this if-else separation is OK. */
    if( (existcv(opnopwrap) && (exist(opnopwrap) == PSD_ON) && !rectfov_npw_support) || ((exist(opsquare) != PSD_ON) && (pi_piphasfovnub == 0) && rectfov_npw_support) ) {
        rhphasescale = 1.0;
        cvoverride(opphasefov, rhphasescale, PSD_FIX_ON, PSD_EXIST_ON);
    } else if( (exist(opsquare) == PSD_ON) && existcv(opsquare) ) {
        rhphasescale = (float)exist(opyres) / (float)exist(opxres);
        /* Allow Phase FOV to go higher than 1.0 to catch errors later *//* YMSmr06736 05/11/2005 YI */
        /*cvmax(opphasefov, (rhphasescale > 1.0 ? rhphasescale : 1.0));*//* removed. YMSmr07181 */
        /* YMSmr07181: opphasefov is overrode only when opyres<=opxres in case of SqP.
           cvcheck() will return ADVISORY_FAILURE if opyres>opxres in case of SqP */
        if( existcv(opyres) && existcv(opxres) && (rhphasescale<=1.0) ){
            cvoverride(opphasefov, rhphasescale, PSD_FIX_ON, PSD_EXIST_ON);
            eg_phaseres = exist(opxres);
        }
    } else if( UnLocked ) {
        if( ((exist(opphasefov) < avminphasefov)
             || (exist(opphasefov) > avmaxphasefov))
            && existcv(opphasefov) )
        {
            epic_error( use_ermes,
                        "Phase FOV less than %0.2f and greater than %0.2f are not supported.",
                        EM_PSD_PHASEFOV_OUT_OF_RANGE2, EE_ARGS(2), FLOAT_ARG, 
                        avminphasefov, FLOAT_ARG, avmaxphasefov, 0 );
            return FAILURE;
        } else {
            rhphasescale = exist(opphasefov);
        }
    } else if ( (0 == piphasfovnub) && (0 == piphasfovnub2) ) {
        rhphasescale = 1.0;
        cvoverride(opphasefov, rhphasescale, PSD_FIX_ON, PSD_EXIST_ON);
    }
    
    cvoverride(rhfreqscale, opfreqfov, PSD_FIX_ON, PSD_EXIST_ON);

    if (quickstep_flag || headneck_pos_scan)
    {
       pircbnub = 0;
    }

    /* Put in respiratory trigger */
    /* Some buttons still show up that shouldn't */
    if (PSD_ON == ifir_flag)
    {
       pirtrepnub = 4 + 2 + 1; /* bit mask for resp rep buttons */
       pirtrepval2 = 1; 
       pirtrepval3 = 2; 
       if(PSD_ON == navtrig_flag)
       {
           pirtpointnub = 0;
       } else {
           pirtpointnub = 8 + 2;
       }
       pirtrigwinnub = 0;
    } else if ((PSD_OFF == navtrig_flag) && (PSD_OFF == navgate_flag)) {
       pirtrepnub = 0; /* bit mask for resp rep buttons */
       pirtrepval2 = 5; 
       pirtrepval3 = 4; 
       pirtpointnub = 31;
       pirtrigwinnub = 5;
    }
    pirtseqnub = 0;/*     inter-seq delay buttons (bitmap) */
    pitseqnub = 0; /* jensong found this */

    /* ***************************
       ISI parameters
       *************************** */

    if (isi_flag == PSD_ON)
    {
        if (cine3d_flag == PSD_ON)
        {
            pw_isi7 = 200us;
        } else {
            pw_isi7 = 100us;
        } 
        ssp_pwisi7 = IMax(2, pw_isi7+10, pw_gxw);
    }
    else
    {
        ssp_pwisi7 = pw_gxw;
    }


    if (!ss_rf1) 
    {
       /* iso_delay and bw are set after scalerfpulses has been called */
       /* If pulse width of 90 scaled, then scale off90 accordingly */

       iso_delay = RUP_GRD((int)((float)rfpulse[RF1_SLOT].isodelay*
                              pw_rf1/rfpulse[RF1_SLOT].nom_pw));
       bw_rf1 = (int)rfpulse[RF1_SLOT].nom_bw*rfpulse[RF1_SLOT].nom_pw/pw_rf1;

       t_exb = iso_delay;
    }

    /* ***************************
       Multi-Phase parameters
       *************************** */

    if (mph_flag == PSD_ON) {
        if ( exist(opfphases) == 1 ) {
            sldelay = TR_PASS;        /* interslice delay */
        } else {
            sldelay = (int)(opsldelay);
        }

        sldeltime = IMax(2, (sldelay - TR_PASS), 0);
        /* actual delay time after TR_PASS */
    }


    area_gzrf0k = GZRF0KAREA_FGRE3D;
    if ((amppwgradmethod(&gradz[GZRF0K_SLOT], area_gzrf0k, loggrd.tz,
                         0.0 /* start amp */, 0.0 /* end amp */,
                         loggrd.zrt, MIN_PLATEAU_TIME))==FAILURE) {
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"amppwgradmethod:gzrf0k");
        return FAILURE;
    }

    if(ifir_frir_flag)
    {
        if ((amppwgradmethod(&gradz[GZKRFFRIR_SLOT], area_gzrf0k, loggrd.tz,
                             0.0 /* start amp */, 0.0 /* end amp */,
                             loggrd.zrt, MIN_PLATEAU_TIME))==FAILURE) 
        {
            epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1),STRING_ARG,"amppwgradmethod:gzkrffrir");
            return FAILURE;
        }
    }

    /* **************************************************************
       Other Gradient Waveforms
       ************************************************************* */
    gradz[GZRF1_SLOT].num = 1;
    gradz[GZCOMB_SLOT].num = 1;
    gradz[GZP_SLOT].num = 1;
    gradx[GX1_SLOT].num = 1;
    gradx[GXW_SLOT].num = 1;

    if (exist(opetl)>=2) {
       gradx[GXW2_SLOT].num = exist(opetl)-1;
       gradx[GX2_SLOT].num  = exist(opetl)-1;
    }
    else
    {
       gradx[GXW2_SLOT].num = 0;
       gradx[GX2_SLOT].num = 0;
    }

    if (flow_comp_type == TYPFC) {
       gradz[GZ1_SLOT].num = 1;
       gradx[GXFC_SLOT].num = 1;
       grady[GYFE1_SLOT].num = 0;
       grady[GYFE2_SLOT].num = 0;
    }
    else if (flow4D_flag==PSD_ON) 
    {
       gradz[GZ1_SLOT].num = 1;
       gradx[GXFC_SLOT].num = 1;
       grady[GYFE1_SLOT].num = 1;
       grady[GYFE2_SLOT].num = 1;
    } 
    else
    {
       gradz[GZ1_SLOT].num = 0;
       gradx[GXFC_SLOT].num = 0;
       grady[GYFE1_SLOT].num = 0;
       grady[GYFE2_SLOT].num = 0;
    }

    if( PSD_ON == tricks_flag ) {
        gradx[GXW_SLOT].num = 1;
    }

    /* sat pulse activity */
    if (sp_sat == PSD_ON ) {
        gradx[GKSX_SLOT].num = 1;
        gradz[GKSZ_SLOT].num = 1;
    } else {
        gradx[GKSX_SLOT].num = 0;
        gradz[GKSZ_SLOT].num = 0;
    }

    std_amp = .818;               /* standard amplitude of 1 sinc pulse */

    /* ****************
       Nex bookkeeping - no phase wrap adjustments and error messages
       ************** */  
    if( exist(opnopwrap) == PSD_ON ) {
        pinexnub = 1 + 8 + 16 + 32;
        pinexval4 = 1;
        pinexval5 = 2;
        pinexval6 = 3;
        if(ugfsf_flag) {
            pinexval6 = 4;
        }
        if(idealiq_flag)
        {
            pinexval4 = 1.5; /* 1.5 NEX NPW - equivalent to fn = 0.75 */
        }
    } else {
        if( (exist(opautote) == PSD_MINTEFULL) && (UnLocked) ) {
            if (PSD_ON == exist(oplava))
            {
                pinexnub = 1 + 4 + 8 + 16 + 32;
                pinexval3 = 1;
                pinexval4 = 2;
                pinexval5 = 3;
                pinexval6 = 4;
            }
            else
            {
                pinexnub = 1 + 2 + 4 + 8 + 16 + 32;
                pinexval2 = 0.5;
                pinexval3 = 0.75;
                pinexval4 = 1;
                pinexval5 = 2;
                pinexval6 = 3;
            }
        } else {
            pinexnub = 1 + 4 + 8 + 16 + 32;
            pinexval3 = 1;
            pinexval4 = 2;
            pinexval5 = 3;
            pinexval6 = 4;
        }

        if (heart3d_flag && vast_mode)
        {
            pinexnub = 2 + 4;
            pinexval2 = 0.5;
            pinexval3 = 1.0; 
        }

        if( idealiq_flag ) {
            pinexnub = 1 + 2 + 4 + 8;
            pinexval2 = 0.75;
            pinexval3 = 1;
            pinexval4 = 2;
        }
        if (cine3d_flag) {
           pinexnub = 1 + 4 + 8 + 16 + 32;
           pinexval3 = 1;
           pinexval4 = 3;
           pinexval5 = 4;
           pinexval6 = 5;
        }
    }

    {
        /*
         * One of the VAST enhancements is to set NEX to 0.5 for all
         * cardiac gated acquisitions and to prevent the user from
         * changing this choice.  We have to add some logic to prevent
         * this value to be maintained during switches.
         */
        static int nex_override = PSD_OFF;

        if( (vast_mode == PSD_ON) && (exist(opcgate) == PSD_ON) && ((!heart3d_flag) || (heart3d_flag && irprep_flag && (PSD_OFF==navgate_flag))) ) {
            pinexnub = 0;
            cvoverride(opnex, 0.5, PSD_FIX_ON, PSD_EXIST_ON);
            cvdef(opnex, 0.5);
            nex_override = PSD_ON;
        } else if( turbo_cemra_enable ) {
           if( quickstep_flag )
           {
               pinexnub = 0;
               cvoverride(opnex, 0.5, PSD_FIX_ON, PSD_EXIST_ON);
               cvdef(opnex, 0.5);
           }
           else
           {
               opnex = 1.0;
               cvdef(opnex, 1.0);
               pinexnub=1+2+4+8;
               pinexval2 = 0.5;
               pinexval3 = 0.75;
               pinexval4 = 1;
           }
           nex_override = PSD_ON;
        } else if( brava_flag || osfp_flag || merge_flag || quickstep_flag || (medal_flag && (PSD_OFF == exist(oplava))) 
                   || msde_flag
                   || (multiEcho_flag && !idealiq_flag) || disco_flag ) { /* MRIge91682 */
            pinexnub=0;
            cvoverride(opnex, 1.0, PSD_FIX_ON, PSD_EXIST_ON);
            cvdef(opnex, 1.0);
            nex_override = PSD_ON;
        } else if( (PSD_ON == exist(oplava)) && ((PSD_ON == exist(opnav)) || (ASSET_SCAN_PHASE == exist(opasset)) || (ASSET_SCAN_SLICE == exist(opasset))) ) {
            pinexnub=0;
            cvoverride(opnex, 1.0, PSD_FIX_ON, PSD_EXIST_ON);
            cvdef(opnex, 1.0);
            nex_override = PSD_ON;
        } else if(ifir_flag) {
            pinexnub=0;
            if ( 1==exist(oprtrep) )
            {
               cvoverride(opnex, 0.5, PSD_FIX_ON, PSD_EXIST_ON);
               cvdef(opnex, 0.5);
            } else {
               cvoverride(opnex, 1.0, PSD_FIX_ON, PSD_EXIST_ON);
               cvdef(opnex, 1.0);
            }
            nex_override = PSD_ON;
        } else if (headneck_pos_scan) {
            pinexnub=0;
            cvdef(opnex, 1.0);
            cvoverride(opnex, 1.0, PSD_FIX_ON, PSD_EXIST_ON);
            nex_override = PSD_ON;
        } else {
            /*
             * If we are switching from VAST, then unset the NEX;
             * otherwise, just set a default value and let scan set it
             * from that point on.
             */
            if( PSD_ON == nex_override ) {
                cvoverride(opnex, 1.0, PSD_FIX_OFF, PSD_EXIST_OFF);
                nex_override = PSD_OFF;
            } else {
                opnex = 1.0;
            }
            cvdef(opnex, 1.0);

            if (heart3d_flag)
            {
                opnex = 0.5;
                cvdef(opnex,0.5);
            }
        }
    }

    /* VAL15  04/08/2005 YI */
    if(pcfiesta_flag && (pc_mode < PC_BASIC)) {
        opnex = 2.0;
        cvdef(opnex, 2.0);
        pinexnub = 1 + 2 + 4 + 8; 
        if(exist(opnopwrap) == PSD_ON) {  /* NPW On */
            if(pc_mode == PC_APC) { /* APC */
                pinexval2 = 4.0;
                pinexval3 = 6.0;
                pinexval4 = 8.0;
            } else {                /* SGS */
                pinexval2 = 8.0;
                pinexval3 = 12.0; 
                pinexval4 = 16.0; 
            }
        } else {                          /* NPW Off */
            if(pc_mode == PC_APC) { /* APC */
                pinexval2 = 2.0;
                pinexval3 = 3.0;
                pinexval4 = 4.0;
            } else {                /* SGS */
                pinexval2 = 4.0;
                pinexval3 = 6.0; 
                pinexval4 = 8.0; 
            }
        }
    }

    /*
     * nextemp is declared as an integer.  The intent is to guard
     * against odd nex or fractional nex other than 0.5, 0.75, 1.5.
     */

    nextemp = exist(opnex);
    rhhnover = 0;	/* init */
    fn = 1;	/* init */
    nex = 1;	/* init */

    /* added backward compatibility - latha@mr */
    if ((exist(opnex)==0) || ((exist(opnex) != nextemp) && (!UnLocked))) {
        epic_error( use_ermes, "The selected number of excitations is not valid for the current prescription.", EM_PSD_NEX_OUT_OF_RANGE, EE_ARGS(0) );
        return FAILURE;
    }

    if (PSD_ON == exist(oplava))
    { /* Make sure a valid integer NEX value is Rxed */ 
        if ( floorf(exist(opnex)) != (exist(opnex)) )
        {
            epic_error( use_ermes, "The selected number of excitations is not valid for the current prescription.", EM_PSD_NEX_OUT_OF_RANGE, EE_ARGS(0) );
            return FAILURE;
        }
    }

    if (UnLocked)
    {
        if (exist(opnex) == .50)
        {
            if (nop == 2)
            {
                if( 0 == pinexnub )
                {
                    epic_error( use_ermes, "The No Phase Wrap option is invalid in this psd.", EM_PSD_NOPWRAP_INCOMPATABLE, EE_ARGS(0) );
                }
                else
                {
                    epic_error( use_ermes, "This nex is not valid for No Phase Wrap.", EM_PSD_NPW_INCOMPATIBLE, EE_ARGS(0) );
                }
                return FAILURE;
            }
            fn = exist(opnex);
            nex = 1;
        }
        else if (exist(opnex) == 0.75)
        {
            if (nop == 2)
            {
                if( 0 == pinexnub )
                {
                    epic_error( use_ermes, "The No Phase Wrap option is invalid in this psd.", EM_PSD_NOPWRAP_INCOMPATABLE, EE_ARGS(0) );
                }
                else
                {
                    epic_error( use_ermes, "This nex is not valid for No Phase Wrap.", EM_PSD_NPW_INCOMPATIBLE, EE_ARGS(0) );
                    return FAILURE;
                }
            }
            fn = .75;
            nex = 1;
        }
        else if (exist(opnex) == 1.5)
        {
            if (exist(opnopwrap) == PSD_ON)
            {
                fn = .75;
                nex = 1;
            }
            else
            {
                fn = 1;
                nex =2;
            }
        }
        else if (exist(opnex) - nextemp)
        {
            epic_error( use_ermes, "A fractional nex other than .5, .75, or 1.5 with No Phase Wrap is not allowed.", EM_PSD_FNEX_OUT_OF_RANGE, EE_ARGS(0) );
            return FAILURE;
        }
        else
        {
            if (( nop == 2 ) && (exist(opnex) == 1) && existcv(opnex))
            {
                if (medal_flag || osfp_flag || cine3d_flag || (pfkr_flag  && !(vibrant_flag || brava_flag) ) ) 
                   fn = 1.0;
                else
                   fn = 0.5;
            }
            else
            {
                fn = 1;
            }
        }

        if (heart3d_flag)
        {
            if (exist(opnex) > 1)
            {
               epic_error( use_ermes, "%s is incompatible with %s",
                           EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                           STRING_ARG, "3D Heart",
                           STRING_ARG, " a multiple NEX prescription" );
               return FAILURE;
            }

            if ( (exist(opnex) > 0.74) && (exist(opnex) < 0.76) )
            {
               epic_error( use_ermes, "%s is incompatible with %s",
                           EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                           STRING_ARG, "3D Heart",
                           STRING_ARG, " 0.75 NEX prescription" );
               return FAILURE;
            }
        }
    } else {
        if ((exist(opnex)==1) && (nop==2) && (existcv(opnex))) {
            epic_error( use_ermes, "This nex is not valid for No Phase Wrap.", EM_PSD_NPW_INCOMPATIBLE, EE_ARGS(0) );
            avminnex = 2.0;
            avmaxnex = 2.0;
            return ADVISORY_FAILURE;
        }
    } /* end backward compatibility */

    if (pfkyz2kr_flag) {
        if (turbo_cemra_flag) {
          pfkr_flag = PSD_ON;
          pfkr_fraction = 0.7;
        } else if ((fn < 1.0) && !(brava_flag || vibrant_flag)) {
          pfkr_flag = PSD_ON;
          if (fn == 0.5)
          {
             pfkr_fraction = 0.7;
          }
          else if (fn == 0.75)
          {
             pfkr_fraction = 0.75;
          }
          else
          {
             pfkr_fraction = PI/4.0;
          }
          fn = 1.0;
       }
       if ( pfkr_flag && (exist(opnopwrap) == PSD_ON) ) {
           cvmin(pfkr_fraction_act, 0.5); /* MRIhc20624 */
           if ( (fn < 1.0) && (pfkz_fraction < 1.0)) {
               pfkr_fraction = 0.78;
           } else if ((exist(opnex) > 1) || (pfkz_fraction < 1.0)) {			  		
               pfkr_fraction = 0.7;
           } else {
               pfkr_fraction = 0.6;
           }
       }
    } else {
       if (!osfp_flag) {
          pfkr_flag = PSD_OFF;
          pfkr_fraction = 1.0;
       }
    }
    
    if ( fn == 0.5) {
        if (ifir_flag) {
            rhhnover = (int)(30*nop);
        } else {
            rhhnover = (int)(16*nop); 
        } 
        /* MRIhc09877: Don't collect more overscans than regular
           lines. Also in function phase_order_fgre3d(), reverse 
           centric ordering fails when rhhnover > rhnframes. */
        rhhnover = IMin(2, rhhnover, rhnframes); 
    } else {
        rhhnover = 0;
    }
    
    /* ARC Fractional NEX support  MRIhc16180 */
    if (arc_flag && (fn < 1.0) && (arc_ph_stride > 1.0))
    {
        int phCalUpperSize;
        /* Fractional NEX must not cut into calibration region */
        if (0.5 == fn)
        {
            phCalUpperSize = arc_ph_calupper - unaccel_rhnframes + 1;
        }
        else
        {
            phCalUpperSize = arc_ph_calupper - phaseres/2 + 1;
        }
        phCalUpperSize = phCalUpperSize + phCalUpperSize % 2;

        if ((fn > 0.5) && 
            ( (int)ceilf((FLOAT)phaseres * fn) < (int)ceilf((FLOAT)phaseres/2.0 + phCalUpperSize)))
        {
            /* If Fractional NEX without overscan cuts into calibration convert to 0.5 NEX */
            fn = 0.5;
            rhhnover = IMin(2,(int)(16 * nop), rhnframes);
        }

        rhhnover = rhhnover + rhhnover % 2;

        if (0.5 == fn)
        {
            arc_ph_calupper = unaccel_rhnframes + rhhnover - 1;
            arc_ph_calwidth = arc_ph_calupper - arc_ph_callower + 1;            
        }
    }

    /* MRIge45694: Use Homodyne- II 
       for fractional echo processing: pradeeps@wiproge  */
    if ((fn < 1.0)  || (rhtype & RHTYPFRACTECHO)) {
        rhhniter = 1;  /* Use homodyne-II */
    }

    /* nex calculation for oddnex */
    if (fn == 1)  {
        if (PSD_ON == exist(oplava)) {
            nex = IMax(2,(int) 1,(int)exist(opnex));
        } else if ( (((int)exist(opnex))%2) && (exist(opnex) > 2) && (nop == 2)) {
            nex = IMax(2,(int) 1,(int)((exist(opnex)+1)/nop));
        } else  { 
            nex = IMax(2,(int) 1,(int)(exist(opnex)/nop));
        }
    }

    /*  Flag setting for Odd Nex */

    /* reset odd NEX flags. The else was removed from the
       following if statement because it duplicates code. */
    oddnex_npw = PSD_OFF;

    if  ( (PSD_OFF == exist(oplava)) && (((int)exist(opnex))%2) && (exist(opnex) > 2) && (nop == 2) ) {
        oddnex_npw = PSD_ON;
    } 

    /* In oddnex npw, last excitation covers only half k-space */
    if (oddnex_npw == 1) {
        truenex = ((float)nex - 0.5);
    } else { 
        truenex = (float)nex;
    }

    if ((exist(opnopwrap) != PSD_ON) && (opnex == 1.5)) {
        nex = 2;
        truenex = ((float)nex - 0.5);
    }

    if(pc_mode < PC_BASIC)nex_save = nex; /* VAL15 12/14/2004 YI */

    /* BRAVA/VIBRANT - Frequency direction is defaulted to AP */
    if( brava_flag || vibrant_flag ) {
        piswapfc = 1;
        cvoverride(opspf, 1, PSD_FIX_ON, PSD_EXIST_ON);
    }

    /* KLUDGE:  These amplitudes and pulse widths should be set
       using amppwgrad. */
    if (exist(opfluorotrigger)==PSD_ON)
    {
        area_gxks = 800.0;
        area_gyks = 1500.0;
        area_gzks = 800.0;
    }
    else
    {
        area_gxks = GXSATKILLER;
        area_gyks = GYSATKILLER;
        area_gzks = GZSATKILLER;
    }

    /* MRIge55533 JAH: When spatial sat and chem sat are both on,
       unwanted coherence(s) creeps into the signal. Investigation
       showed it could be eradicated most efficiently by inverting 
       the sign of the spatial sat z crusher. */
    if( (fatFlag == PSD_ON) || (exist(opwater) == PSD_ON)) {
        area_gzks = -area_gzks;
    }

    if (exist(opfluorotrigger)==PSD_ON)
    {
        SCAN_INFO satscaninfo;

        sp_get_scaninfo_matrix(&sat_info[0][0],&satscaninfo);

        if (obloptimize(&satloggrd, &phygrd,
                        &satscaninfo, 1,
                        PSD_OBL, SAT_COAX, SAT_OBL_METHOD,
                        sat_obl_debug, &sat_newgeo, cfsrmode)==FAILURE) {
            epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1),STRING_ARG,"obloptimize");
            return FAILURE;
        }

        if ((amppwgrad(area_gxks, satloggrd.tx_xyz,
                       0.0 /* start amp */, 0.0 /* end amp */,
                       satloggrd.xrt, MIN_PLATEAU_TIME, &a_gxks,
                       &pw_gxksa, &pw_gxks, &pw_gxksd))==FAILURE) {
            epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1),STRING_ARG,"amppwgrad:gxks");
            return FAILURE;
        }

        if ((amppwgrad(area_gyks, satloggrd.ty_xyz,
                       0.0 /* start amp */, 0.0 /* end amp */,
                       satloggrd.yrt, MIN_PLATEAU_TIME, &a_gyks,
                       &pw_gyksa, &pw_gyks, &pw_gyksd))==FAILURE) {
            epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1),STRING_ARG,"amppwgrad:gyks");
            return FAILURE;
        }

        if ((amppwgrad(area_gzks, satloggrd.tz_xyz,
                       0.0 /* start amp */, 0.0 /* end amp */,
                       satloggrd.zrt, MIN_PLATEAU_TIME, &a_gzks,
                       &pw_gzksa, &pw_gzks, &pw_gzksd))==FAILURE) {
            epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1),STRING_ARG,"amppwgrad:gzks");
            return FAILURE;
        }
    }
    else
    {
        if ((amppwgrad(area_gxks, loggrd.tx_xyz,
                       0.0 /* start amp */, 0.0 /* end amp */,
                       loggrd.xrt, MIN_PLATEAU_TIME, &a_gxks,
                       &pw_gxksa, &pw_gxks, &pw_gxksd))==FAILURE) {
            epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1),STRING_ARG,"amppwgrad:gxks");
            return FAILURE;
        }

        if ((amppwgrad(area_gyks, loggrd.ty_xyz,
                       0.0 /* start amp */, 0.0 /* end amp */,
                       loggrd.yrt, MIN_PLATEAU_TIME, &a_gyks,
                       &pw_gyksa, &pw_gyks, &pw_gyksd))==FAILURE) {
            epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1),STRING_ARG,"amppwgrad:gyks");
            return FAILURE;
        }

        if ((amppwgrad(area_gzks, loggrd.tz_xyz,
                       0.0 /* start amp */, 0.0 /* end amp */,
                       loggrd.zrt, MIN_PLATEAU_TIME, &a_gzks,
                       &pw_gzksa, &pw_gzks, &pw_gzksd))==FAILURE) {
            epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1),STRING_ARG,"amppwgrad:gzks");
            return FAILURE;
        }
    }

    if (ifir_flag == PSD_ON)
    {
        if (InversionGRxEval() == FAILURE)
        {
            epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "InversionGRxEval");
            return FAILURE;
        }
    }

    if (SpSatEval(&sp_sattime) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "SpSatEval");
        return FAILURE;
    }

    piccsatnub = 0;    /* MRIge44780-lock out ConSat */


    if (sp_sat) {
        int sp_extra, sp_extra_max;   /* MRIge45215 & MRIge45218 (search for sp_extra) */

        sp_extra_max = 0;
        if ((exist(opsat)!=PSD_OFF) && (exist(opsatx)!=PSD_OFF))  {
            /*
              since SpSatEval calcs. a different value of pw_gyksx1 than
              we are going to use, subtract off its value, then set our value
              and add it back on
            */
            sp_sattime -= (pw_gyksx1a + pw_gyksx1 + pw_gyksx1d);
            pw_gyksx1 = pw_gyks;
            pw_gyksx1a = pw_gyksa;
            pw_gyksx1d = pw_gyksd;
            sp_sattime += (pw_gyksx1a + pw_gyksx1 + pw_gyksx1d);
            a_gyksx1 = a_gyks;
        }

        if ((exist(opsat)!=PSD_OFF) && (exist(opsaty)!=PSD_OFF))  {
            sp_sattime -= (pw_gyksy1a + pw_gyksy1 + pw_gyksy1d);
            pw_gyksy1 = pw_gyks;
            pw_gyksy1a = pw_gyksa;
            pw_gyksy1d = pw_gyksd;
            sp_sattime += (pw_gyksy1a + pw_gyksy1 + pw_gyksy1d);
            a_gyksy1 = a_gyks;
        }

        if ((exist(opsat)!=PSD_OFF) && (exist(opsatz)!=PSD_OFF))  {
            sp_sattime -= (pw_gyksz1a + pw_gyksz1 + pw_gyksz1d);
            pw_gyksz1 = pw_gyks;
            pw_gyksz1a = pw_gyksa;
            pw_gyksz1d = pw_gyksd;
            sp_sattime += (pw_gyksz1a + pw_gyksz1 + pw_gyksz1d);
            a_gyksz1 = a_gyks;
        }

        if ((exist(opexsatmask) & PSD_EXPLICIT_1) != 0) {
            sp_extra = (pw_gyksa + pw_gyks + pw_gyksd);
            sp_extra -= (pw_gykse1a + pw_gykse1 + pw_gykse1d);
            sp_extra_max = (sp_extra > sp_extra_max) ? sp_extra : sp_extra_max;
            pw_gykse1 = pw_gyks;
            pw_gykse1a = pw_gyksa;
            pw_gykse1d = pw_gyksd;
            a_gykse1 = a_gyks;
        } else if ((exist(opexsatmask) & PSD_EXPLICIT_2) != 0) {
            sp_extra = (pw_gyksa + pw_gyks + pw_gyksd);
            sp_extra -= (pw_gykse2a + pw_gykse2 + pw_gykse2d);
            sp_extra_max = (sp_extra > sp_extra_max) ? sp_extra : sp_extra_max;
            pw_gykse2 = pw_gyks;
            pw_gykse2a = pw_gyksd;
            pw_gykse2a = pw_gyksd;
            a_gykse2 = a_gyks;
        }

        if ((exist(opexsatmask) & PSD_EXPLICIT_3) != 0) {
            sp_extra = (pw_gyksa + pw_gyks + pw_gyksd);
            sp_extra -= (pw_gykse3a + pw_gykse3 + pw_gykse3d);
            sp_extra_max = (sp_extra > sp_extra_max) ? sp_extra : sp_extra_max;
            pw_gykse3 = pw_gyks;
            pw_gykse3a = pw_gyksa;
            pw_gykse3d = pw_gyksd;
            a_gykse3 = a_gyks;
        } else if ((exist(opexsatmask) & PSD_EXPLICIT_4) != 0) {
            sp_extra = (pw_gyksa + pw_gyks + pw_gyksd);
            sp_extra -= (pw_gykse4a + pw_gykse4 + pw_gykse4d);
            sp_extra_max = (sp_extra > sp_extra_max) ? sp_extra : sp_extra_max;
            pw_gykse4 = pw_gyks;
            pw_gykse4a = pw_gyksa;
            pw_gykse4d = pw_gyksd;
            a_gykse4 = a_gyks;
        }
        if ((exist(opexsatmask) & PSD_EXPLICIT_5) != 0) {
            sp_extra = (pw_gyksa + pw_gyks + pw_gyksd);
            sp_extra -= (pw_gykse5a + pw_gykse5 + pw_gykse5d);
            sp_extra_max = (sp_extra > sp_extra_max) ? sp_extra : sp_extra_max;
            pw_gykse5 = pw_gyks;
            pw_gykse5a = pw_gyksd;
            pw_gykse5a = pw_gyksd;
            a_gykse5 = a_gyks;
        } else if ((exist(opexsatmask) & PSD_EXPLICIT_6) != 0) {
            sp_extra = (pw_gyksa + pw_gyks + pw_gyksd);
            sp_extra -= (pw_gykse6a + pw_gykse6 + pw_gykse6d);
            sp_extra_max = (sp_extra > sp_extra_max) ? sp_extra : sp_extra_max;
            pw_gykse6 = pw_gyks;
            pw_gykse6a = pw_gyksa;
            pw_gykse6d = pw_gyksd;
            a_gykse6 = a_gyks;
        } 

        sp_sattime += sp_extra_max;
        pw_gks = IMax(3, pw_gxks, pw_gyks, pw_gzks); 


        /* checks sat errors unique to fgre3d */
        /* if (saterr_f3d() == FAILURE) return FAILURE; */

        /* turns sat off in ps2 - unique to fgre3d */
        satact_f3d();
    }

    if (PSD_ON == ifir_flag)
    {
        if (exist(opgirmode) == PSD_GIRAUTO)
        {
            ifir_vthick = IFIR_IR_VTHICK;
            ifir_position = -(ifir_vthick - exist(opslquant) * exist(opslthick)) * 0.5 + ifir_vthick * 0.05;
        }
        else
        {
            ifir_position = 0;
        }
    }

    /* call chemsateval to initailize chemsat rf params. */
    if( ChemSatEval( &cs_sattime ) == FAILURE ) {
        return FAILURE;
    }

    if(ifir_stir_flag)
    {
        off_rfcssat = 0;
    }

    /* MRIge75871 */
    cvoverride(opvthick, exist(opslthick)*exist(opslquant), PSD_FIX_ON, PSD_EXIST_ON);

    /* spgr, dither variables */ /*MRIge30804*/
    spgr_flag = (((exist(oppseq)==PSD_SPGR)||(exist(oppseq)==PSD_TOFSP)||(exist(op4dflow)==PSD_ON) ) ? PSD_ON : PSD_OFF ); 
    seeddef = 21001;
    seed = seeddef * spgr_flag;	/* random seed for phase spoiling */

    /* NAV */
    if (FAILURE == Monitor_Eval( rfpulse, (int)RF_FREE, &monave_sar, &moncave_sar, &monpeak_sar ))
    {
        epic_error(use_ermes, "%s failed",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "Monitor_Eval");
        return FAILURE;
    }

    /* *********************
       Starting point logic
       ********************* */
    /* cardiac gating is not supported in fgre3d */
    avmintdel1 = 0;
    td0 = GRAD_UPDATE_TIME;
    tlead = RUP_GRD(tlead);
    /* tlead will be extended by DAB_length after SAT start calcs */
    gating = TRIG_LINE;
    sp_satcard_loc = 0;

    profile_opvthick = opvthick;

    /* IR PREP (pjg) */
    /* IR prep Slice Select */
    if (ampslice(&a_gzrf0, bw_rf0, (ifir_flag ? ifir_vthick : opvthick), gscale_rf0, TYPDEF) == FAILURE)
    {
        epic_error(use_ermes,"ampslice for gzrf0 failure",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"amplice (for gzrf0)");
        return FAILURE;
    }

    if (optramp(&pw_gzrf0a, a_gzrf0, loggrd.tz, loggrd.zrt, TYPDEF) == FAILURE)
    {
        epic_error(use_ermes,"ampslice for gzrf0 failure",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"optramp (for gzrf0)");
        return FAILURE;
    }

    pw_gzrf0d = pw_gzrf0a;

    if (optramp(&pw_gzrffrira, a_gzrffrir, loggrd.tz, loggrd.zrt, TYPDEF) == FAILURE)
    {
        epic_error(use_ermes,"ampslice for gzrffrir failure",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"optramp (for gzrffrir)");
        return FAILURE;
    }
    pw_gzrffrird = pw_gzrffrira;

    if( existcv(opslquant) ) { 
        /* lock out odd number of slices per slab */
        if( (int)(exist(opslquant)%2) != 0 ) {
            epic_error( use_ermes, "Only even number of slices per slab "
                        "is supported.", EM_PSD_ODD_SLQPERSLAB_INCOMPATIBLE,
                        EE_ARGS(0) );
            return FAILURE;
        }
    }

@inline VAST.e VASTcveval
@inline FastCINE3D.e fcine3d_cveval

    if (msde_flag) /* MSDE timing calculation */
    {
        pos_msde_start = RUP_GRD((int)(GRAD_UPDATE_TIME + tlead
                       + rffrequency_length[bd_index] - rfupa));
        tseq_msde_start = pos_msde_start;
    }
@inline MSDE.e MSDE_CVeval

    if (fiesta_killer_flag)
    {
        float area_killer;
        area_killer = 2.0e7/GAM;
        /* Derating to 80% of Max loggrd to reduce the acoustic noise */
        if ((amppwgradmethod(&gradz[GZK_SLOT], area_killer, 0.8 * loggrd.tz_xyz,
                             0.0, 0.0, loggrd.zrt, MIN_PLATEAU_TIME))==FAILURE) {
            epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                       1,STRING_ARG,"amppwgradmethod:gzk");
            return FAILURE;
        }
        ia_gzk = a_gzk * max_pg_iamp / loggrd.tz;
        gradz[GZK_SLOT].num = 1;
    } else {
        gradz[GZK_SLOT].num = 0;
    }

    /* insert code copied from EFFSLICESEL_SPSP */
    if (ss_rf1)
    {
        ia_gzrf1 = a_gzrf1*max_pg_iamp/loggrd.tz;
        ia_rf1 = a_rf1*max_pg_iamp;
        ia_thetarf1 = a_thetarf1*max_pg_iamp/loggrd.tz;
    }

@inline loadrheader.e rheadereval

    /* MRIhc33773 : update rhnecho at eval time */
    if( PSD_ON == pcfiesta_flag ) {
        rhnecho = exist(opnecho) * phase_cycles;
    } else {
        if (ideal_flag) {
            rhnecho = ideal_necho;
        } else if (medal_flag) {
            rhnecho = medal_necho*medal_etl;
        } else if (flow4D_flag) {
            rhnecho = nflow4D;
        } else {
            rhnecho = (tricks_flag? 1 : exist(opnecho));
        }
    }

@inline loadrheader.e recon_lag_eval

    /*JAH: MRIge63197 -- For Gradient Heating versus dBdt optimization
      we turn off the scaling factor applied in calcPulseParams
      only for calcOptimizedPulses */
    grady[GY1_SLOT].scale = 1;
    grady[GY1R_SLOT].scale = 1;
    gradz[GZCOMB_SLOT].scale = 1;
    gradz[GZP_SLOT].scale = 1;

    /* GEHmr02676: enable to update waveform (run setOptimizedGradientScalingFactor()) at first calcOptimizedPulses() call.
                   pgen_for_dbdt_opt will be turned off after setOptimizedGradientScalingFactor() call. */
    pgen_for_dbdt_opt = 1;
    dbdtlevel_opt = 0;

        /* MRIge92895: dbdt level opt, now only turn it on for fiesta*/
    if ((PSD_SSFP == exist(oppseq)) && (PSD_XRMW_COIL != cfgcoiltype) && (PSD_XRMB_COIL != cfgcoiltype) && (PSD_VRMW_COIL != cfgcoiltype)) 
    {
        dbdtlevel_opt = 1;
    }
    /* IFIR GRx */
    InversionGRx_calc_pulse_timing();

    /* MRIge91352 - SAR/dbdt changes for E3 */

    /* Perform optimizations for main sequence (idx_seqcore) */
    seqEntryIndex = idx_seqcore;
    {
        /* MRIhc14873 */
        (loggrd.opt.xrt) = myhw.xrt;                                      
        (loggrd.opt.yrt) = myhw.yrt;                                      
        (loggrd.opt.zrt) = myhw.zrt;                                      

        (loggrd.opt.xft) = myhw.xft;                                      
        (loggrd.opt.yft) = myhw.yft;                                      
        (loggrd.opt.zft) = myhw.zft; 

        if( (status = calcOptimizedPulses( &loggrd, &pidbdtper, &srderate,
                                           cfdbdtper, seqEntryIndex,
                                           dbdt_debug,
                                           use_ermes,
                                           higher_dbdt_flag )) != SUCCESS ) {
            /* Allow error message from the lower level routines to show up  */
            return status;
        }
        if (dbdtlevel_opt == 1) {

            /* Scale the phase encode according
             * to the average power over
             *          * time */
            avepepowscale(&ave_grady_gy1_scale, phaseres,
                          (rhnframes - ((int)(float)phaseres/2.0))+rhhnover);

            ave_gradz_gzcomb_scale = sqrt(0.33333*(a_comb*a_comb + a_end*a_end + a_end*a_comb))/a_gzcomb;
            ave_gradz_gzp_scale = sqrt(0.33333*(a_comb2*a_comb2 + a_end2*a_end2 + a_end2*a_comb2))/a_gzp;

            grady[GY1_SLOT].scale = ave_grady_gy1_scale;
            grady[GY1R_SLOT].scale = ave_grady_gy1_scale;
            gradz[GZCOMB_SLOT].scale = ave_gradz_gzcomb_scale;
            gradz[GZP_SLOT].scale = ave_gradz_gzp_scale;

            if ((intermittant_chemsat == PSD_ON) && ( (fatFlag == PSD_ON) || (opwater == PSD_ON) ) ){
                grady[GYKCS_SLOT].num = 0; 
            } 

            if ((status = scale_grad()) != SUCCESS) {
                return status;
            }

            if ( FAILURE == minseq( &min_seqgrad,
                                    gradx, GX_FREE,
                                    grady, GY_FREE,
                                    gradz, GZ_FREE,
                                    &loggrd, seqEntryIndex, tsamp, tmin,
                                    use_ermes, seg_debug ) ) {
                epic_error( use_ermes, "minseq failed.",
                            EM_PSD_ROUTINE_FAILURE, EE_ARGS(1),
                            STRING_ARG, "minseq" );
                return FAILURE;
            }

            /* GEHmr02863: if skip_minseqseg not equal to false, minseq() does not run.
               Do not multiple by osfp_weight_grad to get correct limitations */
            if ((osfp_flag) && (FALSE == skip_minseqseg))
            {
                /* In SSSD (cfgradamp = 5550), osfp_weight_grad is not applied to minseq*
                   for short thermal time constant components (less than about 1sec) */

                if (5550 != cfgradamp)
                {
                    minseqgrddrv_t = RUP_GRD((int) (osfp_weight_grad*minseqgrddrv_t));
                }

                if (5550 == cfgradamp)
                {

                    minseqgrddrv_case_t = RUP_GRD((int) (osfp_weight_grad*minseqgrddrv_case_t));
                    minseqcable_maxpow_t = RUP_GRD((int) (osfp_weight_grad*minseqcable_maxpow_t));
                }

                minseqgpm_t = RUP_GRD((int) (osfp_weight_grad*minseqgpm_t));
                minseqcoil_t = RUP_GRD((int) (osfp_weight_grad*minseqcoil_t));
                minseqcable_t = RUP_GRD((int) (osfp_weight_grad*minseqcable_t));
                minseqbusbar_t = RUP_GRD((int) (osfp_weight_grad*minseqbusbar_t));
                minseqchoke_t = RUP_GRD((int) (osfp_weight_grad*minseqchoke_t));

                if (5550 == cfgradamp)
                {
                    min_seqgrad = IMax(7, minseqgrddrv_t, minseqgrddrv_case_t,
                                          minseqgpm_t, minseqgpm_maxpow_t,
                                          minseqcable_t, minseqcable_maxpow_t,
                                          minseqcoil_t);
                }
                else
                {
                    min_seqgrad = RUP_GRD((int) (osfp_weight_grad*min_seqgrad));
                }
            }
             

            if (debug_dbdt) {
                printf("POS1: min_seqgrad= %d, minseqcoil= %d, tmin= %d, pidbdtper=%f\n", 
                       min_seqgrad, minseqcoil_t, tmin, pidbdtper);
            }
            if ((intermittant_chemsat == PSD_ON) && ( (fatFlag == PSD_ON) || (opwater == PSD_ON) ) )            grady[GYKCS_SLOT].num = 1;  

            /* SVBranch, Smart Burst Mode */
            if ( (cfdbdtper > cfdbdtper_norm) && (min_seqgrad > tmin) && (!sbm_flag) ) {
                int tmp_tmax_grad;                                             
                float tmp_srderate;                                               

                grady[GY1_SLOT].scale = 1;
                grady[GY1R_SLOT].scale = 1;
                gradz[GZCOMB_SLOT].scale = 1;
                gradz[GZP_SLOT].scale = 1;

                tmp_tmax_grad = min_seqgrad;
                tmp_srderate = srderate;                                          

                (loggrd.opt.xrt) = myhw.xrt;                                      
                (loggrd.opt.yrt) = myhw.yrt;                                      
                (loggrd.opt.zrt) = myhw.zrt;                                      

                (loggrd.opt.xft) = myhw.xft;                                      
                (loggrd.opt.yft) = myhw.yft;                                      
                (loggrd.opt.zft) = myhw.zft;                                      

                /* set_cvs_changed_flag( TRUE ); */
                enforce_minseqseg = PSD_ON;
                if( (status = calcOptimizedPulses( &loggrd, &pidbdtper, &srderate,
                                                   cfdbdtper_norm, seqEntryIndex,                 
                                                   dbdt_debug, use_ermes,             
                                                   higher_dbdt_flag )) != SUCCESS ) { 
                    return status;                                                
                }
                /* Scale the  phase  encode  according  to  the average  power  over time */
                grady[GY1_SLOT].scale = ave_grady_gy1_scale;
                grady[GY1R_SLOT].scale = ave_grady_gy1_scale;
                gradz[GZCOMB_SLOT].scale = ave_gradz_gzcomb_scale;
                gradz[GZP_SLOT].scale = ave_gradz_gzp_scale;

                if ((intermittant_chemsat == PSD_ON) && ( (fatFlag == PSD_ON) || (opwater == PSD_ON) ) )
                    grady[GYKCS_SLOT].num = 0; 

                if ( FAILURE == minseq( &min_seqgrad,                  
                                        gradx, GX_FREE,                               
                                        grady, GY_FREE,                               
                                        gradz, GZ_FREE,                               
                                        &loggrd, seqEntryIndex, tsamp, tmin,          
                                        use_ermes, seg_debug ) ) {                    
                    epic_error( use_ermes, "minseq failed.",                          
                                EM_PSD_ROUTINE_FAILURE, EE_ARGS(1),
                                STRING_ARG, "minseq" );    
                    return FAILURE;                                                   
                }

                /* GEHmr02863: if skip_minseqseg not equal to false, minseq() does not run.
                   Do not multiple by osfp_weight_grad to get correct limitations */
                if ((osfp_flag) && (FALSE == skip_minseqseg))
                {
                    /* In SSSD (cfgradamp = 5550), osfp_weight_grad is not applied to minseq*
                       for short thermal time constant components (less than about 1sec) */

                    if (5550 != cfgradamp)
                    {
                        minseqgrddrv_t = RUP_GRD((int) (osfp_weight_grad*minseqgrddrv_t));
                    }

                    if (5550 == cfgradamp)
                    {
                        minseqgrddrv_case_t = RUP_GRD((int) (osfp_weight_grad*minseqgrddrv_case_t));
                        minseqcable_maxpow_t = RUP_GRD((int) (osfp_weight_grad*minseqcable_maxpow_t));
                    }

                    minseqgpm_t = RUP_GRD((int) (osfp_weight_grad*minseqgpm_t));
                    minseqcoil_t = RUP_GRD((int) (osfp_weight_grad*minseqcoil_t));
                    minseqcable_t = RUP_GRD((int) (osfp_weight_grad*minseqcable_t));
                    minseqbusbar_t = RUP_GRD((int) (osfp_weight_grad*minseqbusbar_t));
                    minseqchoke_t = RUP_GRD((int) (osfp_weight_grad*minseqchoke_t));

                    if (5550 == cfgradamp)
                    {
                        min_seqgrad = IMax(7, minseqgrddrv_t, minseqgrddrv_case_t,
                                              minseqgpm_t, minseqgpm_maxpow_t,
                                              minseqcable_t, minseqcable_maxpow_t,
                                              minseqcoil_t);
                    }
                    else
                    {
                        min_seqgrad = RUP_GRD((int) (osfp_weight_grad*min_seqgrad));
                    }
                }

                if (debug_dbdt) {
                    printf("POS2: min_seqgrad= %d, minseqcoil= %d, tmin= %d, pidbdtper=%f\n",
                           min_seqgrad, minseqcoil_t, tmin, pidbdtper);
                }

                if ((intermittant_chemsat == PSD_ON) && ( (fatFlag == PSD_ON) || (opwater == PSD_ON) ) )            grady[GYKCS_SLOT].num = 1;

                if( min_seqgrad > tmp_tmax_grad || tmin > tmp_tmax_grad ){ 
                    srderate =tmp_srderate;                                       

                    grady[GY1_SLOT].scale = 1;
                    grady[GY1R_SLOT].scale = 1;
                    gradz[GZCOMB_SLOT].scale = 1;
                    gradz[GZP_SLOT].scale = 1;


                    (loggrd.opt.xrt) = myhw.xrt;                  
                    (loggrd.opt.yrt) = myhw.yrt;                  
                    (loggrd.opt.zrt) = myhw.zrt;                  

                    (loggrd.opt.xft) = myhw.xft;                  
                    (loggrd.opt.yft) = myhw.yft;                  
                    (loggrd.opt.zft) = myhw.zft;                  

                    /* set_cvs_changed_flag( TRUE ); */
                    enforce_minseqseg = PSD_ON;
                    if( (status = calcOptimizedPulses( &loggrd, &pidbdtper, &srderate,
                                                       cfdbdtper, seqEntryIndex,          
                                                       dbdt_debug, use_ermes,             
                                                       higher_dbdt_flag )) != SUCCESS ) { 
                        return status;                                            
                    }
                    if (debug_dbdt) {
                        printf("POS3: min_seqgrad= %d, minseqcoil= %d, tmin= %d, pidbdtper=%f\n",
                               min_seqgrad, minseqcoil_t, tmin, pidbdtper);
                    }

                }                                                       
            }
        }
    }

    /**********************************************************
      Advisory Panel Calculations 
      All rfpulse and gradient bookkeeping structures should be
      uptodate by this point.  Advisory panel routines automatically
      set corresponding advisory panel export variables.
      * ********************************************************** */
    gating = TRIG_INTERN;		/* cardiac gating is not supported in fgre3d */

    /* Seqtype needed for several routines */
    if (seqtype(&seq_type) == FAILURE) {
        epic_error(use_ermes,"%s failed",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"seq_type");
        return FAILURE;
    }

@inline Tricks.e SetSeqtype
@inline VAST.e VASTsetseqtype

    /* Imgtimutil calculates actual tr for normal scans, available portion of R-R
       interval for imaging for cardiac scans.  First parameter is only used if 
       the scan is cardiac gated. */
    act_tr = exist(optr);
    avail_image_time = RDN_GRD(act_tr); 
    premid_rf90 = 0;			/* Cardiac gating is not supported */
    if (imgtimutil(premid_rf90, seq_type, gating, 
                   &avail_image_time) == FAILURE) {
        epic_error(use_ermes,"%s failed",EM_PSD_ROUTINE_FAILURE,EE_ARGS(1),
                   STRING_ARG,"imgtimutil");
        return FAILURE;
    } 

    if(PSD_ON == ifir_flag)
    {
        pirtetr = (60.0 / exist(oprtrate)) * 1000000;
        advrounddown(&pirtetr);
    }

    act_tr = avail_image_time;
    choplet = 0;
    rhptsize = opptsize;
    rhfrsize = echo1_filt->outputs;

    if( existcv(opcgate) && (PSD_ON == exist(opcgate)) ) 
    {
        if(vast_mode)
        {   
            t2prep_rate = 1.0/(max_pencodes 
                            + ssfp_flag*(enable_alpha+fiesta_gated_dda)
                            + (!ssfp_flag)*gated_dda);
        } else {
            t2prep_rate = ((float)tmin)/ ((60.0 / (float)(exist(ophrate))) * 1000000.0);
        }
    } else {
        t2prep_rate = 1.0/ (float) (slquant1);
    }

    if (t2prep_rate < 0.02)
        t2prep_rate = 0.02;

    /* Elliptical centric ordering re-sorts views starting from
       sequential view order */

    if ( (centric_flag == 1) && 
         ( (SmartPrepKey == Present) || (ftMRAKey == Present) || (QUICKSTEPKey == Present) || lava_flag || medal_flag ) ) {
        phorder = CENTRIC;
    }

    if ( (reverse_centric_flag == 1) && 
         ( (SmartPrepKey == Present) || (ftMRAKey == Present) || (QUICKSTEPKey == Present) ) ) {
        phorder = REVERSE_CENTRIC;
    }

    /* MRIge81273 - Override Centric or Reverse Centric to Reverse Sequential
       if 0.5 or 0.75 NEX is selected */
    if (existcv(opnex) && (exist(opnex) == 0.5 || exist(opnex) == 0.75) && (!pfkr_flag) &&
        ((phorder == CENTRIC) || (phorder == REVERSE_CENTRIC)) ) {
        phorder = REVERSE_SEQUENTIAL;
    }

    if ( ((ellipt_flag == 1) || (reverse_ellipt_flag == 1)) && 
         ( (SmartPrepKey == Present) || (ftMRAKey == Present) || (QUICKSTEPKey == Present) ) ) {
        phorder = SEQUENTIAL;
    }

    /* ungated FatSat FIESTA */
    if ( ugfsf_flag ){
        if(exist(opnex) == 0.5){
            ugfsf_view_order_flag = 1; /* reversed sequential */
        }
        else if(exist(opnex) == 0.75){
            if( (value_system_flag) || !((exist(oprtcgate)==PSD_ON)&&(resp_gate_trig_sw==0)) )
                ugfsf_view_order_flag = 2; /* centric */
            else
                ugfsf_view_order_flag = 0; /* modified sequential */
        }
        else{
            if( (value_system_flag) || !((exist(oprtcgate)==PSD_ON)&&(resp_gate_trig_sw==0)) )
                ugfsf_view_order_flag = 2; /* centric */
            else
                ugfsf_view_order_flag = 0; /* modified sequential */
        }

        if (ugfsf_view_order_flag == 1)
            phorder = REVERSE_SEQUENTIAL;
        else if (ugfsf_view_order_flag == 2)
            phorder = CENTRIC;
        else
            phorder = SEQUENTIAL;

        if(exist(oprtcgate)==PSD_ON)
            ugfsf_slice_order_flag = 0;
        else
            ugfsf_slice_order_flag = 1;

        if( rhnframes <= 256 ){
          if(ugfsf_view_order_flag == 2)
              num_shot = 2; /* if centric, num_shot shall be 2 to avoid artifact */
          else
              num_shot = 1;
        }
        else{
           num_shot = 2;
        }
    }

    rhnslices = exist(opslquant)*exist(opvquant)*exist(opfphases);

    rhdab0s = cfrecvst;  /* start receiver for DAB to poll */
    rhdab0e = cfrecvend;  /* end receiver for DAB to poll */

    /* RV: MRIhc19003 - Replace opnecho with ideal_necho in case of IDEAL */

    rhmeth = ( (xres != 256) && ( xres != 512 ) )? 1: 0;

    /* 0=standard recon(key the filter size off x_acq_size), 
       1=homodyne recon (key the filter size off fft size) */

    rhdaxres = xres;	/* data acquisition size */
    rhdayres = rhnframes + rhhnover + 1;

    if (arc_flag && !(arc_pack_bam & BAM_REDUCE_Y))
    {
        /* Sort/Nex into fully sampled y therefore use unaccelerated sizes */
        rhdayres = unaccel_rhnframes + rhhnover + 1;

        if(idealiq_flag && idealiq_pc_flag)
        {
            rhdayres += idealiq_pc_ylines;
        }
    }


    /* MRIhc36786  replace 1+rhnframes+rhhnover by rhdayres */

    if (rawdata) {
        slice_size = (baseline+rhdayres)*
            (int)( (float)(2*rhptsize*rhfrsize*(tricks_flag?exist(opnecho):rhnecho)) * truenex);
    } else {
        /* MRIge84316- Take out truenex in else case -Venkat*/
        slice_size = rhdayres*2*rhptsize*rhfrsize*(tricks_flag ? exist(opnecho) : rhnecho);
    }



    /* added backward compatibility - latha@mr */
    if (UnLocked) 
    {
        int totalPhase = (phasefovgt1_flag && (opphasefov > 1) ) ? 
            (int)(exist(opyres)*exist(opphasefov)) : exist(opyres);
        
        if (exist(opxres) >= totalPhase)
        {
            rhrcxres = ((exist(opxres) <= 256) ? 256 : 512);
            if ((hires_recon == PSD_ON) || exist(opxres) > 256) { 
                rhrcxres = 512;
            }
            /* MRIge82977 Initialise rhrcxres -Venkat */
            if ( (recon_1024 == PSD_ON) || (exist(opxres) > 512) ) {
                rhrcxres = 1024;
            }
        
            rhimsize = rhrcxres;
        }
        else      
        {
            rhimsize = ((totalPhase <= 256) ? 256 : 512);
            if ((hires_recon == PSD_ON) || (totalPhase > 256) ) {
                rhimsize = 512;
            }
            /* MRIge82977 Initialise rhrcxres -Venkat */
            if ( (recon_1024 == PSD_ON) || (totalPhase > 512) ) {
                rhimsize = 1024;
            }
            
            rhrcxres = ((exist(opxres) <= 256) ? 256 : 512);
        }
        if (phasefovgt1_flag && (opphasefov > 1) )
        {
            rhrcyres = (int)(exist(opyres) * (1 + opnopwrap)*(exist(opphasefov)));
            rhrcyres = rhrcyres + rhrcyres % 2;
        }
        else
        {
            rhrcyres = rhimsize * (1 + opnopwrap)*(exist(opphasefov));
        }

    } else {
        rhrcxres = exist(opxres);     /* recon fft size */
        rhrcyres = exist(opxres) * (1 + opnopwrap) * (exist(opphasefov));
        /* Y transform size of reconstructed image */
       
        if ( PSD_ON == phasefovgt1_flag && opphasefov > 1 ) 
        {
            rhimsize = IMax(2,exist(opxres),(int)(exist(opyres)*exist(opphasefov)));
            rhimsize = rhimsize + rhimsize % 2;
        }
        else
        { 
             rhimsize = exist(opxres);
        }
        
    } /* end backward compatibility */

    /* Future: Support pFOV > 1 where yres*pFOV may be > yres
       May be okay for all option.  Need to test */
    /*  if ( PSD_ON == phasefovgt1_flag && opphasefov > 1 ) {
        rhimsize = IMax(2, rhrcxres, rhrcyres);
        }
    */

    if (arc_flag) {
        if( rhrcyres % 2 == 1) {
            rhrcyres += 1;
        }
    }

    /* pradeeps@wiproge  */
    if ( (recon_1024 == PSD_ON) || (exist(opxres) > 512) ) {
        rhrcxres = 1024;
        cvoverride(opproject, 0, PSD_FIX_ON, PSD_EXIST_ON);
        piprojnub = 1;  /* MRIge49419  Vascular Screen:Lock out projections */
    }

    rhcphases = 1;
    rhctr = 1;
    rhcrrtime = 1;

    if ((exist(oppseq) == PSD_TOF) || (exist(oppseq) == PSD_TOFSP)) {
        vas_ovrhd = (exist(opcollapse)+exist(read_col)+
                     exist(phase_col)) * exist(opnecho) + 2*rhnecho;
        if ( exist(opproject) == 1 ) { 
            vas_ovrhd += 19;
        }
        if ( exist(opproject) == 2 ) { 
            vas_ovrhd += 37;
        } 

        vas_ovrhd  = rhimsize*rhimsize*4*vas_ovrhd +3904; 

        /* recon control bit mask for vascular */
        rhvtype   =    VASCULAR
            + COLLAPSE_Z * exist(opcollapse)
            + COLLAPSE_X * exist(read_col)
            + COLLAPSE_Y * exist(phase_col)
            + exist(opproject) * ANG_10_DEG;

        /* Number of extra image files for scanrhnecho to create */
        pivextras = exist(opcollapse) + exist(read_col) + exist(phase_col);
    } else if (flow4D_flag) {

       /**************************
        PC vasc Recon variables
        **************************/

        rhimsize = IMax(2,rhrcxres,rhrcyres);
        vas_ovrhd = /* vascular collapse memory */
            rhimsize*rhimsize*4*( 2*rhnecho)
            + 3904 ;

        maxpc_cor = PSD_ON; 
        mag_mask = 0;

        rhvtype  =  VASCULAR
            + PHASE_CON
            + PHASE_2*maxpc_cor
            + NOISE_SUPP*mag_mask
            + MAGNITUDE /*opmagc */
            + PHYSICAL_X /* oprlflow*(opflaxall == 1)*/
            + PHYSICAL_Y /* opapflow*(opflaxall == 1) */
            + PHYSICAL_Z ; /*opsiflow*(opflaxall == 1) */

        pivextras = (rhnslices)*(4);
        /* Number of extra image files for scanrhnecho to create */
        /*  The rhvcoefs determine how the "flow echoes" are combined into physical axes */
        if ((balanced_FE==1) && (exist(opflaxall) == PSD_ON)) {
          rhvcoefxa =  -1.0;
          rhvcoefxb =  1.0;
          rhvcoefxc =  1.0;
          rhvcoefxd =  -1.0;

          rhvcoefya = -1.0;
          rhvcoefyb = 1.0;
          rhvcoefyc = -1.0;
          rhvcoefyd = 1.0;

          rhvcoefza = 1.0;
          rhvcoefzb = -1.0;
          rhvcoefzc = 1.0;
          rhvcoefzd = 1.0;
        } else if ((balanced_FE==-1) && (exist(opflaxall) == PSD_ON)) {

          rhvcoefxa = 2.0;
          rhvcoefxb = 1.0;
          rhvcoefxc = 2.0;
          rhvcoefxd = 1.0;

          rhvcoefya = 3.0;
          rhvcoefyb = 2.0;
          rhvcoefyc = 3.0;
          rhvcoefyd = 2.0;

          rhvcoefza = 4.0;
          rhvcoefzb = 3.0;
          rhvcoefzc = 4.0;
          rhvcoefzd = 3.0;
        } else {
          rhvcoefxa = 2.0 - (FLOAT)(exist(opflaxall) == PSD_OFF);
          rhvcoefxb = 1.0 + (FLOAT)(exist(opflaxall) == PSD_OFF);
          rhvcoefxc = 2.0;
          rhvcoefxd = 1.0;

          rhvcoefya = 3.0;
          rhvcoefyb = 1.0;
          rhvcoefyc = 3.0;
          rhvcoefyd = 1.0;

          rhvcoefza = 4.0;
          rhvcoefzb = 1.0;
          rhvcoefzc = 4.0;
          rhvcoefzd = 1.0;

        }
       /*  The rhvcoefs determine how the "flow echoes" are combined into a magnitude image. See the 4.5  Recon Vascular SDD addendum for more details. */
        rhvmcoef1 = 0.25 + 0.25*(FLOAT)(exist(opflaxall) == PSD_OFF);
        rhvmcoef2 = 0.25 + 0.25*(FLOAT)(exist(opflaxall) == PSD_OFF);
        rhvmcoef3 = 0.25;
        rhvmcoef4 = 0.25;

        scale_fac = 0.18 + 9.82*(FLOAT)(mag_mask == 0);
        rhvenc = scale_fac*usevenc/(M_PI*10.0);
        /* Recon header value for velocity encoding */

    }
    else
    {
        vas_ovrhd  = 0;
        /* recon control bit mask for vascular */
        rhvtype   = 0;
        /* Number of extra image files for scanrhnecho to create */
        pivextras = 0;
    }

@inline Tricks.e Rheval

@inline cal3d.e cal3d_cveval1
    
    /* RV: MRIhc19003 - Need to move this from predownload prior to maxslquanttps
    call since the IDEAL BAM model needs these CV's to be set!!! */ 
    /* MRIhc22014 - Turn ON fldata dump by default */
    if(PSD_ON == ideal_flag) {
       rhrcdixproc = exist(opdixproc);

       rhrcidealctrl = (IDEAL_DUMP_FLDATA + IDEAL_OUTPUT_AFTER_POSTCHECKER + IDEAL_PERFORM_GRADWARP +
                        IDEAL_PERFORM_FLOAT2FIX + IDEAL_IDEAL_RECV_COMBINE + IDEAL_PERFORM_CLIP +
                        IDEAL_USE_CALC_IMAGE);
       if((existcv(opasset)&&((exist(opasset)==2)||(exist(opasset)==3)))|| (rhdab0e == rhdab0s)) 
       {  /* Turn off bit 6 (coil combine operation) */
          rhrcidealctrl &= ~IDEAL_IDEAL_RECV_COMBINE;
       }

       rhrcideal = IDEAL_ON_OFF_FLAG;
       
       if(fullte_flag != 1) {
          rhrcideal |= IDEAL_CENTER_KSPACE_HALF_ECHO;
       } else {
          rhrcideal &= ~IDEAL_CENTER_KSPACE_HALF_ECHO;
       }

       if(!pfkyz2kr_flag && (fn == 0.5)) { /* Perform half-nex IDEAL processing in IrP cases */
          rhrcideal |= IDEAL_PERFORM_HALF_NEX_PROCESSING;
       } else {
          rhrcideal &= ~IDEAL_PERFORM_HALF_NEX_PROCESSING;
       }
       rhnecho = ideal_necho;
       rhechopc_ctrl = 0;

    } else if(idealiq_flag) {
       rhrcideal = (IDEAL_ON_OFF_FLAG + IDEAL_T2STAR_CORRECT + IDEAL_MP_CORRECT + IDEAL_MAG_FITTING);
       if(1 != fullte_flag)
       {
          rhrcideal |= IDEAL_CENTER_KSPACE_HALF_ECHO;
       }
       else
       {
          rhrcideal &= ~IDEAL_CENTER_KSPACE_HALF_ECHO;
       }
       rhrcdixproc = exist(opdixproc);

       rhrcidealctrl = (IDEAL_DUMP_FLDATA + IDEAL_OUTPUT_AFTER_POSTCHECKER + IDEAL_PERFORM_GRADWARP +
                        IDEAL_PERFORM_FLOAT2FIX + IDEAL_IDEAL_RECV_COMBINE + IDEAL_PERFORM_CLIP +
                        IDEAL_USE_CALC_IMAGE);
       if((existcv(opasset)&&((exist(opasset)==2)||(exist(opasset)==3)))|| (rhdab0e == rhdab0s)) 
       { /* Turn off bit 6 (coil combine operation) */
          rhrcidealctrl &= ~IDEAL_IDEAL_RECV_COMBINE;
       }

       if(idealiq_pc_flag)
       {
           rhechopc_extra_bot = idealiq_pc_ylines;
           rhechopc_ylines = idealiq_pc_ylines;
           rhechopc_primary_yfirst = idealiq_pc_ylower + 1;
           rhechopc_reverse_yfirst = rhdayres - idealiq_pc_ylines;
           rhechopc_zlines = idealiq_pc_zlines;
           rhechopc_yxfitorder = ECHO_PC_FIRST_ORDER; 
           rhechopc_ctrl = ECHO_PC_ACQUIRED + ECHO_PC_APPLY + ECHO_PC_AHN_CLIP_WEIGHT;
       }
       else
       {
           rhechopc_ctrl = 0;
       }

    } else {
       rhrcideal = 0;
       rhechopc_ctrl = 0;
    }

    /* It is known that water-to-fat frequency is temperature dependent, MRM 72:464-470 (2014).
     * recon has a predefined multi-peak fat spectrum for fat at body temperature.
     * recon also allows psd to shift the fat spectrum manually, to account for various effect,
     * such as when scanning phantom at room temperature.
     * Essentially, recon use 210Hz as a reference for calculating the shift.
     * For example, if scanning phantom at room temperature, it is likely user needs to set
     * rhdf to 217 on 1.5T to shift the fat spectrum 7Hz further away from water.
     */
     rhdf = FATWATER_DIXFREQ_1_5T * cffield/B0_15000;

     /* MRIhc48860 -- for BAM calc need to calculate rhrcdixproc before maxslquanttps call*/
     if (medal_flag && (exist(opmedal)==PSD_ON))
     {
         rhrcdixproc = exist(opdixproc);
         rhrcdixproc |= (DIXON_WATER + DIXON_FAT); 
     }


    /* Control code for acquisition to disk feature
     * Enable acquisition to disk for multiphase VIBRANT-DE 
     * Not compatible with DynaPlan.
     */
    if ((PSD_ON == opvibrant) && (PSD_ON == opmedal) && (rhnpasses > 1) && 
        (cfacqtodisksize > 0) && (PSD_OFF == exist(opdynaplan)))
    {
        /* Set rhinitpass to 1 so that only 1 phase of data is store in
         * BAM */
        rhdiskacqctrl |= RDB_DISK_ACQ_OVERFLOW;
        rhinitpass = DISK_ACQ_RHINITPASS;
    } else {
        rhdiskacqctrl &= ~RDB_DISK_ACQ_OVERFLOW;
    }

    {
        /* MRIhc21901, MRIhc23348, MRIhc23349 */
        MAXSLQUANTTPS_OPTION maxslquanttps_option;
        maxslquanttps_option.arcRxToAcqSlicesIntercept = 0.0;
        maxslquanttps_option.arcRxToAcqSlicesSlope = 1.0;

        if (arc_flag && (BAM_REDUCE_Z & arc_pack_bam))
        {
            if (arc_pack_bam == 15) /* for DVC ARC */
            {
                maxslquanttps_option.arcRxToAcqSlicesIntercept = arc_sl_calwidth*(1.0-1.0/arc_sl_stride);
                /* recon does not count partial Kz in compressed bam allocation for now */
                /* maxslquanttps_option.arcRxToAcqSlicesSlope = pfkz_fraction/arc_sl_stride; */
                maxslquanttps_option.arcRxToAcqSlicesSlope = 1.0/arc_sl_stride;
            } else {
                maxslquanttps_option.arcRxToAcqSlicesSlope = 1.0/arc_sl_netaccel;
            }
        }

        if (disco_flag)
        {
            /* total_acq_points will not be counted until predownload, so estimate here */
            float pfr = aregion_fraction;

            if (2 == num_regions)
            {
                pfr += (1-aregion_fraction)/num_sub_regions;
            }
            else
            {
                int i;
                for (i = 2; i <= num_regions; i++)
                {
                    pfr += (1-aregion_fraction)/(i*(num_regions-1));
                }
            }

            maxslquanttps_option.discoTotalAcqPoints = (int)ceil(exist(opfphases)*sampledPoints*pfr);
        }

        if (PSD_ON == exist(opquickstep))
        {   /* MRIhc41744: + 1 is for venuous phase. BAM is still overestimated
               as PSD is unaware of other stations' BAM size */ 
            if (maxslquanttps( &max_bamslice, (int)rhimsize, slice_size,
                               rhinitpass + 1, &maxslquanttps_option ) == FAILURE)
            {
                epic_error(use_ermes,
                           "Not enough memory for scan size. Reduce scan size",
                           EM_PSD_SCAN_SIZE, EE_ARGS(0));
                return FAILURE;
            }
        }
        else
        {
            if (maxslquanttps( &max_bamslice, (int)rhimsize, slice_size,
                           rhinitpass, &maxslquanttps_option ) == FAILURE)
            {
                epic_error(use_ermes,
                           "Not enough memory for scan size. Reduce scan size",
                           EM_PSD_SCAN_SIZE, EE_ARGS(0));
                return FAILURE;
            }
        }
    }

    /* ASSET */
    if (maxyres(&avmaxyres, (ogsfY*loggrd.ty_xyz), (RUP_GRD((ceil) (ogsfY*yrt))), 3s, 
                nop*exist(opfov)*exist(opphasefov)*asset_factor,
                &grady[GY1_SLOT],PHASESTEP32) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "maxyres");
        return FAILURE;
    }

    avmaxyres = 1024;

    /* number of z encodes between SATs */
    if (osfp_flag || radfb_flag || pfkr_yz_flag || (ENCODE_GROUP_NONE != encode_group) )
        satview = views_per_segment;
    else if (merge_flag)
       satview = 4; 
    else
       satview = 12;

    if ( intslab_flag == PSD_ON ) {
	/* Override to no PRESS mode*/
	presscfh_override = PRESSCFH_NONE;
    } else {
	/* 0 means no override. Use the settings from Prescan.e */
	presscfh_override = 0;
    }

@inline Prescan.e PScveval

@inline cal3d.e cal3d_cveval_prescan

    /* Gradient coil heating calculations */

    /* Scale the phase encode according to the average power over time */
    avepepowscale(&ave_grady_gy1_scale, phaseres,
                  (rhnframes - ((int)(float)phaseres/2.0))+rhhnover);

    ave_gradz_gzcomb_scale = sqrt(0.33333*(a_comb*a_comb + a_end*a_end + a_end*a_comb))/a_gzcomb;
    ave_gradz_gzp_scale = sqrt(0.33333*(a_comb2*a_comb2 + a_end2*a_end2 + a_end2*a_comb2))/a_gzp;

    grady[GY1_SLOT].scale = ave_grady_gy1_scale;
    grady[GY1R_SLOT].scale = ave_grady_gy1_scale;
    gradz[GZCOMB_SLOT].scale = ave_gradz_gzcomb_scale;
    gradz[GZP_SLOT].scale = ave_gradz_gzp_scale;

    /* If spatial sat is on
       the spatial sat pulses must be weighted by (1/(satview+2)),
       the chem sat pulses must be weighted by ((satview+1)/(satview+2)), and
       the regular pulses must be weighted by ((satview+1)/(satview+2)).

       One way to accomplish this is to set the num field of the pulses to
       these various weights.  However, in the 5.3 release the num field is
       an integer.  To create the same effect, the amp field of the pulses
       are multiplied by pow(weight, 0.5). */

    satweight = 1.0 / (satview + 2.0);

    /* MRIge66079 - ATV: RTIA3D/ftMRA */
    /* ATV - chemweight, regweight is set to 1.0 to avoid problem 
       with recursive multiplication in SAR, rf amp calculation  */
    if ( (ftmra_flag) || (maskv_ftmra_flag) )
    {
        chemweight = 1.0;
        regweight = 1.0;
    }
    else
    {
        chemweight = (satview + 1.0) / (satview + 2.0);
        regweight = (satview + 1.0) / (satview + 2.0);
    }

    /* End RTIA3D/ftMRA */

    if (sp_sat) {
        /* weight the amp value of all the sat gradients appropriately */
        for (numgrads = 0; numgrads < NUMXSAT; numgrads++)
            gradx[numgrads].scale = satweight;
        for (numgrads = 0; numgrads < NUMYSAT; numgrads++)
            grady[numgrads].scale = satweight;
        for (numgrads = 0; numgrads < NUMZSAT; numgrads++)
            gradz[numgrads].scale = satweight;

        if ( (fatFlag == PSD_ON)  || opwater == PSD_ON) {
            /* weight the amp value of the chem sat gradients appropriately */
            gradx[GXKCS_SLOT].scale = chemweight;
            grady[GYKCS_SLOT].scale = chemweight;
            gradz[GZKCS_SLOT].scale = chemweight;
        }  

        /* weight the regular gradients */
        gradx[GX1_SLOT].scale = regweight;
        gradx[GXW_SLOT].scale = regweight;
        gradx[GXWEX_SLOT].scale = regweight;
        grady[GY1_SLOT].scale *= regweight;
        grady[GY1R_SLOT].scale *= regweight;
        gradz[GZRF1_SLOT].scale = regweight;
        gradz[GZCOMB_SLOT].scale *= regweight;
        gradz[GZP_SLOT].scale *= regweight;
        gradz[GZRF0_SLOT].scale = regweight;
        gradz[GZRF0K_SLOT].scale = regweight;

        ave_grady_gy1_scale *= regweight;
        ave_gradz_gzcomb_scale *= regweight;
        ave_gradz_gzp_scale *= regweight;

        if (ifir_frir_flag)
        {
            gradz[GZRFFRIR_SLOT].scale = regweight; 
            gradz[GZKRFFRIR_SLOT].scale = regweight;
        }

        if (exist(opetl)>= 2 ) {
           gradx[GX2_SLOT].scale = regweight;
           gradx[GXW2_SLOT].scale = regweight;
        }

        if (flow_comp_type == TYPFC) {
           gradz[GZ1_SLOT].scale = regweight;
           gradx[GXFC_SLOT].scale = regweight;
        }

       if (flow4D_flag==PSD_ON) {
           gradz[GZ1_SLOT].scale = regweight;
           gradx[GXFC_SLOT].scale = regweight;
           grady[GYFE1_SLOT].scale = regweight;
           grady[GYFE2_SLOT].scale = regweight;

        }

    }      

    /* IR PREP (pjg) */
    /* Determines type of centric slice ordering for IR prep option.
       The order depends on the number of slices. */
    /* We also use centric order for intermittant_chemsat */

    if( (PSD_ON == smartprep_flag) || ((PSD_ON == exist(opcgate)) && (PSD_ON == navgate_flag)) ) {
        slorder = SEQUENTIAL;
        if( monitor_test ) {
            slorder = 1;
        }
    }

    if( UnLocked ) {
        if (ENCODE_GROUP_ZY == encode_group) {
            if (sp_sat || irprep_flag) {
                slorder = CENTRIC;
            }
            else
            {
                slorder = SEQUENTIAL;
            }
        } else if( (irprep_flag == PSD_ON) || (intermittant_chemsat == PSD_ON) ) {
            if ( irprep_flag && bravo_flag ) {
                slorder = 1; /* centric view order for BRAVO */
            }
            else if( PSD_ON == extraspecial_flag ) {
                slorder = 5; /* BBA - improved SPECIAL slice order */
            } else {
                if ( arc_equant <= 64 ) { 
                    slorder = 1;
                } else {
                    slorder = 2;
                }
            }
        } else {
            slorder = 0;
        }  /* end backward compatibility */
    }

    /* Determine scaling factor to be used on gradient for the IR prep
       pulse. The pulse is not played for every sequence so the number
       of occurrences should be scaled appropriately. Since num field in
       the structure is an integer, the amplitude field is scaled by
       the frequency of the IR prep pulse.
       1/(irfreq + irdisdacqs)
    */

    /* BBA - Improved Special to optimize number of alpha pulses  */ 
    if( PSD_ON == extraspecial_flag ) {
        optr = 6000;
    } 
    slfreq = 8;
    tempslfreq = 64;
    while( tempslfreq != slfreq ) {
        switch( slorder )
        {
        case 1:
            slfreq = arc_equant;
            break;

        case 2:
            slfreq = arc_equant/2;
            break;

        case 3:
            slfreq = arc_equant/4;
            break;

        case 4:
            slfreq = arc_equant/8;
            break;

        case 5:
            /* BBA - improved SPECIAL */  
            if( SpecIRSlorder( &slfreq, &slfreq0 ) == FAILURE ) {
                epic_error( use_ermes, supfailfmt,
                            EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                            STRING_ARG, "SpecIRSlorder" );
                return FAILURE;
            } 
            optr = 50000;
            break;

        default:
            slfreq = 1;
            break;
        } 

        irfreq = slfreq;
        chemfreq = slfreq;

        /* MRIge91682 */
        if( lava_flag || brava_flag || pfkz_flag ) {
            chemfreq = pfkz_views_per_segment;
        }

        if (osfp_flag||segmented_flag) {
            chemfreq = views_per_segment;
            irfreq = views_per_segment;
        }

        if (vast_mode) {
           chemfreq = max_pencodes + ssfp_flag * (enable_alpha + fiesta_gated_dda)
                      + (!ssfp_flag) * gated_dda;
           irfreq = max_pencodes + ssfp_flag * (enable_alpha + fiesta_gated_dda)
                    + (!ssfp_flag) * gated_dda;
        }

        if (cine3d_flag)
        {
           chemfreq = ( (exist(op4dflow)==PSD_ON) ? nflow4D :  exist(opvps) );
        }

        if ((PSD_ON == exist(opcgate)) && (PSD_ON == navgate_flag))
        {
           navscale = 1.0/(max_pencodes + ssfp_flag*(enable_alpha + fiesta_gated_dda)
                    + (!ssfp_flag)*gated_dda);
        }

        if((chemfreq == 1) || extraspecial_flag || lava_flag || pfkz_flag || osfp_flag || vast_mode) {
            chemsat_dda = 0;
        } 
        else if (bravo_flag && specir_flag) {
            chemsat_dda = 4; 
        }
        else {
            chemsat_dda = 2;
        }

        if( brava_flag ) {
            if (oprbw > 60 ) {
                chemsat_dda = 2;
            } else {
                chemsat_dda = 1;
            }
            if (aspir_override && aspir_flag)
            {
                chemsat_dda = 0;
            }
        }

        /* ungated FatSat FIESTA */
        if( ugfsf_flag && (act_tr > 0) ){
            view_per_shot = (int)ceil((double)(rhnframes + rhhnover) / num_shot);
            chemfreq = view_per_shot;

            if( (exist(oprtcgate)==PSD_ON) && (resp_gate_trig_sw==0) )
                target_ti = 200ms;
            else
                target_ti = 120ms;

            if(0==fiesta_rampup_type){
                ugfsf_ramp_dda =  0;
                ugfsf_flat_dda = 20;
             }
             else{
                 ugfsf_ramp_dda = 10;

                 /******************************************************************/
                 /* Set the most conservative value for ugfsf_flat_dda (=0)        */
                 /* because act_tr is not accurate here. re-calculate it afterward */
                 /******************************************************************/
                 ugfsf_flat_dda =  0;
                 /*
                 if(ugfsf_view_order_flag==0)
                    ugfsf_flat_dda = 4;
                 else if(ugfsf_view_order_flag==1)
                     ugfsf_flat_dda = (int)ceil((double)(target_ti-cs_sattime)/act_tr) - ugfsf_ramp_dda - (int)(rhhnover/num_shot);
                 else if(ugfsf_view_order_flag==2)
                     ugfsf_flat_dda = (int)ceil((double)(target_ti-cs_sattime)/act_tr) - ugfsf_ramp_dda;
                 if(ugfsf_flat_dda<0) ugfsf_flat_dda = 0;
                 */
             }

            chemsat_dda = ugfsf_ramp_dda + ugfsf_flat_dda;
        }

        if ((osfp_flag || vast_mode || specir_flag) && irprep_flag) irdisdacqs = 0;

        irscale = 1.0/(irfreq + irdisdacqs);

        chemscale  = 1.0/(chemfreq + chemsat_dda);

        if (intermittant_chemsat == PSD_OFF) {
            sl_per_chem = 0;
        } else {
            sl_per_chem = chemfreq;  
        }

        if(irprep_flag == PSD_ON) {
            gradz[GZRF0_SLOT].scale = irscale;
            /* weight IR cursher pulse as well */
            gradz[GZRF0K_SLOT].scale = irscale;

            if(ifir_frir_flag)
            {
                gradz[GZRFFRIR_SLOT].scale = irscale;
                gradz[GZKRFFRIR_SLOT].scale = irscale;
            }
        }

        if(exist(opcgate) && (irprep_flag || navsat_flag) && slabtracking_flag) 
        {
            if(navigatorCYL_flag)
            {
                grady[GYCYLRATIPUP_SLOT].scale = navscale;
                grady[GYCYLRTIPUP_SLOT].scale = navscale;
                gradz[GZCYLRATIPUP_SLOT].scale = navscale;
                gradz[GZCYLRTIPUP_SLOT].scale = navscale;
                grady[GYCYLRATIPUP_SLOT].powscale = 1.0;
                grady[GYCYLRTIPUP_SLOT].powscale = 1.0;
                gradz[GZCYLRATIPUP_SLOT].powscale = 1.0;
                gradz[GZCYLRTIPUP_SLOT].powscale = 1.0;
            } else {
                grady[GYMONTIPUP_SLOT].scale = navscale;
                grady[GYMONTIPUP_SLOT].powscale = 1.0;
            }
            gradz[GZKMONTIPUP_SLOT].scale = navscale;
            gradz[GZKMONTIPUP_SLOT].powscale = 1.0;
        }

        if(exist(opcgate) && (irprep_flag || navsat_flag))
        {
            if(navigatorCYL_flag)
            {
                grady[GYCYLRA_SLOT].scale = navscale;
                grady[GYCYLR_SLOT].scale = navscale;
                gradz[GZCYLRA_SLOT].scale = navscale;
                gradz[GZCYLR_SLOT].scale = navscale;
                grady[GYCYLRA_SLOT].powscale = 1.0;
                grady[GYCYLR_SLOT].powscale = 1.0;
                gradz[GZCYLRA_SLOT].powscale = 1.0;
                gradz[GZCYLR_SLOT].powscale = 1.0;
            } else {
                gradx[GXFCMON_SLOT].scale = navscale;
                gradx[GX1MON_SLOT].scale = navscale;
                gradx[GXWMON_SLOT].scale = navscale;
                grady[GYRF2LMON_SLOT].scale = navscale;
                grady[GYRF2RMON_SLOT].scale = navscale;
                grady[GYRF2MON_SLOT].scale = navscale;
                grady[GYRF1MON_SLOT].scale = navscale;
                grady[GY1MON_SLOT].scale = navscale;
                gradz[GZRF1MON_SLOT].scale = navscale;
                gradz[GZ1MON_SLOT].scale = navscale;
                gradx[GXFCMON_SLOT].powscale = 1.0;
                gradx[GX1MON_SLOT].powscale = 1.0;
                gradx[GXWMON_SLOT].powscale = 1.0;
                grady[GYRF2LMON_SLOT].powscale = 1.0;
                grady[GYRF2RMON_SLOT].powscale = 1.0;
                grady[GYRF2MON_SLOT].powscale = 1.0;
                grady[GYRF1MON_SLOT].powscale = 1.0;
                grady[GY1MON_SLOT].powscale = 1.0;
                gradz[GZRF1MON_SLOT].powscale = 1.0;
                gradz[GZ1MON_SLOT].powscale = 1.0;
            }
            gradz[GZKMON_SLOT].scale = navscale;
            gradz[GZKMON_SLOT].powscale = 1.0;
        }

        /* scaling of IR gradient pulse for gated sequence ALP */
@inline VAST.e VAST_scaleKillergrad                                               

        if (intermittant_chemsat == PSD_ON) {
            /* weight the amp value of the chem sat gradients appropriately */
            gradx[GXKCS_SLOT].scale = chemscale;
            grady[GYKCS_SLOT].scale = chemscale;
            gradz[GZKCS_SLOT].scale = chemscale;
        }

        /* Increase rms current for SR 17 systems */
        if (cfsrmode == PSD_SR17) {
            loggrd.xirmspos = 46.0;
            loggrd.yirmspos = 46.0;
            loggrd.zirmspos = 46.0;

            loggrd.xirmsneg = 46.0;
            loggrd.yirmsneg = 46.0;
            loggrd.zirmsneg = 46.0;
        }

        /* We don't want intermittant chemsat to count againts pwm or amptrans */
        if ((intermittant_chemsat == PSD_ON)&&(( fatFlag == PSD_ON)||(opwater==PSD_ON)))
            grady[GYKCS_SLOT].num = 0;

        /* RF amp, SAR, and system limitations on seq time */
        /* set .powscale for each pulse.           QT*/
        if ((cfsrmode == PSD_SR17) && (opphysplane != PSD_OBL)) {
            gradx[GX1_SLOT].powscale =1.0;
            gradx[GXW_SLOT].powscale =1.0;
            gradx[GXWEX_SLOT].powscale =1.0;
            gradx[GKSX_SLOT].powscale =1.0;
            grady[GY1_SLOT].powscale =1.0;
            grady[GY1R_SLOT].powscale =1.0;
            gradz[GZRF1_SLOT].powscale =1.0;
            gradz[GZCOMB_SLOT].powscale =1.0;
            gradz[GZP_SLOT].powscale =1.0;
            gradz[GZRF0_SLOT].powscale =1.0;
            gradz[GZRF0K_SLOT].powscale =1.0;
            gradz[GKSZ_SLOT].powscale =1.0;

            if (ifir_frir_flag)
            {
                gradz[GZRFFRIR_SLOT].powscale =1.0;
                gradz[GZKRFFRIR_SLOT].powscale =1.0;
            }

            if (exist(opetl)>=2) {
               gradx[GX2_SLOT].powscale =1.0;
               gradx[GXW2_SLOT].powscale =1.0;
            }

            if (flow_comp_type == TYPFC) {
               gradz[GZ1_SLOT].powscale =1.0;
               gradx[GXFC_SLOT].powscale =1.0;
            }

            if (flow4D_flag==PSD_ON) {
               gradz[GZ1_SLOT].powscale =1.0;
               gradx[GXFC_SLOT].powscale =1.0;
               grady[GYFE1_SLOT].powscale =1.0;
               grady[GYFE2_SLOT].powscale =1.0;
            }

            if (msde_flag)
            {
                gradx[GXFLPVENC_SLOT].powscale = 1.0;
                grady[GYFLPVENC_SLOT].powscale = 1.0;
                gradz[GZFLPVENC_SLOT].powscale = 1.0;

                gradx[GXFLPK_SLOT].powscale = 1.0;
                grady[GYFLPK_SLOT].powscale = 1.0;
                gradz[GZFLPK_SLOT].powscale = 1.0;
            }

        } else {
            gradx[GX1_SLOT].powscale = loggrd.xfs/loggrd.tx_xyz;
            gradx[GXW_SLOT].powscale = loggrd.xfs/loggrd.tx_xyz;
            gradx[GXWEX_SLOT].powscale = loggrd.xfs/loggrd.tx_xyz;
            gradx[GKSX_SLOT].powscale = loggrd.xfs/loggrd.tx_xyz;
            grady[GY1_SLOT].powscale = loggrd.yfs/loggrd.ty_xyz;
            grady[GY1R_SLOT].powscale = loggrd.yfs/loggrd.ty_xyz;
            gradz[GZRF1_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;
            gradz[GZCOMB_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;
            gradz[GZP_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;
            gradz[GZRF0_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;
            gradz[GZRF0K_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;
            gradz[GKSZ_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;

            if (ifir_frir_flag)
            {
                gradz[GZRFFRIR_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;
                gradz[GZKRFFRIR_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;
            }

            if (exist(opetl)>=2) {
               gradx[GX2_SLOT].powscale = loggrd.xfs/loggrd.tx_xyz;
               gradx[GXW2_SLOT].powscale = loggrd.xfs/loggrd.tx_xyz;
            }

            if (flow_comp_type == TYPFC) {
               gradz[GZ1_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;
               gradx[GXFC_SLOT].powscale = loggrd.xfs/loggrd.tx_xyz;
            }
            if (flow4D_flag==PSD_ON) {
               gradz[GZ1_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;
               gradx[GXFC_SLOT].powscale = loggrd.xfs/loggrd.tx_xyz;
               grady[GYFE1_SLOT].powscale = loggrd.yfs/loggrd.ty_xyz;
               grady[GYFE2_SLOT].powscale = loggrd.yfs/loggrd.ty_xyz;
            }

            if (msde_flag)
            {
                gradx[GXFLPVENC_SLOT].powscale = loggrd.xfs/loggrd.tx_xyz;
                grady[GYFLPVENC_SLOT].powscale = loggrd.yfs/loggrd.ty_xyz;
                gradz[GZFLPVENC_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;

                gradx[GXFLPK_SLOT].powscale = loggrd.xfs/loggrd.tx_xyz;
                grady[GYFLPK_SLOT].powscale = loggrd.yfs/loggrd.ty_xyz;
                gradz[GZFLPK_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;
            }

        }

        if (FAILURE == t2prep_cveval())
        {
            epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "t2prep_cveval");
            return FAILURE;
        }

        /* Perform grad safety checks for main sequence (idx_seqcore) */
        seqEntryIndex = idx_seqcore;
        if ( FAILURE == minseq( &min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, seqEntryIndex, tsamp, tmin,
                                use_ermes, seg_debug ) ) {
            epic_error( use_ermes, "%s failed.",
                        EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
            return FAILURE;
        }

        /* GEHmr02863: if skip_minseqseg not equal to false, minseq() does not run.
           Do not multiple by osfp_weight_grad to get correct limitations */
        if ((osfp_flag) && ((FALSE == skip_minseqseg) || (fabs(old_osfp_weight_grad-osfp_weight_grad)>1.0E-6)))
        {
            if(FALSE==skip_minseqseg)
            {
                unscaled_minseqgpm_t = minseqgpm_t;
                unscaled_minseqcoil_t = minseqcoil_t; 
                unscaled_minseqcable_t = minseqcable_t; 
                unscaled_minseqbusbar_t = minseqbusbar_t; 
                unscaled_minseqchoke_t = minseqchoke_t; 
                if (5550 == cfgradamp)
                {
                    unscaled_minseqgrddrv_case_t = minseqgrddrv_case_t; 
                    unscaled_minseqcable_maxpow_t = minseqcable_maxpow_t; 
                }
            }
            else
            {
                if(fabs(old_osfp_weight_grad-osfp_weight_grad)>1.0E-6)
                {
                    minseqgpm_t=unscaled_minseqgpm_t;
                    minseqcoil_t=unscaled_minseqcoil_t; 
                    minseqcable_t=unscaled_minseqcable_t; 
                    minseqbusbar_t=unscaled_minseqbusbar_t; 
                    minseqchoke_t=unscaled_minseqchoke_t; 
                    if (5550 == cfgradamp)
                    {
                        minseqgrddrv_case_t=unscaled_minseqgrddrv_case_t; 
                        minseqcable_maxpow_t=unscaled_minseqcable_maxpow_t; 
                    }
                    else
                    {
                        min_seqgrad = IMax(5, minseqgrddrv_t, minseqgpm_t, minseqcable_t, minseqcable_maxpow_t, minseqcoil_t);
                    }
                    old_osfp_weight_grad=osfp_weight_grad;
                }
            }

            if(debug_scale)
            {
                printf("min_seqgrad=%d,osfp_weight_grad=%f,seg_totalPEs=%d,skip_minseqseg=%d,old_osfp_weight_grad=%f\n", 
                min_seqgrad, osfp_weight_grad, seg_totalPEs,skip_minseqseg,old_osfp_weight_grad);
            }

            /* In SSSD (cfgradamp = 5550), osfp_weight_grad is not applied to minseq*
                for short thermal time constant components (less than about 1sec) */

            if (5550 != cfgradamp)
            {
                minseqgrddrv_t = RUP_GRD((int) (osfp_weight_grad*minseqgrddrv_t));
            }

            if (5550 == cfgradamp)
            {
                minseqgrddrv_case_t = RUP_GRD((int) (osfp_weight_grad*minseqgrddrv_case_t));
                minseqcable_maxpow_t = RUP_GRD((int) (osfp_weight_grad*minseqcable_maxpow_t));
            }

            minseqgpm_t = RUP_GRD((int) (osfp_weight_grad*minseqgpm_t));
            minseqcoil_t = RUP_GRD((int) (osfp_weight_grad*minseqcoil_t));
            minseqcable_t = RUP_GRD((int) (osfp_weight_grad*minseqcable_t));
            minseqbusbar_t = RUP_GRD((int) (osfp_weight_grad*minseqbusbar_t));
            minseqchoke_t = RUP_GRD((int) (osfp_weight_grad*minseqchoke_t));

            if (5550 == cfgradamp)
            {
                min_seqgrad = IMax(7, minseqgrddrv_t, minseqgrddrv_case_t,
                                      minseqgpm_t, minseqgpm_maxpow_t,
                                      minseqcable_t, minseqcable_maxpow_t,
                                      minseqcoil_t);
            }
            else
            {
                min_seqgrad = RUP_GRD((int) (osfp_weight_grad*min_seqgrad));
            }
        }

        /* Under voltage prediction for SSSD */
        if(5550 == cfgradamp && vol_ratio_est_req < 1.0)
        {
            if(PSD_ON == exist(opmerge) || PSD_ON == exist(opswan))
            {
                epic_error(use_ermes,
                           "Too much Gradient Power is required.",
                           EM_PSD_GRADPOWER_FOV_BW_PHASE_TE, EE_ARGS(0));
            }
            else
            {
                epic_error(use_ermes,
                           "Too much Gradient Power is required.",
                           EM_PSD_GRADPOWER_FOV_BW_PHASE, EE_ARGS(0));
            }

            return FAILURE;
        }
   
        /* We don't want intermittant chemsat to count againts pwm or amptrans */
        if ((intermittant_chemsat == PSD_ON) && ( (fatFlag == PSD_ON) || (opwater == PSD_ON) ) )
            grady[GYKCS_SLOT].num = 1;

        /*************************************************
          RF Scaling
          Scale SAT Pulses to the area of the 90 pulse.
          ********************************************** */

        /* First, find the peak B1 for the whole sequence. */
        if (findMaxB1Seq(&maxB1Seq, maxB1, MAX_ENTRY_POINTS, rfpulse, RF_FREE) == FAILURE)
        {
            epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"findMaxB1Seq");
            return FAILURE;
        }

        /* Throw in an extra scale factor to account for xmtadd. */
        if (setScale(L_SCAN, RF_FREE, rfpulse, 
                     maxB1[L_SCAN],maxB1[L_SCAN]/maxB1Seq) == FAILURE) {
            epic_error(use_ermes, "%s failed.",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "setScale");
            return FAILURE;
        }


        /* RF amp, SAR, and system limitations on seq time */
        /* If spatial sat is on
           the spatial sat pulses must be weighted by (1/(satview+2)),
           the chem sat pulses must be weighted by ((satview+1)/(satview+2)), and
           the regular pulses must be weighted by ((satview+1)/(satview+2)).

           One way to accomplish this is to set the num field of the pulses to
           these various weights.  However, in the 5.3 release the num field is
           an integer.  To create the same effect,both the act fa and the pw
           fields of the pulses are multiplied by the appropriate weight. */
        if ( (sp_sat) && (vast_mode == PSD_OFF) ) {
            /* copy the pw and act fa values of all the pulses into temp vars */
            for (numpulses = 0; numpulses < RF_FREE; numpulses++) {
                temprfpw[numpulses] = *rfpulse[numpulses].pw;
                temprffa[numpulses] = *rfpulse[numpulses].act_fa;
            }

            /* weight the pw and act fa value of the sat pulses */
            for (numpulses = 0; numpulses < NUMRFSAT; numpulses++) {
                *rfpulse[numpulses].pw *= satweight;
                *rfpulse[numpulses].act_fa *= satweight;
            }

            if ( (fatFlag == PSD_ON)  || (opwater == PSD_ON) ) {
                /* weight the pw and act fa value of the chem sat pulses */
                for (numpulses = NUMRFSAT; numpulses < NUMRFSAT + 1; numpulses++) {
                    *rfpulse[numpulses].pw *= chemweight;
                    *rfpulse[numpulses].act_fa *= chemweight;
                }
            }

            /* weight the pw and act fa value of all the reg pulses */
            for (numpulses = NUMRFSAT + 1; numpulses < NUMRFSAT + 2; numpulses++) {
                *rfpulse[numpulses].pw *= regweight;
                *rfpulse[numpulses].act_fa *= regweight;
            }
        }

        /* IR PREP (pjg) */
        /*
          Determine scaling factor to be used on rf pulse for the IR prep
          pulse. The pulse is not played for every sequence so the number
          of occurrences should be scaled appropriately. Since num field in
          the structure is an integer, the pulse width & flip angle fields is 
          scaled by the frequency of the IR prep pulse.
          1/(irfreq + irdisdacqs)
        */
        if( PSD_ON == irprep_flag ) {
            temprfpw[RF0_SLOT] = *rfpulse[RF0_SLOT].pw;
            temprffa[RF0_SLOT] = *rfpulse[RF0_SLOT].act_fa;
            *rfpulse[RF0_SLOT].pw *= irscale;
            *rfpulse[RF0_SLOT].act_fa *= irscale;
        }

        /* IFIR GRx */
        if (ifir_flag == PSD_ON)
        {
            /* Copy the pw and fa values of the pulses into temp vars */
            if (exist(opgirmode) == PSD_GIRMANUAL)
            {
                temp_rfgir01pw = *rfpulse[RFGIR01_SLOT].pw;
                temp_rfgir01fa = *rfpulse[RFGIR01_SLOT].act_fa;

                temp_rfgir02pw = *rfpulse[RFGIR02_SLOT].pw;
                temp_rfgir02fa = *rfpulse[RFGIR02_SLOT].act_fa;

                /* Scale VAST_ScaleIRrf was removed from VAST.e hence 
                 * the changes are incorporated here itself */

                if(exist(opnumgir) >= 1) 
                {
                    *rfpulse[RFGIR01_SLOT].pw *= irscale;
                    *rfpulse[RFGIR01_SLOT].act_fa *= irscale;
                 
                    *rfpulse[RFGIR02_SLOT].pw *= irscale;
                    *rfpulse[RFGIR02_SLOT].act_fa *= irscale;
                }
            }
        }

        if (ifir_flag && sp_sat) {
            /* copy the pw and act fa values of all the pulses into temp vars */
            for (numpulses = 0; numpulses < NUMRFSAT; numpulses++) {
                temprfpw[numpulses] = *rfpulse[numpulses].pw;
                temprffa[numpulses] = *rfpulse[numpulses].act_fa;
                *rfpulse[numpulses].pw *= 1.0/(max_pencodes+ssfp_flag*fiesta_gated_dda);
                *rfpulse[numpulses].act_fa *= 1.0/(max_pencodes+ssfp_flag*fiesta_gated_dda);
            }
        }

        /* Intermittant chem sat is handled just like IR prep */
        if (intermittant_chemsat == PSD_ON) {
            if ( (sp_sat) && (vast_mode == PSD_OFF) ) {
                /* HCSDM00268699 -- Restore original pw/fa before
                 * scaling */
                *rfpulse[RFCSSAT_SLOT].pw = temprfpw[RFCSSAT_SLOT];
                *rfpulse[RFCSSAT_SLOT].act_fa = temprffa[RFCSSAT_SLOT];
            }
            temprfpw[RFCSSAT_SLOT] = *rfpulse[RFCSSAT_SLOT].pw;
            temprffa[RFCSSAT_SLOT] = *rfpulse[RFCSSAT_SLOT].act_fa;
            *rfpulse[RFCSSAT_SLOT].pw *= chemscale;
            *rfpulse[RFCSSAT_SLOT].act_fa *= chemscale;
        }
    
        if(exist(opcgate) && (irprep_flag || navsat_flag) && slabtracking_flag) 
        {
            if(navigatorCYL_flag)
            {
                temprfpw[RFCYLRTIPUP_SLOT] = *rfpulse[RFCYLRTIPUP_SLOT].pw;
                temprffa[RFCYLRTIPUP_SLOT] = *rfpulse[RFCYLRTIPUP_SLOT].act_fa;
                *rfpulse[RFCYLRTIPUP_SLOT].pw *= navscale;
                *rfpulse[RFCYLRTIPUP_SLOT].act_fa *= navscale;
            } else {
                temprfpw[RFMONTIPUP_SLOT] = *rfpulse[RFMONTIPUP_SLOT].pw;
                temprffa[RFMONTIPUP_SLOT] = *rfpulse[RFMONTIPUP_SLOT].act_fa;
                *rfpulse[RFMONTIPUP_SLOT].pw *= navscale;
                *rfpulse[RFMONTIPUP_SLOT].act_fa *= navscale;
            }
        }

        if(exist(opcgate) && (irprep_flag || navsat_flag)) 
        {
            if(navigatorCYL_flag)
            {
                temprfpw[RFCYLR_SLOT] = *rfpulse[RFCYLR_SLOT].pw;
                temprffa[RFCYLR_SLOT] = *rfpulse[RFCYLR_SLOT].act_fa;
                *rfpulse[RFCYLR_SLOT].pw *= navscale;
                *rfpulse[RFCYLR_SLOT].act_fa *= navscale;
            } else {
                temprfpw[RF1MON_SLOT] = *rfpulse[RF1MON_SLOT].pw;
                temprffa[RF1MON_SLOT] = *rfpulse[RF1MON_SLOT].act_fa;
                *rfpulse[RF1MON_SLOT].pw *= navscale;
                *rfpulse[RF1MON_SLOT].act_fa *= navscale;
                temprfpw[RF2MON_SLOT] = *rfpulse[RF2MON_SLOT].pw;
                temprffa[RF2MON_SLOT] = *rfpulse[RF2MON_SLOT].act_fa;
                *rfpulse[RF2MON_SLOT].pw *= navscale;
                *rfpulse[RF2MON_SLOT].act_fa *= navscale;
            }
        }

        /* Scale rf fields appropriately to achieve correct rf amp heating calculations
           This is done for T2 Prep since the sequence is played out only every optr. 
           SAR values are accurate since the appropriate fields have been modified
           with t2prep_rate in T2Prep.e */
        if( t2prep_flag ) 
        {
            int tmppw;
            temprfpw[RF90_SLOT] = *rfpulse[RF90_SLOT].pw;
            temprffa[RF90_SLOT] = *rfpulse[RF90_SLOT].act_fa;
            temprfpw[RF180_SLOT] = *rfpulse[RF180_SLOT].pw;
            temprffa[RF180_SLOT] = *rfpulse[RF180_SLOT].act_fa;
            temprfpw[RFTIPUP_SLOT] = *rfpulse[RFTIPUP_SLOT].pw;
            temprffa[RFTIPUP_SLOT] = *rfpulse[RFTIPUP_SLOT].act_fa;

            tmppw = RUP_RF((int)ceil(*rfpulse[RF90_SLOT].pw * t2prep_rate));
            *rfpulse[RF90_SLOT].pw = tmppw;
            *rfpulse[RF90_SLOT].act_fa = temprffa[RF90_SLOT]/temprfpw[RF90_SLOT]*tmppw;
            tmppw = RUP_RF((int)ceil(*rfpulse[RF180_SLOT].pw * t2prep_rate));
            *rfpulse[RF180_SLOT].pw = tmppw;
            *rfpulse[RF180_SLOT].act_fa = temprffa[RF180_SLOT]/temprfpw[RF180_SLOT]*tmppw;
            tmppw = RUP_RF((int)ceil(*rfpulse[RFTIPUP_SLOT].pw * t2prep_rate));
            *rfpulse[RFTIPUP_SLOT].pw = tmppw;
            *rfpulse[RFTIPUP_SLOT].act_fa = temprffa[RFTIPUP_SLOT]/temprfpw[RFTIPUP_SLOT]*tmppw;
        }

        if (msde_flag)
        {
            int tmppw;

            msde_rate = (views_per_segment >= 1.0) ? (1.0 / views_per_segment) : 1.0;

            temprfpw[RFFLP90_SLOT]  = *rfpulse[RFFLP90_SLOT].pw;
            temprffa[RFFLP90_SLOT]  = *rfpulse[RFFLP90_SLOT].act_fa;
            temprfpw[RFFLP180_SLOT] = *rfpulse[RFFLP180_SLOT].pw;
            temprffa[RFFLP180_SLOT] = *rfpulse[RFFLP180_SLOT].act_fa;
            temprfpw[RFFLP90R_SLOT] = *rfpulse[RFFLP90R_SLOT].pw;
            temprffa[RFFLP90R_SLOT] = *rfpulse[RFFLP90R_SLOT].act_fa;

            tmppw = RUP_RF((int)ceil(*rfpulse[RFFLP90_SLOT].pw * msde_rate));
            *rfpulse[RFFLP90_SLOT].pw = tmppw;
            *rfpulse[RFFLP90_SLOT].act_fa = temprffa[RFFLP90_SLOT]/temprfpw[RFFLP90_SLOT]*tmppw;

            tmppw = RUP_RF((int)ceil(*rfpulse[RFFLP180_SLOT].pw * msde_rate));
            *rfpulse[RFFLP180_SLOT].pw = tmppw;
            *rfpulse[RFFLP180_SLOT].act_fa = temprffa[RFFLP180_SLOT]/temprfpw[RFFLP180_SLOT]*tmppw;

            tmppw = RUP_RF((int)ceil(*rfpulse[RFFLP90R_SLOT].pw * msde_rate));
            *rfpulse[RFFLP90R_SLOT].pw = tmppw;
            *rfpulse[RFFLP90R_SLOT].act_fa = temprffa[RFFLP90R_SLOT]/temprfpw[RFFLP90R_SLOT]*tmppw;
        }

        if( debug_scale == PSD_ON ) {
            if( vast_mode == PSD_ON ) {
                if( irprep_flag == PSD_ON ) {
                    rfpulse[RF0_SLOT].num = 1;
                }
                if( fatFlag == PSD_ON ) {
                    rfpulse[RFCSSAT_SLOT].num = 1;
                }      
                rfpulse[RF1_SLOT].num = max_pencodes + fiesta_gated_dda;
            }
        }

        if ( exist(opfluorotrigger) == PSD_ON ) {
            ftmra_satact_off();
        }

        /* MRIge82416 -SVR 
         * return FAILURE when minseqrfamp() returns a FAILURE */
        if( minseqrfamp( &min_seqrfamp, (int)RF_FREE, rfpulse, L_SCAN ) == FAILURE ) { 
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1),STRING_ARG,"minseqrfamp");
            if( t2prep_flag )
            { 
                *rfpulse[RF90_SLOT].pw = temprfpw[RF90_SLOT];
                *rfpulse[RF90_SLOT].act_fa = temprffa[RF90_SLOT];
                *rfpulse[RF180_SLOT].pw = temprfpw[RF180_SLOT];
                *rfpulse[RF180_SLOT].act_fa = temprffa[RF180_SLOT];
                *rfpulse[RFTIPUP_SLOT].pw = temprfpw[RFTIPUP_SLOT];
                *rfpulse[RFTIPUP_SLOT].act_fa = temprffa[RFTIPUP_SLOT];
            }
            if (msde_flag)
            {
                *rfpulse[RFFLP90_SLOT].pw      = temprfpw[RFFLP90_SLOT];
                *rfpulse[RFFLP90_SLOT].act_fa  = temprffa[RFFLP90_SLOT];
                *rfpulse[RFFLP180_SLOT].pw     = temprfpw[RFFLP180_SLOT];
                *rfpulse[RFFLP180_SLOT].act_fa = temprffa[RFFLP180_SLOT];
                *rfpulse[RFFLP90R_SLOT].pw     = temprfpw[RFFLP90R_SLOT];
                *rfpulse[RFFLP90R_SLOT].act_fa = temprffa[RFFLP90R_SLOT];
            }
            return FAILURE;
        }

        if( maxseqsar( &max_seqsar, (int)RF_FREE, rfpulse, L_SCAN ) == FAILURE ) {
            epic_error(use_ermes, "%s failed", 
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "maxseqsar");
            if( t2prep_flag )
            { 
                *rfpulse[RF90_SLOT].pw = temprfpw[RF90_SLOT];
                *rfpulse[RF90_SLOT].act_fa = temprffa[RF90_SLOT];
                *rfpulse[RF180_SLOT].pw = temprfpw[RF180_SLOT];
                *rfpulse[RF180_SLOT].act_fa = temprffa[RF180_SLOT];
                *rfpulse[RFTIPUP_SLOT].pw = temprfpw[RFTIPUP_SLOT];
                *rfpulse[RFTIPUP_SLOT].act_fa = temprffa[RFTIPUP_SLOT];
            }
            if (msde_flag)
            {
                *rfpulse[RFFLP90_SLOT].pw      = temprfpw[RFFLP90_SLOT];
                *rfpulse[RFFLP90_SLOT].act_fa  = temprffa[RFFLP90_SLOT];
                *rfpulse[RFFLP180_SLOT].pw     = temprfpw[RFFLP180_SLOT];
                *rfpulse[RFFLP180_SLOT].act_fa = temprffa[RFFLP180_SLOT];
                *rfpulse[RFFLP90R_SLOT].pw     = temprfpw[RFFLP90R_SLOT];
                *rfpulse[RFFLP90R_SLOT].act_fa = temprffa[RFFLP90R_SLOT];
            }
            return FAILURE;
        }

        if(exist(opcgate) && (irprep_flag || navsat_flag) && slabtracking_flag)
        {
            if(navigatorCYL_flag)
            {
                *rfpulse[RFCYLRTIPUP_SLOT].pw = temprfpw[RFCYLRTIPUP_SLOT];
                *rfpulse[RFCYLRTIPUP_SLOT].act_fa = temprffa[RFCYLRTIPUP_SLOT];
            } else {
                *rfpulse[RFMONTIPUP_SLOT].pw = temprfpw[RFMONTIPUP_SLOT];
                *rfpulse[RFMONTIPUP_SLOT].act_fa = temprffa[RFMONTIPUP_SLOT];
            }
        }

        if(exist(opcgate) && (irprep_flag || navsat_flag))
        {
            if(navigatorCYL_flag)
            {
                *rfpulse[RFCYLR_SLOT].pw = temprfpw[RFCYLR_SLOT];
                *rfpulse[RFCYLR_SLOT].act_fa = temprffa[RFCYLR_SLOT];
            } else {
                *rfpulse[RF1MON_SLOT].pw = temprfpw[RF1MON_SLOT];
                *rfpulse[RF1MON_SLOT].act_fa = temprffa[RF1MON_SLOT];
                *rfpulse[RF2MON_SLOT].pw = temprfpw[RF2MON_SLOT];
                *rfpulse[RF2MON_SLOT].act_fa = temprffa[RF2MON_SLOT];
            }
        }

        if( t2prep_flag ) 
        {
            *rfpulse[RF90_SLOT].pw = temprfpw[RF90_SLOT];
            *rfpulse[RF90_SLOT].act_fa = temprffa[RF90_SLOT];
            *rfpulse[RF180_SLOT].pw = temprfpw[RF180_SLOT];
            *rfpulse[RF180_SLOT].act_fa = temprffa[RF180_SLOT];
            *rfpulse[RFTIPUP_SLOT].pw = temprfpw[RFTIPUP_SLOT];
            *rfpulse[RFTIPUP_SLOT].act_fa = temprffa[RFTIPUP_SLOT];
        }

        if (msde_flag)
        {
            *rfpulse[RFFLP90_SLOT].pw      = temprfpw[RFFLP90_SLOT];
            *rfpulse[RFFLP90_SLOT].act_fa  = temprffa[RFFLP90_SLOT];
            *rfpulse[RFFLP180_SLOT].pw     = temprfpw[RFFLP180_SLOT];
            *rfpulse[RFFLP180_SLOT].act_fa = temprffa[RFFLP180_SLOT];
            *rfpulse[RFFLP90R_SLOT].pw     = temprfpw[RFFLP90R_SLOT];
            *rfpulse[RFFLP90R_SLOT].act_fa = temprffa[RFFLP90R_SLOT];
        }

        max_seqsar = max_seqsar + 1;  /* MRIge62876,DCZ: max_seqsar is an interger. The 
                                         rounding has led to some problem in
                                         SAR evaluation. Add 1 microsand to 
                                         ensure that the max_seqsar is not 
                                         violated. */

        if ( (sp_sat) && (vast_mode == PSD_OFF) ) {
            /* restore the pulse width and flip angle value of all the pulses */
            for (numpulses = 0; numpulses < RF_FREE; numpulses++) {
                *rfpulse[numpulses].pw = temprfpw[numpulses];
                *rfpulse[numpulses].act_fa = temprffa[numpulses];
            }
        }

        /* IR PREP (pjg) */
        /* Restore original flip angle and pulse width to IR prep pulse. */ 
        if( irprep_flag == PSD_ON ) {
            *rfpulse[RF0_SLOT].pw = temprfpw[RF0_SLOT];
            *rfpulse[RF0_SLOT].act_fa = temprffa[RF0_SLOT];
        }

        /* IFIR GRx */
        if (ifir_flag == PSD_ON)
        {
            /* Restore the pw and fa values of the pulses from temp vars */
            if (exist(opirmode) == PSD_GIRMANUAL)
            {
                *rfpulse[RFGIR01_SLOT].pw = temp_rfgir01pw;
                *rfpulse[RFGIR01_SLOT].act_fa = temp_rfgir01fa;

                *rfpulse[RFGIR02_SLOT].pw = temp_rfgir02pw;
                *rfpulse[RFGIR02_SLOT].act_fa = temp_rfgir02fa;
            }
        }

        if (ifir_flag && sp_sat) {
            /* copy the pw and act fa values of all the pulses into temp vars */
            for (numpulses = 0; numpulses < NUMRFSAT; numpulses++) {
                *rfpulse[numpulses].pw = temprfpw[numpulses];
                *rfpulse[numpulses].act_fa = temprffa[numpulses];
            }
        }

        if (intermittant_chemsat == PSD_ON) {
            *rfpulse[RFCSSAT_SLOT].pw = temprfpw[RFCSSAT_SLOT];
            *rfpulse[RFCSSAT_SLOT].act_fa = temprffa[RFCSSAT_SLOT];
        }

        if (2 == rfb1opt_flag) {
            bf_rfscale = IMax(2,max_seqsar, min_seqrfamp);
        }

        max_seqsar_orig = max_seqsar;

        if (osfp_flag)
        {
            max_seqsar = RUP_GRD(((int) (osfp_weight*max_seqsar) +150));
            min_rfavgpow = RUP_GRD((int) (osfp_weight*min_rfavgpow));
            min_rfrmsb1 = RUP_GRD((int) (osfp_weight*min_rfrmsb1));
            min_rfdycc = RUP_GRD((int) (osfp_weight*min_rfdycc));
            min_rfampcpblty = RUP_GRD((int) (osfp_weight*min_rfampcpblty));
            min_seqrfamp = RUP_GRD((int) (osfp_weight*min_seqrfamp));
        }

        /* ALP cardiac feature MGD2: Proposal to modify act_tr
           limitation from minseqrfamp and maxseqsar for gated 
           sequences based on the assumption about actual RF pulse 
           "ON" duration during the RR interval.  The scale factor 
           is based of the fraction of available imaging time that 
           RF is actually ON and the minseqrfamp and maqseqsar are 
           scaled appropriately */
@inline VAST.e VAST_scaleTR


        /*  MRIge62874, DCZ:
            tmin_reduced is used to reduce the TR.  It
            distributed the dead time in IRprep in equal
            fraction to each read-out period.
        */
        tmin_reduced = 0;
        if( irprep_flag && (!vast_mode) ) {
            tmin_reduced = tmin_reduced +  (tseq_irprep + time_ssi -
                                            2*pw_gzrf0a - pw_gzrf0 - 2*pw_gzrf0ka -  pw_gzrf0k)/
                (irfreq + irdisdacqs); 
            /* MRIge62874, DCZ: Uses the the equation for
               the old adj_tmin. It corresponds to
               adj_act_tr calculation later, but
               a bit more conservative here.*/
        }

        /* IFIR GRx */
        if (ifir_flag == PSD_ON)
        {
            if ((exist(opgirmode) == PSD_GIRMANUAL) && (exist(opnumgir) >= 1))
            {
                tmin_reduced = tmin_reduced + ((gir_time_eval + time_ssi) / (irfreq + irdisdacqs));
            }
        }

        /* DCZ: The specir_ti is already shortened to an optimal level. Trying to
           reduce to tmin_total further can easily lead to SAR problem. 
           Further reduction for the case of intermittant_chemsat is not used 
           here. */

        /* DCZ: Delay due to the use of multi-phase might help to reduce the 
           tmin_toal. However, the reduction of tmin_total based on multi-phase 
           can also lead to other problem, such as Tgt problem. So just be 
           conservative and not to use it as a factor for the TR reduction. */
        /* MRIge91684 */
@inline RFb1opt.e RFb1opteval

        tmin_total_temp = IMax( 3,
                                ((sbm_flag) ? 0 : min_seqgrad), /* SVBranch, Smart Burst Mode */
                                min_seqrfamp,
                                max_seqsar ) - tmin_reduced; /* MRIge62874, DCZ */

        tmin_total = IMax( 2,tmin,tmin_total_temp);  /*  MRIge62874, DCZ */

         /* MRIhc16935 */

        if( (irprep_flag == PSD_ON) 
            || ((ifir_flag == PSD_ON) && ((exist(opgirmode) == PSD_GIRMANUAL) && (exist(opnumgir) >= 1))) ) {

            if ( min_seqgrad > tmin_total) {
                
                psd_tol_value = min_seqgrad - tmin_total; 
            }
            else {
                psd_tol_value = 0;
            }
            
        }else {
            
            psd_tol_value = 0;
        }

        
        printDebug( DBLEVEL1, (dbLevel_t)seg_debug, funcName, "minseqcoil_t = %d\n", minseqcoil_t );
        printDebug( DBLEVEL1, (dbLevel_t)seg_debug, funcName, "minseqgrddrv_t = %d\n", minseqgrddrv_t );
        printDebug( DBLEVEL1, (dbLevel_t)seg_debug, funcName, "minseqgpm_t = %d\n", minseqgpm_t );
        printDebug( DBLEVEL1, (dbLevel_t)seg_debug, funcName, "min_seqrfamp = %d\n", min_seqrfamp );
        printDebug( DBLEVEL1, (dbLevel_t)seg_debug, funcName, "max_seqsar = %d\n", max_seqsar );

       /* MRIhc16353 - RV: IDEAL change */
       if(PSD_ON == ideal_flag)
       {
           if (ideal_opt_te > 0) {
               te_time = ideal_min_te;
           }
        }
        
        /* symmetric TE for IFIR */
        if ( ssfp_flag && ssfp_symmetry_flag && (tmin_total > tmin) &&
             (exist(opautote) == PSD_MINTEFULL) )
        {
            te_time = RUP_GRD (tmin_total/2);
            tmin_total = te_time * 2;
            non_tetime = te_time;
        }
  
        act_te = te_time;
        opte = act_te;

        if ( vstrte_flag )
        {
            avminte = (int) 10.0*floor(act_te/10.0);  
        }
        else
        {
            avminte = act_te;
        }

        if (!flexte_flag)
           setexist(opte, 1);

        /* Set maximum TE after the calculation for avminte is done */
        if (merge_flag) {
           avminte = act_te + (int) (merge_echoIndex*esp);
           avminte *= 10;
           advroundup(&avminte);
           avminte /= 10;
        } else {
           avmaxte = avminte + 10ms;
        }

        if ((exist(opetl) >= 2) || medal_flag) {
            if (!merge_flag) {
               avmaxte = act_te;
               if (PSD_OFF == medal_multitr_flag)  
                   avmaxte2 = act_te + (opetl-1)*esp;
               else 
                   avmaxte2 = medal_te2;
            }

            if (idealiq_flag)
            {
                /* to display min and max TE on UI */
                avmaxte = avminte + idealiq_esp*(exist(opnecho)-1);
            }

            /* 
            if (medal_flag) {
              if (rhmedal_echo_order) {
                 avmaxte = medal_ip_te_max;
                 avmaxte2 = medal_oop_te_max;
              } else {
                 avmaxte = medal_oop_te_max;
                 avmaxte2 = medal_ip_te_max;
              }
            }
            */

        }
        else
        {
            advrounddown(&avmaxte);
        }

        printDebug( DBLEVEL1, (dbLevel_t)seg_debug, funcName, "tmin = %d\n", tmin );
        printDebug( DBLEVEL1, (dbLevel_t)seg_debug, funcName, "tmin_total = %d\n", tmin_total );
        avmintseq = tmin_total;

        if (merge_flag)
        {
           if (exist(opuser16)==0) {
              if (cffield < B0_30000)
                 merge_mintr = MERGE_TR_1HT;
              else
                 merge_mintr = MERGE_TR_3T;
           }
           else
           {
              merge_mintr = tmin_total;
           }
           avmintr = IMax (2, merge_mintr, tmin_total);
        }
        else
        {
           avmintr=IMax(2, tmin_total, avmintr);
        }

        if(flextr_flag) {
            avmintr *= 10;
            advroundup(&avmintr);
            avmintr /= 10;
        }

        if (maxpass(&acqs,seq_type,rhnslices, arc_equant) == FAILURE) {
            epic_error(use_ermes,"%s failed",
                       EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"maxpass");
            return FAILURE;
        }
        
        /* If acq to disk is on, check disk limit.  Use worst case */
        if (rhdiskacqctrl & RDB_DISK_ACQ_OVERFLOW) {
            int max_acq_disk = 0;

            /* Determine number of acquisition that will fit on disk */

            max_acq_disk = maxpassquantdisk(rhdaxres, rhdayres, rhptsize, rhnex,
                                            rhnecho, opslquant, opvquant,
                                            cfacqtodisksize);

            /* Increment by rhinitpass this many passes will be allocated in BAM and will
             * not need to go to disk */

            max_acq_disk += rhinitpass;

            /* Check whether current Rx will fit */
            if ( acqs > max_acq_disk )
            {
                epic_error( use_ermes, "No memory for a scan this size."
                            "Please reduce the scan size.", EM_PSD_SCAN_SIZE, EE_ARGS(0) );
                return FAILURE;
            }
        }

        rhnpasses = acqs;

        if (RDB_DISK_ACQ_OVERFLOW == (rhdiskacqctrl & RDB_DISK_ACQ_OVERFLOW))
        {
            rhinitpass = DISK_ACQ_RHINITPASS;
        }
        else if ( rhnpasses > 1 )
        {
            /* MRIhc50672
               All phases/slabs of certain types of acquisitions must entirely fit in BAM.
               For example, Dynaplan with multiple slabs. */
            if ( exist(opdynaplan) || medal_flag || quickstep_flag ||
                 ( ((rhdab0e - rhdab0s + 1) >= 16) && (ACCEL_ARC == rhasset) ) )
            {
                rhinitpass = rhnpasses;
            } 
            else
            {
                rhinitpass = IMin( 2, exist(optphases) * exist(opfphases) * exist(opvquant), 3 );
            }
        } 
        else 
        {
            rhinitpass = 1;
        }

@inline Tricks.e Setacqs

        /* MRIge82416 -SVR: return FAILURE when slicein1() returns a FAILURE */
        if (slicein1(&slquant_per_trig, acqs, seq_type) == FAILURE) {
            epic_error(use_ermes, "%s failed", 
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG,"slicein1");
            slquant_per_trig = 1; /* just try to get out of eval to catch
                                     the problem in cvcheck */
            return FAILURE;
        }

        if (slquant_per_trig == 0) {
            epic_error(use_ermes, "slquant_per_trig is 0", EM_PSD_SLQUANT_ZERO, EE_ARGS(0));
            return FAILURE;
        }

        slquant1 = slquant_per_trig;

        avround = 0;	/* do not roundup in mintr call */
        /* MRIge41507 fix CMC */
        /* MRIge82416 -SVR: return FAILURE when mintr() returns a FAILURE */
        if (mintr(&avmintr, seq_type,
                  tmin_total - ((gating == TRIG_LINE)? 1ms / slquant_per_trig : 0),  
                  slquant_per_trig, gating) == FAILURE) {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1),STRING_ARG,"mintr");
            return FAILURE;
        }

        if (merge_flag)
        {
           if (exist(opuser16)==0) {
              if (cffield < B0_30000)
                 merge_mintr = MERGE_TR_1HT;
              else
                 merge_mintr = MERGE_TR_3T;
           }
           else
           {
              merge_mintr = tmin_total;
           }
           avmintr = IMax (2, merge_mintr, tmin_total);
        }
        else
        {
           avmintr = tmin_total;
        }

        if(flextr_flag) {
            avmintr *= 10;
            advroundup(&avmintr);
            avmintr /= 10;
        }

        /* MRIge58050 */
        if ( ( TRIG_LINE == gating )&&
             (avmintr % (int)(1s/cflinfrq)) >= (int)(1s/cflinfrq)-(TR_SLOP) ) {
            avmintr = avmintr + TR_SLOP;
        }

        /* RJL - MRIge26267. Changed logic such that if any sat is ON then we calculate the
         * times otherwise they are zero.
         */
        if ((exist(opsat)!=PSD_OFF) && ((exist(opsatx)!=PSD_OFF)||(exist(opsaty)!=PSD_OFF)||
                                        (exist(opsatz)!=PSD_OFF)||(exist(opexsatmask)!=PSD_OFF)))
        {  /* MRIge44642: fixed the calculation of sp_satend. sp_satend is the time at the end
              of the last crusher gradient, and will be used to calculate the timing for
              gxks and gzks
           */
            int sp_seqend;            /* sequence end */
            int sp_satend_to_seqend;  /* time from sat end to sequence end */

            sp_seqend = sp_satstart + sp_sattime ;	/* sequence end */
            sp_satend_to_seqend = pw_isisat - isi_satdelay + pw_rotupdate + isi_extra
                + rot_delay + isi_extra + pw_isisat - isi_satdelay;
            sp_satend = sp_seqend - sp_satend_to_seqend;
            sp_sattime = RUP_GRD(sp_satstart+sp_sattime + time_ssi);
        }
        else
        {
            sp_satend = 0;
            sp_sattime = 0;
        }

        if (flextr_flag) {
           if (exist(opautotr)==PSD_ON)
           {
              setexist(optr,PSD_OFF);
              setfix(optr, PSD_OFF);
              optr = avmintr;
              setexist(optr,PSD_ON);
           }
        } else {
           avmaxtr = avmintr;
           optr = avmintr;
        }

        act_tr = optr;

        /* BBA - improved SPECIAL */
        if( (PSD_ON == intermittant_chemsat) && (PSD_ON == extraspecial_flag) ) {
            if (SpecIRSlorder(&tempslfreq, &tempslfreq0) == FAILURE) {
                epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "SpecIRSlorder");
                return FAILURE;
            } 
            nsegments = ceil((float)(arc_equant)/tempslfreq);
            linestodiscard = nsegments*tempslfreq - arc_equant;
        } else {
            tempslfreq = slfreq;
            linestodiscard = 0;
        }
    } /* end WHILE loop */

    /* ungated FatSat FIESTA */
    if( ugfsf_flag && (act_tr > 0) ){
        view_per_shot = (int)ceil((double)(rhnframes + rhhnover) / num_shot);
        chemfreq = view_per_shot;

        if( (exist(oprtcgate)==PSD_ON) && (resp_gate_trig_sw==0) )
            target_ti = 200ms;
        else
            target_ti = 120ms;

        if(0==fiesta_rampup_type){
            ugfsf_ramp_dda =  0;
            ugfsf_flat_dda = 20;
         }
         else{
            ugfsf_ramp_dda = 10;

            /* act_tr is accurate now. Let's calculate ugfsf_flat_dda. */
            if(ugfsf_view_order_flag==0)
               ugfsf_flat_dda = 4;
            else if(ugfsf_view_order_flag==1) /* for 0.5NEX */
                ugfsf_flat_dda = (int)ceil((double)(target_ti-cs_sattime)/act_tr) - ugfsf_ramp_dda - (int)(rhhnover/num_shot);
            else if(ugfsf_view_order_flag==2)
                ugfsf_flat_dda = (int)ceil((double)(target_ti-cs_sattime)/act_tr) - ugfsf_ramp_dda;
            if(ugfsf_flat_dda<0) ugfsf_flat_dda = 0;
         }

        chemsat_dda = ugfsf_ramp_dda + ugfsf_flat_dda;
        ugfsf_linear_ramp_down = 10;

        if(ugfsf_view_order_flag==0){
            view_to_center = (int)ceil((double)(target_ti - cs_sattime) / act_tr) - chemsat_dda;
            if(view_to_center<0) view_to_center = 0;
        }
        else{
            view_to_center = 0;
        }
    }

    if (!flextr_flag) {
       setexist(optr,1);                /* set existence for support routines */
    }

    /* Sequence time for 1/2 alpha 1/2 TR preparation sequence ALP */
    if( (ssfp_flag == PSD_ON) && (vast_mode == PSD_ON) ) {
        int act_htr_tmp;
        act_htr_tmp = pw_gzrf1htra + pw_gzrf1htr + pw_gzrf1htrd +
            pw_gzcombhtra + pw_gzcombhtr + pw_gzcombhtrd +
            pw_gzphtra + pw_gzphtr + pw_gzphtrd + 
            pos_start + time_ssi + 16us;

        act_htr = IMax(2, act_htr_tmp, act_tr/2);
        act_htr = RUP_GRD(act_htr);
    } else {
        act_htr = RUP_GRD(time_ssi + 16us);
    }

    /* MRIge59148 */
    /* Calculate Smartprep Image Acq Delay */
    /* MGD2, RJF */
    if ( Calc_Monitor_Acq_Delay(act_tr) == FAILURE) {
        epic_error(use_ermes,"%s failed.",EM_PSD_SMARTPREP_FAIL,EE_ARGS(1),
                   STRING_ARG,"Calc Smart Prep Acq. Delay");
        return FAILURE;
    }

    /* Chemsat and spatial SAT evaluation */
    /* Display auto TI in pitival2 */
    if (PSD_OFF == exist(opautoti))
    {
        keep_opti1 = exist(opti);
        keep_optifixedflag = _opti.fixedflag;
        keep_optiexistflag = _opti.existflag;
        keep_opautotifixedflag = _opautoti.fixedflag;
        keep_opautotiexistflag = _opautoti.existflag;
        cvoverride(opautoti, PSD_ON, PSD_FIX_OFF, PSD_EXIST_ON);
        if( ChemSatEval( &cs_sattime ) == FAILURE )
        {
            return FAILURE;
        }
        pitival2 = exist(opti);
        cvoverride(opautoti, PSD_OFF, keep_opautotifixedflag, keep_opautotiexistflag);
        cvoverride(opti, keep_opti1, keep_optifixedflag, keep_optiexistflag);
    }

    /* MRIge58026: Make sure this is called after act_tr is set -- BJM */
    if( ChemSatEval( &cs_sattime ) == FAILURE ) {
        return FAILURE;
    }

    /* Display auto TI in pitival2 */
    if (PSD_ON == exist(opautoti))
    {
        pitival2 = exist(opti);
    }

    if(ifir_stir_flag)
    {
        off_rfcssat = 0;
    }

    /* MRIge45105: the following 34 lines were moved from before to after 
       optr calculations because min_ti depends on optr  -JFS
    */
    /* IR PREP (pjg) */
    /* Timing for IR prep pulse */
    /* RJF - gated_dda should be multiplied with act_tr */
    if( irprep_flag == PSD_ON )
    {
        if (ifir_flag)
        {
            /* time to play just IR pulse  */
            /* GEHmr01956 Added prep pulse time to this calculation */
            tseq_irprep = RUP_GRD(IMax(2, -rfupa + rffrequency_length[bd_index],  pw_gzrf0a)
                            + (int)(pw_gzrf0/2) + exist(opbspti) - optr*irdisdacqs  
                            - (sp_sat * sp_sattime)
                            - (specir_flag * cs_sattime)
                            - (vast_mode * ssfp_flag * (fiesta_gated_dda+ifir_dummy_pe) * act_tr) 
                            - (ifir_flag * ssfp_flag * (1==exist(oprtrep)) * rhhnover * act_tr)
                            - time_ssi - t_exa - GRAD_UPDATE_TIME 
                            + SQ_LOCKOUT_LENGTH + 1);
            /* add SQ_LOCKOUT_LENGTH for the lockout bit and 1 for PlayOutSSP call */
        } else {  
            /* min time to play IR pulse & disdacqs */
            /* Note addition of gated_dda disdaqs that are used in VAST - RJF */
            min_ti = (int)(pw_gzrf0/2) + pw_gzrf0d + pw_gzrf0ka + 
                       pw_gzrf0k + pw_gzrf0kd + time_ssi + optr*irdisdacqs +  /* Note that VAST doesn't play this. */
                       vast_mode*(!ssfp_flag)*(gated_dda+rhhnover/IMax(2,(num_outer_loops-1),1))*act_tr + pos_start + t_exa +
                       slabtracking_flag*(mon_navgs*mon_tr+tmin_montipup) + 
                       specir_flag*(!vast_mode)*(cs_sattime + chemsat_dda*act_tr);

            if ( existcv(opcgate) && (PSD_ON == exist(opcgate)) && (PSD_ON == vast_mode) ) 
            {  
                avmaxti = RUP_GRD(avmaxtdel1 - tlead - IMax(2, rffrequency_length[bd_index]-rfupa, pw_gzrf0a) - pw_gzrf0/2.0);
            }
            else
            {
                avmaxti = 2500ms;
            }

            if (bravo_flag && aspir_flag)
            {
                avminti = IMax(2, 100ms, min_ti);
                advroundup(&avminti);
            }
            else
            {
                if( min_ti < 50 ) {
                    avminti = 50;
                } else {
                    avminti = min_ti;
                    advroundup(&avminti);
                }
            }
            
            min_tseq_irprep = RUP_GRD(IMax(2, -rfupa + rffrequency_length[bd_index],  pw_gzrf0a)
                            + pw_gzrf0 + pw_gzrf0d + pw_gzrf0ka + pw_gzrf0k + pw_gzrf0kd + GRAD_UPDATE_TIME);
        
            /* time to play just IR pulse  */
            tseq_irprep = RUP_GRD(tlead 
                            + IMax(2, -rfupa + rffrequency_length[bd_index],  pw_gzrf0a)
                            + (int)(pw_gzrf0/2) + exist(opti) - optr*irdisdacqs  
                            - vast_mode*(!ssfp_flag)*(gated_dda+(rhhnover/IMax(2,(num_outer_loops-1),1)))*act_tr 
                            - specir_flag*(!vast_mode)*(cs_sattime + chemsat_dda*act_tr)  
                            - slabtracking_flag * (mon_navgs*mon_tr+tmin_montipup)
                            - time_ssi - t_exa - tlead - GRAD_UPDATE_TIME 
                            + SQ_LOCKOUT_LENGTH + 1);
            /* add SQ_LOCKOUT_LENGTH for the lockout bit and 1 for PlayOutSSP call */
        }
    }

    if(ifir_frir_flag)
    {
        /* time to play just IR pulse  */
        /* add SQ_LOCKOUT_LENGTH for the lockout bit and 1 for PlayOutSSP call */
        tseq_prep_frir= RUP_GRD(IMax(2, -rfupa + rffrequency_length[bd_index],  pw_gzrffrira)
                        + (int)(pw_gzrffrir/2) + SQ_LOCKOUT_LENGTH + 1
                        + pw_gzrffrir/2 + pw_gzrffrird + pw_gzkrffrir + pw_gzkrffrira + pw_gzkrffrird
                        + time_ssi + GRAD_UPDATE_TIME);
    }

    /* Acquistion Timing */
    pipautype = PSD_LABEL_PAU_ACQ;        /* use "Acq B/4 Pause" as annotation */

    /* IR PREP (pjg) */
    if( irprep_flag == PSD_ON ) {
        /* MRIhc18543-scan time calculation was incorrect before since irseqs was based on slorder*/
        if (PSD_ON == pfkz_flag)
        {
            irseqs = pfkz_segments;
        }
        else
        {
            switch (slorder) {
               case 1:
                  irseqs = 1;
                   break;
               case 2:
                  irseqs = 2;
                  break;
               case 3:
                  irseqs = 4;
                  break;
               case 4:
                  irseqs = 8;
                  break;
               } 
        }
        slq_shots = irseqs;
    }

    if (intermittant_chemsat == PSD_ON) {
        switch (slorder) {
        case 1:
            chemseqs = 1;
            break;

        case 2:
            chemseqs = 2;
            break;

        case 3:
            chemseqs = 4;
            break;

        case 4:
            chemseqs = 8;
            break;

            /* BBA - improved SPECIAL */ 
        case 5:
            chemseqs = tempslfreq;
            chemseq0 = tempslfreq0;
            break;
        }
        slq_shots = chemseqs;
    }

    /* ************************
       Initialization of cvs used in Fast SAT
       ********************** */

    /* number of z encodes between SATs */
    scansatint = ((sp_sat == 1) ? satview : 1);
    if (satview == 1) {
        scansat0 = 0;
    } else {
        scansat0 = (    (( (int) (arc_equant) / 2) - (satview / 2)) % satview   );
        /* subtract 1 since indexing by 0 */
        if (scansat0 != 0)
            scansat0 = scansat0 - 1;
    }


    /* MRIge45584: make sure scansat0 >= 0 */
    scansat0 = (scansat0<0) ? 0 : scansat0;

    /* first z encode to play SAT before */
    scansat0 = ((sp_sat == 1) ? scansat0 : arc_equant);  

    /* apply sat pulses symmetric about center encoding */
    if( reverseLoopOrder ) {
        scansat0 = ((rhnframes + rhhnover)/ 2 - (satview / 2)) % satview;

        /* subtract 1 since indexing by 0 */
        if( scansat0 != 0 ) {
            scansat0 = scansat0 - 1;
        }

        /* guard against negative values */
        if( scansat0 < 0 ) {
            scansat0 = 0;
        }
    }

    /* ****************************
       Locations/Acqs before pause
       **************************** */
    /*  MRIhc04159 opslicecnt should not be > 0 if acqs is 1 */
    if ((acqs==1) && (exist(opslicecnt)!=0)) {
        cvoverride(opslicecnt,0,PSD_FIX_ON,PSD_EXIST_ON);
    }

    /* Display scan clock in seconds unless pause*/

    if (exist(opslicecnt)==0) {
        pidmode = PSD_CLOCK_NORM;
        slicecnt = acqs;
    } else {
        slicecnt = exist(opslicecnt);
        pidmode = PSD_CLOCK_PAUSE;
    }


    /* MRIge44882 - moved from cvcheck() and added an argument passed to 
       the epic_error() call - latha@mr */
    if ((exist(opslicecnt) > (acqs-1)) && existcv(opslicecnt)) {
        epic_error(use_ermes,"Number of ACQ_B4_Pause cannot exceed %-d",
                   EM_PSD_ACQS_B4_EXCEEDED,EE_ARGS(1),INT_ARG,(acqs-1));
        return FAILURE;
    }

    if ( existcv(opsldelay) && existcv(opslicecnt)
         && (exist(opsldelay) != avminsldelay)
         && (exist(opslicecnt) !=0) ) {
        epic_error(use_ermes,
                   "Pause is not available with non-minimum delay between acqs.",
                   EM_PSD_PAUSE_DELAY_INCOMPATIBLE, EE_ARGS(0)); /* Added 0 - latha@mr */
        return FAILURE;
    }
    /* end MRIge44882 */


    /* ************************
       Scan Clock
       ********************** */

     if (mph_flag == PSD_ON) {
         if(exist(opslicecnt) == 0) { /* MRIhc08979  08/05/2005 YI */
             passtime = TR_PASS*acqs + (acqs-1)*sldeltime;
         } else {
             passtime = TR_PASS*acqs;
         }
     } else {
         passtime = TR_PASS * acqs;
     }

    /* elliptical centric needs >1second disdaqs.
       Add explicitly if not SmartPrep*/

    /* MRIge61115, MRIge87708 fix */
    if( (phorder == CENTRIC) || (centric_flag == PSD_ON) ||
        (phorder == REVERSE_CENTRIC) || (reverse_centric_flag == PSD_ON) ||
        (ellipt_flag == PSD_ON) || (reverse_ellipt_flag == PSD_ON) ||
        (PSD_ON == msde_flag) ||
        (ssfp_flag == PSD_ON) || (smartprep_flag == PSD_ON) ) {
        dda = (int) (1s/optr); /* 1 second disdaqs */
    } else {
        dda = 8; 
    } 

    if( existcv(opcgate) && (PSD_ON == exist(opcgate)) ) {
        dda = 8;
    }

    dda_one_second = (int) (1s/optr); /* 1 second disdaqs */

    if (osfp_flag) dda = 0;

    /* HK for Fiesta-C */
    if (pcfiesta_flag == PSD_ON) {
        dda = 20;
    }

    if ((PSD_OFF != pfkr_yz_flag ) && (PSD_ON == centric_flag) && (PSD_ON == (lava_flag || brava_flag || vibrant_flag)))
    {
        num_dummy_segmentedTR = 3; /* Make SPGR signal stable */
    }
    else
    {
        num_dummy_segmentedTR = 0;
    }

    /* ATV - same check as in Smartprep_Cvcheck */

    if (exist(opuser4) < _opuser4.minval || exist(opuser4) > _opuser4.maxval)
        if ((opuser4) < _opuser4.minval || (opuser4) > _opuser4.maxval)
        {
            epic_error(use_ermes,"Image acq. delay out of range",EM_PSD_MONITOR_RANGE,EE_ARGS(0));
            return FAILURE;
        }

    trigger_delay_wosp = (1-smartprep_flag)*1s*exist(opuser4);

    if ( (smartprep_flag == PSD_OFF) && 
         ( (SmartPrepKey == Present) || (ftMRAKey == Present) || (QUICKSTEPKey == Present) ) )
    {
        if ( (trigger_delay_wosp > 1s) )
        {
            trigger_delay_silent_countdown = trigger_delay_wosp - 1s;
            dda_trigger_delay_silent_countdown = (int) (trigger_delay_silent_countdown/100ms) ;
            dda_trigger_delay_disdaqs = (int) (1s/optr) ;
            cvdef(opinittrigdelay, 1.0); /* Auto Voice  04/12/2005 YI */ 
        }
        else
        {
            trigger_delay_silent_countdown = 0;
            dda_trigger_delay_silent_countdown = 0;
            dda_trigger_delay_disdaqs = (int) ( (1s*(exist(opuser4))) /optr);
            cvdef(opinittrigdelay, opuser4); /* Auto Voice  04/12/2005 YI */ 
        }
    }


    if ( (smartprep_flag == PSD_ON)  )
    {
        trigger_delay_wosp = 0;
        trigger_delay_silent_countdown = 0;
        dda_trigger_delay_silent_countdown = 0 ;
        dda_trigger_delay_disdaqs = 0 ;
    } 

    /* Increase ps2_dda to 128 to make sure that enought disdaqs are
       played out that R1/R2 values get set properly */

    ps2_dda = 128;	
    if (osfp_flag) ps2_dda = 0;

    if(PSD_ON == cal3d_flag) 
    {
        psd_pscshim = PSD_CONTROL_PSC_SKIP;   /* force to skip AutoShim for 3D cal */
        ps2_dda_cal3d = ((int)(ps2_dda_time_cal3d/(float)act_tr)/2)*2;
    }
    else
    {
        psd_pscshim = APS_CONTROL_PSC;   /* Reset back */
    }

    /* calculate the number of sat slices */
    /* GEHmr01918: when pfkz_flag is on, the slice encoding is pfkz_total. */  
    num_sats = sp_sat * ((int)(( ((PSD_ON == pfkz_flag) ? pfkz_total : arc_equant) - scansat0) / scansatint) + 1);
    /* number of sat and disdaqs played during disdaqs */
    sat_dda = sp_sat * 2;

    /* MRIge67085 - no spatial SAT in the 3D FTMRA scan  */
    if (ftmra_flag || maskv_ftmra_flag || merge_flag) 
    {
        merge_satweight = num_sats/(equant*pfkz_fraction);
        sat_dda = 0;
        num_sats = 0;
    }

    if (gating == TRIG_INTERN)
        use_tr = (float)act_tr;
    else
        use_tr = (float)act_tr + TR_SLOP;

    /* Calculate Optimal Flip Angle for IDEALIQ */
    if( (PSD_ON == idealiq_flag) && (PSD_ON == piautofa) )
    {
        idealiq_optfa = calc_optimal_fa_idealiq( (int) act_tr );

        if( idealiq_optfa < 1 )
        {
            idealiq_optfa = 1;
        }

        if( idealiq_optfa > 25 )
        {
            idealiq_optfa = 25;
        }

        if ( B0_30000 == (int)cffield )
        {
            pifaval2 = idealiq_optfa;
            pifaval3 = 3;
        }
        else
        {
            pifaval2 = idealiq_optfa;
            pifaval3 = 5;
        }

        if (existcv(opflip))  /* HCSDM00265426 */
        {
            avmaxflip = idealiq_optfa;
            cvmax(opflip, idealiq_optfa);
        }

        if( PSD_ON == exist(opautoflip) )
        {
            cvoverride(opflip,idealiq_optfa,PSD_FIX_ON,PSD_EXIST_ON);
        }
    }

    /* Calculate duty-cycle for respiratory gating. This factor is used
       to increase scan time */
    /* added backward compatibility - latha@mr */
    respdc = UnLocked*1./(1.-(float)(oprtarr*respgate_flag)/100.);

    /* MRIge51710 - spatial sat is executed once for multiple nex, 
       so adjust nreps for that. There is a factor of 2 before num_sats
       because a disdacq is played after each SAT in SatPrep. sp_sattime 
       is always equal to act_tr! */ 

    /* MRIge65040 - spatial sat is now executed for every nex so update nreps calculation */

    if ((intermittant_chemsat==PSD_ON) && (extraspecial_flag == PSD_ON) ) {
        nreps = acqs * ( (dda + slice_dda*chemseqs*nsegments + sat_dda + baseline) +
                            (int)( (float)(chemseqs*nsegments + 2*num_sats) * 
                                   (truenex + (float)dex) * (float)(rhnframes+rhhnover) ) );
    } 
    else 
    {
        if (arc_flag || pfkr_flag)
        {
            if (FAILURE == walkSamplingPattern(&sampledPoints,
                                               &sampledPointsNoMask, 
                                               &calibrationPoints,
                                               &maskPoints, 
                                               zy_views, zy_slices,
                                               fn, pfky_total_unaccel,
                                               pfkz_fraction, pfkz_total_unaccel,
                                               pfkr_fraction, 
                                               get_act_phase_fov() * nop, ethick,
                                               phaseres, equant,
                                               arc_flag, calRegion,
                                               arc_ph_stride, arc_sl_stride))
            {
                epic_error(use_ermes, "%s failed",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "walkSamplingPattern");
                return FAILURE;
            }
        }
        else
        {
            sampledPoints = (rhnframes + rhhnover) * pfkz_total;
        }

        if (idealiq_flag && idealiq_pc_flag)
        {
            idealiq_pc_dda = IDEALIQ_PC_DDA;
            if(idealiq_pc_dimension == 1)
            {
                idealiq_pc_ylines = 1;
            }
            else
            {
                idealiq_pc_ylines = IDEALIQ_2DPC_YLINES;
            }
            idealiq_pc_ylower = IMax(2, 0, (INT)floorf((FLOAT)((phaseres - 1) - idealiq_pc_ylines) / 2.0 + 0.5));
            idealiq_pc_yupper = IMin(2, phaseres - 1, idealiq_pc_ylower + idealiq_pc_ylines - 1);

            idealiq_pc_zlines = zy_slices;
            idealiq_pc_zlower = IMax(2, 0, (INT)floorf((FLOAT)((equant - 1) - idealiq_pc_zlines) / 2.0 + 0.5));
            idealiq_pc_zupper = IMin(2, equant - 1, idealiq_pc_zlower + idealiq_pc_zlines - 1);

            /* make sure all reference lines are within cal/partial kr region */
            while(FALSE == isRefRegionValid(idealiq_pc_ylower, idealiq_pc_yupper,
                                            idealiq_pc_zlower, idealiq_pc_zupper,
                                            zy_views, zy_slices,
                                            fn, pfky_total_unaccel,
                                            pfkz_fraction, pfkz_total_unaccel,
                                            pfkr_fraction, 
                                            get_act_phase_fov() * nop, ethick,
                                            phaseres, equant,
                                            arc_flag, calRegion))
            {
                idealiq_pc_zlines -= 2;
                if(idealiq_pc_zlines < IDEALIQ_PC_MIN_ZLINES)
                {
                    /* exit the loop. Catch the error in cvcheck() */
                    break;
                }
                idealiq_pc_zlower = IMax(2, 0, (INT)floorf((FLOAT)((equant - 1) - idealiq_pc_zlines) / 2.0 + 0.5));
                idealiq_pc_zupper = IMin(2, equant - 1, idealiq_pc_zlower + idealiq_pc_zlines - 1);
            }

            idealiq_pc_extra_TR = idealiq_pc_dda*idealiq_nshots + idealiq_pc_ylines*idealiq_pc_zlines*idealiq_nshots*nex;
        }
        else
        {
            idealiq_pc_dda = 0;
            idealiq_pc_ylines = 0;
            idealiq_pc_zlines = 0;
        }

        /* MRIge91682 */
        if(PSD_ON == ideal_flag)
        {  /* RV: MRIhc19003 - Replaced opnecho with ideal_necho */
            nreps = acqs * ( (dda + slice_dda*pfkz_total + sat_dda + baseline)*(ideal_echo_mode*(ideal_necho-1) + 1) +
                             (int)((float)((2*num_sats*((float)sampledPoints/pfkz_total) + sampledPoints) * ideal_necho) *
                                   (truenex + (float)dex)));
        }
        else if(idealiq_flag)
        { 
            nreps = acqs * ( (dda + slice_dda*pfkz_total + sat_dda + baseline) +
                             (int)((float)((2*num_sats*((float)sampledPoints/pfkz_total) + sampledPoints) * idealiq_nshots) *
                                   (truenex + (float)dex)) + 
                             (idealiq_pc_flag * idealiq_pc_extra_TR) );
        }
        else
        {
            nreps =  acqs * phase_cycles * (dda + slice_dda*pfkz_total + sat_dda + baseline +
                             (int)((float)(2*num_sats*((float)sampledPoints/pfkz_total) + sampledPoints) *  nflow4D *
                                   (truenex + (float)dex)));
        }
        /* ungated FatSat FIESTA */
        if(ugfsf_flag) {
            if(pcfiesta_flag == PSD_ON) { /* HDsv 03/16/2009 YI */
                nreps = acqs * phase_cycles * ( (int)( (float)(arc_equant*truenex) *
                                                       num_shot * (float)(chemsat_dda + view_per_shot + ugfsf_linear_ramp_down) ) );
                nreps += acqs * ( (int)( (float)(ugfsf_slice_dda) *
                                         num_shot * (float)(chemsat_dda + view_per_shot + ugfsf_linear_ramp_down) ) );
            } else {
                nreps = acqs * ( (int)( (float)(arc_equant*truenex + ugfsf_slice_dda) *
                                        num_shot * (float)(chemsat_dda + view_per_shot + ugfsf_linear_ramp_down) ) );
            }
        }
    }

    if (medal_flag && medal_multitr_flag) {
        nreps *= medal_necho;
        nreps -= acqs * (dda + slice_dda*pfkz_total + sat_dda + baseline)*(!medal_echo_mode)*(medal_necho-1); 
    }

    /* 3d oblique - changed passtime to acqs*passtime - latha@mr */
    /* changed back to 'just' passtime...MRIge57698  - agilandk@mr */
    
    avmintscan = (float)((gating == TRIG_INTERN) ? act_tr + merge_flag*sp_sat*sp_sattime*merge_satweight :
                         (act_tr + TR_SLOP + merge_flag*sp_sat*sp_sattime*merge_satweight))  * nreps + passtime;
    /* GHEmr01918: when (sp_sat && !segmented_flag), nreps contains SpSat sequence
                   but TR of SpSat is different from TR of acquisition sequence.
                   So we need to remove this difference from avmintscan */
    if( sp_sat && !segmented_flag && !merge_flag)
    {
        avmintscan -= (float)( ((gating == TRIG_INTERN) ? act_tr : (act_tr + TR_SLOP)) - sp_sattime ) *
                             ( num_sats*((float)sampledPoints/pfkz_total) ) * acqs * (truenex + (float)dex) *
                             ( (PSD_ON == ideal_flag) ? ideal_necho : (idealiq_flag ? idealiq_nshots : phase_cycles) );
    }
    
    /* MRIge72936 inserted asset_factor into the avmintscan for both irprep and intermittant */
    /* MRIge62659 rhhnover added to avmintscan calculation */
    /* MRIge91682 */
    /* MRIhc09598 included rhhnover for each IR segment (irseqs) */
    /* MRIhc37790 */
    if( irprep_flag == PSD_ON ) {
        avmintscan = avmintscan +
            (float)((tseq_irprep + time_ssi + act_tr * irdisdacqs) *
                    (irseqs * ((eg_phaseres * pfkz_segments * asset_factor *
                                exist(opphasefov) * nop * fn / arc_ph_netaccel) + 
                               rhhnover) *
                     (truenex + (float)dex) + slice_dda)) * (float)acqs * (ideal_echo_mode? ideal_necho:1);
    }

    /* MRIge62659 rhhnover added to avmintscan calculation */
    /* MRIge91682 */
    if ( (intermittant_chemsat==PSD_ON) && (extraspecial_flag == PSD_OFF) && (pfkz_flag == PSD_OFF) ) {
        /* ungated FatSat FIESTA */
        if(ugfsf_flag){
            avmintscan = avmintscan + (float)( (cs_sattime + time_ssi + ugfsf_shot_delay)*num_shot*(arc_equant*truenex+ugfsf_slice_dda) )
                                      * acqs * phase_cycles + (float)((rhnframes+rhhnover)*seq3dtr)*(acqs-1);
        }
        else{
            avmintscan = avmintscan + (float)((cs_sattime + time_ssi + act_tr *chemsat_dda)*
                                          (((eg_phaseres * asset_factor * chemseqs * exist(opphasefov) * nop * fn / arc_ph_netaccel) + rhhnover )* 
                                           (truenex + (float)dex)+slice_dda)) *acqs;
        }
    }

    if ( (intermittant_chemsat==PSD_ON) && (extraspecial_flag == PSD_OFF) && (pfkz_flag == PSD_ON) ) {
        avmintscan = avmintscan + (float)((cs_sattime + time_ssi + act_tr *chemsat_dda)*
                                          (((eg_phaseres * pfkz_segments * asset_factor * exist(opphasefov) * nop * fn / arc_ph_netaccel) + rhhnover )*
                                           (truenex + (float)dex) + slice_dda )) *acqs;
    }

    /* BBA - improved SPECIAL */
    if ((intermittant_chemsat==PSD_ON) && (extraspecial_flag == PSD_ON) ) {
        avmintscan = avmintscan + (float)((cs_satstart + cs_sattime + time_ssi + act_tr *chemsat_dda)*
                                          (((eg_phaseres * nsegments * exist(opphasefov) * nop * fn / arc_ph_netaccel) + rhhnover*nsegments )* 
                                           (truenex + (float)dex)+slice_dda)) *acqs;
    }

    if (segmented_flag)
    {
        if (ENCODE_GROUP_NONE != encode_group)
        { 
           int segment_sattime;

           /* There is one disdaq after SAT which is act_tr duration this check is in SatPrep() */ 
           if ( (ftmra_flag == PSD_OFF) && (osfp_flag == PSD_OFF) && (!merge_flag) && (!ifir_flag) ) {
               segment_sattime = sp_sattime + act_tr;
           } else { 
               segment_sattime = sp_sattime;
           }

           min_segment_tr = act_tr*(views_per_segment*(medal_flag?medal_necho:1)*(idealiq_flag?idealiq_nshots:1)
                                    + osfp_flag*osfp_dda + osfp_flag*osfpsd_flag*osfp_dda)
               + sp_sat*segment_sattime + specir_flag*(cs_sattime+chemsat_dda*act_tr) 
               + irprep_flag * (tseq_irprep + time_ssi + act_tr  * irdisdacqs) ;
       }
       else
       {
           min_segment_tr = act_tr*(views_per_segment*(medal_flag?medal_necho:1)
               + osfp_flag*osfp_dda + osfp_flag*osfpsd_flag*osfp_dda)
               + sp_sat*sp_sattime + specir_flag*(cs_sattime+chemsat_dda*act_tr)
               + msde_flag * (tseq_msde + act_tr * msde_dda)
               + irprep_flag * (tseq_irprep + time_ssi + act_tr  * irdisdacqs) ;

           avmaxte2 = min_segment_tr;
       }

       if (osfp_flag) 
       {
          min_end_segment_delay =(int) (0.75*(float) min_segment_tr);
          if (min_end_segment_delay < 1s) min_end_segment_delay = 1s;
          if (min_end_segment_delay > 1.5s) min_end_segment_delay = 1.5s;
          end_segment_delay = min_end_segment_delay;
          osfp_delay_factor = ((float) end_segment_delay / (float) min_segment_tr);
          osfp_weight = 0.1*((int) ((ceil) (10.0/(osfp_delay_factor + 1.0))));
          if(gradOpt_flag)
          {
              osfp_weight_grad = 0.01*((int) ((ceil) (100.0/(osfp_delay_factor + 1.0))));
          }
          else
          {
              osfp_weight_grad = osfp_weight;
          }
          
       }
       else
       {
          end_segment_delay = 0;
       }

       segment_tr = min_segment_tr + end_segment_delay;
       /* HCSDM00389691 add delay time when multiphase.*/
       avmintscan = acqs*phase_cycles*(truenex + (float)dex)*segment_tr*(nr_of_segments+1) + (mph_flag ? passtime : 0);

       if (ENCODE_GROUP_NONE != encode_group)
       {
            avmintscan = avmintscan + act_tr * (acqs * phase_cycles * (dda + slice_dda*pfkz_total + sat_dda + baseline));
       }

       if (PSD_OFF != pfkr_yz_flag)
       {
            avmintscan = avmintscan + acqs * act_tr * (dda + slice_dda*views_per_segment)
               + acqs * ( ((PSD_ON == centric_flag) && (PSD_OFF==ftmra_flag)) ? segment_tr*(num_dummy_segmentedTR) : 0) /* include disdaq time for LAVA */

               - (ftmra_sat_flag ? acqs*nr_of_segments*truenex*sp_sat*sp_sattime: 0);
       }

       if(idealiq_flag && idealiq_pc_flag)
       {
            avmintscan = avmintscan + acqs * act_tr * idealiq_pc_extra_TR;
       }
    }

    post_osfp_weight = osfp_weight;

    /* MRIge53533 - Calculate scan time using # of respiratory cycles */
    if (UnLocked && respgate_flag && exist(oprtarr) <= GATE_TRIGGER_WINDOW_MAX) {
        /* MRIge70233: any variables below regarding View should be considered as Nex.
         * RespGate() locates between nex loop and slice loop as shown below:
         *
         *   view loop{
         *      nex loop{
         *                RespGate();
         *                slice loop{
         *                }
         *             }
         *   }
         *
         * so the update time for respiratory gating should be "PerNex"
         * instead of "PerView". The calculation of nTRsPerView, tscanPerView
         * maxRespCycle are correspondingly changed
         */
        INT maxRespCycles;
        INT nTRsPerView;
        FLOAT respCycles, viewsPerCycle;
        FLOAT respPeriod, respWindow;
        FLOAT TR, tscanPerView, extraDdaTime;
        FLOAT tscanTemp;

        /* calculate Respiratory period and data acquistition window */
        respPeriod = 10s;
        if (exist(oprtrate) >= 6) {
            respPeriod = 60.0s/exist(oprtrate);
        }

        respWindow = respPeriod;
        respWindow *= (1.0 - oprtarr/100.0);

        /* scan time per view */
        /* ungated FatSat FIESTA */
        if(!ugfsf_flag)
            nTRsPerView = pfkz_total + num_sats;
        else
            nTRsPerView = view_per_shot;
        TR = (float)((gating == TRIG_INTERN) ? act_tr :(act_tr + TR_SLOP));
        tscanPerView = nTRsPerView * TR ;

        if( PSD_OFF != irprep_flag ) {
            tscanPerView += irseqs * (tseq_irprep + time_ssi + act_tr * irdisdacqs);
        }

        /* ungated FatSat FIESTA */
        if(!ugfsf_flag){
            if( PSD_OFF != sl_per_chem ) {
                tscanPerView += chemseqs * (cs_sattime + time_ssi + act_tr * chemsat_dda);
            }
        }
        else{
            tscanPerView += cs_sattime + time_ssi + act_tr * ugfsf_linear_ramp_down + act_tr * chemsat_dda + ugfsf_shot_delay;
        }

        /* MRIge55039 - Begin Changes to Scan time calculations */
        /* Calculate # of respiratory cycles */
        /* ungated FatSat FIESTA */
        if(!ugfsf_flag)
            maxRespCycles = opfphases * opvquant * (rhnframes + rhhnover) * (truenex + dex);
        else
            maxRespCycles = opfphases * opvquant * (opslquant + ugfsf_slice_dda) * truenex * num_shot;

        viewsPerCycle = ceil(respWindow/tscanPerView);
        respCycles = ceil((FLOAT)maxRespCycles/viewsPerCycle);
        tscanTemp = respCycles * respPeriod;

        if( viewsPerCycle*tscanPerView > respPeriod ){ /* extreme case */
            /* in the extreme case,we just estimate the scanning time as it is,
             * following code are added to replace the old logic to have
             * a more accurate astimation. MRIge70233
             */
            int k = 1;
            int cyclesPerRun;
            while(1){
                int dt;
                if( k >= maxRespCycles ) break;
                dt = k*tscanPerView - floor(k*tscanPerView/respPeriod)*respPeriod;
                if( dt < respWindow ){
                    k += 1;
                    continue;
                }else{
                    break;
                }
            }
            cyclesPerRun = ceil(k*tscanPerView/respPeriod);
            tscanTemp = maxRespCycles/k*cyclesPerRun*respPeriod
                + maxRespCycles%k*tscanPerView;
        } /*  viewsPerCycle*tscanPerView > respPeriod */

        /* extra dda time */
        extraDdaTime = dda*act_tr;
        if(!ugfsf_flag)
            extraDdaTime += TR*slice_dda*pfkz_total;
        else
            extraDdaTime += TR*slice_dda*arc_equant;
        if( PSD_OFF != irprep_flag ) {
            extraDdaTime += slice_dda * (tseq_irprep + time_ssi + act_tr  * irdisdacqs) ;
        }
        if (PSD_OFF != sl_per_chem) {
            extraDdaTime += slice_dda * (cs_sattime+ time_ssi + act_tr  * chemsat_dda);
        }
        extraDdaTime *= opfphases * opvquant;

        /* MRIge55039 - End of Changes */

        /* total scan time */
        /* ungated FatSat FIESTA */
        if(!ugfsf_flag){
            /* RV: MRIhc19003 - Replaced opnecho with ideal_necho for IDEAL */
            if(PSD_ON == ideal_flag)
            {
                avmintscan = ideal_necho*tscanTemp + extraDdaTime*(1.0 - 0.01*oprtarr);
            }
            else if(idealiq_flag)
            {
                avmintscan = idealiq_nshots*tscanTemp + extraDdaTime*(1.0 - 0.01*oprtarr);
            }
            else
            {
                avmintscan = tscanTemp + extraDdaTime*(1.0 - 0.01*oprtarr);
            }
        }
        else{
            if(resp_gate_trig_sw==0) /* resp trigger */
                avmintscan = opfphases * opvquant * truenex * respPeriod * (exist(opslquant)+ugfsf_slice_dda) * num_shot;
            else
                avmintscan = tscanTemp;
        }
    } /* MRIge53533 */

@inline Tricks.e ScanTime
@inline Disco.e ScanTime   

@inline cal3d.e cal3d_cveval1_avmintscan
@inline FastCINE3D.e fcine3d_scantime

    /* Fill this in for Acqs B4 Pause time annoations */
    if (acqs > 0 && !disco_flag)
    {
        pitslice = avmintscan/acqs;
    }

    /*MRIhc04779 add rtpend sequence time to scan clock*/
    /*MRIhc05287 rtpend are now in Monitor.e, no longer part of 
     * real scan, therefore, not included in the scan clock*/
/*    if (smartprep_flag == PSD_ON) {
      avmintscan = avmintscan + smartp_rtpend_wait*1000;
      }
*/

    if(ifir_flag)
    {
        int respPeriod = 10s;
        if (exist(oprtrate) >= 6) {
            respPeriod = 60.0s/exist(oprtrate);
        }
        avmintscan = respPeriod * exist(opslquant);
    }
 
    pitscan = avmintscan;		/* Value shown on the clock */
    pisctim1= pitscan;

    /* MRIge46182: recalculate scan time */
    /* VAST uses a different acquisition scheme, ignore regular triggering logic 
       for calculation of segments, scantime etc. - RJF */
    if( existcv(opcgate) && (PSD_ON == exist(opcgate)) && (PSD_OFF == vast_mode) && (!cine3d_flag) ) {
        int ecgSegs;            /* # of valid ECG triggers required */
        float ecgTimePerSeg;	/* sequence time after each ECG trigger */

        ecgSegs = acqs*((reverseLoopOrder ? nex : truenex) + (float)dex)* 
            (reverseLoopOrder ? arc_equant : (rhnframes+rhhnover));

        ecgTimePerSeg = (float)((gating == TRIG_INTERN) ? act_tr : (act_tr + TR_SLOP));
        ecgTimePerSeg *= dda + (reverseLoopOrder ? (rhnframes+rhhnover) : (arc_equant+num_sats));

        if( irprep_flag == PSD_ON ) {
            ecgTimePerSeg += exist(opti) + (int)(pw_gzrf0/2) 
                + IMax(2, pw_gzrf0a, -rfupa + rffrequency_length[bd_index]);
        }

        if (GateCveval(ecgSegs, ecgTimePerSeg) == FAILURE) {
            return FAILURE;
        }
        avmintscan = pitscan;
    }

    /*
     * Calculate max number of slices
     */
    {
        /* Round down to nearest even number */
        max_bamslice -= max_bamslice % 2;

        /* MRIge88856, MRIge89741 - Maximum number of slices is 256 */
        max_slquant = IMin(2, max_bamslice, (MAXSLQUANT3D_FGRE/slicezp));

        /* Subtract kiss-off slices when using single slab to match UI */
        if( pimultislab == PSD_OFF )
        {
            max_slquant = max_slquant - 2 * opslblank;
        }

        /* MRIge67207 - Update maximum number of scan locations
           for Cardiac Gating */
        /* MRIge83165 : corrected bounds for slquant for TRICKS -Venkat */
        if( !UnLocked ||
            (existcv(opcgate) && (PSD_ON == exist(opcgate))) ) {
            avmaxslquant = max_slquant - DISCARDSLICE;
        } else {
            avmaxslquant = max_slquant;
        }

        if (merge_flag) {
            int maxslquant;
                maxslquant = 2 * ( (int) (((MAX_SLICES_PER_PASS / slicezp) - (DISCARDSLICE))/2.0) );
                max_slquant = IMin(2, maxslquant, avmaxslquant);
            }
        
        /* Limit number of slices based on ELLIPT_CEN_MAX total frames */
        {
            int max_slquant_ellipt = 2 * ( (int) (ELLIPT_CEN_MAX/(2*(rhnframes + rhhnover))) );
            avmaxslquant = IMin(2, max_slquant, max_slquant_ellipt);
            max_slquant = avmaxslquant;
        }
        if (cine3d_flag)
        {
             max_slquant = cine3d_maxslquant;
             avmaxslquant = max_slquant;
        }

    }

    /* Set number of Acqs B4 Pause buttons based on total number of acqs */
    if (cal3d_flag || disco_flag) {
        pipaunub = 0;
    } else if (acqs > 5) {
        pipaunub = 6;
    } else if (acqs > 3) {
        pipaunub = 5;
    } else if (acqs > 2) {
        pipaunub = 4;
    } else if (acqs > 1) {
        pipaunub = 3;
    } else {
        pipaunub = 0;
    }
    pipauval2 = 0;
    pipauval3 = 1;
    pipauval4 = 2;
    pipauval5 = 3;
    pipauval6 = 5;

    if ( vstrte_flag )
    {
        avmintr = (int) 10.0*floor(avmintr/10.0);
    }

    /* MRIge66079 - ATV: RTIA3D/ftMRA */
    /* ATV - setting legal range for FOV, flip angle,
       slice thickness for RTIA mode. The slice 
       thickness here refers to the 2D slice in 
       real-time mode and not the opslthick for 
       the prescribed 3D volume */  

    /* MRIge72695 - Increased the real-time FOV factor from 1.5 to
       sqrt(3) ~= 1.732 to prevent axis current distortion faults */
    rtca_max_fov = avmaxfov;
    if (rtia3d_restricted_nav_flag)
    {
        rtca_max_fov = avmaxfov;
        rtca_min_fov = exist(opfov);
    }
    else
    {
        const float RT_FOV_FACTOR = 1.73205080756887729352;

        rtca_min_fov = RT_FOV_FACTOR * exist(opfov);
        if (rtca_min_fov > rtca_max_fov) {
            rtca_max_fov = rtca_min_fov;
        }
    }

    rtca_insteps_fov = 10;

    rtca_max_flip = 1.0 * exist(opflip);
    if (rtca_max_flip > avmaxflip) {
        rtca_max_flip = avmaxflip;
    }

    rtca_min_flip = 0.5*exist(opflip);
    if (rtca_min_flip < avminflip) {
        rtca_min_flip = avminflip;
    }

    rtca_insteps_flip = 1;

    if (a_gzrf1 > a_base_max)
        rtca_min_slabthick = (rtia3d_eff_slabthick * a_gzrf1) / loggrd.tz;
    else
        rtca_min_slabthick = (rtia3d_eff_slabthick * a_base_max) / loggrd.tz;

    if (rtca_min_slabthick < 20.0)
        rtca_min_slabthick = 20.0;

    /* ATV - in low res ultra-fast imaging mode, use thick 
       2D slices = 3D slab thickness */
    if ( ( (oprbw > 63.0) && (opxres < 160) && (opfov > 42.0) && 
           (opslthick > 8.0) && (opslquant> 8.0) ) || 
         (rtca_min_slabthick > rtia3d_eff_slabthick) || (rtia3d_thkslab_proj_flag))
    {
        rtca_min_slabthick =  rtia3d_eff_slabthick;
    }

    rtca_min_slthick = rtca_min_slabthick/(exist(opslquant));
    if (rtca_min_slthick < avminslthick) {
        rtca_min_slthick = avminslthick;
    }
    rtca_min_slthick *= opslquant;

    rtca_max_slthick = 2.0 * rtca_min_slthick;

    rtca_insteps_slthick = 0.1;
    rtca_insteps_slthick *= opslquant;

    if (rtia3d_irp_flag)
       rtia3d_original_flip = rtca_min_flip;
    else
       rtia3d_original_flip = exist(opflip);

    rtia3d_original_fov = exist(opfov);

    rtia3d_original_slthick = exist(opslthick);
    rtia3d_original_slthick *= opslquant;

    /* End RTIA3D/ftMRA */

    /* Now that we have the TI and act_tr calculated, we can
       calculate min/max trigger delay for gated scans.
       The TI and Trigger Delay entries will be validated
       later in cvcheck(). */
@inline VAST.e VASTtiming

    if (FAILURE == NavigatorEval())
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "NavigatorEval");
        return FAILURE;
    }

    if( (exist(opectricks) == PSD_ON) || (exist(opswift) == PSD_ON) || disco_flag )
    {
        pitresnub = 1;
    }
    else if (heart3d_flag || ((PSD_ON == exist(opcgate)) && irprep_flag && vast_mode) || cine3d_flag)
    {
        /* HCSDM00282845: Display acquisition window length with temporal resolution */
        pitresnub = 1;
        if (cine3d_flag) {
             pitres = (INT)(60000000.0 / ((FLOAT)exist(ophrate)*(FLOAT)exist(opaphases)) + 0.5);
        } else {
             pitres = pe_acq2 * act_tr;
        }


    }
    else
    {
        pitresnub = 0;
    }

    return SUCCESS;
}   /* end cveval1() */

STATUS scale_grad(void)
{

    int slfreq0 = 1;
    /* Gradient coil heating calculations */

    satweight = 1.0 / (satview + 2.0);                                        

    if ( (ftmra_flag) || (maskv_ftmra_flag) )                                 
    {                                                                         
        chemweight = 1.0;                                                     
        regweight = 1.0;                                                      
    }                                                                         
    else                                                                      
    {                                                                         
        chemweight = (satview + 1.0) / (satview + 2.0);                       
        regweight = (satview + 1.0) / (satview + 2.0);                        
    }                                                                         

    /* End RTIA3D/ftMRA */                                                    

    if (sp_sat) {                                                             
        for (numgrads = 0; numgrads < NUMXSAT; numgrads++)
            gradx[numgrads].scale = satweight;                                
        for (numgrads = 0; numgrads < NUMYSAT; numgrads++)
            grady[numgrads].scale = satweight;                                
        for (numgrads = 0; numgrads < NUMZSAT; numgrads++)                    
            gradz[numgrads].scale = satweight;                                

        if ( (fatFlag == PSD_ON)  || opwater == PSD_ON) {        
            gradx[GXKCS_SLOT].scale = chemweight;                             
            grady[GYKCS_SLOT].scale = chemweight;                             
            gradz[GZKCS_SLOT].scale = chemweight;                             
        }
        gradx[GX1_SLOT].scale = regweight;                                    
        gradx[GXW_SLOT].scale = regweight;                                    
        gradx[GXWEX_SLOT].scale = regweight;                                  
        grady[GY1_SLOT].scale *= regweight;                                   
        grady[GY1R_SLOT].scale *= regweight;                                  
        gradz[GZRF1_SLOT].scale = regweight;                                  
        gradz[GZCOMB_SLOT].scale *= regweight;                                 
        gradz[GZP_SLOT].scale *= regweight;                                    
        gradz[GZRF0_SLOT].scale = regweight;                                  
        gradz[GZRF0K_SLOT].scale = regweight;                                 

        ave_grady_gy1_scale *= regweight;
        ave_gradz_gzcomb_scale *= regweight;
        ave_gradz_gzp_scale *= regweight;

        if (ifir_frir_flag)
        {
            gradz[GZRFFRIR_SLOT].scale = regweight;
            gradz[GZKRFFRIR_SLOT].scale = regweight;
        }
    }

    /* IR PREP (pjg) */        
    if( UnLocked ) {                                                          
        if( (irprep_flag == PSD_ON) || (intermittant_chemsat == PSD_ON) ) {   
            if ( irprep_flag && bravo_flag ) {
                slorder = 1; /* centric view order for BRAVO */
            }
            else if( extraspecial_flag ) {
                slorder = 5; /* BBA - improved SPECIAL slice order */
            } else {
                if ( arc_equant <= 64 ) { 
                    slorder = 1;
                } else {
                    slorder = 2;
                }
            }
        } else {
            slorder = 0;
        }  /* end backward compatibility */
    }                                                 

    switch( slorder )                                                     
    {                                                                     
    case 1:                                                               
        slfreq = arc_equant;                                                  
        break;                                                            

    case 2:                                                               
        slfreq = arc_equant/2;                                                
        break;                                                            

    case 3:                                                               
        slfreq = arc_equant/4;                                                
        break;                                                            

    case 4:                                                               
        slfreq = arc_equant/8;                                                
        break;                                                            

    case 5:                                                               
        if( SpecIRSlorder( &slfreq, &slfreq0 ) == FAILURE ) {             
            epic_error( use_ermes, supfailfmt,                            
                        EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),               
                        STRING_ARG, "SpecIRSlorder" );                    
            return FAILURE;                                               
        }   
        break;                                                            

    default:                                                              
        slfreq = 1;                                                       
        break;                                                            
    }                                                                     

    irfreq = slfreq;                                                      
    chemfreq = slfreq;                                                    

    if( lava_flag || brava_flag || pfkz_flag ) {
        chemfreq = pfkz_views_per_segment;                                
    }                                                                     

    if (osfp_flag || segmented_flag)
    {
        chemfreq = views_per_segment;
        irfreq = views_per_segment;
    }

    if (vast_mode) {
       chemfreq = max_pencodes + ssfp_flag * (enable_alpha + fiesta_gated_dda)
                  + (!ssfp_flag) * gated_dda;
       irfreq = max_pencodes + ssfp_flag * (enable_alpha + fiesta_gated_dda)
                + (!ssfp_flag) * gated_dda;

       if(ifir_flag){
           irfreq = max_pencodes + irprep_flag + enable_alpha + fiesta_gated_dda + opnumgir + ifir_frir_flag;
           chemfreq = irfreq; 
       }
    }

    if (cine3d_flag)
    {
        chemfreq = ( (exist(op4dflow)==PSD_ON) ? nflow4D :  exist(opvps) );
    }

    if ((PSD_ON == exist(opcgate)) && (PSD_ON == navgate_flag))
    {
       navscale = 1.0/(max_pencodes + ssfp_flag*(enable_alpha + fiesta_gated_dda)
                  + (!ssfp_flag)*gated_dda);
    }

    if((chemfreq == 1) || extraspecial_flag || lava_flag || pfkz_flag || osfp_flag || vast_mode) {
        chemsat_dda = 0;
    } 
    else if (bravo_flag && specir_flag) {
        chemsat_dda = 4; 
    }
    else {
        chemsat_dda = 2;
    }

    if( brava_flag ) {
        if (oprbw > 60 ) {
            chemsat_dda = 2;
        } else {
            chemsat_dda = 1;
        }
    }

    /* ungated FatSat FIESTA */
    if( ugfsf_flag && (act_tr > 0) ){
        view_per_shot = (int)ceil((double)(rhnframes + rhhnover) / num_shot);

        chemfreq = view_per_shot;

        if( (exist(oprtcgate)==PSD_ON) && (resp_gate_trig_sw==0) )
            target_ti = 200ms;
        else
            target_ti = 120ms;

        if(0==fiesta_rampup_type){
            ugfsf_ramp_dda =  0;
            ugfsf_flat_dda = 20;
         }
         else{
            ugfsf_ramp_dda = 10;

            /* act_tr is accurate now. Let's calculate ugfsf_flat_dda. */
            if(ugfsf_view_order_flag==0)
               ugfsf_flat_dda = 4;
            else if(ugfsf_view_order_flag==1) /* for 0.5NEX */
                ugfsf_flat_dda = (int)ceil((double)(target_ti-cs_sattime)/act_tr) - ugfsf_ramp_dda - (int)(rhhnover/num_shot);
            else if(ugfsf_view_order_flag==2)
                ugfsf_flat_dda = (int)ceil((double)(target_ti-cs_sattime)/act_tr) - ugfsf_ramp_dda;
            if(ugfsf_flat_dda<0) ugfsf_flat_dda = 0;
         }

        chemsat_dda = ugfsf_ramp_dda + ugfsf_flat_dda;
        ugfsf_linear_ramp_down = 10;

        if(ugfsf_view_order_flag==0){
            view_to_center = (int)ceil((double)(target_ti - cs_sattime) / act_tr) - chemsat_dda;
            if(view_to_center<0) view_to_center = 0;
        }
        else{
            view_to_center = 0;
        }
    }

    irscale = 1.0/(irfreq + irdisdacqs);                                  

    chemscale  = 1.0/(nflow4D*(chemfreq + chemsat_dda));

    if (intermittant_chemsat == PSD_OFF) {                                
        sl_per_chem = 0;                                                  
    } else {                                                              
        sl_per_chem = chemfreq;                                           
    }

    if(irprep_flag == PSD_ON) {
        gradz[GZRF0_SLOT].scale = irscale;
        gradz[GZRF0K_SLOT].scale = irscale;

        if (ifir_frir_flag)
        {
            gradz[GZRFFRIR_SLOT].scale = irscale;
            gradz[GZKRFFRIR_SLOT].scale = irscale;
        }
    }           

    if(exist(opcgate) && (irprep_flag || navsat_flag) && slabtracking_flag)
    {
        if(navigatorCYL_flag)
        {
            grady[GYCYLRATIPUP_SLOT].scale = navscale;
            grady[GYCYLRTIPUP_SLOT].scale = navscale;
            gradz[GZCYLRATIPUP_SLOT].scale = navscale;
            gradz[GZCYLRTIPUP_SLOT].scale = navscale;
        } else {
            grady[GYMONTIPUP_SLOT].scale = navscale;
        }
        gradz[GZKMONTIPUP_SLOT].scale = navscale;
    }

    if(exist(opcgate) && (irprep_flag || navsat_flag))
    {
        if(navigatorCYL_flag)
        {
            grady[GYCYLRA_SLOT].scale = navscale;
            grady[GYCYLR_SLOT].scale = navscale;
            gradz[GZCYLRA_SLOT].scale = navscale;
            gradz[GZCYLR_SLOT].scale = navscale;
        } else {
            gradx[GXFCMON_SLOT].scale = navscale;
            gradx[GX1MON_SLOT].scale = navscale;
            gradx[GXWMON_SLOT].scale = navscale;
            grady[GYRF2LMON_SLOT].scale = navscale;
            grady[GYRF2RMON_SLOT].scale = navscale;
            grady[GYRF2MON_SLOT].scale = navscale;
            grady[GYRF1MON_SLOT].scale = navscale;
            grady[GY1MON_SLOT].scale = navscale;
            gradz[GZRF1MON_SLOT].scale = navscale;
            gradz[GZ1MON_SLOT].scale = navscale;
        }
        gradz[GZKMON_SLOT].scale = navscale;
    }

    if ( ifir_flag && (exist(opgirmode) == PSD_GIRMANUAL) && (exist(opnumgir) >= 1) )
    {
       gradz[GZRFGIR01_SLOT].scale = irscale;
       gradz[GZKGIR01_SLOT].scale = irscale;

       gradz[GZRFGIR02_SLOT].scale = irscale;
       gradz[GZKGIR02_SLOT].scale = irscale;
    }

@inline VAST.e VAST_scaleKillergrad                                               

    if (intermittant_chemsat == PSD_ON) {                                 
        gradx[GXKCS_SLOT].scale = chemscale;                              
        grady[GYKCS_SLOT].scale = chemscale;                              
        gradz[GZKCS_SLOT].scale = chemscale;                              
    }                                                                     

    if (msde_flag)
    {
        msde_rate = (views_per_segment >= 1.0) ? (1.0 / views_per_segment) : 1.0;

        gradx[GXFLPVENC_SLOT].scale = msde_rate;
        grady[GYFLPVENC_SLOT].scale = msde_rate;
        gradz[GZFLPVENC_SLOT].scale = msde_rate;

        gradx[GXFLPK_SLOT].scale = msde_rate;
        grady[GYFLPK_SLOT].scale = msde_rate;
        gradz[GZFLPK_SLOT].scale = msde_rate;
    }

    if (cfsrmode == PSD_SR17) {                                           
        loggrd.xirmspos = 46.0;                                           
        loggrd.yirmspos = 46.0;                                           
        loggrd.zirmspos = 46.0;                                           

        loggrd.xirmsneg = 46.0;                                           
        loggrd.yirmsneg = 46.0;                                           
        loggrd.zirmsneg = 46.0;                                           
    }                                                                     

    if ((cfsrmode == PSD_SR17) && (opphysplane != PSD_OBL)) {             
        gradx[GX1_SLOT].powscale =1.0;                                    
        gradx[GXW_SLOT].powscale =1.0;                                    
        gradx[GXWEX_SLOT].powscale =1.0;                                  
        gradx[GKSX_SLOT].powscale =1.0;                                   
        grady[GY1_SLOT].powscale =1.0;                                    
        grady[GY1R_SLOT].powscale =1.0;                                   
        gradz[GZRF1_SLOT].powscale =1.0;                                  
        gradz[GZCOMB_SLOT].powscale =1.0;                                 
        gradz[GZP_SLOT].powscale =1.0;                                    
        gradz[GZRF0_SLOT].powscale =1.0;                                  
        gradz[GZRF0K_SLOT].powscale =1.0;                                 
        gradz[GKSZ_SLOT].powscale =1.0;       
        gradz[GZK_SLOT].powscale =1.0;       

        if (ifir_frir_flag)
        {
            gradz[GZRFFRIR_SLOT].powscale =1.0;
            gradz[GZKRFFRIR_SLOT].powscale =1.0;
        }

        if (exist(opetl)>=2) {
           gradx[GX2_SLOT].powscale =1.0;
           gradx[GXW2_SLOT].powscale =1.0;
        }

        if (flow_comp_type == TYPFC) {
           gradz[GZ1_SLOT].powscale =1.0;
           gradx[GXFC_SLOT].powscale =1.0;
        }

        if (flow4D_flag == PSD_ON) {
           gradz[GZ1_SLOT].powscale =1.0;
           gradx[GXFC_SLOT].powscale =1.0;
           grady[GYFE2_SLOT].powscale =1.0;
           grady[GYFE2_SLOT].powscale =1.0;

        }

        if (msde_flag)
        {
            gradx[GXFLPVENC_SLOT].powscale = 1.0;
            grady[GYFLPVENC_SLOT].powscale = 1.0;
            gradz[GZFLPVENC_SLOT].powscale = 1.0;

            gradx[GXFLPK_SLOT].powscale = 1.0;
            grady[GYFLPK_SLOT].powscale = 1.0;
            gradz[GZFLPK_SLOT].powscale = 1.0;
        }

    } else {                                                              
        gradx[GX1_SLOT].powscale = loggrd.xfs/loggrd.tx_xyz;              
        gradx[GXW_SLOT].powscale = loggrd.xfs/loggrd.tx_xyz;              
        gradx[GXWEX_SLOT].powscale = loggrd.xfs/loggrd.tx_xyz;            
        gradx[GKSX_SLOT].powscale = loggrd.xfs/loggrd.tx_xyz;             
        grady[GY1_SLOT].powscale = loggrd.yfs/loggrd.ty_xyz;              
        grady[GY1R_SLOT].powscale = loggrd.yfs/loggrd.ty_xyz;             
        gradz[GZRF1_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;            
        gradz[GZCOMB_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;           
        gradz[GZP_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;              
        gradz[GZRF0_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;            
        gradz[GZRF0K_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;           
        gradz[GKSZ_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;        
        gradz[GZK_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;        

        if (ifir_frir_flag)
        {
            gradz[GZRFFRIR_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;
            gradz[GZKRFFRIR_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;
        }

        if (exist(opetl)>=2) {
           gradx[GX2_SLOT].powscale = loggrd.xfs/loggrd.tx_xyz;
           gradx[GXW2_SLOT].powscale = loggrd.xfs/loggrd.tx_xyz;
        }

        if (flow_comp_type == TYPFC) {
           gradz[GZ1_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;
           gradx[GXFC_SLOT].powscale = loggrd.xfs/loggrd.tx_xyz;
        }

        if (flow4D_flag==PSD_ON) {
           gradz[GZ1_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;
           gradx[GXFC_SLOT].powscale = loggrd.xfs/loggrd.tx_xyz;
           grady[GYFE1_SLOT].powscale = loggrd.yfs/loggrd.ty_xyz;
           grady[GYFE2_SLOT].powscale = loggrd.yfs/loggrd.ty_xyz;
        }


        if (msde_flag)
        {
            gradx[GXFLPVENC_SLOT].powscale = loggrd.xfs/loggrd.tx_xyz;
            grady[GYFLPVENC_SLOT].powscale = loggrd.yfs/loggrd.ty_xyz;
            gradz[GZFLPVENC_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;

            gradx[GXFLPK_SLOT].powscale = loggrd.xfs/loggrd.tx_xyz;
            grady[GYFLPK_SLOT].powscale = loggrd.yfs/loggrd.ty_xyz;
            gradz[GZFLPK_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;
        }

    }

    if (FAILURE == t2prep_cveval())
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "t2prep_cveval");
        return FAILURE;
    }

    return SUCCESS;

} /*end of scale_grad*/


/* @Description
   Type and Call:
   --------------
   void calc_xresfn(&Xres, &Fnecholim, opxres, Act_Echofrac)

   END*/

/* This routine returns the relative echo fraction, Fnecholim and the
   number of acquired data points, Xres. 
   Note that the relative echo fraction (Fnecholim) is the echo fraction relative to
   the *fractional* readout gradient duration. This can be calculated explicity from
   the echo fraction relative to the *full* readout gradient duration
   (Act_Echofrac). */
void
calc_xresfn( int *Xres,
             float *Fnecholim,
             int OPxres,
             float *Act_Echofrac )
{
    short xrestmp;
    float fnecholimtmp;
    short xadd;

    /* for 1/2 or 3/4 NEX we increase echo fraction to ~80%*/
    if ((fn == 0.5) || (fn == 0.75) || medal_flag || idealiq_flag
        || (heart3d_flag && pfkz_flag))
    {
        if(ANNEFACT_REDUCTION_MID == annefact_reduction_flag)
        {
            *Act_Echofrac = 0.90;
        }
        else
        {
            *Act_Echofrac = 0.80;
        }
    }
    else 
    {
        if (osfp_flag || (ssfp_flag && vstrte_flag))
           *Act_Echofrac = 0.60;
        else if ( (PSD_ON == quickstep_flag) && (cfsrmode < PSD_SR100) )
           *Act_Echofrac = 0.70;
        else if (ANNEFACT_REDUCTION_MID == annefact_reduction_flag)
           *Act_Echofrac = 0.9;
        else if (ANNEFACT_REDUCTION_HIGH == annefact_reduction_flag)
           *Act_Echofrac = fract_echo_annefact_reduction;
        else
           *Act_Echofrac = 0.75;
    }
    xrestmp = (int)(*Act_Echofrac*OPxres + 4); /* Acquired at least 4
                                                  additional points just in case*/

    /* Round up to the nearest xres divisible by 4 (see TKF) */
    xrestmp = (int)(4*ceil((float)xrestmp/4));
    xadd = (int)(xrestmp - OPxres*(*Act_Echofrac)); /* Additional points        beyond kxmax */

    if ( vstrte_flag && (fn>=1.0) && (exist(opxres) >= 64) && !ssfp_flag )
    {
        *Act_Echofrac = 0.505;
        xrestmp = 2 * (int) ((0.25-!(cfsrmode>=PSD_SR200)*0.01)*OPxres);
        xadd = 0;
    }

    /* Relative fnecho_lim can be calculated from the act_echofrac and the total readout gradient duration */
    fnecholimtmp = (*Act_Echofrac - 0.5)/(*Act_Echofrac + (float)xadd/OPxres) + 0.5;
    *Xres = xrestmp;
    *Fnecholim = fnecholimtmp;
}   /* end calc_xresfn() */


/* The following code calculates the Fat/Water in or out-of Phase TE values

*Description:

STATUS fwphase(&actte, &fullteflag, mintefe,mintenfe,Llimte1,Llimte2,Llimte3,Ulimte1,Ulimte2,Ulimte3);

Type and Call:
-------------

STATUS fwphase(&actte, &fullteflag, mintefe,mintenfe,Llimte1,Llimte2,Llimte3,Ulimte1,Ulimte2,Ulimte3)

Parameters Passed:
-----------------
(I: for input parameter, O: for output parameter)

(O)             INT actte: actural TE calculated for F/W in/out-of phase

(O)             INT fullteflag: flag for full echo case. 1=full echo, 
0=frac echo

(I)             INT mintefe: minimum TE for fractional echo

(I)             INT mintenfe: minimum TE for full echo

(I)             INT Llimte1: lower limit for first F/W in/out-of phase range

(I)             INT Llimte2: lower limit for second F/W in/out-of phase range

(I)             INT Llimte3: lower limit for third F/W in/out-of phase range

(I)             INT Ulimte1: upper limit for first F/W in/out-of phase range

(I)             INT Ulimte2: upper limit for first F/W in/out-of phase range

(I)             INT Ulimte3: upper limit for first F/W in/out-of phase range

*/
int
fwphase( INT *actte,
         INT *fullteflag,
         INT mintefe,
         INT mintenfe,
         INT Llimte1,
         INT Llimte2,
         INT Llimte3,
         INT Ulimte1,
         INT Ulimte2,
         INT Ulimte3 )
{
    INT range1,range2,range3;
    INT te1,te2,te3;
    INT fullte1, fullte2, fullte3;
    INT minfrac1, minfrac2, minfrac3;

    range1 = ( ( mintefe <= Ulimte1 ) ? 1 : 0 );
    range2 = ( ( (Ulimte1 < mintefe) && ( mintefe <= Ulimte2) )
               ? 1 : 0);
    range3 = ( (Ulimte2 < mintefe)? 1 : 0 );

    if ((range1+range2+range3)!= 1)
    {
        epic_error( 0, "%s",                            
                    EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),               
                    STRING_ARG, "range sum exceeds 1" );                    
        return FAILURE;
    }

    /* The following CVs are used to flag whether a full echo can be used*/
    fullte1 = ( (mintenfe <= Llimte1 )? 1 : 0 ) * range1;
    fullte2 = ( (mintenfe <= Llimte2 )? 1 : 0 ) * range2;
    fullte3 = ( (mintenfe <= Llimte3 )? 1 : 0 ) * range3;

    *fullteflag = fullte1 + fullte2 + fullte3;
    /* flag to determine whether full echo is allowed for F/W in/out-of phase */

    if ((*fullteflag != 1)&&(*fullteflag != 0))
    {
        epic_error( use_ermes, "%s must be set to either 0 or 1.",
                    EM_PSD_CV_0_OR_1, EE_ARGS(1),
                    STRING_ARG, "Full TE flag" );
        return FAILURE;
    }

    /* The minimum fractional echo te, limited by the lower limits of the F/W
       in phase range, is: */
    minfrac1 = ( (mintefe <= Llimte1 )? Llimte1 : mintefe ) * range1;
    minfrac2 = ( (mintefe <= Llimte2 )? Llimte2 : mintefe ) * range2;
    minfrac3 = ( (mintefe <= Llimte3 )? Llimte3 : mintefe ) * range3;

    /* The te can then be set using: */
    te1 = fullte1*Llimte1 + (1.0 - fullte1)*minfrac1;
    te2 = fullte2*Llimte2 + (1.0 - fullte2)*minfrac2;
    te3 = fullte3*Llimte3 + (1.0 - fullte3)*minfrac3;

    *actte = te1 + te2 + te3;

    return SUCCESS;
}   /* end fwphase() */

/* The following code calculates the Fat/Water in or out-of Phase TE values for Full Echo

*Description:

STATUS fwphase_fullecho(&actte, &fullteflag, mintefe,mintenfe,Llimte1,Llimte2,Llimte3,Ulimte1,Ulimte2,Ulimte3);

Type and Call:
-------------

STATUS fwphase_fullecho(&actte, &fullteflag, mintefe,mintenfe,Llimte1,Llimte2,Llimte3,Ulimte1,Ulimte2,Ulimte3)

Parameters Passed:
-----------------
(I: for input parameter, O: for output parameter)

(O)             INT actte: actural TE calculated for F/W in/out-of phase

(O)             INT fullteflag: flag for full echo case. 1=full echo, 
0=frac echo

(I)             INT mintefe: minimum TE for fractional echo

(I)             INT mintenfe: minimum TE for full echo

(I)             INT Llimte1: lower limit for first F/W in/out-of phase range

(I)             INT Llimte2: lower limit for second F/W in/out-of phase range

(I)             INT Llimte3: lower limit for third F/W in/out-of phase range

(I)             INT Ulimte1: upper limit for first F/W in/out-of phase range

(I)             INT Ulimte2: upper limit for first F/W in/out-of phase range

(I)             INT Ulimte3: upper limit for first F/W in/out-of phase range

*/
    int
        fwphase_fullecho( INT *actte,
                 INT *fullteflag,
                 INT mintefe,
                 INT mintenfe,
                 INT Llimte1,
                 INT Llimte2,
                 INT Llimte3,
                 INT Ulimte1,
                 INT Ulimte2,
                 INT Ulimte3 )
{
    INT range1,range2,range3;
    INT minfull1, minfull2, minfull3;

    range1 = ( ( mintenfe <= Ulimte1 ) ? 1 : 0 );
    range2 = ( ( (Ulimte1 < mintenfe) && ( mintenfe <= Ulimte2) )
               ? 1 : 0);
    range3 = ( (Ulimte2 < mintenfe)? 1 : 0 );

    if ((range1+range2+range3)!= 1)
    {
        epic_error( 0, "%s",                            
                    EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),               
                    STRING_ARG, "range sum exceeds 1" );                    
        return FAILURE;
    }

    *fullteflag = 1;  /* MRIhc10961: always full echo TE */

    /* The minimum fractional echo te, limited by the lower limits of the F/W
       in phase range, is: */
    minfull1 = ( (mintenfe <= Llimte1 )? Llimte1 : mintenfe ) * range1;
    minfull2 = ( (mintenfe <= Llimte2 )? Llimte2 : mintenfe ) * range2;
    minfull3 = ( (mintenfe <= Llimte3 )? Llimte3 : mintenfe ) * range3;

    *actte = minfull1 + minfull2 + minfull3;

    return SUCCESS;
}   /* end fwphase_fullecho() */


/* This is the global pulse parameter calculation 
   function for efgre3d */
STATUS
set_gzrf1_params( void ) 
{
    float slab_fact2; /* YMSmr07948 10/18/2005 YI */ 
    int temp_slblank = 2; 

    pw_gzrf1 = pw_rf1;

    if (!ss_rf1) 
    {

       if (ampslice(&a_gzrf1, bw_rf1, opvthick, gscale_rf1, TYPDEF) == FAILURE) {
           epic_error(use_ermes, supfailfmt,
                      EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"amplice (for gzrf1)");
           return FAILURE;
       }

       /* make the 3d rf excitation slab thinner than phase encoded volume */
       if (osfp_flag || merge_flag) {
          a_gzrf1 = a_gzrf1 * slab_fact; 
       } else {
        if(value_system_flag && ssfp_flag) {
            /* YMSmr07948 10/18/2005 YI */
            if(exist(opflip) > 65.0) {
                slab_fact2 = 1.5;
            } else {
                slab_fact2 = 1.333;
            }
            a_gzrf1 = a_gzrf1 * slab_fact * slab_fact2;
        } else {
            if(pcfiesta_flag)
            {
                temp_slblank = 2;
            }
            else
            {
                temp_slblank = opslblank;
            }
            a_gzrf1 = a_gzrf1 * slab_fact * exist(opslquant) /
                  IMax(2, 1, exist(opslquant) - 2*temp_slblank);
        }
       }
    }

    /* MRIge66079 - ATV: RTIA3D/ftMRA */
    /* ATV - calculate rtia3d_slice_thinning_factor to accomodate thinner 2D slice in real-time mode */

    rtia3d_eff_slabthick = opslthick*(IMax(2, 1, exist(opslquant) - 2*opslblank)) /slab_fact;

    if (a_gzrf1 > a_base_max)
        rtca_min_slabthick = (rtia3d_eff_slabthick * a_gzrf1) / loggrd.tz;
    else
        rtca_min_slabthick = (rtia3d_eff_slabthick * a_base_max) / loggrd.tz;

    if (rtca_min_slabthick < 20.0)
        rtca_min_slabthick = 20.0;

    if ( (ftmra_flag) || (maskv_ftmra_flag) )
    {
        if ( ( (oprbw > 63.0) && (opxres < 160) && (opfov > 42.0) &&
               (opslthick > 8.0) && (opslquant> 8.0) ) || 
             (rtca_min_slabthick > rtia3d_eff_slabthick) || (rtia3d_thkslab_proj_flag) )
        {
            rtca_min_slabthick = rtia3d_eff_slabthick;
        }
        rtia3d_slice_thinning_factor = (rtia3d_eff_slabthick/rtca_min_slabthick);
    }
    else
    {
        rtia3d_slice_thinning_factor = 1.0;
    }

    rtca_min_slthick = rtca_min_slabthick;

    if (ss_rf1) {
        t_exa = hrf1a;
        pw_gzrf1a = pw_ss_rampz;
        pw_gzrf1d = pw_gzrf1a;
    } else {
       if (optramp(&pw_gzrf1a, rtia3d_slice_thinning_factor*a_gzrf1, loggrd.tz, zrt, TYPDEF) == FAILURE) { 
           epic_error(use_ermes, supfailfmt,
                      EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                      STRING_ARG, "optramp (for gzrf1a)");
           return FAILURE;
       }

       if (optramp(&pw_gzrf1d, rtia3d_slice_thinning_factor*a_gzrf1, (ogsfZ*loggrd.tz_xyz), (RUP_GRD((ceil) (ogsfZ*zrt))), TYPDEF) == FAILURE) {
           epic_error(use_ermes, supfailfmt,
                      EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                      STRING_ARG, "optramp (for gzrf1d)");
           return FAILURE;
       }

       /* End RTIA3D/ftMRA */
       t_exa = pw_gzrf1a + pw_rf1 - iso_delay;
    } 

    /* MS  Half alpha Half TR */
    if( (ssfp_flag == PSD_ON) && (vast_mode == PSD_ON) ) {
        a_gzrf1htr = a_gzrf1;
        pw_gzrf1htr = pw_gzrf1;
        pw_gzrf1htra = pw_gzrf1a;
        pw_gzrf1htrd = pw_gzrf1d;
    }

    if (flow_comp_type==TYPFC) {
        if (ss_rf1) {
            area_gz1 = ((float)pw_constant + (float)pw_ss_rampz + (float)off90minor)*a_gzrf1/2;
        }
        else {
            area_gz1 = (iso_delay + (pw_gzrf1d / 2.0)) * a_gzrf1;
        }
        if ( amppwgz1( &a_gz1, &pw_gz1, &pw_gz1a, &pw_gz1d,
                       area_gz1, TR_MAX , MIN_PLATEAU_TIME,
                       (RUP_GRD((ceil) (ogsfZ*zrt))) , (ogsfZ*loggrd.tz_xyz)) == FAILURE ) {
            epic_error( use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                        EE_ARGS(1), STRING_ARG, "amppwgz1:gz1" );
            return FAILURE;
        }
        pw_gzfca = 0;
        pw_gzfcd = 0;
        pw_gzfc = 0;
        a_gzfc = 0.0;
    } else {
        pw_gz1a = 0;
        pw_gz1d = 0;
        pw_gz1 = 0;
        a_gz1 = 0.0;
        pw_gzfca = 0;
        pw_gzfcd = 0;
        pw_gzfc = 0;
        a_gzfc = 0.0;
    }

    area_gzfc = a_gzfc * (pw_gzfca/2 + pw_gzfc + pw_gzfcd/2 );
    if (!ss_rf1)
    {
       area_gz1 = a_gz1 * (pw_gz1a/2 + pw_gz1 + pw_gz1d/2);
    }

/** add 4dflow grads here -- at the end ***/
@inline FastCINE3D.e fcine3d_gzrf1_FlowEnc

    return SUCCESS;
}   /* set_gzrf1_params() */


STATUS
set_gzcomb_params( void ) 
{
    DOUBLE TempVar;

    /* Scale the waveform amps for the phase encodes
     * so each phase instruction jump is an integer step */
    /* ZZ, MRIhc35831: add exist() check to equant to avoid failure */
    if (endview(exist(equant), &endviewz_iamp) == FAILURE) {
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"endview:gzp");
        return FAILURE;
    }

    endviewz_scale = (float)max_pg_iamp / (float)endviewz_iamp;

    /* iso_delay takes the place of pw_gzrf1/2: MRIge15714 CFL 3/17/93 */
    if ((flow_comp_type == TYPFC) || ns3d_flag || flow4D_flag) {
       refocus = 0.0;
    } else {
       if (ss_rf1){
          refocus = ((float)pw_constant + (float)pw_ss_rampz + (float)off90minor)*a_gzrf1/2;
       }
       else{
          refocus = fabs(a_gzrf1) * (iso_delay + pw_gzrf1d/2);
       }
    }
    
    TempVar = (loggrd.tz_xyz<(loggrd.tz_xyz/endviewz_scale))?loggrd.tz_xyz:(loggrd.tz_xyz/endviewz_scale);

    /* MRIge75785 - MRIge75330 */
    if ( exist(opfluorotrigger) == PSD_ON )
    {
        /* ATV - amppwencode2/amppwtpe2 are derived from amppwencode/amppwtpe function 
           to support the generation of phase encoding pulse with adjustable offset. */ 

        if (amppwencode2(&(gradz[GZCOMB_SLOT]), &pw_gzcomb_tot,
                         (ogsfZ*TempVar), (RUP_GRD((ceil) (ogsfZ*zrt))),exist(opvthick),exist(opslquant),refocus,rtia3d_slice_thinning_factor) == FAILURE) {
            epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                       1,STRING_ARG,"amppwencode:gzcomb");
        }
    }
    else
    {
        if (amppwencode_slice(&(gradz[GZCOMB_SLOT]), &pw_gzcomb_tot,
                              (ogsfZ*TempVar), (RUP_GRD((ceil) (ogsfZ*zrt))),ethick,equant,refocus) == FAILURE) {
            epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                       1,STRING_ARG,"amppwencode_slice:gzcomb");
        }
    }

    encode = 0.5*(float)pw_gzcomba*a_gzcomba +
        0.5*(float)pw_gzcomb*(a_gzcomba + a_gzcombb) +
        0.5*(float)pw_gzcombd*a_gzcombb - fabs(refocus);

    a_delta = 4.0*encode/(float)(equant-1.0)/
        (PSDRAMPEDTRAP*(float)pw_gzcomba +
         (1.0+PSDRAMPEDTRAP)*(float)pw_gzcomb +
         (float)pw_gzcombd);

    if (flow4D_flag == PSD_ON) 
    {
        a_comb = a_gzfccomb;
        a_gzcomba = a_gzfccomb;
        a_gzcombb = 0.0;
        a_base = a_gzfcbase;
        a_end = a_gzfcend;
        pw_gzcomba = pw_gzfca;
        pw_gzcomb = pw_gzfc;
        pw_gzcombd = pw_gzfcd;
    }
    else 
    {   if (flow_comp_type == TYPFC)
        {
           /* lgest negative amp for refocus + slice encode pulse */
           a_end  = -a_gzcombb;

           /* lgest positive amp for refocus + slice encode pulse */

           a_comb = a_end + a_delta*(float)(equant-1.0);
        }
        else
        {
           /* lgest negative amp for refocus + slice encode pulse */
           a_comb  = a_gzcombb;

           /* lgest positive amp for refocus + slice encode pulse */

           a_end = a_comb - a_delta*(float)(equant-1.0);
        }

        /* amp for the refocus pulse only */
        /* old: a_base = a_end + a_delta*(float)(exist(opslquant)-1.0)/2.0;*/

        a_base = 0.5*(a_comb + a_end);
    } /* end flow4D flag */

    if( rtia3d_thkslab_proj_flag && (ssfp_flag == PSD_OFF) ) {
        float temp_area;
        temp_area = a_base*(0.5*pw_gzcomba + 0.5*pw_gzcombd + pw_gzcomb);
        a_base_proj_dephaser = (temp_area - area_de)/(1.0*pw_gzcomb+0.5*pw_gzcomba+0.5*pw_gzcombd);
        if( a_base_proj_dephaser < 0 ) {
            if( a_base_proj_dephaser < a_end ) {
                a_base_proj_dephaser = a_end;
            }
        }
        if( a_base_proj_dephaser > 0 ) {
            if( a_base_proj_dephaser > a_comb ) {
                a_base_proj_dephaser = a_comb;
            }
        }
    } else {
        a_base_proj_dephaser = a_base;
    }

    if ( fabs(a_base) < fabs(a_base_proj_dephaser) ) {
        a_base_max = fabs(a_base_proj_dephaser);
    } else {
        a_base_max = fabs(a_base); 
    } 

    /* gzcomb starts off as negative */

    a_gzcomb = -a_comb;

    /* Half alpha half TR GSS/MS */
    if( (ssfp_flag == PSD_ON) && (vast_mode == PSD_ON) ) {
        a_gzcombhtr = a_gzcomb;
        a_gzcombhtra = a_gzcomba;
        a_gzcombhtrb = a_gzcombb;

        pw_gzcombhtr = pw_gzcomb;
        pw_gzcombhtra = pw_gzcomba;
        pw_gzcombhtrd = pw_gzcombd;
    }

    return SUCCESS;
}   /* end set_gzcomb_params() */


STATUS
set_gzk_gzp_params( void )
{
    DOUBLE TempVar;

    /*
      Z board combined killer and slice encode rewinder
    */

    /* Initialize z gradient killers */ /*MRIge30804*/

    /* MRIge66079 - ATV: RTIA3D/ftMRA */
    /* ATV - use larger slice killer for ftMRA mode */

    if ( (turbo_flag >= PSD_ON) && (ftmra_flag == PSD_OFF) && (maskv_ftmra_flag == PSD_OFF)  ) {
        area_gzk = 300;
    } else {
        if (spgr_flag == PSD_ON) {
            area_gzk = GKILLERAREA_SPGR;
        } else {
            area_gzk = GKILLERAREA_GRE;
        }

    }

    if((PSD_ON == ideal_flag) && (PSD_ON == spgr_flag)) {
       area_gzk = 3000;
    }

    /* End RTIA3D/ftMRA */

    /* YMSmr07158  06/05/2006  Fixed annefact like artifacts with Fat SAT */
    if( value_system_flag && cs_sat && !specir_flag ) {
        area_gzk = 3000;
    }

    /* YMSmr09539  06/15/2006 YI */
    if( value_system_flag && cs_sat && specir_flag && lava_flag ) {
        char * coil_name = coilInfo[0].coilName;
        int flag = !strcmp(coil_name,"GE_HDx 8BodyFullFOV");
        if(flag)area_gzk = 1000;
    }
    
    /* MRIhc48193 */
    if (PSD_ON == exist(opmerge))
    {
        area_gzk = 2400;
    }

    if (zkiller_flag == PSD_OFF) {
        area_gzk = 0;
    }

    swap_fat_cs = PSD_OFF;

    /* MRIge93061, MRIhc23207 */
    /* MRIhc42618: Sagittal SWAN was using swap_fat_cs on. The
     * swap_fat_cs flag was originally intended for IR-FSPGR 
     * type-in sequence, and multi-echo sequence should not use
     * this. Will limit the scope of swap_fat_cs to single-echo
     * FSPGR/FGRE only. Slice ASSET does not handle swap_fat_cs correctly 
     * lock it off.  
    */

    /* HCSDM00403567 Lock out fluorotrigger case because recon does not support
     *               echo flip on partial ky data in realtime scan.
     */
    if( ((irprep_flag == PSD_ON && ssfp_flag != PSD_ON) ||
         (spgr_flag == PSD_ON && irprep_flag == PSD_OFF)) 
        && oprbw < 45.0  && (existcv(opfov) && exist(opfov) < 285) 
        && (PSD_OFF == ideal_flag) && (PSD_OFF == tricks_flag) && (PSD_OFF == disco_1echo_flag)
        && (PSD_OFF == medal_flag) && (PSD_OFF == vibrant_flag)
        && (ASSET_SCAN_SLICE != opasset) && (rhnecho == 1) 
        && (PSD_OFF == exist(opfluorotrigger)) ) 
    {
        if (isHeadNeckTxPosition())
        {
            area_gzk = 1400;
            if(PSD_SAG == opplane || (PSD_OBL == opplane && PSD_SAG == opobplane) ) 
            {
                swap_fat_cs = PSD_ON;
            }
        }
    }

    /* ATV: balanced slice selection gradient for FIESTA */

    if( ssfp_flag ) {
       if (ss_rf1){
          area_gzk = area_gz1;
       }
       else{
          area_gzk = fabs(a_gzrf1) * (pw_gzrf1 - iso_delay + 0.5 * pw_gzrf1a);
       }
    }

    if (flow4D_flag == PSD_ON)
    {
      area_gzk = GZKAREA_4DFLOW;
    }

    if (zrewind_flag) {
        TempVar = (loggrd.tz_xyz<(loggrd.tz_xyz/endviewz_scale))?loggrd.tz_xyz:(loggrd.tz_xyz/endviewz_scale);
        if (amppwencode_slice(&(gradz[GZP_SLOT]), &gzptime,
                              (ogsfZk*TempVar), (RUP_GRD((ceil) (ogsfZk*zrt))), ethick,
                              equant, area_gzk) == FAILURE) {
            epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1),STRING_ARG,"amppwencode_slice:gzp");
            return FAILURE;
        }
    } else {
        gzptime = 0;
        pw_gzpa = 0;
        pw_gzpd = 0;
        pw_gzp = 0;
        a_gzp = 0;
        gradz[GZP_SLOT].num = 0;
    }

    if (ss_rf1){
       total_area_gz = refocus - area_gzk;
    }
    else{
       total_area_gz = a_gzrf1 * (pw_gzrf1 + 0.5 * pw_gzrf1a + 0.5 * pw_gzrf1d) -
           refocus - area_gzk ; 
    }

    encode2 = 0.5*(float)pw_gzpa*a_gzpa +
        0.5*(float)pw_gzp*(a_gzpa + a_gzpb) +
        0.5*(float)pw_gzpd*a_gzpb - area_gzk;
    if (zrewind_flag)  {
        a_delta2 = 4.0*encode2/(float)(equant-1.0)/
            (PSDRAMPEDTRAP*(float)pw_gzpa +
             (1.0+PSDRAMPEDTRAP)*(float)pw_gzp +
             (float)pw_gzpd);
    } else {
        a_delta2=0.0;
    }

    if( ssfp_flag == PSD_ON ) 
    {
        a_end2 = -a_gzpb;
        a_comb2 = a_end2 + a_delta2*(float)(equant-1.0);
    } 
    else 
    {
        /* lgest positive amp for slice select rewind and killer */
        a_comb2  = a_gzpb;

        /* lgest positive amp for slice select rewind and killer */
        a_end2 = a_comb2 - a_delta2*(float)(equant-1.0);
    }

    /* amp for the killer pulse only */
    a_base2 = 0.5*(a_comb2 + a_end2);

    a_gzp = a_comb2;

    /* Half alpha half TR GSS/MS */
    if( (ssfp_flag == PSD_ON) && (vast_mode == PSD_ON) ) {
        a_gzphtr = a_gzp;
        a_gzphtra = a_gzpa;
        a_gzphtrb = a_gzpb;

        pw_gzphtr = pw_gzp;
        pw_gzphtra = pw_gzpa;
        pw_gzphtrd = pw_gzpd;
    }

    return SUCCESS;
}   /* end set_gzk_gzp_params() */


STATUS
set_gy1_gy1r_params( void )
{
    DOUBLE TempVar;
    float round_factor = (fn == 0.75) ? 6.0 : 2.0;

    yfov_aspect = nop * exist(opphasefov);

    /*
     * MRIge43708: Round up rhnframes to ensure that rhnframes and
     * rhnframes / fn are even.  Recon doesn't like odd number of frames
     * and endview() doesn't like odd values for rhnframes / fn.
     */
    unaccel_rhnframes = (int)(ceil( eg_phaseres * fn * yfov_aspect * asset_factor /
                            round_factor ) * round_factor);

    phaseres = (int)(ceil( eg_phaseres * yfov_aspect * asset_factor / 2.0) * 2.0);

    if (arc_flag)
    {
        rhnframes = calcAccelEncodeNum(arc_ph_callower, arc_ph_calupper,
                                       unaccel_rhnframes, arc_ph_stride);
        zy_views = phaseres;
    }
    else
    {
        rhnframes = unaccel_rhnframes;
        zy_views = rhnframes + rhhnover;
    }

    if(idealiq_flag && idealiq_pc_flag)
    {
        rhnframes += idealiq_pc_ylines;
    }

    /*
     * Scale the waveform amps for the phase encodes so each phase
     * instruction jump is an integer step.
     */
    if( endview( phaseres, &endview_iamp ) == FAILURE ) {
       	epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                    EE_ARGS(1), STRING_ARG, "endview" );
       	return FAILURE;
    }

    endview_scale = (float)max_pg_iamp / (float)endview_iamp;

    TempVar = (loggrd.ty_xyz<(loggrd.ty/endview_scale))?loggrd.ty_xyz:(loggrd.ty/endview_scale);

    /* ASSET */
    if (amppwencode(&grady[GY1_SLOT], &pw_gy1_tot,
       	            (ogsfY*TempVar), (RUP_GRD((ceil) (ogsfY*yrt))), nop*exist(opfov)*exist(opphasefov)*asset_factor,
               	    phaseres, 0.0 /* offset area */) == FAILURE) {
       	epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
               	   1,STRING_ARG,"amppwencode:gy1");
    }

    if (amppwencode(&grady[GY1R_SLOT], &pw_gy1r_tot,
                    (ogsfYk*TempVar), (RUP_GRD((ceil) (ogsfYk*yrt))), nop*exist(opfov)*exist(opphasefov)*asset_factor,
                    phaseres, 0.0 /* offset area */) == FAILURE) {
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                   1,STRING_ARG,"amppwencode:gy1");
    }

    if(gradOpt_flag)
    {
        ss_rewinder_flag = (ogsfY == ogsfYk) ? 1 : 0;
    }
    else
    {
        ss_rewinder_flag = !aTRopt_flag;
    }

    /* MRIGe63917 -- Normally, the instruction amplitudes are scaled
       for gradient pulses to reflect the desired physical gradient
       amplitude. The waveform amplitudes are set to full scale.
       However, for phase encoding pulses, the instruction amplitude
       is determined from the number of encoding steps (see endview_iamp)
       and the waveform amplitude (a_gy1<a,b>) is scaled to produce the
       desired FOV (maximum phase encoding physical amplitude). */

    /* phase rewinder */
    if (rewinder_flag == PSD_ON) {
        if (ss_rewinder_flag) {
            a_gy1ra = -a_gy1a;
            a_gy1rb = -a_gy1b;
            pw_gy1r = pw_gy1;
            pw_gy1ra = pw_gy1a;
            pw_gy1rd = pw_gy1d;
        }
        else
        {
            a_gy1ra = -a_gy1ra;
            a_gy1rb = -a_gy1rb;
        }
        grady[GY1R_SLOT].num = 1;
        /* MRIge63197 -- Following FGRE model, scale a_gy1r as it
           really plays and make sure ia_gy1r goes to endview_iamp.
           This has the same effect as the old definition:
           loggrd.ty_xyz/endview_scale;*/
        a_gy1r = a_gy1ra;
    } else {
        a_gy1ra = 0;
        a_gy1rb = 0;
        pw_gy1r = 0;
        pw_gy1ra = 0;
        pw_gy1rd = 0;
        grady[GY1R_SLOT].num = 0;
        ia_gy1r = 0;
    }

    pw_gy1r_tot = pw_gy1ra + pw_gy1r + pw_gy1rd;

    /* MRIge63197 -- Following FGRE model, scale a_gy1 as it
       really plays and make sure ia_gy1 goes to endview_iamp.
       This has the same effect as the old definition:
       loggrd.ty_xyz/endview_scale */
    a_gy1 = a_gy1a;

@inline FastCINE3D.e fcine3d_gy1_gy1r_FlowEnc


    return SUCCESS;
}   /* end set_gy1_gy1r_params() */


STATUS
set_rdout_and_tmin( void )
{
    int ideal_defshift = 1000;
    int one_sixth_pi, one_half_pi, two_thirds_pi;
    int ideal_slop = 100us;

    /**********************************************************
      Determine full or fractional echo
      also determine readout gradient amplitude and pulse width
      ********************************************************* */
    /* first calculate the timing for full echo case */
    xres = exist(opxres);
    fnecho_lim = 1;
    fecho_factor = 1;

    if (calcfilter(&echo1_rtfilt, exist(oprbw),
                   xres, OVERWRITE_OPRBW)== FAILURE) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter");
        return FAILURE;
    }

    echo1bw = echo1_rtfilt.bw;
    echo2bw = echo1_rtfilt.bw;
    echo1_filt = &echo1_rtfilt;

    /* HCSDM00339164 */
    pw_gxwl = 0;

    pw_gxw_full = pw_gxwl + RUP_GRD(echo1_filt->tdaq) + pw_gxwr;
    pw_gxw = pw_gxw_full;


    /* if 64Khz rbw, increase fov and chop off - MRIge39543 */
    if (ampfov(&a_gxw, echo1bw, exist(opfreqfov)*exist(opfov)) == FAILURE) {
        epic_error(use_ermes,"%s failed",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"ampfov");
        return FAILURE;
    }

    /*
      Minimum sequence time calculation based on Y and Z gradients
      mintefgre uses these parameters to determine the minimum allowable TE.
    */

    /* Calculate minimum time from mid 90 to end of refocus based on slice
       select axis */
    /* iso_delay accounts for minimum phase alpha rf */

    if (flow4D_flag) 
    {
        min_seq1 = iso_delay + pw_gzrf1d + w_z1 + w_zfc;
    }
    else 
    {
        min_seq1 = iso_delay + pw_gzrf1d + pw_gzcomb_tot + (flow_comp_type== TYPFC?(pw_gz1a + pw_gz1 + pw_gz1d):0);
    }
    /* Calculate minimum time from mid 90 to end of gy1 on phase encoding axis */
    /* iso_delay accounts for min phase rf */

    /* MRIge91683 */
    min_seq3 = RUP_GRD(iso_delay + pw_gy1_tot + (count_rfupd?rfupd:0) + (flow4D_flag?yfe_time:0) );

    if (flow4D_flag == PSD_ON) {
      mintefgrePC( &min_tenfe,
               &t_rd1a_full, &t_rdb_full, &tfe_extra,
               &pw_gxwa_full, &pw_gxwd_full,
               &a_gx1u_full, &a_gx1d_full,
               &pw_gx1a_full, &pw_gx1_full, &pw_gx1d_full,
               &a_gxfcu_full, &a_gxfcd_full,
               &pw_gxfca_full, &pw_gxfc_full, &pw_gxfcd_full,
               &fl_width_x_full, fecho_factor, pw_gxwl, pw_gxw_full, pw_gxwr,
               a_gxw, t_exb, pc_const,
               min_seq1, min_seq3 );
    } else {

        mintefgre( &min_tenfe,
               &t_rd1a_full, &t_rdb_full, &tfe_extra,
               &pw_gxwa_full, &pw_gxwd_full,
               &a_gx1_full, &pw_gx1a_full, &pw_gx1_full, &pw_gx1d_full,
               &a_gxfc_full, &pw_gxfca_full, &pw_gxfc_full, &pw_gxfcd_full,
               fecho_factor, pw_gxwl, pw_gxw_full, pw_gxwr,
               a_gxw, t_exb, flow_comp_type ,
               min_seq1, min_seq3 );
    }
    /* HCSDM00339164 */
    if( (ANNEFACT_REDUCTION_HIGH == annefact_reduction_flag) && (PSD_MINTE == exist(opautote)) )
    {
        annefact_reduction_flag = PSD_OFF;
        calc_xresfn(&xres_ann_off, &fnecho_lim, (int)(exist(opxres)),&act_echofrac);
        annefact_reduction_flag = ANNEFACT_REDUCTION_HIGH;
        calc_xresfn(&xres_ann_on, &fnecho_lim, (int)(exist(opxres)),&act_echofrac);
        pw_gxwl = RUP_GRD(  echo1_filt->tdaq * ( FMax( 2,_fract_echo_annefact_reduction.maxval,(float)xres_ann_off/(float)(exist(opxres)) )
                                                 - (float)xres_ann_on/(float)(exist(opxres)) )  );
    }
    else
    {
        pw_gxwl = 0;
    }

    /* now calculate the timing for fractional echo case */

    calc_xresfn(&xres, &fnecho_lim, (int)(exist(opxres)),&act_echofrac);

    fecho_factor = fnecho_lim;

    if (calcfilter(&echo1_rtfilt_frac, exist(oprbw), xres, OVERWRITE_OPRBW)== FAILURE) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter");
        return FAILURE;
    }

    echo1_filt = &echo1_rtfilt_frac;
    pw_gxw_frac = RUP_GRD(echo1_filt->tdaq);

    /* HCSDM00339164 */
    if(ANNEFACT_REDUCTION_HIGH == annefact_reduction_flag)
    {
        pw_gxw_frac += pw_gxwl;
    }

    /* Update RBW value */
    if( SUCCESS != calcvalidrbw( exist(oprbw), &valid_rbw, &valid_max_rbw,
                                 &valid_decimation, OVERWRITE_OPRBW, 0 ) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcvalidrbw");
        return FAILURE;
    }
    if (flow4D_flag )
    {
      float xres_temp_float;
      xres_temp_float = (FLOAT)xres /(FLOAT)(exist(opxres));
      mintefgrePC( &min_tefe,
               &t_rd1a_frac, &t_rdb_frac, &tfe_extra,
               &pw_gxwa_frac, &pw_gxwd_frac,
               &a_gx1u_frac, &a_gx1d_frac,
               &pw_gx1a_frac, &pw_gx1_frac, &pw_gx1d_frac,
               &a_gxfcu_frac, &a_gxfcd_frac,
               &pw_gxfca_frac, &pw_gxfc_frac, &pw_gxfcd_frac,
               &fl_width_x_frac, xres_temp_float , pw_gxwl, pw_gxw_frac, pw_gxwr,
               a_gxw, t_exb, pc_const,
               min_seq1, min_seq3 );
    }
    else
    {
        mintefgre( &min_tefe, &t_rd1a_frac, &t_rdb_frac, &tfe_extra, &pw_gxwa_frac,
               &pw_gxwd_frac, &a_gx1_frac, &pw_gx1a_frac, &pw_gx1_frac,
               &pw_gx1d_frac, &a_gxfc_frac, &pw_gxfca_frac, &pw_gxfc_frac,
               &pw_gxfcd_frac, fecho_factor, pw_gxwl, pw_gxw_frac, pw_gxwr,
               a_gxw, t_exb, flow_comp_type ,
               min_seq1, min_seq3 );
    }
    /*
     * Set minimum FOV
     */
    /*
     * Calculate minimum FOV based on relationship
     *     FOV = 2 * oprbw / (GAM * Gx)
     * The scaling factor of 2000 converts kHz to Hz and Nyquist
     * frequency to sampling frequency.  The final scaling by 10.0
     * converts the units for fov from cm to mm (rounded up to the
     * nearest 10 mm.
     * MRIge44291 - Do ceiling to prevent truncation.
     */
   /* HCSDM00360543 */
    avminfov =  10.0 * ceilf( (2000.0 * FMin( 2, valid_rbw, avmaxrbw_system) ) /
                              (GAM * ogsfXw * loggrd.tx_xyz));

#ifdef REMOVE
    /* MRIhc08023 - This Patch set the minimum fov based on the current calcualted minfov 
    and the curent bandwidth oprbw. */
   
    /* Update min FOV for 3D FIESTA */
    if( (ssfp_flag == PSD_ON) && !osfp_flag ) {
        avminfov = FMax( 3, avminfov, floor( 0.02 * opxres ) * 10, 60.0 );
        if( avminfov < 120 ) {
            if( existcv(opgradmode) && (TRM_ZOOM_COIL == exist(opgradmode)) ) {
                if (oprbw > 41.67 + 0.1) {
                    avminfov = 120;
                }
            } else {
                if (oprbw > 31.25 + 0.1) {
                    avminfov = 120;
                }
            }
        }
        if( (avminfov >= 120) && (avminfov < 140) ) {
            if( existcv(opgradmode) && (TRM_ZOOM_COIL == exist(opgradmode)) ) {
                if (oprbw > 62.5 + 0.1) {
                    avminfov = 140;
                }
            } else {
                if (oprbw > 41.67 + 0.1) {
                    avminfov = 140;
                }
            }
        }
        if( (avminfov >= 140) && (avminfov < 180) ) {
            if (oprbw > 62.5 + 0.1) {
                avminfov = 180;
            }
        }
        if( (avminfov >= 180) && (avminfov < 260) ) {
            if (oprbw > 83.33 + 0.1) {
                avminfov = 260;
            }
        }
    }
#endif

    avminfov = FMax( 2, FMin( 2, avminfov, avmaxfov ), (float)FOV_MIN );

    /* 
       Don't let the FOV go lower than 10. This will significantly reduce
       the YRES you can attain in VAST enabled navigator due to the increase 
       in TR. - RJF, 11.0 
    */

    if( (PSD_ON == exist(opcgate)) && (PSD_ON == navgate_flag) ) {
        avminfov = FMax( 2, avminfov, NAV_MIN_FOV );
    }

    /* Update min FOV for ASSET */
@inline Asset.e AssetMinFOV

    if (medal_flag && ((!medal_autotelock_flag) || medal_autote_flag)) {
        int axial_bipolar_vibrantde_flag =
            ((PSD_ON == exist(opvibrant)) && 
             (PSD_AXIAL == opplane) &&
             (PSD_OFF == medal_multitr_flag))
            && strncmp("efgre3dvibde",psd_name,12);
            
        int tmp_maxxres;
        float tmp_minfov;
        int firstModeFlag = (cfdbdtper>cfdbdtper_norm);

        /* SVBranch, GEHmr04241: ART on Dual Echo */
        calcMedalMaxXresMinFov(exist(opfov), exist(oprbw), cfsrmode, cffield, cfgcoiltype, 
                         axial_bipolar_vibrantde_flag, medal_autote_flag, firstModeFlag,
                         exist(opsilent), exist(opsilentlevel), &tmp_maxxres, &tmp_minfov);

        /* MRIhc32537, MRIhc49891 */
        
        avmaxxres = 4*((int)(0.25*tmp_maxxres));
        avmaxxres = IMax( 2, avmaxxres, 128);
        avmaxxres = IMin( 2, avmaxxres, 1024);
        cvmax(opxres, avmaxxres);

        avminfov = FMax( 3, avminfov, FMin( 2, tmp_minfov, avmaxfov ), (float)FOV_MIN );

        setexist(opxres,PSD_ON);
        setexist(opfov,PSD_ON);

        if ((exist(opxres) > avmaxxres) || (exist(opfov) < avminfov))
        {
            return ADVISORY_FAILURE;
        }
    }

    /* YMSmr07345  10/03/2005 YI  Calculate advisory FOV value after 
       avminfov is finally fixed. */
    if( assetph_flag == PSD_ON ) {
        pifovval2 = avminfov;
        pifovval3 = avminfov + (avmaxfov - avminfov)/4.0;
        pifovval4 = avminfov + (avmaxfov - avminfov)/2.0;
        pifovval5 = avminfov + 3.0*(avmaxfov - avminfov)/4.0;
        pifovval6 = avmaxfov;
    }

    /* Now calculate the f/w in/out of phase case */

    /* fullte_flag always presumes frac echo to start with */
    fullte_flag = 0;

    if ( (!medal_flag && (exist(opetl)>=2)) || (brava_flag && (B0_30000 == (int)cffield) ) ) {
         fullte_flag = PSD_ON;
    }

    switch (exist(opautote)) {
    case PSD_FWINPHS:

    case PSD_FWOUTPHS:
        /* System Dependency library (FEC) */
        SDL_SetLimTE(SD_PSD_EFGRE3D,cffield,exist(opautote),
                     &llimte1,&llimte2,&llimte3,
                     &ulimte1,&ulimte2,&ulimte3);

       if ( brava_flag && (B0_30000 == (int)cffield) ) {
             llimte1 = LLIMTEIN1_BRAVA_3T; 
             ulimte1 = ULIMTEIN1_BRAVA_3T;
             llimte2 = LLIMTEIN2_BRAVA_3T;
             ulimte2 = ULIMTEIN2_BRAVA_3T; 
             llimte3 = LLIMTEIN3_BRAVA_3T;
        }  

        if (PSD_ON == fullte_flag) {
            fwphase_fullecho(&act_te, &fullte_flag, min_tefe, min_tenfe,
                    llimte1,llimte2,llimte3,ulimte1,ulimte2,ulimte3);
        } else {
            fwphase(&act_te, &fullte_flag, min_tefe, min_tenfe,
                llimte1,llimte2,llimte3,ulimte1,ulimte2,ulimte3);
        }
        break;  /* fat, water out of phase */

    case PSD_MINTE:
        fullte_flag = 0;  /* frac. echo */
        act_te = min_tefe;
        break;  /* min fractional te */

    case PSD_MINTEFULL:
        fullte_flag = 1; /* full echo */
        act_te = min_tenfe;
        break;  /* min full te */

    default:
        fullte_flag = 0; /* frac. echo */
        act_te = min_tefe;
        break;
    }

    if( existcv(opautote) && (PSD_OFF == exist(opautote)) && existcv(opte) && (!medal_flag && (exist(opetl)>=2)) ) 
    {
         fullte_flag = PSD_ON;
         act_te = min_tenfe;
    }

    /* MRIhc16353 - RV: IDEAL change */
    if(PSD_ON == ideal_flag)
    {
       ideal_min_te = act_te;
    }

    if( B0_30000 == (int)cffield )
    {
       medal_fw_freq_ave = 224.0;
       medal_fw_freq_ulimit = 240.0;
       medal_fw_freq_llimit = 190.0;
    }
    else 
    {
        /* TE range in-phase 4ms to 5.3ms with center around 4.2ms
         * TE range out-phase 2ms to 2.6ms with center around 2.1ms */
       medal_fw_freq_ave = 240.0;
       medal_fw_freq_ulimit = 250.0;
       medal_fw_freq_llimit = 190.0;
    }

    if ((exist(opvibrant) && exist(opmedal)) || (exist(opdisco) && breastCoil_flag)) 
    { 
        /* VSN: Keeping it same for both 3.0T and 1.5T for now */
        medal_fw_freq_llimit = 190;
        medal_fw_freq_ave = 224;
    }

    medal_freq_max = medal_fw_freq_ulimit*cffield/B0_15000;
    medal_freq_min = medal_fw_freq_llimit*cffield/B0_15000;
    medal_freq_ave = medal_fw_freq_ave*cffield/B0_15000;
    
    avminrbw2 = exist(opxres)*medal_freq_ave/(2.0*exist(oprbw)*1e3);

    medal_pi_max = (int)( 0.5 + (1.0s/(2.0*medal_freq_min)) ) ;
    medal_pi_min = (int)( 0.5 + (1.0s/(2.0*medal_freq_max)) ) ;
    medal_pi_ave = (int)( 0.5 + (1.0s/(2.0*medal_freq_ave)) ) ;

    medal_oop_te = medal_pi_ave;
    medal_oop_te_max = medal_pi_max;
    medal_oop_te_min = medal_pi_min;
    medal_oop_te_plus = medal_oop_te_max - medal_oop_te;
    medal_oop_te_minus = medal_oop_te - medal_oop_te_min;
    medal_k_oop_pi = 1;

    medal_ip_te = 2*medal_pi_ave;
    medal_ip_te_plus = 0;
    medal_ip_te_minus = 0;
    medal_ip_te_max = medal_ip_te + medal_ip_te_plus;
    medal_ip_te_min = medal_ip_te - medal_ip_te_minus;
    medal_k_ip_pi = 1;

    if (medal_flag && medal_autote_flag) {
        int done_searching = FALSE;
        if (act_te <=  medal_oop_te_max) {
           if (act_te < medal_oop_te)
              act_te = RUP_GRD(medal_oop_te);
           rhmedal_echo_order = 0;
           done_searching = TRUE;
        } else if ( (act_te <= medal_ip_te_max) && medal_flexecho_order_flag) {
           if (act_te < medal_ip_te)
               act_te = RUP_GRD(medal_ip_te);
           rhmedal_echo_order = 1;
           done_searching = TRUE;
        } else {

          while (!done_searching ) {
              medal_oop_te += (2*medal_pi_ave);
              medal_oop_te_max = medal_oop_te + medal_oop_te_plus;
              medal_oop_te_min = medal_oop_te - medal_oop_te_minus;
              medal_k_oop_pi += 1;

              medal_ip_te += 2*medal_pi_ave;
              medal_ip_te_max = medal_ip_te + medal_ip_te_plus;
              medal_ip_te_min = medal_ip_te - medal_ip_te_minus;
              medal_k_ip_pi += 1;

              if (act_te <=  medal_oop_te_max) {
                 if (act_te < medal_oop_te)
                    act_te = RUP_GRD(medal_oop_te);
                 rhmedal_echo_order = 0;
                 done_searching = TRUE;
              } else if ( (act_te <= medal_ip_te_max) && medal_flexecho_order_flag )  {
                 if (act_te < medal_ip_te)
                    act_te = RUP_GRD(medal_ip_te);
                 rhmedal_echo_order = 1;
                 done_searching = FALSE;
              }
          }
        }

    } else if (medal_flag)  {
        if (act_te <=  medal_oop_te_max) {
           if (act_te < medal_oop_te)
              act_te = RUP_GRD(medal_oop_te);
        }
        rhmedal_echo_order = 0;
    }

    /* MRIhc16353 - RV: IDEAL change */
    if(PSD_ON == ideal_flag)
    {
       /* HCSDM00148431 : dix_freq is set regardless of the field strength */
       dix_freq = FATWATER_DIXFREQ_1_5T * (float)cffield/(float)B0_15000;

       one_sixth_pi =  (int)(0.5 + (1.0s/(2.0*dix_freq) * 1.0/6.0)) ;
       /*
       one_half_pi = (int)(0.5 + (1.0s/(2.0*dix_freq) * 1.0/2.0)) ;
       two_thirds_pi = (int)(0.5 + (1.0s/(2.0*dix_freq) * 2.0/3.0 )) ;
       ideal_pi      = (int)( 0.5 + (1.0s/(2.0*dix_freq)) ) ;
       */
       one_half_pi = one_sixth_pi*3;
       two_thirds_pi = one_sixth_pi*4;
       ideal_pi      = one_sixth_pi*6;

       {
          int temp_int;
          temp_int = (ideal_pi - one_sixth_pi + ideal_slop);  /* min 1st echo */
          if (act_te > temp_int) {
             k_ideal_pi = (int)(((act_te - (temp_int))/ideal_pi) + 2);
          } else {
             k_ideal_pi = 1;
          }
       } 

       if  (act_te < (k_ideal_pi*ideal_pi - one_sixth_pi) )
       { /* min te is too short - round up to next -pi/6 */
           ideal_min_te = RUP_GRD(k_ideal_pi*ideal_pi - one_sixth_pi);
       } else {
           ideal_min_te = act_te;
       } 
    }

    /* Set Readout Pulse parameters here  */

    if (fullte_flag == 1)     /* full echo */
    {
        t_rdb = t_rdb_full;
        t_rd1a = t_rd1a_full;
        pw_gx1 = pw_gx1_full;
        pw_gx1a = pw_gx1a_full;
        pw_gx1d = pw_gx1d_full;
        a_gx1 = (flow4D_flag ? a_gx1u_full : a_gx1_full);
        pw_gxfc = pw_gxfc_full;
        pw_gxfca = pw_gxfca_full;
        pw_gxfcd = pw_gxfcd_full;
        a_gxfc = (flow4D_flag ? a_gxfcu_full : a_gxfc_full);
        xres = exist(opxres);
        fnecho_lim = 1;
        fecho_factor = 1;
        tfe_extra = 0;
        pw_gxw = pw_gxw_full;
        pw_gxwa = pw_gxwa_full;
        pw_gxwd = pw_gxwd_full;
        echo1_filt = &echo1_rtfilt;
    } /* full echo */
    else
    {
        t_rdb = t_rdb_frac;
        t_rd1a = t_rd1a_frac;
        pw_gx1 = pw_gx1_frac;
        pw_gx1a = pw_gx1a_frac;
        pw_gx1d = pw_gx1d_frac;
        a_gx1 = (flow4D_flag ? a_gx1u_frac : a_gx1_frac);
        pw_gxfc = pw_gxfc_frac;
        pw_gxfca = pw_gxfca_frac;
        pw_gxfcd = pw_gxfcd_frac;
        a_gxfc = (flow4D_flag ? a_gxfcu_frac : a_gxfc_frac);
        pw_gxw = pw_gxw_frac;
        pw_gxwa = pw_gxwa_frac;
        pw_gxwd = pw_gxwd_frac;
        calc_xresfn(&xres, &fnecho_lim, (int)(exist(opxres)),&act_echofrac);
        fecho_factor = fnecho_lim;
        echo1_filt = &echo1_rtfilt_frac;
    } /* fractional echo */

    pitfeextra = tfe_extra;

    /****** extra x crusher time to dephase s- signal ***/
    if( (turbo_flag > 0) ||
        ( (B0_30000 == (int)cffield) && existcv(opxres) && existcv(opfov) &&
          (exist(opxres) <= 320) && (exist(opfov) >= 200) ) ) {
        /*
         * Set extra X crusher time for dephasing the s-signal.
         * In turbo mode cases, this is done to kill the stimulated
         * signal and can be done all the time due to the smaller
         * RF pulse.
         * For non turbo mode cases, this fixes the fineline 
         * artifacts (MRIge88944).  Right now we do this only for 3T
         * when opres <= 320 and FOV >= 200.  There is no substantial
         * penalty in terms of scantime or TR.
         */
        area_gxwex = 5.0e6 * exist(opxres) / (exist(opfov) * GAM);
    } else {
        area_gxwex = max_area_gxwex;
    }
    gxwex_on = PSD_ON;

    /* MRIge67548 */ /* MRIge91682 */
    if( ( (exist(opetl)==1)
          && ( spgr_flag && (oprbw > 63.0) && (turbo_flag > 1)
               && !lava_flag && !brava_flag && !vibrant_flag && !specir_flag
               && !irprep_flag && !medal_flag && !merge_flag
               && !msde_flag && !flow4D_flag
               && !ideal_flag && ( ( (opflip <= 10) && !reverse_ellipt_flag
                                     && !ellipt_flag )
                                   || ( (opflip <= 5)
                                        && (reverse_ellipt_flag
                                            || ellipt_flag) ) ) ) )
        || (vstrte_flag && !ssfp_flag) )
    {
        area_gxwex = 0;
        gxwex_on = PSD_OFF;
    }

    /* ATV: balanced gradient for read direction - FIESTA mode */

    if( ssfp_flag == PSD_ON ) {
        area_gx1 = a_gx1 * (0.5 * pw_gx1a + 0.5 * pw_gx1d + pw_gx1); 
        area_gxwex =  -a_gxw * ( pw_gxwa + pw_gxw) - area_gx1;
        gxwex_on = PSD_ON;
    } else { /* MRIhc07226: slice tracking for GRE */
        area_gx1 = a_gx1 * (0.5 * pw_gx1a + 0.5 * pw_gx1d + pw_gx1); 
    }

    /* Dual echo SSFP MEDAL gxwex calc above is wrong */
    if (ssfp_flag && medal_flag && (opetl >= 2)) {
        area_gxwex = area_gx1;
    } 

    area_gx1 = a_gx1 * (0.5 * pw_gx1a + 0.5 * pw_gx1d + pw_gx1);
    area_gxw = a_gxw * (pw_gxwa + pw_gxw) ;
    area_gxfc = a_gxfc * (pw_gxfca + pw_gxfc);
    area_gx2 = -area_gxw; 

    if( (amppwgradmethod(&gradx[GX2_SLOT], area_gx2, ogsfX2*loggrd.tx,
                         0.0, 0.0, RUP_GRD((ceil)(ogsfX2*xrt)), MIN_PLATEAU_TIME)) == FAILURE ) {
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"amppwgradmethod:gx2");
        return FAILURE;
    }

    pw_gxw2 = pw_gxw;
    pw_gxw2a = pw_gxwa;
    pw_gxw2d = pw_gxwd;
    a_gxw2 = a_gxw;

    if (isHeadNeckTxPosition() && !cal3d_flag)
    {
        if(value_system_flag == VALUE_SYSTEM_HDE) {
            /* MRIge93061 */
            if( ((irprep_flag == PSD_ON && ssfp_flag != PSD_ON) || (spgr_flag == PSD_ON && irprep_flag == PSD_OFF))
                && oprbw < 45.0 && (existcv(opfov) && exist(opfov) < 285) ) 
            {
                area_gxwex += 600;
            }
        }
        else
        {
            /* MRIge93061, MRIhc17788, MRIhc21416
            * Increase area_gxwex to 4000 for all SPGR cases (Except TOF)
            * and non-gated and non (LAVA + BRAVA + SPECIAL + VIBRANT + COSMIC +
            *                        TRICKS + SwiFT + IDEAL + MERGE + QUICKSTEP cases).
            * And ONLY for all GE Head Coils */
            if( (exist(oppseq)==PSD_SPGR) &&
                !(exist(opcgate) == PSD_ON) &&
                !lava_flag && !brava_flag && (!specir_flag || bravo_flag) && !vibrant_flag &&
                !osfp_flag && !tricks_flag && !disco_1echo_flag && !ideal_flag && !idealiq_flag &&
                !msde_flag &&
                !merge_flag && !vibrantxv_flag && !quickstep_flag && !medal_flag)
            {
                area_gxwex = 4000;
            }
        } /* end !value_system_flag */
    }

    if (swan_flag) {
       area_gxwex = 4000;
    }
    
    if (headneck_pos_scan) {
       area_gxwex = 1200;
    }

    if (flow4D_flag == PSD_ON) 
    {
      area_gxwex =  GZKAREA_4DFLOW;;
    }
    /* HCSDM00382904 : increase the killer area to reduce banding artifact for VRMW. Scan time will not increase. */
    if ((PSD_ON == cal3d_flag) && isKizunaSystem())
    {
       area_gxwex = 500;
    }


       /* check if area required is greater than that available by
       stretching the readout gradient.  */

    gxwex_target = loggrd.tx_xyz;

    if(derate_gxwex) {
        /* gradient derating for HDe 3D dual echo */
        if( (value_system_flag == VALUE_SYSTEM_HDE) && (medal_flag) ) {
            gxwex_target =  FMin(2, gxwex_target_hfdslite_value_3dde, loggrd.tx_xyz);
        }
        else if (area_gxwex > max_area_gxwex) {
            gxwex_target =  FMin(2, gxwex_target_hfdslite, loggrd.tx_xyz);
        }
    }

    /* MRIge66079 - ATV: RTIA3D/ftMRA */
    /* ATV - gxwex will be unbridged from gxw for ftMRA mode so
       gradient instruction amplitude can be scaled in real-time */
    /* MRIge91973 - unbridged gxwex for FIESTA */
    if( gxwex_on == PSD_ON )
    {
        if( (ftmra_flag == PSD_OFF ) && (maskv_ftmra_flag == PSD_OFF)
            && (ssfp_flag == PSD_OFF) && (exist(opetl)==1)
            && (flow_comp_type != TYPFC) )
        {
            if( ( (ssfp_flag == PSD_OFF)
                  && (area_gxwex < ((float)(IMax(2,pw_gy1r_tot,gzptime) - pw_gxwd) * a_gxw)) )
                || (a_gxw == gxwex_target))
            {
                a_gxwex = a_gxw;
                pw_gxwexd = pw_gxwd;

                /* Never allow pw_gxwex to be less than 4 usec JAP */
                pw_gxwex = IMax(2, 4, RUP_GRD((int)((area_gxwex/a_gxwex)
                                                    - (float)(pw_gxwexd/2))));
                pw_gxwexa = GRAD_UPDATE_TIME;

                /* GEHmr02509: smart derating */
                if( PSD_ON == gradOpt_flag )
                {
                    area_gxwex = (float)(pw_gxwex+pw_gxwexa + 0.5*pw_gxwexd)*a_gxwex;
                    if( (amppwgradmethod(&gradx[GXWEX_SLOT], area_gxwex, (ogsfXwex*gxwex_target),
                                         a_gxw, 0.0, (RUP_GRD((ceil) (ogsfXwex*xrt))), MIN_PLATEAU_TIME)) == FAILURE )
                    {
                        force_gradOpt_loop_break = PSD_ON;  /* HCSDM00360543 */
                        return FAILURE;
                    }
                }
            } else {
                if( ssfp_flag == PSD_ON ) {
                    if( (amppwgradmethod(&gradx[GXWEX_SLOT], area_gxwex, (ogsfXwex*gxwex_target),
                                         0.0, 0.0, (RUP_GRD((ceil) (ogsfXwex*xrt))), MIN_PLATEAU_TIME)) == FAILURE ) {
                        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                                   EE_ARGS(1),STRING_ARG,"amppwgradmethod:gxwex");
                        return FAILURE;
                    }
                    pw_gxwexa = pw_gxwa+pw_gxwexd;

                } else {
                    if( (amppwgradmethod(&gradx[GXWEX_SLOT], area_gxwex, (ogsfXwex*gxwex_target),
                                         a_gxw, 0.0, (RUP_GRD((ceil) (ogsfXwex*xrt))), MIN_PLATEAU_TIME)) == FAILURE ) {
                        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                                   EE_ARGS(1),STRING_ARG,"amppwgradmethod:gxwex");
                        return FAILURE;
                    }
                }
            }
            pw_gxwd = pw_gxwexa;
            gxwex_bridge = PSD_ON;
        } else {
            float start_amp;

            if (exist(opetl)>=2) {
               if (!uniPolar_flag && ((exist(opetl)%2)==0)) {
                  area_gxwex *= -1.0;
               }
            }

            /* MRIge91973 */
            /* RTIA3D/ftMRA/FIESTA */
            if ( (exist(opetl)>=2) && (oprbw > 63.0) && (ssfp_flag == PSD_OFF) && !idealiq_flag ) {
                if (area_gxwex > (a_gxw * (0.5 * (pw_gxwa+pw_gxwd) + GRAD_UPDATE_TIME )) ) {
                    area_gxwex = (a_gxw * (0.5 * (pw_gxwa+pw_gxwd) + GRAD_UPDATE_TIME ));
                }
            }

            if( bridge_gxw2_gxwex_3dde ) {
                start_amp = -a_gxw; /* bridge gxw2 and gxwex */
            } else {
                start_amp = 0.0;
            }
            if( (amppwgradmethod(&gradx[GXWEX_SLOT], area_gxwex, (ogsfXwex*gxwex_target),
                                 start_amp, 0.0, (RUP_GRD((ceil) (ogsfXwex*xrt))), MIN_PLATEAU_TIME)) == FAILURE ) {
                epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                           EE_ARGS(1),STRING_ARG,"amppwgradmethod:gxwex");
                return FAILURE;
            }
            if( bridge_gxw2_gxwex_3dde ) {
                pw_gxw2d = pw_gxwexa; /* bridge gxw2 and gxwex */
            } else {
                pw_gxwd = pw_gxwa;
                pw_gxwexa = pw_gxwexd;
            }
            gxwex_bridge = PSD_OFF;
        }
    } else {
        /* No gxwex */
        /* MRIge66706 */
        pw_gxwexa = GRAD_UPDATE_TIME;
        pw_gxwex  = GRAD_UPDATE_TIME;
        a_gxwex = a_gxw;
        pw_gxwexd = pw_gxwd;
    }



    /* End RTIA3D/ftMRA */

    /* ATV: total_area_gx should be 0 for fully-balanced on read direction */
    /* MRIge91973 */
    if (ftmra_flag || maskv_ftmra_flag || ssfp_flag )
    {
        total_area_gx =  a_gx1 * (0.5 * pw_gx1a + 0.5 * pw_gx1d + pw_gx1) +
            a_gxw * (0.5 * pw_gxwa + 0.5 * pw_gxwd +  pw_gxw ) +
            a_gxwex * (0.5 *pw_gxwexa + 0.5 * pw_gxwexd + pw_gxwex);
    }
    else
    {
        total_area_gx =  a_gx1 * (0.5 * pw_gx1a + 0.5 * pw_gx1d + pw_gx1) +
            a_gxw * ( pw_gxwa +  pw_gxw ) +
            a_gxwex * ( pw_gxwexd + pw_gxwex);
    }

    total_area_gxfc = a_gx1 * (0.5 * pw_gx1a + 0.5 * pw_gx1d + pw_gx1) +
                      a_gxfc * (0.5 * pw_gxfca + 0.5 * pw_gxfcd + pw_gxfc) +
                      a_gxw * (0.5 * pw_gxwa + t_rd1a ) ;

    gradx[GXWEX_SLOT].num = 1;

    /* Divide by 0 protection */
    if ((echo1_filt->tdaq == 0) || (echo1_filt->decimation == 0)) {
        epic_error(use_ermes,"echo1 tdaq or decimation = 0",
                   EM_PSD_BAD_FILTER,EE_ARGS(0));
        return FAILURE;
    }

    if (!flexte_flag) {
       opte = act_te;
       setexist(opte,1);     /* set existence for support routines    */
    } else {
       if( existcv(opautote) && (PSD_OFF == exist(opautote)) && existcv(opte) ) {
           if (merge_flag)
              merge_targetTE = exist(opte);
           else
              act_te = exist(opte);
       }
    }

    if ( vstrte_flag )
    {
        avminte= (int) 10.0*floor(act_te/10.0);
    }
    else
    {
        avminte = act_te;
    }
    avround = 1;          /* restore avround for subsequent calls  */

    if ((exist(opetl) >= 2) || medal_flag) {
       if (!merge_flag) { 
          avmaxte = act_te;
          if (PSD_OFF == medal_multitr_flag)
              avmaxte2 = act_te + (opetl-1)*esp;
          else       
              avmaxte2 = medal_te2;
       }

       if (idealiq_flag)
       {
           /* to display min and max TE on UI */
           avmaxte = avminte + idealiq_esp*(exist(opnecho)-1);
       }

       /*
       if (medal_flag) {
          if (rhmedal_echo_order) {
             avmaxte = medal_ip_te_max;
             avmaxte2 = medal_oop_te_max;
          } else {
             avmaxte = medal_oop_te_max;
             avmaxte2 = medal_ip_te_max;
          }
       }
       */

    }

    if(!idealiq_flag)
    {
        setexist(opnecho, PSD_ON);  /* Since there are no buttons for this, we
                                       have to set its existence too         */
    }

    if (merge_flag)
    {
       pinecho = 1;
       if (rhfiesta == 0)
          pinecho = exist(opnecho);
    }
    else
    {
       /* RV: MRIhc19003 - Change from opnecho to ideal_necho */
       if(PSD_ON == ideal_flag)
       {
          pinecho = ideal_necho;
       }
       else if (medal_flag) 
       {
          pinecho = medal_necho*medal_etl;
       }
       else if (idealiq_flag) 
       {
          pinecho = exist(opnecho);
       }
       else if (flow4D_flag)
       {
          pinecho = nflow4D;
       }
       else
       {
          pinecho = exist(opetl);
       }
       rhchannel_combine_method = 0; /* No C3 or phase filtering */
       rhchannel_combine_filter_type = 0; /* No filtering */
    }

    /* Allow intermittant chemsat JP */
    /* add time for cine3d packet at start of acquisition */ 
    pos_start = RUP_GRD( tlead+(cine3d_flag?DAB_length[bd_index]:0) ) ;
    cs_satstart_min = RUP_GRD(pos_start + rffrequency_length[bd_index] 
                              - rfupa);

    /* Initialization for cs_satstart */
    cs_satstart = cs_satstart_min; 

    if (!vstrte_flag) {
        if ((cs_sat==PSD_ON)&&(intermittant_chemsat==PSD_OFF)) {
            pos_start = pos_start + RUP_GRD((INT)(cs_sattime));

            sp_satstart = pos_start;

        } else {

            /* BJM: modification for unblank time reduction.  Need to keep */
            /* sat start timing  relative to rfupa (-250). Note rfupa is negative! */
            /* sp sat seq will start at the same time as the regular tr seq */
            sp_satstart = pos_start + 
                RUP_GRD((INT)IMax(2,pw_gzrf1a,
                                  DAB_length[bd_index]+rffrequency_length[bd_index] -
                                  rfupa - psd_rf_wait) - pw_gzrf1a);

            /* Need to subtract off psd_grd_wait from pos_start */
            /* BJM: change from rfup to rfupacv to permit 50us unblank */
            /* Note that rfupacv is positive...*/
            /* HAD: Used rfupa instead of rfupacv. rfupa is negative*/

            /* Moved it back to rfupacv for HDxt */
            pos_start = pos_start + 
                RUP_GRD((INT)IMax(2,pw_gzrf1a,
                                 DAB_length[bd_index] + rffrequency_length[bd_index] +
                                 rfupacv - psd_rf_wait) - pw_gzrf1a);

        }
    }

    /* pos_start_ir is required to calculate tdel 
       min and max for 3D MDE - RJF */

    if( irprep_flag == PSD_ON ) {
        pos_start_ir_min = RUP_GRD((int)(tlead +
                                         IMax(2, pw_gzrf0a, 
                                              rffrequency_length[bd_index] - rfupa) 
                                         - pw_gzrf0a));
    }

    if(ifir_frir_flag) 
    {
        pos_start_frir = RUP_GRD((int)(tlead + IMax(2, pw_gzrffrira,
                                 rffrequency_length[bd_index] - rfupa) - pw_gzrffrira));
    }

    if(fiesta_killer_flag) {
        pos_start_gzk = RUP_GRD( tlead );
        tseq_gzk = pos_start_gzk + RUP_GRD(pw_gzka + pw_gzk + pw_gzkd + time_ssi);
    }

   /* MRIhc16353 - RV: IDEAL change */
   if(PSD_ON == ideal_flag)
   {
       int foo1,foo2,foo3;
       if ( ideal_opt_te > 0 ) {
              act_te = ideal_min_te;
       }

       if (ideal_opt_te == 0) {
          foo1 = act_te;
          foo2 = act_te + ideal_defshift;
          foo3 = act_te + 2*ideal_defshift;
       } 
       else {
          foo1 = ideal_min_te;  /* should be the same as ideal_min_te */
          foo2 = RUP_GRD(one_half_pi + k_ideal_pi*ideal_pi);
          foo3 = RUP_GRD(7*one_sixth_pi + k_ideal_pi*ideal_pi);
       } 
       if (ideal_echo_mode == 0)  { /* doing dixon on inner loop - change order */
          ideal_te1 = foo1;
          ideal_te2 = foo3;
          ideal_te3 = foo2;
       } else {
          ideal_te1 = foo1;
          ideal_te2 = foo2;
          ideal_te3 = foo3;
       }

       ideal_max = IMax(3, ideal_te1, ideal_te2, ideal_te3);
       ideal_min = IMin(3, ideal_te1, ideal_te2, ideal_te3);
    }

    if (medal_flag && medal_multitr_flag)
    {
        medal_te1 = act_te;
        if (rhmedal_echo_order) {
           medal_oop_te = medal_pi_ave + (medal_k_oop_pi)*(2*medal_pi_ave);
           medal_oop_te_max = medal_oop_te + medal_oop_te_plus;
           medal_oop_te_min = medal_oop_te - medal_oop_te_minus;
           medal_te2 = RUP_GRD(medal_oop_te);
        } else {
           if (act_te > medal_pi_ave)
           {
               medal_ip_te = act_te + medal_pi_ave + (medal_k_ip_pi-1)*(2*medal_pi_ave);
               medal_ip_te_max = 2*medal_pi_ave + IMax(2, medal_ip_te_plus, (act_te-medal_pi_ave));
               medal_ip_te_min = medal_ip_te - medal_ip_te_minus;
           }
           else
           {
               medal_ip_te = 2*medal_pi_ave + (medal_k_ip_pi-1)*(2*medal_pi_ave);
               medal_ip_te_max = medal_ip_te + medal_ip_te_plus;
               medal_ip_te_min = medal_ip_te - medal_ip_te_minus;
           }
           medal_te2 = RUP_GRD(medal_ip_te); 
        }
        avminte2 = medal_te2;
        medal_min = IMin(2, medal_te1, medal_te2);
        medal_max = IMax(2, medal_te1, medal_te2);
    }

    /* Calculate some necessary intermediate times for advisory panel */
    te_time = act_te;

    /* For 3D Cal, wait until signal is stable. */
    if (cal3d_flag)
    {
        te_time = IMax(2, act_te, 500us);
    }

    if( (exist(opetl)>= 2) ) {
        esp = RUP_GRD( t_rdb + IMax (2,  (pw_gxwd + pw_gxw2a + uniPolar_flag*(pw_gx2a + pw_gx2 + pw_gx2d)),
                                     attenlength + tnslength +
                                     IMax(2, DABSETUP, (XTRSETLNG + XTR_length[bd_index] + DAB_length[bd_index])) +
                                     RBA_length[bd_index] +
                                     psd_grd_wait) + t_rd1a );

        act_te2 = act_te + esp;

        if (medal_flag) {
          if (rhmedal_echo_order) {
             int done_searching = FALSE;
             medal_oop_te += (2*medal_pi_ave);
             medal_oop_te_max = medal_oop_te + medal_oop_te_plus;
             medal_oop_te_min = medal_oop_te - medal_oop_te_minus;
             medal_k_oop_pi += 1;

             if (medal_autote_flag) {
                if ((act_te2 <= medal_oop_te_max)) {
                   if ( (act_te2 < medal_oop_te) )
                      act_te2 = RUP_GRD(medal_oop_te);
                      done_searching = TRUE;
                   } else {
                      while (!done_searching) {
                          medal_oop_te += (2*medal_pi_ave);
                          medal_oop_te_max = medal_oop_te + medal_oop_te_plus;
                          medal_oop_te_min = medal_oop_te - medal_oop_te_minus;
                          medal_k_oop_pi += 1;

                          if ((act_te2 <= medal_oop_te_max)) {
                             if ( (act_te2 < medal_oop_te) )
                                act_te2 = RUP_GRD(medal_oop_te);
                             done_searching = TRUE;
                          }
                      }
                   }
             } else {
                if ((act_te2 <= medal_oop_te_max)) {
                   if ( (act_te2 < medal_oop_te) )
                      act_te2 = RUP_GRD(medal_oop_te);
                }
             }
           } else {
             int done_searching = FALSE;
             medal_ip_te = IMax(2, act_te, medal_pi_ave) + medal_pi_ave;
             if (act_te > medal_pi_ave)
             {
                 medal_ip_te = act_te + medal_pi_ave + (medal_k_ip_pi-1)*(2*medal_pi_ave);
                 medal_ip_te_max = 2*medal_pi_ave + IMax(2, medal_ip_te_plus, (act_te-medal_pi_ave));
                 medal_ip_te_min = medal_ip_te - medal_ip_te_minus;
             }
             else
             {
                 medal_ip_te = 2*medal_pi_ave + (medal_k_ip_pi-1)*(2*medal_pi_ave);
                 medal_ip_te_max = medal_ip_te + medal_ip_te_plus;
                 medal_ip_te_min = medal_ip_te - medal_ip_te_minus;
             }
             medal_ip_te_min = medal_ip_te - medal_ip_te_minus;
             medal_k_ip_pi = 1;

             if (medal_autote_flag) {
                if ( (act_te2 <= medal_ip_te_max) ) {
                   if (act_te2 < medal_ip_te)
                      act_te2 = RUP_GRD(medal_ip_te);
                   done_searching = TRUE;
                } else {
                     while (!done_searching) {
                         medal_ip_te += 2*medal_pi_ave;
                         medal_ip_te_max = medal_ip_te + medal_ip_te_plus;
                         medal_ip_te_min = medal_ip_te - medal_ip_te_minus;
                         medal_k_ip_pi += 1;

                         if ( (act_te2 <= medal_ip_te_max) ) {
                            if (act_te2 < medal_ip_te)
                               act_te2 = RUP_GRD(medal_ip_te);
                            done_searching = TRUE;
                         }
                     }
                 }
             } else {
                if ( (act_te2 <= medal_ip_te_max) ) {
                   if (act_te2 < medal_ip_te)
                      act_te2 = RUP_GRD(medal_ip_te);
                }
             }
           }

           esp = RUP_GRD(act_te2 - act_te);
           act_te2 = act_te + esp;

        }

        avminte2 = act_te2;
        opte2 = act_te2;
    } else {
        esp = 0;
        opte2 = medal_te2; 
        act_te2 = opte2; 
    }

    if( merge_flag ){
        int merge_max_echoes = (INT)((merge_targetTE-act_te+0.25*esp)*2.0/esp + 0.5);

        if (exist(opuser16)==0) {
           if (cffield < B0_30000)
           {
               if (swan_flag)
                   merge_defaultTE = SWAN_TE_1HT;
               else
                   merge_defaultTE = MERGE_TE_1HT;
           }
           else
           {
               if (swan_flag)
                   merge_defaultTE = SWAN_TE_3T;
               else
                   merge_defaultTE = MERGE_TE_3T;
           }
        }
        else
        {
           merge_defaultTE = merge_targetTE;
        }

        merge_min_echoes = (INT)((merge_defaultTE-act_te+0.25*esp)*2.0/esp + 0.5);
        merge_min_echoes = IMax(2,merge_min_echoes,3);
        merge_min_echoes = IMin(2,merge_min_echoes, avmaxnecho);
        merge_max_echoes = IMax(2,merge_max_echoes, merge_min_echoes);
        merge_max_echoes = IMin(2,merge_max_echoes, avmaxnecho);
        if ( (exist(opnecho) < merge_max_echoes) || flexte_flag )  {
           cvoverride(opnecho, merge_max_echoes, PSD_FIX_OFF, PSD_EXIST_ON);
        }
        cvoverride(opetl, exist(opnecho), PSD_FIX_ON, PSD_EXIST_ON);
        etl_override = PSD_ON;
        merge_echoIndex = 0.5*(exist(opetl)-1);
        avminte = act_te + (int) (merge_echoIndex*esp);
        avminte *= 10;
        advroundup(&avminte);
        avminte /= 10;

        avmaxte = act_te + (int) (0.5*(MAX_ECHOES)*esp);
        avmaxte *= 10;
        advroundup(&avmaxte);
        avmaxte /= 10;
        avmaxte  = IMax(2, avminte, avmaxte);

        avminte2 = act_te;
        avmaxte2 = esp;

        if (swan_flag)
            avmaxte2 = act_te + (opetl-1)*esp;
    }

    /* Include SSP board in non_tetimpe calculation */
    /* MRIge42112 - Added psd_grd_wait to gradient pulse length to allow the
       last gradient pulse to complete and to stabilize before EOS */

    /* MRIge91683 */
    /* MRIhc22600 - Need a minimimum wait time after the last gradient playout to avoid gradient overrange
    errors during FT MRA realtime acquistion */ 
    rewinding_time = IMax(5,pw_gy1r_tot+(count_grd_wait?psd_grd_wait:0)+waitTime,
                          gzptime+(count_grd_wait?psd_grd_wait:0)+waitTime,
                          isi_flag*pw_isi7 + 10,
                          (ftmra_flag||maskv_ftmra_flag||ssfp_flag||(opetl>=2)||(flow_comp_type==TYPFC)||(!gxwex_on))*pw_gxwd + gxwex_on*(pw_gxwexa+pw_gxwex+pw_gxwexd) +(count_grd_wait?psd_grd_wait:0)+waitTime,
                          psd_grd_wait + attenlength + tnslength );

    /* MRIhc16353 - RV: IDEAL change */
    if(PSD_ON == ideal_flag)
    {
       ideal_pw = RUP_GRD(ideal_max - ideal_min);
    }
    else
    {
       ideal_pw = 0;
    }

    if(idealiq_flag)
    {
        int k;
        float esp_in_rad_over_pi, te1_in_rad_over_pi;
        float new_te1_in_rad_over_pi;
        float pi_time;
        float delta_esp;

        idealiq_esp = RUP_GRD((int)(esp/idealiq_nshots));

        /* acceptable xres range is calculated for APx */
        idealiq_min_xres = avminxres;
        idealiq_max_xres = avmaxxres;

        if(idealiq_esp < idealiq_min_esp)
        {
            delta_esp = (float)idealiq_nshots * (float)(idealiq_min_esp - idealiq_esp);
            idealiq_min_xres = exist(opxres) + (int)ceilf(2.0 * exist(oprbw) * delta_esp * 1.0e-3 / 4.0) * 4;
        }
        else if(idealiq_esp > idealiq_max_esp)
        {
            delta_esp = (float)idealiq_nshots * (float)(idealiq_max_esp - idealiq_esp);
            idealiq_max_xres = exist(opxres) + (int)floorf(2.0 * exist(oprbw) * delta_esp * 1.0e-3 / 4.0) * 4;
        }

        /* if TE1 and esp is in a bad region, increase TE1 to get out of the region */
        pi_time = 1.0s/dix_freq/2;
        esp_in_rad_over_pi = (float)idealiq_esp / pi_time;
        te1_in_rad_over_pi = (float)act_te / pi_time;

        for(k=0;k<idealiq_num_bad_region;k++)
        {
            if( (dTE_lb[k]<=esp_in_rad_over_pi) && (esp_in_rad_over_pi<dTE_ub[k]) && 
                (TE1_lb[k]<=te1_in_rad_over_pi) && (te1_in_rad_over_pi<TE1_ub[k]) )
            {
                new_te1_in_rad_over_pi = TE1_ub[k];
                act_te = RUP_GRD((int)(new_te1_in_rad_over_pi * pi_time));
            }
        }

        te_time = act_te;
        act_te2 = act_te + esp;
        avminte2 = act_te2;
        opte2 = act_te2;

        idealiq_pw = idealiq_esp * (idealiq_nshots-1);
    }
    else
    {
       idealiq_esp = 0;
       idealiq_pw = 0;
    }

    if(medal_flag && medal_multitr_flag)
    {
       medal_pw = RUP_GRD(medal_max - medal_min);
    }
    else
    {
       medal_pw = 0;
    }

    non_tetime = pos_start + t_exa + t_rdb + rewinding_time + ideal_pw + idealiq_pw + medal_pw + time_ssi + (2 * GRAD_UPDATE_TIME);

    tmin = te_time + non_tetime + (exist(opetl)-1)*esp;

    /* symmetric TE for IFIR */
    if( ssfp_flag && ssfp_symmetry_flag &&
        (exist(opautote) == PSD_MINTEFULL) )
    {
        te_time = RUP_GRD (act_te);
        non_tetime = RUP_GRD (non_tetime);
        if( non_tetime > te_time ) {
           te_time  = non_tetime ;
        } else {
           non_tetime = te_time ;
        }
        tmin = te_time + non_tetime;
    }

    act_te = te_time;

    if ( vstrte_flag )
    {
        avminte = (int) 10.0*floor(act_te/10.0);
    }
    else
    {
        avminte = act_te;
    }

    if (!flexte_flag) {
       opte = act_te;
       setexist(opte, 1);
    }

    /* Set maximum TE Only after the last calculation for avminte is done */
    if (!merge_flag)
       avmaxte = avminte + 10ms;

    if ((exist(opetl)>=2) || medal_flag)
    {
       if (!merge_flag)
       {
          avmaxte = act_te;
          avmaxte2 = act_te + (opetl-1)*esp;
       }

       if (idealiq_flag)
       {
           /* to display min and max TE on UI */
           avmaxte = avminte + idealiq_esp*(exist(opnecho)-1);
       }

       /*
       if (medal_flag)
       {
          if (rhmedal_echo_order)
          {
             avmaxte = medal_ip_te_max;
             avmaxte2 = medal_oop_te_max;
          }
          else
          {
             avmaxte = medal_oop_te_max;
             avmaxte2 = medal_ip_te_max;
          }
       }
       */

    }
    else
       advrounddown(&avmaxte);
   
    if (ideal_flag || medal_flag || idealiq_flag || cine3d_flag)
    {
       pite1nub = 6;
    }
    else if ( lava_flag || brava_flag || bravo_flag || osfp_flag || ifir_flag ||
              quickstep_flag || multiEcho_flag || headneck_pos_scan ||
              (!merge_flag && (exist(opetl)>=2)) )
    {
       pite1nub = 0;
    }
    else
    {
       pite1nub = 30 + flexte_flag;
    }

    tmin = RUP_GRD(tmin);

    if(swap_fat_cs == PSD_ON)
    {
        a_gx1 = -a_gx1;
        a_gxwex = -a_gxwex;
        a_gxw = -a_gxw;
    } 

@inline FastCINE3D.e fcine3d_rdout_FlowEnc
    return SUCCESS;
}   /* end set_rdout_and_tmin() */

/*
 *  mintefgre
 *
 *  Description:
 *    ???
 *
 *  Type and Call:
 *  --------------
 *  STATUS mintefgre( &Minte, &Rd1a, &Rd1b, &tfeextra, &a_pwgxw, &d_pwgxw,
 *                    &ampgx1, &a_pwgx1, &c_pwgx1, &d_pwgx1,
 *                    &ampgxfc, &a_pwgxfc, &c_pwgxfc, &d_pwgxfc,
 *                    fecho_factor, c_pwgxwl, c_pwgxw, c_pwgxwr,
 *                    ampgxw, Trf1b, fctype, minseq1, minseq3 )
 */
STATUS
mintefgre( int *Minte,
           int *Rd1a,
           int *Rd1b,
           int *tfeextra,
           int *a_pwgxw,
           int *d_pwgxw,
           float *ampgx1,
           int *a_pwgx1,
           int *c_pwgx1,
           int *d_pwgx1,
           float *ampgxfc,
           int *a_pwgxfc,
           int *c_pwgxfc,
           int *d_pwgxfc,
           float fecho_factor,
           int c_pwgxwl,
           int c_pwgxw,
           int c_pwgxwr,
           float ampgxw,
           int Trf1b,
           int fctype,
           int minseq1,
           int minseq3 )
{
    int minTegx, minTegy, minTegz, mintetmp;  /* for min te calcs */
    float areaGxw;
    float areaReadramp;
    int rd1atmp, rdbtmp;
    int a_pwgx1tmp, c_pwgx1tmp, d_pwgx1tmp;
    float ampgx1tmp;
    int a_pwgxwtmp, d_pwgxwtmp;
    int acqType;
    int a_pwgxfctmp;
    int c_pwgxfctmp;
    int d_pwgxfctmp;
    float ampgxfctmp;
    int c_pwgxwfull;
    int avail_pwgx1=1s;
    int misc_daqtime;
    float fecho_factor_tmp;

    c_pwgxwfull = c_pwgxw;

    acqType = TYPGRAD;		/* fgre3d is always a grad. echo sequence */

    *tfeextra = RUP_GRD((int)((1 - fecho_factor)*(c_pwgxw-c_pwgxwl-c_pwgxwr)));

    rd1atmp = c_pwgxwl + (int)((fecho_factor - 0.5) * (c_pwgxw-c_pwgxwl-c_pwgxwr));
    /* Time to center of echo from start of readout */
    rdbtmp = c_pwgxw - c_pwgxwl - (int)((fecho_factor - 0.5) * (c_pwgxw-c_pwgxwl-c_pwgxwr));
    /* Time from center of echo to end of readout */

    if (optramp(&a_pwgxwtmp, ampgxw, (ogsfXw*loggrd.tx_xyz), (RUP_GRD((ceil) (ogsfXw*xrt))), TYPDEF) == FAILURE)
    {
        epic_error(use_ermes, supfailfmt,
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "optramp (for pwgxwtmp)");
        return FAILURE;
    }
    misc_daqtime = attenlength + tnslength + IMax(2, DABSETUP, (XTRSETLNG + XTR_length[bd_index] + DAB_length[bd_index])) + 
                   RBA_length[bd_index] + psd_grd_wait;

    if ((a_pwgxwtmp < misc_daqtime/2) && (uniPolar_flag==0) && (opetl>1))
    {
        a_pwgxwtmp = RUP_GRD(misc_daqtime/2);
    }

    d_pwgxwtmp = a_pwgxwtmp;

    avround = 0;                        /* get exact, non rounded te */

    if ( fctype==TYPFC ) {
        if ( amppwgxfcmin( ampgxw, a_pwgxwtmp, c_pwgxwfull, d_pwgxwtmp,
                           avail_pwgx1, fecho_factor,
                           (ogsfX1*loggrd.tx_xyz), (RUP_GRD((ceil) (ogsfX1*xrt))), loggrd.xbeta,
                           &ampgx1tmp, &a_pwgx1tmp, &c_pwgx1tmp,
                           &d_pwgx1tmp, &ampgxfctmp, &a_pwgxfctmp,
                           &c_pwgxfctmp, &d_pwgxfctmp ) == FAILURE ) {
            epic_error( use_ermes, "%s failed.  TE or FOV too small.",
                        EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG,
                        "amppwgxfcmin" );
            return FAILURE;
        }

        minTegx = RUP_GRD(Trf1b + GRAD_UPDATE_TIME + a_pwgx1tmp +
                           c_pwgx1tmp + d_pwgx1tmp + a_pwgxfctmp +
                           c_pwgxfctmp+ d_pwgxfctmp + a_pwgxwtmp + rd1atmp);
    } 
    else 
    {
       areaGxw = ampgxw * c_pwgxw;

       fecho_factor_tmp = ((c_pwgxw - c_pwgxwl - c_pwgxwr) * (fecho_factor - 0.5) + c_pwgxwl) / c_pwgxw + 0.5;

       areaReadramp = 0.5*ampgxw*a_pwgxwtmp;
 
       if (amppwgx1(&ampgx1tmp, &c_pwgx1tmp, &a_pwgx1tmp, &d_pwgx1tmp,
                    acqType, areaGxw, areaReadramp,
                    3s, fecho_factor_tmp, MIN_PLATEAU_TIME,
                    (RUP_GRD((ceil) (ogsfX1*xrt))) , (ogsfX1*loggrd.tx_xyz)) == FAILURE)
       {
           epic_error(use_ermes,"%s failed",
                   EM_PSD_SUPPORT_FAILURE,1,STRING_ARG,"amppwgx1");
       }


       ampgxfctmp = 0;
       a_pwgxfctmp = 0;
       c_pwgxfctmp = 0;
       d_pwgxfctmp = 0;

       minTegx = RUP_GRD(Trf1b+GRAD_UPDATE_TIME+a_pwgx1tmp+c_pwgx1tmp+d_pwgx1tmp+a_pwgxwtmp+rd1atmp);

    }

    minTegz = RUP_GRD(minseq1 + rd1atmp);
    minTegy = RUP_GRD(minseq3 +rd1atmp);

    mintetmp = IMax(3,minTegx, minTegy, minTegz);

    *Rd1a = rd1atmp;
    *Rd1b = rdbtmp;
    *a_pwgxw = a_pwgxwtmp;
    *d_pwgxw = d_pwgxwtmp;
    *ampgx1 = ampgx1tmp;
    *a_pwgx1 = a_pwgx1tmp;
    *c_pwgx1 = c_pwgx1tmp;
    *d_pwgx1 = d_pwgx1tmp;
    *ampgxfc  = ampgxfctmp;
    *a_pwgxfc = a_pwgxfctmp;
    *c_pwgxfc = c_pwgxfctmp;
    *d_pwgxfc = d_pwgxfctmp;

    *Minte = RUP_GRD(mintetmp);

    if (swan_flag) {
        if (*Minte < swanfirstTE)
            *Minte = RUP_GRD(swanfirstTE);
    }

    avround = 1;

    return SUCCESS;
}

@inline FastCINE3D.e fcine3d_hostsupport

/* Description:
   This code returns the estimated navigator efficiency for a given acceptance window width.
 */
float calc_nav_eff( const float window )
{
    float est_eff = 0.0;

    if (window <= 2.0) {
        est_eff = 0.35;
    } else if (window > 2.0 && window <= 10.0) {
        est_eff = (0.50-0.35) * (window-2.0) / (10.0-2.0) + 0.35;
    } else if (window > 10.0 && window <= 30.0) {
        est_eff = (1.0-0.50) * (window-10.0) / (30.0-10.0) + 0.50;
    } else if (window >= 30.0) {
        est_eff = 1.0;
    }

    return est_eff;
}

/* Description:
   This code turns off spatial sat in PS2 - unique to fgre3d.

   Type and Call:
   -------------
   STATUS satact_f3d()

   Parameters Passed:
   -----------------
   (I: for input parameter, O: for output parameter)
   No parameters are passed.                                    */

STATUS satact_f3d(void)
{
    INT skip_next_sat;            /* flags if explicit sats are parallel */

    /* default sats */
    /* RFSX2, RFSY2, and RFSZ2 will never be on since two sat pulses of
       different thicknesses are not allowed in fgre3d */
    if ( (exist(opsat) != PSD_OFF) && (exist(opsatx) != PSD_OFF) && (existcv(opsatx)) )
    {
        rfpulse[RFSX1_SLOT].activity = PSD_SCAN_ON;
        if (exist(opsatx) == PSD_SATHAD)
            rfpulse[RFSX1_SLOT].activity += PSD_SCAN_HAD - PSD_SCAN_ON;
    }
    if ( (exist(opsat) != PSD_OFF) && (exist(opsaty) != PSD_OFF) && (existcv(opsaty)) )
    {
        rfpulse[RFSY1_SLOT].activity = PSD_SCAN_ON;
        if (exist(opsaty) == PSD_SATHAD)
            rfpulse[RFSY1_SLOT].activity += PSD_SCAN_HAD - PSD_SCAN_ON;
    }
    if ( (exist(opsat) != PSD_OFF) && (exist(opsatz) != PSD_OFF) && (existcv(opsatz)) )
    {
        rfpulse[RFSZ1_SLOT].activity = PSD_SCAN_ON;
        if (exist(opsatz) == PSD_SATHAD)
            rfpulse[RFSZ1_SLOT].activity += PSD_SCAN_HAD - PSD_SCAN_ON;
    }

    /* explicit or grx sats */
    skip_next_sat = 0;
    if ( ((exist(opexsatmask) & PSD_EXPLICIT_1) != 0) && (existcv(opexsatmask)) )
    {
        rfpulse[RFSE1_SLOT].activity = PSD_SCAN_ON;
        if ( ((exist(opexsatparal) & PSD_1_PARALLEL) != 0) && (existcv(opexsatparal)) )
        {
            skip_next_sat = 1;
            rfpulse[RFSE1_SLOT].activity += PSD_SCAN_HAD - PSD_SCAN_ON;
        }
    }
    if ( ((exist(opexsatmask) & PSD_EXPLICIT_2) != 0) && (skip_next_sat == 0) && (existcv(opexsatmask)) )
    {
        rfpulse[RFSE2_SLOT].activity = PSD_SCAN_ON;
    }
    skip_next_sat = 0;
    if ( ((exist(opexsatmask) & PSD_EXPLICIT_3) != 0) && (existcv(opexsatmask)) )
    {
        rfpulse[RFSE3_SLOT].activity = PSD_SCAN_ON;
        if ( ((exist(opexsatparal) & PSD_2_PARALLEL) != 0) && (existcv(opexsatparal)) )
        {
            skip_next_sat = 1;
            rfpulse[RFSE3_SLOT].activity += PSD_SCAN_HAD - PSD_SCAN_ON;
        } 
    }
    if ( ((exist(opexsatmask) & PSD_EXPLICIT_4) != 0) && (skip_next_sat == 0) && (existcv(opexsatmask)) )
    {
        rfpulse[RFSE4_SLOT].activity = PSD_SCAN_ON;
    }
    skip_next_sat = 0;
    if ( ((exist(opexsatmask) & PSD_EXPLICIT_5) != 0) && (existcv(opexsatmask)) )
    {
        rfpulse[RFSE5_SLOT].activity = PSD_SCAN_ON;
        if ( ((exist(opexsatparal) & PSD_3_PARALLEL) != 0) && (existcv(opexsatparal)) )
        {
            skip_next_sat = 1;
            rfpulse[RFSE5_SLOT].activity += PSD_SCAN_HAD - PSD_SCAN_ON;
        } 
    }
    if ( ((exist(opexsatmask) & PSD_EXPLICIT_6) != 0) && (skip_next_sat == 0) && (existcv(opexsatmask)) )
    {
        rfpulse[RFSE6_SLOT].activity = PSD_SCAN_ON;
    }

    return SUCCESS;
}

STATUS ftmra_satact_off(void)
{
    for (numpulses = RFSX1_SLOT; numpulses < (RFSX1_SLOT + NUMRFSAT); numpulses++)
    {
        ftmrasat_rf_act[numpulses] = rfpulse[numpulses].activity;
        rfpulse[numpulses].activity = 0;
    }

    if (rtia3d_irp_flag) {
       *rfpulse[HARD180_SLOT].act_fa *= 1.0/(rhnframes+rhhnover);
       ftmra_hard180_act = rfpulse[HARD180_SLOT].activity;
       rfpulse[HARD180_SLOT].activity = PSD_OFF;
    }

    return SUCCESS;
}

STATUS ftmra_satact_on(void)
{
    for (numpulses = RFSX1_SLOT; numpulses < (RFSX1_SLOT + NUMRFSAT); numpulses++)
    {
        rfpulse[numpulses].activity = ftmrasat_rf_act[numpulses];
    }

    if (rtia3d_irp_flag) {
       rfpulse[HARD180_SLOT].activity = ftmra_hard180_act;
       *rfpulse[HARD180_SLOT].act_fa = 180.0;
    }

    return SUCCESS;
}


/* Description:
   This code performs three spatial sat checks unique to fgre3d.

   Type and Call:
   -------------
   STATUS saterr_f3d()

   Parameters Passed:
   -----------------
   (I: for input parameter, O: for output parameter)
   No parameters are passed.                                    */

STATUS saterr_f3d(void)
{
    INT num_dfsats;		/* number of default sats */
    INT num_exsats;		/* number of explicit sats */
    INT skip_next_sat;		/* flags if explicit sats are parallel */
    INT first_exon;               /* flags if explicit sats are not parallel */
    INT satthick_error;		/* flags if parallel sats and diff thicknesses */

    /* Initilization of variables */
    num_dfsats = 0;
    num_exsats = 0;
    skip_next_sat = 0;
    first_exon = PSD_OFF;
    satthick_error = PSD_OFF;

    /* default sats */
    if ( (exist(opsat) != PSD_OFF) && (exist(opsatx) != PSD_OFF) && (existcv(opsatx)) ) {
        num_dfsats++;
        if (exist(opsatx) == PSD_SATPARA)
            satthick_error = PSD_ON;
    }

    if ( (exist(opsat) != PSD_OFF) && (exist(opsaty) != PSD_OFF) && (existcv(opsaty)) ) {
        num_dfsats++;
        if (exist(opsaty) == PSD_SATPARA)
            satthick_error = PSD_ON;
    }

    if ( (exist(opsat) != PSD_OFF) && (exist(opsatz) != PSD_OFF) && (existcv(opsatz)) ) {
        num_dfsats++;
        if (exist(opsatz) == PSD_SATPARA)
            satthick_error = PSD_ON;
    }

    /* explicit or grx sats */
    if ( ((exist(opexsatmask) & PSD_EXPLICIT_1) != 0) && (existcv(opexsatmask)) ) {
        num_exsats++;
        first_exon = PSD_ON;
        if ( ((exist(opexsatparal) & PSD_1_PARALLEL) != 0) && (existcv(opexsatparal)) )
            skip_next_sat = 1;
    }

    if ( ((exist(opexsatmask) & PSD_EXPLICIT_2) != 0) && (skip_next_sat == 0) && (existcv(opexsatmask)) ) {
        num_exsats++;
        if (first_exon == PSD_ON)
            satthick_error = PSD_ON;
    }
    skip_next_sat = 0;
    first_exon = 0;

    if ( ((exist(opexsatmask) & PSD_EXPLICIT_3) != 0) && (existcv(opexsatmask)) ) {
        num_exsats++;
        first_exon = PSD_ON;
        if ( ((exist(opexsatparal) & PSD_2_PARALLEL) != 0) && (existcv(opexsatparal)) )
            skip_next_sat = 1;
    }

    if ( ((exist(opexsatmask) & PSD_EXPLICIT_4) != 0) && (skip_next_sat == 0) && (existcv(opexsatmask)) ) {
        num_exsats++;
        if (first_exon == PSD_ON)
            satthick_error = PSD_ON;
    }

    skip_next_sat = 0;
    first_exon = 0;

    if ( ((exist(opexsatmask) & PSD_EXPLICIT_5) != 0) && (existcv(opexsatmask)) ) {
        num_exsats++;
        first_exon = PSD_ON;
        if ( ((exist(opexsatparal) & PSD_3_PARALLEL) != 0) && (existcv(opexsatparal)) )
            skip_next_sat = 1;
    }

    if ( ((exist(opexsatmask) & PSD_EXPLICIT_6) != 0) && (skip_next_sat == 0) && (existcv(opexsatmask)) ) {
        num_exsats++;
        if (first_exon == PSD_ON)
            satthick_error = PSD_ON;
    }

    if ( ( (num_dfsats > 1) || (num_exsats > 1)) && (ftmra_flag==PSD_OFF) ) {
        epic_error(use_ermes,"Spatial SAT on more than one axis is not supported in FGRE3D.", 
                   EM_PSD_FGRE3D_SATONEAXIS, EE_ARGS(0));
        return FAILURE;
    }

    /* MRIge66079 - ATV: RTIA3D/ftMRA */
    if( ftmra_flag && (ssfp_flag == PSD_OFF) )
    {
        if ( (ftmra_dfsat_flag && (exist(opsatz)<PSD_SATHAD) ) ||
             (ftmra_exsat_flag && (exist(opexsatmask)!=PSD_EXPLICIT_1) ) ||
             ( (ftmra_dfsat_flag == PSD_OFF) &&  (exist(opsatz)>PSD_OFF) ) ||
             ( (ftmra_exsat_flag == PSD_OFF) && (exist(opexsatmask)>PSD_OFF) ) ||
             (exist(opsaty)>PSD_OFF) || (exist(opsatx)>PSD_OFF)  )
        {
            epic_error(use_ermes, "Spatial Sat is not available with FTMRA.",
                       EM_PSD_FTMRA_SPSAT_INCOMPATIBLE, EE_ARGS(0));
            return FAILURE;
        }
    }
    /* End RTIA3D/ftMRA */

    if ( (num_dfsats > 0) && (num_exsats > 0) ) {
        if (ftmra_flag)
        {
            epic_error(use_ermes, "Spatial Sat is not available with FTMRA.",
                       EM_PSD_FTMRA_SPSAT_INCOMPATIBLE, EE_ARGS(0));
            return FAILURE;

        }
        else
        {
            epic_error(use_ermes, 
                       "A graphic or explicit SAT band with a default SAT band is not supported in FGRE3D.", 
                       EM_PSD_FGRE3D_GRXSAT, EE_ARGS(0));
            return FAILURE;
        }
    }

    if (satthick_error == PSD_ON) {
        epic_error(use_ermes, 
                   "Two SAT bands with different thicknesses are not supported in FGRE3D.", 
                   EM_PSD_FGRE3D_SATTHICK, EE_ARGS(0));
        return FAILURE;
    }

    return SUCCESS;
}

/* YMSmr07111  10/04/2005 YI */
@inline vmx.e UserCvCtl
@inline ss.e ssEval

/* Description:
   For Auto Protocol Optimization, it's necessary to set
   min / max / delta values of optimized parameters.
   Default setting is described in getAPxParamInit() and
   this function can modify those initial values.
*/
void
getAPxParam(optval   *min,
            optval   *max,
            optdelta *delta,
            optfix   *fix,
            float    coverage,
            int      algorithm)
{
    FILE *fp = NULL;
    const char *filename = "/usr/g/service/log/APx_trajectory.log";

    if(idealiq_flag)
    {
        min->xres = IMax(2, avminxres, 128);

        if((idealiq_esp < idealiq_min_esp) && (idealiq_min_xres > avminxres))
        {
            min->xres = idealiq_min_xres;

            if(autoparams_debug & 4)
            {
                fp = fopen(filename, "a");

                if(NULL != fp)
                {
                    fprintf(fp,"\t!!idealiq_min_xres=%d!!\n", idealiq_min_xres);
                    fclose(fp);
                }
            }

            idealiq_min_xres = avminxres;
        }
        else if((idealiq_esp > idealiq_max_esp) && (idealiq_max_xres < avmaxxres))
        {
            max->xres = idealiq_max_xres;

            if(autoparams_debug & 4)
            {
                fp = fopen(filename, "a");

                if(NULL != fp)
                {
                    fprintf(fp,"\t!!idealiq_max_xres=%d!!\n", idealiq_max_xres);
                    fclose(fp);
                }
            }

            idealiq_max_xres = avmaxxres;
        }

        min->yres = IMax(2, avminyres, 96);

        max->slthick = FMin(2, avmaxslthick, 15.0);
    }
    else
    {
        if(medal_flag && medal_autotelock_flag && (!medal_autote_flag) && (medal_max_xres < avmaxxres) &&
           ((act_te > medal_te1_upper) || (act_te2 > medal_te2_upper)))
        {
            max->xres = medal_max_xres;

            if(autoparams_debug & 4)
            {
                fp = fopen(filename, "a");

                if(NULL != fp)
                {
                    fprintf(fp,"\t!!medal_max_xres=%d!!\n", medal_max_xres);
                    fclose(fp);
                }
            }

            avmaxxres = 512;
            medal_max_xres = avmaxxres;
        }

        max->slthick = FMin(2, avmaxslthick, 6.0);
    }

    min->slquant = IMax(2, avminslquant,
                           (int)ceilf((coverage / max->slthick + 2 * pislblank) / (float)delta->slquant) * delta->slquant);

    if(arc_flag && (arc_sl_stride > 1.0) && (exist(opslquant) < arc_sl_calwidth))
    {
        max->accel_sl = 1.0;
    }

    min->ay = arc_ph_mincalwidth;
    min->az = arc_sl_mincalwidth;

    if(algorithm & APX_ALG_AUTO_BW)
    {
        if (cffield <= B0_15000)
        {
            min->rbw = FMax(2, 62.50, avminrbw);
            max->rbw = FMin(2, 83.33, avmaxrbw_system);  /* HCSDM00360543 */
        }
        else
        {
            min->rbw = FMax(2, 62.50, avminrbw);
            max->rbw = FMin(2, 125.0, avmaxrbw_system);  /* HCSDM00360543 */
        }
    }
}

/* Description:
   For Auto Protocol Optimization, it's necessary to set
   flags to show which parameters are optimized and
   which algirithms are applied.
   Default setting is described in getAPxAlgorithmInit() and
   this function can modify those initial values.
*/
int getAPxAlgorithm(optparam *optflag, int *algorithm)
{
    if((PSD_ON == exist(oplava)) && (pircbnub > 0))
    {
        optflag->rbw = 1;
        *algorithm |= APX_ALG_AUTO_BW;
    }

    if(pfkr_yz_enable && existcv(opuser6))
    {
        optflag->user6 = 1;
    }

    if(!disco_flag && existcv(opuser12))
    {
        optflag->user12 = 1;
    }

    if(!disco_flag && existcv(opuser13))
    {
        optflag->user13 = 1;
    }

    if(existcv(opuser15))
    {
        optflag->user15 = 1;
    }

    return APX_CORE_BH_3D;
}

/* HCSDM00360543 */
void
SaveGradOptCoefficients()
{
        save_gradOpt_scale = gradOpt_scale;
        save_gradOpt_ratio = gradOpt_ratio;
        save_gradOpt_TEfactor = gradOpt_TEfactor;
        save_gradOpt_TRfactor = gradOpt_TRfactor;
        save_ogsfX1   = ogsfX1;
        save_ogsfY    = ogsfY;
        save_ogsfZ    = ogsfZ;
        save_ogsfX2   = ogsfX2;
        save_ogsfXwex = ogsfXwex;
        save_ogsfYk   = ogsfYk;
}
void
RestoreGradOptCoefficients()
{
        gradOpt_scale = save_gradOpt_scale;
        gradOpt_ratio = save_gradOpt_ratio;
        gradOpt_TEfactor = save_gradOpt_TEfactor;
        gradOpt_TRfactor = save_gradOpt_TRfactor;
        ogsfX1   = save_ogsfX1;
        ogsfY    = save_ogsfY;
        ogsfZ    = save_ogsfZ;
        ogsfX2   = save_ogsfX2;
        ogsfXwex = save_ogsfXwex;
        ogsfYk   = save_ogsfYk;
}

/* *************************************************************
 * CVCHECK *
 * This section will be executed every time a 'next page' is 
 * chosen.  This is to assure that the current prescribed 
 * protocol is legal.  If it is not, an error message will be
 * returned to the psd manager.  For now, these messages
 * will be strings.  But later the messages will be given
 * by an ermes number.
 * ********************************************************* */
STATUS
cvcheck( void )
{
@inline ZoomGradLimit.e ZoomGradParam

    /* HCSDM00422934 Pure disabled with multi station */
    if ( exist(opmultistation) && (pipure > 0) )
    {
        epic_error(use_ermes, 
		   "%s is incompatible with %s",
		   EM_PSD_INCOMPATIBLE,EE_ARGS(2),
                   STRING_ARG, "Pure", 
		   STRING_ARG, "Multi station");
        return FAILURE;
    }

    if( (Absent == DE3DKey) && (PSD_ON == de3d_flag) )
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "3D Dual Echo");
        return FAILURE;
    }

    if ( (Absent == NavigatorKey) && ((PSD_ON == navtrig_flag) || (PSD_ON == navgate_flag)) &&
         (!lava_flag && !medal_flag && !ifir_flag && !de3d_flag) && (PSD_ON == _opnecho.fixedflag)) {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "Navigator" );
        return FAILURE;
    }

    if( (Absent == BODYNAVKey) && ((PSD_ON == navtrig_flag) || (PSD_ON == navgate_flag)) && (PSD_OFF == exist(opcgate)))
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "Body Navigator");
        return FAILURE;
    }

    if (!UnLocked && (exist(opspecir) == PSD_ON))
    {
        epic_error( use_ermes, "%s is not available without proper option keys.", EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "SPECIAL");
        return FAILURE;
    }

    /*MRIhc33972, UltraFast Option Key check, ZZ*/
    if( (Absent == UltraFastKey) && (exist(opuser6) == 2) )
    {
        epic_error(use_ermes, "%s is not available without the option key.",
                   EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "UltraFast Mode");
        return FAILURE;
    }

@inline Disco.e DiscoCheck

    /* SVBranch, DISCO is not in SV25.0 scope. Pop up an message if it is selected */
    if ( disco_flag && (VALUE_SYSTEM_SVEM == value_system_flag || VALUE_SYSTEM_SVDM == value_system_flag) )
    {
        epic_error(use_ermes, "%s is incompatible with %s",EM_PSD_INCOMPATIBLE,EE_ARGS(2),
                       STRING_ARG, "DISCO", STRING_ARG, "this system");
        return ADVISORY_FAILURE;
    }

    /* Added backward compatibility - latha@mr */
    if (UnLocked)
    {
        char tmp_error_str[80];
        /* MRIhc20325 Remove UserCV for Multi Station on DVMR or forward only */
        /* Check for Number of Stations User CV */
        /* SVBranch, HCSDM00094105 */
        if( ( !wfmMultistationFlag && exist(opmultistation) ) && (!lava_flag))
        {
            if( existcv(opuser0) &&
                ((_opuser0.minval > exist(opuser0)) ||
                 (_opuser0.maxval < exist(opuser0))) )
            {
                /* Set "good" default value */
                cvoverride(opuser0, (float)opnostations, PSD_FIX_ON, PSD_EXIST_ON);

                /* Display an error message */
                epic_error( use_ermes ,"%s is out of range.",
                            EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1),
                            STRING_ARG, "Number of Stations" );
                return FAILURE;
            }
        }
        else if( (lava_flag) && (specir_flag) && (elava_flag) ) /* SVBranch, HCSDM00094105 For lava sequence, CV0 is used to control elava */
        {
            if( existcv(opuser0) &&(_opuser0.minval != exist(opuser0) && (_opuser0.maxval != exist(opuser0))) )
            {
                cvoverride(opuser0, 0, PSD_FIX_OFF, PSD_EXIST_OFF);
                epic_error( use_ermes ,"%s only support 0 and 1.",EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1),STRING_ARG, "elava flag" );
                return FAILURE;
            }
        }

        if( existcv(opuser1) &&
            ((_opuser1.minval > exist(opuser1)) ||
             (_opuser1.maxval < exist(opuser1))) )
        {
            /* Set "good" default value */
            cvoverride(opuser1, _opuser1.defval, PSD_FIX_ON, PSD_EXIST_ON);

            if( (PSD_ON == ssfp_flag) && (pcfiesta_flag == PSD_ON) && value_system_flag ) {
                sprintf(tmp_error_str,"Processing");
            } else if ( (PSD_ON == exist(oplava)) &&
                        (exist(opnex) > 1) && (PSD_OFF == exist(opnav)) && !disco_flag) {
                sprintf(tmp_error_str,"NEX Mode");
            } else if( heart3d_flag && irprep_flag &&
                       ((B0_30000==(int)cffield) || exist(opresearch)) ) {
                sprintf(tmp_error_str,"IR prep pulse type");
            } else {
                sprintf(tmp_error_str,"User CV variable 1");
            }

            /* Display an error message */
            epic_error( use_ermes ,"%s is out of range.",
                        EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1),
                        STRING_ARG, tmp_error_str);
            return FAILURE;
        }

        if( existcv(opuser3) &&
            ((_opuser3.minval > exist(opuser3)) ||
             (_opuser3.maxval < exist(opuser3))) )
        {
            /* Set "good" default value */
            cvoverride(opuser3, _opuser3.defval, PSD_FIX_ON, PSD_EXIST_ON);

            /* Display an error message */
            epic_error( use_ermes ,"%s is out of range.",
                        EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1),
                        STRING_ARG, "Arrhythmia Check" );
            return FAILURE;
        }

 
        if( existcv(opuser5) &&
            ((_opuser5.minval > exist(opuser5)) ||
             (_opuser5.maxval < exist(opuser5))) )
        {
            /* Set "good" default value */
            cvoverride(opuser5, _opuser5.defval, PSD_FIX_ON, PSD_EXIST_ON);

            if ((PSD_ON == ssfp_flag) && (PSD_ON == pcfiesta_flag))
            {
                sprintf(tmp_error_str,"Fiesta-C RF1 Type");
            }
            else if (turbo_cemra_enable)
            {
                sprintf(tmp_error_str,"Turbo Mode");
            }
            else if (cine3d_flag && ((INT)arr_check == PSD_ON))
            {
                sprintf(tmp_error_str,"Scan Abort Threshold");
            }
            else
            {
                sprintf(tmp_error_str,"userCV5");
            }

            /* Display an error message */
            epic_error( use_ermes ,"%s is out of range.",
                        EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1),
                        STRING_ARG, tmp_error_str );
            return FAILURE;
        }       
        
        /* Check for Turbo Mode User CV */
        if( existcv(opuser6) &&
            ((_opuser6.minval > exist(opuser6)) ||
             (_opuser6.maxval < exist(opuser6))) )
        {
            /* Set "good" default value */
            cvoverride(opuser6, _opuser6.defval, PSD_FIX_ON, PSD_EXIST_ON);

            /* Display an error message  */
            epic_error( use_ermes, "%s must be set to either 0 or 1.",
                        EM_PSD_CV_0_OR_1, EE_ARGS(1), STRING_ARG, "Turbo Mode" );
            return FAILURE;
        }

        if( existcv(opuser7) &&
            ((_opuser7.minval > exist(opuser7)) ||
             (_opuser7.maxval < exist(opuser7))) )
        {
            /* Set "good" default value */
            cvoverride(opuser7, _opuser7.defval, PSD_FIX_ON, PSD_EXIST_ON);

            if (heart3d_flag)
            {
                sprintf(tmp_error_str,"Navigator Guided Slab Tracking");
            } else if (arc_research_flag) {
                sprintf(tmp_error_str,"Maximum ARC Phase X factor");
            } else {
                sprintf(tmp_error_str,"userCV7");
            }

            /* Display an error message */
            epic_error( use_ermes, "%s is out of range.",
                        EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, tmp_error_str);
            return FAILURE;
        }

        if( existcv(opuser8) &&
            ((_opuser8.minval > exist(opuser8)) ||
             (_opuser8.maxval < exist(opuser8))) )
        {
            cvoverride(opuser8, _opuser8.defval, PSD_FIX_ON, PSD_EXIST_ON);

            if (heart3d_flag && (!irprep_flag) && (B0_15000 == (int)cffield))
            {
                sprintf(tmp_error_str,"Navigator excitation method");
            } else if (arc_research_flag) {
                sprintf(tmp_error_str,"Maximum ARC Slice X factor");
            } else {
                sprintf(tmp_error_str,"userCV8");
            }

            /* Display an error message */
            epic_error( use_ermes, "%s is out of range.",
                        EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, tmp_error_str );
            return FAILURE;
        }

        if( existcv(opuser9) &&
            ((_opuser9.minval > exist(opuser9)) ||
             (_opuser9.maxval < exist(opuser9))) )
        {
            cvoverride(opuser9, _opuser9.defval, PSD_FIX_ON, PSD_EXIST_ON);

            if (heart3d_flag)
            {
                sprintf(tmp_error_str,"Navigator signal normalization flag");
            } else if (arc_research_flag) {
                sprintf(tmp_error_str,"Minimum ARC Phase overscans");
            } else {
                sprintf(tmp_error_str,"userCV9");
            }

            /* Display an error message */
            epic_error( use_ermes, "%s is out of range.",
                        EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, tmp_error_str);
            return FAILURE;
        }

        if( existcv(opuser10) &&
            ((_opuser10.minval > exist(opuser10)) ||
             (_opuser10.maxval < exist(opuser10))) )
        {
            cvoverride(opuser10, _opuser10.defval, PSD_FIX_ON, PSD_EXIST_ON);

            /* Display an error message */
            epic_error( use_ermes, "%s is out of range.",
                        EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "Minimum ARC Slice overscans");
            return FAILURE;
        }

        /* Check for Reverse Elliptric Centric User CV */
        if( existcv(opuser11) &&
            ((_opuser11.minval > exist(opuser11)) ||
             (_opuser11.maxval < exist(opuser11))) )
        {
            /* Set "good" default value */
            cvoverride(opuser11, _opuser11.defval, PSD_FIX_ON, PSD_EXIST_ON);

            /* Display an error message */
            if ( !disco_flag )
            {
                epic_error( use_ermes, "%s must be set to either 0 or 1.",
                            EM_PSD_CV_0_OR_1, EE_ARGS(1), STRING_ARG, "Reverse Ellip. Centric" );
            }
            else
            {
                epic_error( use_ermes, "%s must be set to 0-2.",
                            EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "Temporal acceleration" );
            }
            return FAILURE;
        }

        /* Check for Elliptric Centric User CV */
        if( existcv(opuser12) &&
            ((_opuser12.minval > exist(opuser12)) ||
             (_opuser12.maxval < exist(opuser12))) )
        {
            /* Set "good" default value */
            cvoverride(opuser12, _opuser12.defval, PSD_FIX_ON, PSD_EXIST_ON);

            /* Display an error message */
            if ( !disco_flag )
            {
                epic_error( use_ermes, "%s must be set to 0-2.",
                            EM_PSD_CV_0_OR_1, EE_ARGS(1), STRING_ARG, "Ellip. Centric" );
            }
            else
            {
                epic_error( use_ermes, "%s is out of range.",
                            EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "A region fraction" );     
            }    
            return FAILURE;
        }

        /* Check for Centric User CV */
        if( existcv(opuser13) &&
            ((_opuser13.minval > exist(opuser13)) ||
             (_opuser13.maxval < exist(opuser13))) )
        {
            /* Set "good" default value */
            cvoverride(opuser13, _opuser13.defval, PSD_FIX_ON, PSD_EXIST_ON);

            /* Display an error message */
            if ( !disco_flag )
            {
                epic_error( use_ermes, "%s must be set to either 0 or 1.",
                            EM_PSD_CV_0_OR_1, EE_ARGS(1), STRING_ARG, "Centric" );
            }
            else
            {
                epic_error( use_ermes, "%s is out of range.",
                            EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "Number of B regions" );   
            }      
            return FAILURE;
        }

        /* Check for Reverse Centric User CV */
        if( existcv(opuser14) &&
            ((_opuser14.minval > exist(opuser14)) ||
             (_opuser14.maxval < exist(opuser14))) )
        {
            /* Set "good" default value */
            cvoverride(opuser14, _opuser14.defval, PSD_FIX_ON, PSD_EXIST_ON);

            /* Display an error message */
             if ( !disco_flag )
             {
                 epic_error( use_ermes, "%s must be set to either 0 or 1.",
                             EM_PSD_CV_0_OR_1, EE_ARGS(1), STRING_ARG, "Reverse Centric" );
             }
             else
             {
                 epic_error( use_ermes, "%s is out of range.",
                             EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "View sharing" );  
             }         
            return FAILURE;
        }

        if( existcv(opuser16) &&
            ((_opuser16.minval > exist(opuser16)) ||
             (_opuser16.maxval < exist(opuser16))) )
        {
            /* Set "good" default value */
            cvoverride(opuser16, _opuser16.defval, PSD_FIX_ON, PSD_EXIST_ON);

            /* Display an error message */
            if(pcfiesta_flag)
            {
                epic_error( use_ermes, "%s is out of range.",
                            EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "Slices to discard" );
            }
            else  if ((multiEcho_flag) && (!idealiq_flag) )
            {
                epic_error( use_ermes, "%s must be set to either 0 or 1.",
                            EM_PSD_CV_0_OR_1, EE_ARGS(1), STRING_ARG, "Uni-polar echoes" );
            }
            else if (swan_flag)
            {
                epic_error( use_ermes, "%s is out of range.",
                            EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "Swan 1st TE " );

            }
            else if (medal_flag && (arc_research_flag || (PSD_ON == exist(opresearch)) || (PSD_ON == exist(opvibrant)) || (PSD_ON == exist(oplava)) || (PSD_ON == exist(opdisco))))
            {
                epic_error( use_ermes, "%s must be set to either 0 or 1.",
                            EM_PSD_CV_0_OR_1, EE_ARGS(1), STRING_ARG, "Multiple TR Acquisition Option" );
            }
            else if (cine3d_flag)
            {
                epic_error( use_ermes, "%s is out of range.",
                            EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "Respiratory Percent" );

            }
            else  /* we should not be here */
            { 
                epic_error( use_ermes, "%s is out of range.",
                            EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "USER CV 16"  );
            }
            return FAILURE;
        }   /* opuser16 range check */

        /* MRIhc20325 Remove UserCV for Multi Station on DVMR or forward only */
        if ( !wfmMultistationFlag )
        {
            /* Check for Mask Acquisition User CV */
            
            if( existcv(opuser17) &&
                ((_opuser17.minval > exist(opuser17)) ||
                 (_opuser17.maxval < exist(opuser17))) )
            {
                /* Set "good" default value */
                _opuser17.fixedflag = 0;
                if (maskv_loadprotocol_flag) {
                    opuser17 = (float) maskval;
                } else {
                    opuser17 = 0.0;
                }
                _opuser17.fixedflag = 1;

                /* Display an error message */
                epic_error( use_ermes, "%s must be set to either 0 or 1.",
                            EM_PSD_CV_0_OR_1, EE_ARGS(1), STRING_ARG, "Mask Acquisition" );
                return FAILURE;
            }

            /* Check for Venous Acquisition User CV */
            if( existcv(opuser18) &&
                ((_opuser18.minval > exist(opuser18)) ||
                 (_opuser18.maxval < exist(opuser18))) )
            {
                /* Set "good" default value */
                _opuser18.fixedflag = 0;
                if (maskv_loadprotocol_flag) {
                    opuser18 = (float) venousval;
                } else {
                    opuser18 = 0.0;
                }
                _opuser18.fixedflag = 1;
                
                /* Display an error message */
                epic_error( use_ermes, "%s must be set to either 0 or 1.",
                            EM_PSD_CV_0_OR_1, EE_ARGS(1), STRING_ARG, "Venous Acquisition" );
                return FAILURE;
            }
        }

        /* Check for Real-time SAT User CV */
        if( existcv(opuser19) &&
            ((_opuser19.minval > exist(opuser19)) ||
             (_opuser19.maxval < exist(opuser19))) )
        {
            /* Set "good" default value */
            cvoverride(opuser19, _opuser19.defval, PSD_FIX_ON, PSD_EXIST_ON);

            /* Display an error message */
            epic_error( use_ermes, "%s must be set to either 0-2.",
                        EM_PSD_CV_0_OR_1, EE_ARGS(1), STRING_ARG, "Real-time SAT" );
            return FAILURE;
        }

        if ( (_opuser21.minval > exist(opuser21)) ||
             (_opuser21.maxval < exist(opuser21)) )
        {
            /* SVBranch, Smart Burst Mode */
            if(ssfp_flag && sbm_flag)
            {
                cvoverride(opuser21, _opuser21.defval, PSD_FIX_ON, PSD_EXIST_ON);
                /* Display an error message */
                epic_error( use_ermes ,"%s is out of range.",
                            EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "Effect of TR reduction" );
                return FAILURE;
            }
            else
            {
                /* Set "good" default value */
                _opuser21.fixedflag = 0;
                opuser21 = 0.0;
                _opuser21.fixedflag = 1;

                /* Display an error message */
                epic_error( use_ermes, "%s must be set to either 0 or 1.",
                            EM_PSD_CV_0_OR_1, EE_ARGS(1), STRING_ARG, "Unrestricted real-time navigation" );
                return FAILURE;
            }
        }

        if( (exist(opuser22) != 1.0) && (exist(opuser22) != 0.0) )
        {
            /* Set a "good" default */
            cvoverride(opuser22, _opuser22.defval, PSD_FIX_ON, PSD_EXIST_ON);

            /* Display an error message */
            epic_error( use_ermes, "%s must be set to either 0 or 1.",
                        EM_PSD_CV_0_OR_1, EE_ARGS(1), STRING_ARG, "Classic Sequential Ordering" ); 
            return FAILURE;
        }

        /* MRIge91682 */
        if ( (_opuser23.minval > exist(opuser23)) ||
             (_opuser23.maxval < exist(opuser23)) )
        {
            cvoverride(opuser23, _opuser23.defval, PSD_FIX_ON, PSD_EXIST_ON);
            /* Display an error message */
            epic_error( use_ermes ,"%s is out of range.",
                        EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "Slice Resolution" );
            return FAILURE;
        }

        if ( (_opuser24.minval > exist(opuser24)) ||
             (_opuser24.maxval < exist(opuser24)) )
        {
            cvoverride(opuser24, _opuser24.defval, PSD_FIX_ON, PSD_EXIST_ON);
            /* Display an error message */
            /* SVBranch, Smart Burst Mode */
            if(sbm_flag)
            {
                epic_error( use_ermes, "%s must be set to 1-6.",
                            EM_PSD_CV_0_OR_1, EE_ARGS(1), STRING_ARG, "Smart burst mode" );
                return FAILURE;
            }
            else
            {
                epic_error( use_ermes, "%s must be set to 1-8.",
                            EM_PSD_CV_0_OR_1, EE_ARGS(1), STRING_ARG, "FATSAT Segments" );
                return FAILURE;
            }
        }

        /* HCSDM00339164 */
        if ( (_opuser25.minval > exist(opuser25)) ||
             (_opuser25.maxval < exist(opuser25)) )
        {
            cvoverride(opuser25, _opuser25.defval, PSD_FIX_ON, PSD_EXIST_ON);
            /* Display an error message */
            epic_error( use_ermes, "%s is out of range.",
                        EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "Annefact Reduction" );
            return FAILURE;
        }

        /* Check for MultiStation option activation */
        /* The series was saved, or was loaded from a protocol, and 
           The MultiStation Key is ON, and MultiStation Opt is OFF */
        /* MRIhc21005: Removed here for PSD Selection with Multi Station on DVMR or forward only */
        /* if ( (!firstSeriesFlag ||                    
              (PSD_ON == exist(oploadprotocol))) &&  
             pimultistation &&                       
             (exist(opmultistation) == PSD_OFF) )    
        {
            epic_error( use_ermes,
                        "MultiStation option should not be changed for this station",
                        EM_PSD_MULTISTATION_FIXED, EE_ARGS(0) );
            return FAILURE;
        } */

        if ( (pimultistation == PSD_OFF) &&          /* MultiStation Key is OFF, and */
             ( (exist(opmultistation) == PSD_ON) ||  /* MultiStation Opt is ON, or */
               (opnostations != 1) ) )               /* There is more than 1 station */
        {
            epic_error( use_ermes,
                        "MultiStation is not available without option key",
                        EM_PSD_MULTISTATION_OPTION_KEY, EE_ARGS(0) );
            return FAILURE;
        }
    }
    /* end backward compatibility */

    /* YMSmr07111  10/04/2005 YI  Added error check against floating number input. */
    {
        int err_usr_cvnum;
        int act_bit;

        /* SVBranch, Smart Burst Mode */
        if(sbm_flag)  /* use21 is used in SMB and it is float, disable error check here */
        {
            act_bit = (use3 + use5 + use7 + use8 + use11 + use13 + use14 + use17 + use18 + use20 + use22) & piuset;
        }
        else
        {
            act_bit = (use3 + use5 + use7 + use8 + use11 + use13 + use14 + use17 + use18 + use20 + use21 + use22) & piuset;
        }
        if ( disco_flag )
        {
            act_bit &= ~use13 & ~use14;
        }
        if(usercvintchk(act_bit,&err_usr_cvnum) == FAILURE){
            epic_error( use_ermes, "%s must be set to either 0 or 1.",
                        EM_PSD_CV_0_OR_1, EE_ARGS(1), STRING_ARG, "User CV" ); 
            return FAILURE;
        }

        act_bit = (use0 + use1 + use6 + use12 + use15 + use16 + use9 + use10 + use19 + use23 + use24) & piuset;
        if ( disco_flag )
        {
            act_bit &= ~use12;
            act_bit |= use13 | use14;
        }
        if(usercvintchk(act_bit,&err_usr_cvnum) == FAILURE){
            epic_error( use_ermes ,"%s is out of range.",
                        EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "User CV" );
            return FAILURE;
        }
    }

    /* MRIge84319: move NAV checks prior to VAST checks */
    if (FAILURE == Monitor_Cvcheck())
    {
        return FAILURE;
    }
    
    /*if(rhphasescale > 1.0)avmaxyres = exist(opxres);*/ /* YMSmr06736 05/11/2005 YI */ /* removed. YMSmr07181 */

    /** acquisition timing screen **/
    if ( (exist(opyres) > avmaxyres) || ((exist(opyres)*exist(opphasefov)) > avmaxyres) )
    {
        epic_error(use_ermes,"this YRES cannot be achieved with current prescription",
                   EM_PSD_YRES_OUT_OF_RANGE,1,INT_ARG,avmaxyres);
        return ADVISORY_FAILURE;
    }

    if((PSD_ON == isProtocolOptimizing()) && (PSD_ON == exist(oplava)) && (pircbnub > 0))
    {
        /* xRes should be multiples of 4 when Auto BW is supported */
        if (exist(opxres)%4 != 0) 
        {
            epic_error(use_ermes,"The nearest valid XRES value is %d.",
                       EM_PSD_XRES_ROUNDING,EE_ARGS(1),INT_ARG,
                       4*(int)((float)opxres/4.0 + 0.50));
            return ADVISORY_FAILURE; 
        } 
    }
    else
    {
        /* MRIhc13419 -- Following fractional decimation filters support only xRes in multiples of 4 */
        switch ((int) (100*echo1_rtfilt.decimation)) 
        {
            case 125: /* 200 kHz */
            case 175: /* 142.85 kHz */
            case 225: /* 111.11 kHz */
            case 275: /* 90.9 kHz */ 
                if (exist(opxres)%4 != 0) 
                {
                    epic_error(use_ermes,"The nearest valid XRES value is %d.",
                               EM_PSD_XRES_ROUNDING,EE_ARGS(1),INT_ARG,
                               4*(int)((float)opxres/4.0 + 0.50));
                    return ADVISORY_FAILURE; 
                } 
                break;
            default:
                break;
        }
    }

    if( arc_flag && ( exist(opyres) * exist(opphasefov) > ARC_YRES_MAX ) ) {
        epic_error( use_ermes, "YRES must be decreased to %d for the current phase FOV",
                    EM_PSD_YRES_OUT_OF_RANGE_PFOV, EE_ARGS(1), INT_ARG,
                    (int)(floorf(ARC_YRES_MAX/opphasefov/2.0)*2.0) );
        return ADVISORY_FAILURE;
    }

    if ((centric_flag+ellipt_flag+reverse_centric_flag+reverse_ellipt_flag)> 1) {
        epic_error(use_ermes, "%s is incompatible with %s.",
                   EM_PSD_INCOMPATIBLE,EE_ARGS(2),STRING_ARG, "The Selected View Ordering",
                   STRING_ARG,"each other.");
        return FAILURE;
    }

    if ((PSD_ON == extraspecial_flag) && (PSD_ON == pfkz_flag)) {
        epic_error(use_ermes, "%s is incompatible with %s.",
                   EM_PSD_INCOMPATIBLE,EE_ARGS(2),STRING_ARG, "Extra SPECIAL",
                   STRING_ARG,"partial kz");
        return FAILURE;
    }

    /* MRIge66079 - ATV: RTIA3D/ftMRA */
    if ((smartprep_flag == PSD_ON) && (ftmra_flag == PSD_ON) ) {
        epic_error(use_ermes, "%s is incompatible with %s.",
                   EM_PSD_INCOMPATIBLE,EE_ARGS(2),STRING_ARG, "SmartPrep",
                   STRING_ARG,"Fluoro Trigger Imaging Option");
        return FAILURE;
    }

    if( arc_flag && (arc_sl_stride > 1.0) && (opslquant < arc_sl_calwidth) ) {
        epic_error( use_ermes, "The number of scan locations selected must "
                    "be increased to %d for the current prescription.",
                    EM_PSD_SLQUANT_OUT_OF_RANGE2, EE_ARGS(1),
                    INT_ARG, (arc_sl_calwidth - (2 * opslblank)) );
        return ADVISORY_FAILURE;
    }
    
    if ( vibrantxv_flag && (BREAST2Key != Present)) 
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                  EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "VIBRANT-XV");
        return FAILURE;
    }
    
    if ( vibrantxv_flag && (B0_30000 != (int)cffield) ) 
    {
        epic_error( use_ermes, "%s is incompatible with %s.",
                    EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                    STRING_ARG, "VIBRANT and ARC",
                    STRING_ARG, "1.5T systems" );
        return FAILURE;
    }

    if ( vibrantxv_flag && (opplane != PSD_AXIAL) ) 
    {
        epic_error( use_ermes, "%s is incompatible with %s.",
                    EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                    STRING_ARG, "VIBRANT and ARC",
                    STRING_ARG, "Sagittal or Coronal planes" );
        return FAILURE;
    }

    /*
     * Checks with number of slices
     */
    if( existcv(opslquant) ) {

@inline cal3d.e cal3d_cvcheck_slquant

        /*  MRIhc13407 - Front end check for MPH and Dynaplan */
        {
            int slice_limit; /* Without ZIP since max_bamslice already accounts for ZIP */

            /* MRIge92209 */
            /* MRIhc35530*/
            slice_limit = exist(opslquant);

            if( max_bamslice < slice_limit ) {
                if ( (exist(opvibrant) == PSD_ON) && (PSD_OFF == exist(opmedal)) && ((exist(opasset) == 2) || (exist(opasset) == 3))
                     && ((exist(opslzip2) == PSD_ON) || (exist(opslzip4) == PSD_ON)) ) {
                    epic_error( use_ermes, "Not enough memory. Turn off ZIP2 or ZIP4"
                                , EM_PSD_SLICE_ZIP_NO_MEMORY, EE_ARGS(0) );
                    return FAILURE;

                } else {
                        epic_error( use_ermes, "Not enough memory for a scan this size.  "
                                    "Reduce the scan size.", EM_PSD_SCAN_SIZE, EE_ARGS(0) );
                        return FAILURE;
                }
            }
        }

       	if( ((ellipt_flag == 1) || (reverse_ellipt_flag == 1)) && 
            ((exist(opslquant) * (rhnframes + rhhnover)) > ELLIPT_CEN_MAX) ) {
            epic_error( use_ermes, "Maximum number of phases exceeded, reduce "
                        "# of slices or phases", EM_PSD_MAXPHASE_EXCEEDED,
                       	EE_ARGS(0) );
            return FAILURE;
       	}

        if( pimultislab == PSD_OFF && exist(opcgate) == PSD_OFF ) {
            if( existcv(opsllocs) && (exist(opsllocs) < min_slquant - DISCARDSLICE) ) {
                epic_error( use_ermes, "The number of scan locations selected "
                            "must be increased to %d for the current prescription.",
                            EM_PSD_SLQUANT_OUT_OF_RANGE2, EE_ARGS(1),
                            INT_ARG, avminslquant );
                return ADVISORY_FAILURE;
            }

            if( existcv(opsllocs) && (exist(opsllocs) > max_slquant - DISCARDSLICE) ) {
                epic_error( use_ermes, "The number of scan locations selected "
                            "must be reduced to %d for the current prescription.",
                            EM_PSD_SLQUANT_OUT_OF_RANGE, EE_ARGS(1),
                            INT_ARG, avmaxslquant - DISCARDSLICE );
                return FAILURE;
            }
        }

        if( exist(opslquant) < min_slquant ) {
            epic_error( use_ermes, "The number of scan locations selected "
                        "must be increased to %d for the current prescription.",
                        EM_PSD_SLQUANT_OUT_OF_RANGE2, EE_ARGS(1),
                        INT_ARG, avminslquant );
            return ADVISORY_FAILURE;
        }

        if( exist(opslquant) > max_slquant ) {
            epic_error( use_ermes, "The number of scan locations selected "
                        "must be reduced to %d for the current prescription.",
                        EM_PSD_SLQUANT_OUT_OF_RANGE, EE_ARGS(1),
                        INT_ARG, avmaxslquant );
            return FAILURE;
        }

        if( ( MAXVTHICK < exist(opvthick) ) ||
            ( osfp_flag && ( (OSFP_MAX_VTHICK+((float)DISCARDSLICE*exist(opslthick))+0.01) < exist(opvthick) ) ) ) {
            epic_error( use_ermes, "Reduce the number of locs/slab"
                        "or reduce the slice thickness.",
                        EM_PSD_VTHICK_OUT_OF_RANGE, EE_ARGS(0) );
            return FAILURE;
        }

        if( PSD_OFF == extraspecial_flag ) { 
            if( ( (int) (equant) % slq_shots) != 0 ) {
                epic_error( use_ermes, "No. of slices must be %d or %d for slice "
                            "order chosen.", EM_PSD_SLQUANT_VALUE, EE_ARGS(2),
                            INT_ARG, slq_shots * (int)(equant / slq_shots),
                            INT_ARG, slq_shots * (int)(equant / slq_shots + 1) );
                return FAILURE;
            }
        } 

        /* MRIge81888 -  Number locs/slab for slice ASSET should be divisible by four */  
        if(assetsl_flag == PSD_ON) {
            if( (opslquant % 4) != 0 ) {
                epic_error( use_ermes, "Number of slices must be %d or %d for ASSET "
                            , EM_PSD_SLQUANT_VALUE_ASSET, EE_ARGS(2),
                            INT_ARG, 2 * equant,
                            INT_ARG, 2 * (equant - 2));
                return FAILURE;
            }
        }

        if(arc_flag && (lava_flag || brava_flag) && (0 != (sampledPoints%pfkz_total)) && (PSD_OFF == pfkr_yz_flag) && !disco_flag)
        {
            epic_error(use_ermes, "The number of slices has to be increased to %d for this prescription.",
                       EM_PSD_GEM_SLQUANT_OUT_OF_RANGE, EE_ARGS(1), INT_ARG, exist(opslquant)+2);
            return FAILURE;
        }

        /* the maximum number of scan locations per series is SLTAB_MAX,
           including overlap and kissoff slices. */
        if( (exist(opslquant) * slicezp * exist(opvquant)) > SLTAB_MAX ) {
            epic_error( use_ermes, "The number of scan locations selected "
                        "must be reduced to %d for the current prescription.",
                        EM_PSD_SLQUANT_OUT_OF_RANGE, EE_ARGS(1),
                        INT_ARG, (INT)((SLTAB_MAX / slicezp) - (2*opslblank)) );
            return FAILURE;
        }
        if ((slquant1 * slicezp) > MAX_SLICES_PER_PASS) { /* VAL15 2048slices  03/16/2005 YI */
            epic_error(use_ermes, 
                       "The no. of locations/acquisition cannot exceed the max no. of per acq = %d.",
                       EM_PSD_LOC_PER_ACQS_EXCEEDED_MAX_SL_PER_ACQ, EE_ARGS(1),
                       INT_ARG, (int)(MAX_SLICES_PER_PASS/slicezp));
            return FAILURE;
        }
        if (acqs > MAX_PASSES) { /* VAL15 2048slices  03/16/2005 YI */
            epic_error(use_ermes, 
                       "Maximum of %d acqs exceeded.  Increase locations/acq or decrease number of slices.",
                       EM_PSD_MAX_ACQS, EE_ARGS(1), INT_ARG, MAX_PASSES);
            return FAILURE;
        }
    }
    if ( arc_flag && (arc_sl_stride > avmaxaccel_sl_stride ) )  {  
        epic_error( use_ermes, "The slice acceleration must "
                    "be reduced to %0.2f for this prescription.",
                    EM_PSD_GEM_INVALID_ACCEL, EE_ARGS(1),
                    FLOAT_ARG, avmaxaccel_sl_stride);
        return ADVISORY_FAILURE;

    }

    if  ( arc_flag && (arc_ph_stride > avmaxaccel_ph_stride) )  {  
        epic_error( use_ermes, "The phase acceleration must "
                    "be reduced to %0.2f for this prescription.",
                    EM_PSD_GEM_INVALID_ACCEL, EE_ARGS(1),
                    FLOAT_ARG, avmaxaccel_ph_stride);
        return ADVISORY_FAILURE;
    }

   /* RBA - Per MRIhc18622, AssetCheck was not used, but using parts of
    * it. */

    if (assetph_flag && (exist(opaccel_ph_stride) != 1.0) && ((exist(opaccel_ph_stride) != 2.0)) &&
        existcv(opaccel_ph_stride) && (PSD_OFF != exist(opphaseimage)) && (PSD_ON == existcv(opphaseimage)))
    {
        avminaccel_ph_stride = 2.0;
        avmaxaccel_ph_stride = 2.0;
        epic_error( use_ermes, "The phase acceleration must "
                    "be reduced to %0.2f for this prescription.",
                    EM_PSD_GEM_INVALID_ACCEL, EE_ARGS(1),
                    FLOAT_ARG, avmaxaccel_ph_stride);
        return ADVISORY_FAILURE;
    }

    if( assetph_flag && (exist(opaccel_ph_stride) > avmaxaccel_ph_stride) && existcv(opaccel_ph_stride) ) {
        epic_error( use_ermes, "The phase acceleration must "
                    "be reduced to %0.2f for this prescription.",
                    EM_PSD_GEM_INVALID_ACCEL, EE_ARGS(1),
                    FLOAT_ARG, avmaxaccel_ph_stride);
                
        return ADVISORY_FAILURE;
    }
    if( assetsl_flag && (exist(opaccel_sl_stride) > avmaxaccel_sl_stride) && existcv(opaccel_sl_stride) ) {
        epic_error( use_ermes, "The Slice acceleration must "
                    "be reduced to %0.2f for this prescription.",
                    EM_PSD_GEM_INVALID_ACCEL, EE_ARGS(1),
                    FLOAT_ARG, avmaxaccel_sl_stride);
        return ADVISORY_FAILURE;
    }

    /*
      if( (rhnslices * slicezp) > DATA_ACQ_MAX*SLICE_FACTOR )
    */
    if( (exist(opfphases) ) > PHASES_MAX ) {

        epic_error(use_ermes, "Number of phases is out of range", 
                   EM_PSD_CV_OUT_OF_RANGE,EE_ARGS(1),STRING_ARG,"Number of phases");
        return FAILURE;
    }

    if (disco_flag && existcv(opdynaplan_nphases) && existcv(opvsphases) &&
            ((avminvsphases > exist(opvsphases)) || (avmaxvsphases < exist(opvsphases))) )
    {
        epic_error(use_ermes, "Number of wash-in phases is out of range",
                   EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "Number of wash-in phases");
        return FAILURE;
    }

    if( (rhnslices * slicezp) > max_slice_limit ) {
        
        if( enable_1024 )
            epic_error(use_ermes, "The number of locations * phases has exceeded %d.", 
                       EM_PSD_SLCPHA_OUT_OF_RANGE ,EE_ARGS(1),INT_ARG,max_slice_limit);
        else
            epic_error(use_ermes, "Maximum number of images exceeded (1024 images/scan).", 
                       EM_PSD_MAX_1024_IMAGES_PER_SCAN,EE_ARGS(0));

        return FAILURE;
    }

    /* added backward compatibility  - latha@mr */
    if( !UnLocked ) {
        if( existcv(opvquant) && (exist(opvquant) > 1) ) {
            epic_error( use_ermes, "%s does not support multi-slab acquisitions.",
                        EM_PSD_NO_MULTI_SLAB, EE_ARGS(1), STRING_ARG, "FGRE 3D" );
            return FAILURE;
        }
    }

    if( ( (PSD_ON == exist(opmedal)) || ideal_flag || disco_flag ||
         (idealiq_flag && ((PSD_OFF == exist(opresearch)) || (strncmp("idealiq_mslab",psd_name,13)))) )
            && (existcv(opvquant) && (exist(opvquant) > 1)) ) 
    {
        if (PSD_ON == exist(opdisco))
        {
            epic_error( use_ermes, "%s does not support multi-slab acquisitions.",
                        EM_PSD_NO_MULTI_SLAB, EE_ARGS(1), STRING_ARG, "DISCO" );
            return FAILURE;
        } 
        else if (PSD_ON == exist(oplava))
        {
            epic_error( use_ermes, "%s does not support multi-slab acquisitions.",
                        EM_PSD_NO_MULTI_SLAB, EE_ARGS(1), STRING_ARG, "LAVA-Flex" );
            return FAILURE;
        }
        else if (PSD_ON == exist(opvibrant))
        {
            epic_error( use_ermes, "%s does not support multi-slab acquisitions.",
                        EM_PSD_NO_MULTI_SLAB, EE_ARGS(1), STRING_ARG, "VIBRANT-Flex" );
            return FAILURE;
        }
        else if (PSD_ON == exist(opmedal))
        {
            epic_error( use_ermes, "%s does not support multi-slab acquisitions.",
                        EM_PSD_NO_MULTI_SLAB, EE_ARGS(1), STRING_ARG, "FLEX Apps" );
            return FAILURE;
        }
        else if (idealiq_flag)
        {
            epic_error( use_ermes, "%s does not support multi-slab acquisitions.",
                        EM_PSD_NO_MULTI_SLAB, EE_ARGS(1), STRING_ARG, "IDEAL IQ" );
            return FAILURE;
        }
        else
        {
            epic_error( use_ermes, "%s does not support multi-slab acquisitions.",
                        EM_PSD_NO_MULTI_SLAB, EE_ARGS(1), STRING_ARG, "IDEAL" );
            return FAILURE;
        }
    }

    if ( ( (ellipt_flag==1) || (reverse_ellipt_flag==1) ) && 
         (equant*(rhnframes+rhhnover) > ELLIPT_CEN_MAX)) {
        epic_error(use_ermes,"Maximum number of phases exceeded, reduce # of slices or phases",
                   EM_PSD_MAXPHASE_EXCEEDED,EE_ARGS(0));
        return FAILURE;
    }

    if (ellipt_flag==1 && specir_flag==1) {
        epic_error(use_ermes, 
                   "%s is incompatible with %s.",
                   EM_PSD_INCOMPATIBLE,EE_ARGS(2),STRING_ARG, "SPECIAL",
                   STRING_ARG,"Elliptic Centric View Ordering");
        return FAILURE;
    }

    if (reverse_ellipt_flag==1 && specir_flag==1) {
        epic_error(use_ermes,
                   "%s is incompatible with %s.",
                   EM_PSD_INCOMPATIBLE,EE_ARGS(2),STRING_ARG, "SPECIAL",
                   STRING_ARG,"Reverse Elliptic Centric View Ordering");
        return FAILURE;
    }


    if (ellipt_flag==1 && irprep_flag==1) {
        epic_error(use_ermes, 
                   "%s is incompatible with %s.",
                   EM_PSD_INCOMPATIBLE,EE_ARGS(2),STRING_ARG, "IR PREP",
                   STRING_ARG,"Elliptic Centric View Ordering");
        return FAILURE;
    }

    if (reverse_ellipt_flag==1 && irprep_flag==1) {
        epic_error(use_ermes,
                   "%s is incompatible with %s.",
                   EM_PSD_INCOMPATIBLE,EE_ARGS(2),STRING_ARG, "IR PREP",
                   STRING_ARG,"Reverse Elliptic Centric View Ordering");
        return FAILURE;
    }

    if ((PSD_OFF != pfkr_yz_flag) && ((PSD_OFF != ellipt_flag) && !disco_flag))
    {
        epic_error(use_ermes,
                   "%s is incompatible with %s.",
                   EM_PSD_INCOMPATIBLE,EE_ARGS(2), STRING_ARG, "Turbo Mode",
                   STRING_ARG,"Elliptic Centric View Ordering");
        return FAILURE;
    }

    if ((PSD_OFF != pfkr_yz_flag) && (PSD_OFF == segmented_flag) && !disco_flag)
    {
        epic_error(use_ermes,
                   "%s is incompatible with %s.",
                   EM_PSD_INCOMPATIBLE,EE_ARGS(2), STRING_ARG, "Turbo Mode",
                   STRING_ARG,"segmented_flag OFF");
        return FAILURE;
    }

    /* MRIge66079 - ATV: RTIA3D/ftMRA */
    if (ellipt_flag == 1 && (exist(opsat) == PSD_ON) && (ftmra_flag == PSD_OFF) ) {
        epic_error(use_ermes, 
                   "%s is incompatible with %s.",
                   EM_PSD_INCOMPATIBLE,EE_ARGS(2),STRING_ARG, "SAT",
                   STRING_ARG,"Elliptic Centric View Ordering");
        return FAILURE;
    }
    if (reverse_ellipt_flag == 1 && (exist(opsat) == PSD_ON) && (ftmra_flag == PSD_OFF) ) {
        epic_error(use_ermes,
                   "%s is incompatible with %s.",
                   EM_PSD_INCOMPATIBLE,EE_ARGS(2),STRING_ARG, "SAT",
                   STRING_ARG,"Reverse Elliptic Centric View Ordering");
        return FAILURE;
    }
    /* The following cases are only to catch fat or water selection with ftMRA with ellipt 
       or reverse ellipt ordering - RJF */
    if ( (PSD_ON == ellipt_flag) && ( ( PSD_ON == fatFlag ) || (PSD_ON == exist(opwater)) ) ) {

        epic_error(use_ermes,
                   "%s is incompatible with %s.",
                   EM_PSD_INCOMPATIBLE,EE_ARGS(2),STRING_ARG, "Fat Suppression",
                   STRING_ARG,"Elliptic Centric View Ordering");
        return FAILURE;
    }
    if ( ( PSD_ON == reverse_ellipt_flag ) && ( ( PSD_ON == fatFlag ) || (PSD_ON == exist(opwater)) ) )  { 
        epic_error(use_ermes,
                   "%s is incompatible with %s.",
                   EM_PSD_INCOMPATIBLE,EE_ARGS(2),STRING_ARG, "SAT",
                   STRING_ARG,"Reverse Elliptic Centric View Ordering");
        return FAILURE;
    }
    /* End RTIA3D/ftMRA */

    if( PSD_ON == turbo_cemra_flag ) {
        if ( PSD_ON == fatFlag ) {
            epic_error(use_ermes,
                       "%s is incompatible with %s.",
                       EM_PSD_INCOMPATIBLE,EE_ARGS(2),STRING_ARG, "Fat Suppression",
                       STRING_ARG,"Turbo Mode");
            return FAILURE;
        }

        if ( PSD_ON == exist(opwater) ) {
            epic_error(use_ermes,
                       "%s is incompatible with %s.",
                       EM_PSD_INCOMPATIBLE,EE_ARGS(2),STRING_ARG, "Water Suppression",
                       STRING_ARG,"Turbo Mode");
            return FAILURE;
        }
    }

    if( ssfp_flag == PSD_ON ) {
        if( (exist(oppseq) == PSD_SPGR) || (exist(oppseq) == PSD_TOFSP) || (exist(oppseq) == PSD_TOF) ) {
            epic_error( use_ermes,
                        "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "This type of pulse sequence",
                        STRING_ARG, "FIESTA Mode" );
            return FAILURE;
        }

        if( PSD_ON == smartprep_flag ) {
            epic_error( use_ermes,
                        "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "SmartPrep",
                        STRING_ARG, "FIESTA Mode");
            return FAILURE;
        }

        if( (PSD_ON == vast_mode) && (PSD_ON == exist(oprtcgate) && (!ifir_flag)) ) {
            epic_error( use_ermes,
                        "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Fat SAT FIESTA",
                        STRING_ARG, "Respiratory Gating" );
            return FAILURE;
        }

        /* YMSmr07277  07/29/2005 YI  Fobade SAT to avoid banding images on FIESTA. */
        if(value_system_flag) {
            if(sp_sat && (!ifir_flag) && (!osfp_flag)) {
                epic_error( use_ermes,
                            "%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                            STRING_ARG, "SAT",
                            STRING_ARG, "FIESTA" );
                return FAILURE;
            }
        }
        /* YMSmr07347  07/29/2005 YI  Fobade Water SAT on FIESTA */
        if(value_system_flag || heart3d_flag) {
            if( exist(opwater) == PSD_ON ) {
                epic_error( use_ermes,
                            "%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                            STRING_ARG, "Water SAT",
                            STRING_ARG, "FIESTA" );
                return FAILURE;
            }
        }

        /* Consolidate incompatibility checks for Fiesta & Fiesta-C :AK */
        if( (PSD_OFF == pcfiesta_flag) && (PSD_OFF == osfp_flag) && (PSD_OFF == ifir_flag) ) {
            if (PSD_ON == irprep_flag) {
                epic_error( use_ermes,
                            "%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                            STRING_ARG, "IR PREP",
                            STRING_ARG, "FIESTA Mode" );
                return FAILURE;
            }

            if( existcv(opcgate) && (PSD_OFF == exist(opcgate)) ) {
                if ( exist(opfat) == PSD_ON ) {
                    if( PSD_OFF == allow_ugfsf ) {
                        epic_error( use_ermes,
                                    "%s is incompatible with %s.",
                                    EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                                    STRING_ARG, "FAT Suppression",
                                    STRING_ARG, "Ungated FIESTA" );
                    } else {
                        epic_error( use_ermes,
                                    "SPECIAL must be selected for FAT Suppression in 3D FIESTA.",
                                    EM_PSD_3DFIESTA_FATSAT, EE_ARGS(0) );
                    }
                    return FAILURE;
                }

                /* allow ungated FatSat FIESTA */
                if( (PSD_OFF == allow_ugfsf) && (!ifir_flag) ) {
                    if( PSD_ON == specir_flag ) {
                        epic_error( use_ermes,
                                    "%s is incompatible with %s.",
                                    EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                                    STRING_ARG, "SPECIAL",
                                    STRING_ARG, "Ungated FIESTA" );
                        return FAILURE;
                    }

                    if( exist(opsat) == PSD_ON ) {
                        epic_error( use_ermes,
                                    "%s is incompatible with %s.",
                                    EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                                    STRING_ARG, "SAT",
                                    STRING_ARG, "Ungated FIESTA" );
                        return FAILURE;
                    }
                } else {
                    if( (FSFiestaKey == Absent) && (PSD_ON == specir_flag) ) {
                        epic_error( use_ermes,
                                    "%s is not available without the option key.",
                                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1),
                                    STRING_ARG, "3D FATSAT FIESTA" );
                        return FAILURE;
                    }
                }

                if(ifir_flag && (exist(opwater) == PSD_ON)) {
                     epic_error( use_ermes,
                            "%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                            STRING_ARG, "Water Suppression",
                            STRING_ARG, "Inh-3DIFIR" );
                     return FAILURE;
                }

                /*
                 * Make sure that Ungated 3D FIESTA is NOT allowed when
                 * the fiesta3dfs option key is installed alone without the
                 * fiesta3d option key
                 */
                if( (Present == FSFiestaKey) && (Absent == FiestaKey) ) {
                    epic_error( use_ermes,
                                "%s is not available without the option key.",
                                EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1),
                                STRING_ARG, "Ungated FIESTA" );
                    return FAILURE;
                }
            } else if( exist(opcgate) == PSD_ON ) {
                if( exist(opfat) == PSD_ON )  {
                    epic_error( use_ermes,
                                "SPECIAL must be selected for FAT Suppression in 3D FIESTA.",
                                EM_PSD_3DFIESTA_FATSAT, EE_ARGS(0) );
                    return FAILURE;
                }

                if( (FSFiestaKey == Absent) && (PSD_ON == specir_flag) ) {
                    epic_error( use_ermes,
                                "%s is not available without the option key.",
                                EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1),
                                STRING_ARG, "3D FATSAT FIESTA" );
                    return FAILURE;
                }
            }
        } else if( (PSD_ON == pcfiesta_flag) && (PSD_OFF == osfp_flag) ) {
            /* HK - modified for MRIge85189 */
            if( irprep_flag == PSD_ON ) {
                epic_error( use_ermes,
                            "%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                            STRING_ARG, "IR PREP",
                            STRING_ARG, "FIESTA-C" );
                return FAILURE;
            }

            if( exist(opfat) == PSD_ON ) {
                epic_error( use_ermes,
                            "%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                            STRING_ARG, "FAT Suppression",
                            STRING_ARG, "FIESTA-C" );
                return FAILURE;
            }

            if( (PSD_ON == specir_flag) && !fs_pcfiesta_flag ) { /* HDsv 03/16/2009 YI */
                epic_error( use_ermes,
                            "%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                            STRING_ARG, "SPECIAL",
                            STRING_ARG, "FIESTA-C" );
                return FAILURE;
            }

            if( exist(opsat) == PSD_ON && !specir_flag ) { /* HDsv 03/16/2009 YI */
                epic_error( use_ermes,
                            "%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                            STRING_ARG, "SAT",
                            STRING_ARG, "FIESTA-C" );
                return FAILURE;
            }

            /* GEHmr02454  Support only APC with SPECIAL 09/25/2009 YI */
            if( (PSD_ON == specir_flag) && (pc_mode != PC_APC) ) {
                epic_error( use_ermes,
                            "%s needs to be selected with %s.",
                            EM_PSD_ONLY_COMPATIBLE, EE_ARGS(2),
                            STRING_ARG, "APC",
                            STRING_ARG, "SPECIAL" );
                return FAILURE;
            }

            /* MRIge94165 *//* FIESTA-C  06/10/2005 YI ; MRIhc10432 */
            if( (exist(opassetscan) == PSD_ON) && (!value_system_flag) ) {
                epic_error( use_ermes,
                            "%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                            STRING_ARG, "ASSET",
                            STRING_ARG, "FIESTA-C" );
                return FAILURE;
            }
        } else if((PSD_ON == osfp_flag) ) {

            if( exist(opwater) == PSD_ON ) {
                epic_error( use_ermes,
                            "%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                            STRING_ARG, "Water Suppression",
                            STRING_ARG, "COSMIC" );
                return FAILURE;
            }

        }
    }

    /* MRIhc16353 - RV: IDEAL change */
    if((PSD_ON == ideal_flag) || idealiq_flag)
    {
       if((exist(opfat)==PSD_ON)||(exist(opfatcl)==PSD_ON))
       {
          epic_error(use_ermes,"Fat Sat and IDEAL imaging option are incompatible.",
                     EM_PSD_OPFAT_INCOMPATABLE, EE_ARGS(0));
          return FAILURE;
       }

       if(exist(opwater)==PSD_ON)
       {
          epic_error(use_ermes,"Water Sat and IDEAL imaging option are incompatible.",
                     EM_PSD_OPWATER_INCOMPATABLE, EE_ARGS(0));
          return FAILURE;
       }

       if(exist(opspecir)==PSD_ON)
       {
          epic_error(use_ermes,"Special IR and IDEAL imaging option are incompatible.",
                     EM_PSD_IRPREP_SPECIR_INCOMPATIBLE, EE_ARGS(0));
          return FAILURE;
       }

       if((cffield < B0_15000)&&(cffield > B0_30000))
       {
          epic_error(use_ermes,"IDEAL imaging option is not available at this field strength.",
                     EM_PSD_INVALID_FIELD_STRENGTH, EE_ARGS(0));
          return FAILURE;
       }

       /* MRIhc37957 */
       if(irprep_flag && fn == 0.5)
       {
           if(spgr_flag) {
              epic_error(use_ermes, "%s is incompatible with %s", EM_PSD_INCOMPATIBLE,
                      EE_ARGS(2), STRING_ARG, "IDEAL", STRING_ARG, "Homodyne w IrP FSPGR");
              return FAILURE;
           } else {
              epic_error(use_ermes, "%s is incompatible with %s", EM_PSD_INCOMPATIBLE,
                      EE_ARGS(2), STRING_ARG, "IDEAL", STRING_ARG, "Homodyne w IrP FGRE");
              return FAILURE;
           }
       }
    }

    if(idealiq_flag)
    {
        if( existcv(opnshots) && existcv(opetl) && (exist(opnshots)*exist(opetl) > IDEALIQ_MAX_NECHO) )
        {
            epic_error( use_ermes, "The selected number of echoes must be decreased to %d for the current prescription.",
                        EM_PSD_NECHO_OUT_OF_RANGE, EE_ARGS(1), 
                        INT_ARG, IDEALIQ_MAX_NECHO );
            return FAILURE;
        }
        if( existcv(opnshots) && existcv(opetl) && (exist(opnshots)*exist(opetl)< IDEALIQ_MIN_NECHO) )
        {
            epic_error( use_ermes, "The selected number of echoes must be increased to %d for the current prescription.",
                        EM_PSD_MIN_NECHO_OUT_OF_RANGE, EE_ARGS(1), 
                        INT_ARG, IDEALIQ_MIN_NECHO );
            return FAILURE;
        }

        if( existcv(opetl) && (exist(opetl) <= 1) )
        {
            epic_error(use_ermes,"The prescribed echo train length is invalid.", EM_PSD_INVLD_ETL,
                     EE_ARGS(0));
            return FAILURE;
        }

        if( uniPolar_flag != PSD_ON ) 
        {   /* HCSDM00274558 */
            epic_error( use_ermes,
                        "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "IDEALIQ",
                        STRING_ARG, "Bipolar Readout" );
            return FAILURE;
        }

        if( existcv(opnshots) && existcv(opetl) && existcv(oprbw) && existcv(opfov) && existcv(opxres) )
        {
            if( idealiq_esp < idealiq_min_esp )
            {
                epic_error(use_ermes,"Echo spacing (%.3fms) is below lower limit (%.2fms). Increase XRes, decrease #shots or decrease RBW.",
                           EM_PSD_IDEALIQ_ESP_TOO_SHORT, EE_ARGS(2), FLOAT_ARG, (float)idealiq_esp/1ms, 
                           FLOAT_ARG, (float)idealiq_min_esp/1ms);
                return FAILURE;
            }

            if( idealiq_esp > idealiq_max_esp )
            {
                epic_error(use_ermes,"Echo spacing (%.3fms) exceeds upper limit (%.2fms). Reduce XRes, increase #shots or increase RBW.", 
                           EM_PSD_IDEALIQ_ESP_TOO_LONG, EE_ARGS(2), FLOAT_ARG, (float)idealiq_esp/1ms,
                           FLOAT_ARG, (float)idealiq_max_esp/1ms);
                return FAILURE;
            }
        }

        if( (rhdab0e == rhdab0s) && ((rhrcdixproc & DIXON_RC) == DIXON_RC) )
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), 
                        STRING_ARG, "Receiver combined image", STRING_ARG, "single coil" );
            return FAILURE;
        }

        if( (idealiq_pc_flag) && (pfkz_flag || (fn < 1)) )
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), 
                        STRING_ARG, "IDEAL IQ phase correction", STRING_ARG, "partial ky/kz acquisition" );
            return FAILURE;
        }

        if( (idealiq_pc_flag) && (idealiq_pc_zlines < IDEALIQ_PC_MIN_ZLINES) )
        {
            epic_error( use_ermes, "%s is out of range.",
                        EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "Number of reference lines along kz");
            return FAILURE;
        }
    }

#ifdef REMOVE
    if (existcv(opyres) && existcv(opxres) && (exist(opyres) > exist(opxres)) ) {
        epic_error(use_ermes, "yres too big.", EM_PSD_YRES_OUT_OF_RANGE,
                   1, INT_ARG, opxres);
        avmaxyres = exist(opxres);
        avmaxxres = exist(opyres);
        return ADVISORY_FAILURE;
    }
#endif

    /* YMSmr07181 */
    if( exist(opsquare)==PSD_ON  && existcv(opxres) && existcv(opyres) && (exist(opyres) > exist(opxres))) {
        epic_error(use_ermes, "This YRES cannot be achieved with current prescription",
                   EM_PSD_YRES_OUT_OF_RANGE, 1, INT_ARG, avmaxyres);
        avmaxyres = exist(opxres);
        return ADVISORY_FAILURE;
    }

    /*MRIhc02499*/
    if (existcv(opyres) && existcv(opslquant) && (opyres*opslquant>ELLIPT_CEN_MAX) ) {
        avmaxyres =(int)(ELLIPT_CEN_MAX/exist(opslquant));
        epic_error(use_ermes, "yres too big.", EM_PSD_YRES_OUT_OF_RANGE,
                   1, INT_ARG, avmaxyres);
        return ADVISORY_FAILURE;
    }


    /* Flag MT incompatibility-MRIge28286 */
    /* Removed &&(!UnLocked) to lock out MT unconditionally -JFS */
    if ((exist(opmt)==PSD_ON && existcv(opmt)==PSD_ON)) {
        epic_error(use_ermes,"MT not Supported",
                   EM_PSD_MT_INCOMPATIBLE,EE_ARGS(0));
        return FAILURE;
    }    

    /* MRIge44780 - added the following check */
    if ((exist(opccsat)==PSD_ON && existcv(opccsat)==PSD_ON)) {
        epic_error(use_ermes,
                   "Concat SAT is not Supported",
                   EM_PSD_CATSAT_INCOMPATIBLE,EE_ARGS(0));
        return FAILURE;
    }    

    if ((PSD_ON == exist(oplava)) && (exist(opnex) < 1))
    {
        epic_error( use_ermes, "The selected number of excitations is not valid for the current prescription.",
                    EM_PSD_NEX_OUT_OF_RANGE, EE_ARGS(0) );
        avminnex = 1.0;
        return ADVISORY_FAILURE;
    }

    if ((fn < 1) && (nex > 1) && existcv(opnex)) {
        epic_error(use_ermes,
                   "Fast Scan does not support multi-nex fractional nex scans.",
                   EM_PSD_FAST_MNFE_INCOMPATIBLE,0);
        /* 4/21/96 RJL - Event handler for this error to get choice into popup */
        avminnex = (float)((int)exist(opnex));
        avmaxnex = (float)((int)exist(opnex));
        return ADVISORY_FAILURE;
    }

    /* VAL15 12/14/2004 YI */
    if(pc_mode < PC_BASIC){
        if( (exist(opnopwrap)==PSD_OFF) && (exist(opnex) < 2) && existcv(opnex) ){
            epic_error( use_ermes, "The selected number of excitations is not valid for the current prescription.", EM_PSD_NEX_OUT_OF_RANGE, EE_ARGS(0) );
            avminnex = 2;
            return ADVISORY_FAILURE;
        }
        if( (exist(opnopwrap)==PSD_ON) && (exist(opnex) < 4) && existcv(opnex) && existcv(opnopwrap) ){
            epic_error( use_ermes, "The selected number of excitations is not valid for the current prescription.", EM_PSD_NEX_OUT_OF_RANGE, EE_ARGS(0) );
            avminnex = 4;
            return ADVISORY_FAILURE;
        }
        if( (exist(opnopwrap)==PSD_ON) && ((int)(exist(opnex)) % 2) && existcv(opnex) && existcv(opnopwrap) ) {
            epic_error( use_ermes, "This nex is not valid for No Phase Wrap.", EM_PSD_NPW_INCOMPATIBLE, EE_ARGS(0) );
            return FAILURE;
        }
    }

    if ((exist(opnex) == 1.5) && (exist(opnopwrap)==PSD_OFF) 
        && existcv(opnex) && existcv(opnopwrap)) {
        epic_error(use_ermes,"This Nex is only valid when No Phase Wrap is selected.",
                   EM_PSD_15NEX_INCOMPATIBLE,EE_ARGS(0));
        return FAILURE;
    }

    /* added backward compatibility - latha@mr */
    if (UnLocked) {
        if ( (exist(opxres) > avmaxxres) || (opxres > avmaxxres) ) {
             epic_error( use_ermes,
                         "The frequency encodings must be decreased "
                         "to %d for the current prescription.",
                         EM_PSD_XRES_OUT_OF_RANGE, EE_ARGS(1), INT_ARG, avmaxxres );
             return FAILURE;
        }

        if ( existcv(opxres) && ((exist(opxres) < avminxres)) ) {
             epic_error( use_ermes,
                         "The frequency encoding steps must be increased "
                         "to %d for the current prescription.",
                         EM_PSD_XRES_OUT_OF_RANGE2, EE_ARGS(1), INT_ARG, avminxres );
             return ADVISORY_FAILURE;
        }

        /* Flexible XRES/YRES */
        if ( ( exist(opxres) % 2 != 0 ) )  {
            if ( ((exist(opxres) & 0x1) >= 1 ) ) {
                avminxres = (( (exist(opxres) >> 1 ) << 1  ) + 2 ) ;
                return ADVISORY_FAILURE ;
            }

            if ( (exist(opxres) & 0x1) < 1 )  {
                avmaxxres =   ( (exist(opxres) >> 1 ) << 1 ) ;
                return ADVISORY_FAILURE ;
            }
        }

        if ( ( exist(opyres) % 2 != 0 ) )  {
            if ( ((exist(opyres) & 0x1) >= 1 ) ) {
                avminyres = ( ( (exist(opyres) >> 1) << 1 ) + 2 );
                return ADVISORY_FAILURE ;
            }

            if ( (exist(opyres) & 0x1) < 1 )  {
                avmaxyres =   ( (exist(opyres) >> 1 ) << 1 ) ;
                return ADVISORY_FAILURE ;
            }
        }
    }


    /* MRIge44882 - moved this portion of the code to cveval1()  - latha@mr */
    if ((exist(opslicecnt) > (acqs-1)) && existcv(opslicecnt)) {
        epic_error(use_ermes,"Number of ACQ_B4_Pause cannot exceed %-d",
                   EM_PSD_ACQS_B4_EXCEEDED,EE_ARGS(1),INT_ARG,(acqs-1));
        return FAILURE;
    }

    if ( existcv(opsldelay) && existcv(opslicecnt)
         && (exist(opsldelay) != avminsldelay)
         && (exist(opslicecnt) !=0) ) {
        epic_error(use_ermes, 
                   "Pause is not available with non-minimum delay between acqs.",
                   EM_PSD_PAUSE_DELAY_INCOMPATIBLE, EE_ARGS(0));  /* MRIge44882: Added 0 - latha@mr */
        return FAILURE;
    }

    /* Disable ART with dual echo */
    /* SVBranch: SV support ART on Dual Echo. Skip this check on value system */
    if( (PSD_ON == de3d_flag) && (PSD_ON == exist(opsilent)) && !((VALUE_SYSTEM_SVEM == value_system_flag) || (VALUE_SYSTEM_SVDM == value_system_flag)))
    {
        epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, 2, STRING_ARG, "ART", STRING_ARG, "dual echo" );
        return ADVISORY_FAILURE; 
    }

    if( (existcv(oprbw)) && (exist(oprbw) < avminrbw) ) {
        epic_error(use_ermes, "The minimum bandwidth is %4.2f KHz.",
                   EM_PSD_MIN_RBW, 1, FLOAT_ARG, avminrbw);
        return FAILURE;
    }

    if( (existcv(oprbw)) && (exist(oprbw) > avmaxrbw) ) {
        epic_error(use_ermes, "The maximum bandwidth is %4.2f KHz.",
                   EM_PSD_MAX_RBW, 1, FLOAT_ARG, avmaxrbw);
        return ADVISORY_FAILURE;  /* HCSDM00360543 */
    }

    /* FOV range check */
    if( existcv(opfov) ) {
        if( exist(opfov) < avminfov ) {
            if( ASSET_SCAN_PHASE == exist(opasset) ) {
                epic_error( use_ermes, "The FOV needs to be increased to "
                            "%3.1f cm for the current prescription, or Phase "
                            "FOV fraction can be increased.",
                            EM_PSD_FOV_OUT_OF_RANGE3, EE_ARGS(1),
                            FLOAT_ARG, avminfov / 10.0 );
            } else {
                epic_error( use_ermes, "The FOV needs to be increased to "
                            "%3.1f cm for the current prescription, or receive "
                            "bandwidth can be decreased.",
                            EM_PSD_FOV_OUT_OF_RANGE, EE_ARGS(1),
                            FLOAT_ARG, avminfov / 10.0 );
            }
            /*MRIhc19567*/
            return ADVISORY_FAILURE;
        }
        if( exist(opfov) > avmaxfov ) {
            epic_error( use_ermes, "The FOV needs to be decreased to "
                        "%3.1f cm for the current prescription.",
                        EM_PSD_FOV_OUT_OF_RANGE2, EE_ARGS(1),
                        FLOAT_ARG, avmaxfov / 10.0 );                                     
            return ADVISORY_FAILURE;                                                      
        }                                                                                 
        if( opphasefov > 1.0 ) {
            /* floating point ops do not provide exact number; hence a tolerance of
               0.1mm added to ensure that we do not reject cases FOV400 x phFOV1.2 =  480.00001 */
            if( ((exist(opfov) * opphasefov)  - avmaxfov) > 0.1 ) {
                epic_error( use_ermes, "The FOV needs to be decreased to "
                            "%3.1f cm for the current prescription.",
                            EM_PSD_FOV_OUT_OF_RANGE2, EE_ARGS(1),
                            FLOAT_ARG, floorf(avmaxfov/opphasefov) / 10.0 );
                return ADVISORY_FAILURE;
            }
        }
    }                                                                                    
    /*
     * MRIge51832 -  Find minimum slab thickness always, not only when
     * we suspect an invalid slthick entered. ampslice below calculates
     * the minslthick for the maximum target amplitude !  - latha@mr
     */
    ampslice(&av_temp_float, bw_rf1, (loggrd.tz_xyz), gscale_rf1,TYPDEF);

    /* Now, account for slab_fact and calculate min slice thickness
       for the Rx'ed number of slices */
    av_temp_float = av_temp_float * slab_fact * exist(opslquant) /
        IMax(2, 1, exist(opslquant) - 2*opslblank);
    av_temp_float = ceil((av_temp_float / exist(opslquant))*10.0)/10.0;
    avminslthick = av_temp_float;

    if( existcv(opslthick) && (exist(opslthick) < avminslthick) ) { 
        epic_error( use_ermes, "The Slice thickness must be increased to "
                    "%.2f mm for the current prescription.",
                    EM_PSD_SLTHICK_OUT_OF_RANGE, EE_ARGS(1),
                    FLOAT_ARG, avminslthick );
        avminslthick = av_temp_float;
        cvmin(opslthick,avminslthick);
        return ADVISORY_FAILURE;
    }

    /* On the image annotation, the location is specified to 0.1mm.  To ensure even spacing for
       IVI, we need the following check */
    /* added backward compatibility - latha@mr */

    if (((int)(10.0*opslthick + 0.5) % slicezp != 0) && 
        existcv(opslthick) && (exist(opslzip2)||exist(opslzip4)) && 
        (UnLocked )) {
        av_temp_float = (0.1*(float)slicezp)*(float)((int)((10.0/(float)slicezp)*(opslthick+0.05*(float)slicezp)+0.001));
        
        /* If the nearest slice thickness is out of range, round the
         * opposite direction. */
        if (av_temp_float < avminslthick)
        {
            av_temp_float += 0.1*(float)slicezp;
        }
        if (av_temp_float > avmaxslthick)
        {
            av_temp_float -= 0.1*(float)slicezp;
        }

        epic_error(use_ermes,
                   "The nearest allowed slice thickness with the selected slice ZIP factor is %.1f mm.",
                   EM_PSD_NEAREST_SL_THICK, EE_ARGS(1), FLOAT_ARG, av_temp_float);
        avmaxslthick = avminslthick = av_temp_float;
        return ADVISORY_FAILURE;
    }

    if( (PSD_OFF == tricks_flag) && existcv(opnecho) && (exist(opnecho) > avmaxnecho) ) {
        epic_error( use_ermes, "Maximum number of echos is %-d",
                    EM_PSD_NECHO_OUT_OF_RANGE, EE_ARGS(1), 
                    INT_ARG, avmaxnecho );
        return ADVISORY_FAILURE;
    }

    /*
     * Flip Angle checks
     */
    if (ifir_flag && ((exist(opflip) < avminflip) || (exist(opflip) > avmaxflip)) ) {
        epic_error( use_ermes, "The flip angle is out of range",
                    EM_PSD_OPFLIP_OUT_OF_RANGE, EE_ARGS(0) );
        return ADVISORY_FAILURE;
    } else if( (ssfp_flag == PSD_OFF) && ((exist(opflip) < avminflip) || (exist(opflip) > 60.0)) ) {
        /* note the maximum flip angle with the minimum phase pulse is 60 degrees */
        epic_error( use_ermes, "The flip angle is out of range",
                    EM_PSD_OPFLIP_OUT_OF_RANGE, EE_ARGS(0) );
        return ADVISORY_FAILURE;
    } else if( (ssfp_flag == PSD_ON) && (!ifir_flag) && 
               ((exist(opflip) < avminflip) || (exist(opflip) > 90.0)) ) {
        epic_error( use_ermes, "The flip angle is out of range",
                    EM_PSD_OPFLIP_OUT_OF_RANGE, EE_ARGS(0) );
        return ADVISORY_FAILURE;
    }

    /* BBA - Added flip angle check for improved SPECIAL */ 
    if( (extraspecial_flag == PSD_ON) && (exist(opflip) > 20.0) ) {
        epic_error( use_ermes, "The flip angle must be less than or equal to 20 degrees for SPECIAL.",
                    EM_PSD_OPFLIP_OUT_OF_RANGE_SPECIAL, EE_ARGS(0) );
        return ADVISORY_FAILURE;
    }

    /* YMSmr11783 - catch flip angle out of range for 3DDE */
    if( (de3d_flag == PSD_ON) && (opflip > avmaxflip) ) {

        /* turn on existflag to invoke advisory error */
        _opflip.existflag=PSD_ON;

        epic_error( use_ermes, "The flip angle must be less than or equal to 15 degrees for dual echo.",
                    EM_PSD_OPFLIP_OUT_OF_RANGE, EE_ARGS(0) );
        return ADVISORY_FAILURE;
    }

    if( (PSD_ON == idealiq_flag) && ( (opflip > avmaxflip) || (opflip < avminflip) ) )
    {
        epic_error( use_ermes, "The flip angle is out of range",
                    EM_PSD_OPFLIP_OUT_OF_RANGE, EE_ARGS(0) );
        return ADVISORY_FAILURE;
    }

    if( existcv(opte) ) {
        if( exist(opte) < avminte ) {
            epic_error( use_ermes, "The selected TE must be increased "
                        "to %3.1f ms for the current prescription.",
                        EM_PSD_FLOAT_MINTE_OUT_OF_RANGE, EE_ARGS(1),
                        FLOAT_ARG, ((FLOAT)avminte / (FLOAT)1ms) );
            return ADVISORY_FAILURE;
        }

        if( (exist(opte) > avmaxte) && !medal_flag ) {
            epic_error( use_ermes, "The selected TE must be decreased "
                        "to %3.1f ms for the current prescription.",
                        EM_PSD_FLOAT_MAXTE_OUT_OF_RANGE, EE_ARGS(1), 
                        FLOAT_ARG, ((FLOAT)avmaxte / (FLOAT)1ms) );
            return ADVISORY_FAILURE; 
        }
    }

    if( existcv(optr) ) {
        if( exist(optr) < avmintr ) {
            epic_error( use_ermes, "The selected TR needs to be increased "
                        "to %3.1f ms for the current prescription.",
                        EM_PSD_FLOAT_MINTR_OUT_OF_RANGE, EE_ARGS(1),
                        FLOAT_ARG, ((FLOAT)avmintr / (FLOAT)1ms) );
            return ADVISORY_FAILURE;
        }

        if( exist(optr) > avmaxtr ) {
            epic_error( use_ermes, "The selected TR needs to be decreased "
                        "to %3.1f ms for the current prescription.",
                        EM_PSD_FLOAT_MAXTR_OUT_OF_RANGE, EE_ARGS(1),
                        FLOAT_ARG, ((FLOAT)avmaxtr / (FLOAT)1ms) );
            return ADVISORY_FAILURE;
        }
    }

#ifdef UNDEF 
    if( ((exist(oppos) == 3) || (exist(oppos) == 4)) && (exist(opasset)) ) {
        epic_error( use_ermes,
                    "This patient position is not compatible with ASSET.",
                    EM_PSD_POSITION_ASSET_INCOMPATIBLE, EE_ARGS(0));
        return FAILURE;
    }

#endif

    /*
     * VIBRANT (BBA, Slice ASSET) checks
     */
    if( brava_flag || vibrant_flag ) {
        if( existcv(opplane) &&
            ( (exist(opplane) == PSD_COR) ||
              (exist(opplane) == PSD_OBL) ) ) {
            epic_error( use_ermes, "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "VIBRANT",
                        STRING_ARG, "this slab orientation" );
            return FAILURE;
        }
        if( ((PSD_ON == ssfp_flag) || (exist(oppseq) == PSD_TOF) ||
             (exist(oppseq) == PSD_TOFSP) || (PSD_ON == tricks_flag) ||
             (PSD_ON == pcfiesta_flag)) )  {
            epic_error( use_ermes,"%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "VIBRANT",
                        STRING_ARG, "this pulse sequence" );
            return FAILURE;
        }
    }
    /* MRIge82820 */

    /* MRIge83191 */
    if( (brava_flag || vibrant_flag) && 
        existcv(opvquant) && (exist(opvquant) != 1) ) {
        epic_error( use_ermes, "%s does not support multi slab acquisitions.",
                    EM_PSD_NO_MULTI_SLAB, EE_ARGS(1),
                    STRING_ARG, "VIBRANT" );
        return FAILURE;
    }

    /* YMSmr08268  12/02/2005 YI */
    if( (value_system_flag == VALUE_SYSTEM_HDE) && lava_flag &&
        existcv(opvquant) && (exist(opvquant) != 1) ) {

        epic_error( use_ermes, "%s does not support multi slab acquisitions.",
                    EM_PSD_NO_MULTI_SLAB, EE_ARGS(1),
                    STRING_ARG, "LAVA" );
        return FAILURE;
    }

    /* YMSmr08500  12/26/2005 YI */
    if( PSD_ON == exist (opassetscan) && (VALUE_SYSTEM_HDE == value_system_flag) && (exist(opaccel_ph_stride) > 2.0) && existcv(opaccel_ph_stride) ) {

        epic_error(use_ermes, "Phase Acceleration is out of range", 
                   EM_PSD_CV_OUT_OF_RANGE,EE_ARGS(1),STRING_ARG,"Phase Acceleration");
        return FAILURE;
    }        

    /* call the spatial sat checks unique to fgre3d again so the user is
       stopped on the scanning range page */
    if (saterr_f3d() == FAILURE) {
        return FAILURE;
    }

    if (ifir_flag)
    {
        float temp_vthick = IFIR_MAX_SLAB_VTHICK + DISCARDSLICE * exist(opslthick);

        if ((PSD_OFF == exist(oprtcgate)) && (PSD_OFF == navtrig_flag))
        {
            epic_error(use_ermes,"%s should be used with %s.",
                       EM_PSD_ONLY_COMPATIBLE, EE_ARGS(2),
                       STRING_ARG, "Inh-3DIFIR", STRING_ARG, "Respiratory triggering or Navigator");
            return FAILURE;
        }

        if ((existcv(oppseq) && (PSD_SSFP !=exist(oppseq))) || 
            (existcv(opphasecycle) && (PSD_ON==exist(opphasecycle))) ||
            (existcv(opcosmic) && (PSD_ON==exist(opcosmic))))
        {
            epic_error(use_ermes,"%s is incompatible with %s.",
                       EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                       STRING_ARG, "Inh-3DIFIR", STRING_ARG, "this mode");
            return FAILURE;
        }

        /* IFIR GRx */
        if (existcv(opplane) && (exist(opplane) != PSD_AXIAL) && (exist(opgirmode) == PSD_GIRAUTO))
        {
            epic_error( use_ermes,"%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Inh-3DIFIR",
                        STRING_ARG, "auto IR bands for non-axial scan" );
            return FAILURE;
        }
 
        if( (existcv(opslquant)) && (exist(opvthick) > temp_vthick) ) 
        {
             av_temp_int = floor(temp_vthick/exist(opslthick));
             av_temp_int -= av_temp_int % 2;
             if (av_temp_int > min_slquant)
             {  /* Reduce the number of slices */
                 avmaxslquant = av_temp_int - DISCARDSLICE;
                 if((VALUE_SYSTEM_SVEM == value_system_flag) || (VALUE_SYSTEM_SVDM == value_system_flag))
                 {
                     /* SVBranch HCSDM00114912, for ssfp, DISCARDSLICE will be 1/4 of opslquant. Here maximum                        *
                      * #slice per loc to reach IFIR_MAX_SLAB_VTHICK (200cm) is calcualated based on this relation.         */
                     avmaxslquant = floor((IFIR_MAX_SLAB_VTHICK/opslthick)*4/3);
                     avmaxslquant -= avmaxslquant % 2;
                     if((opslthick * (avmaxslquant+2)) <= (IFIR_MAX_SLAB_VTHICK + opslthick* 2 * (int)((avmaxslquant+2)/8.0 + 0.5)))
                     {
                         avmaxslquant += 2;
                     }
                 }

                 epic_error( use_ermes, "The number of scan locations selected "
                             "must be reduced to %d for the current prescription.",
                             EM_PSD_SLQUANT_OUT_OF_RANGE, EE_ARGS(1),
                             INT_ARG, avmaxslquant);
                 return ADVISORY_FAILURE;
             } else { /* Reduce the slice thickness */
                 av_temp_float = (float)floor(temp_vthick/exist(opslquant)*10.0)/10.0;
                 if ( ((int)(10.0*av_temp_float + 0.5) % slicezp != 0) &&
                       ( ((exist(opslzip2)==PSD_ON) && existcv(opslzip2)) ||
                         ((exist(opslzip4)==PSD_ON) && existcv(opslzip4)) ) )
                 {
                     av_temp_float = (0.1*(float)slicezp)*(float)
                       ((int)((10.0/(float)slicezp)*(av_temp_float-0.05*(float)slicezp)+0.001));
                 }

                 avmaxslthick = av_temp_float;
                 epic_error( use_ermes, "The Slice thickness must be decreased to "
                             "%.2f mm for the current prescription.",
                             EM_PSD_SLTHICK_OUT_OF_RANGE2, EE_ARGS(1),
                             FLOAT_ARG, avmaxslthick );
                 return ADVISORY_FAILURE;
             }
        }
    }

    /** traditional spatial sat and chem sat **/
    if (SpSatCheck() == FAILURE) {
        return FAILURE;
    }

    if (cs_sat) {
        if (ChemSatCheck()  == FAILURE)
            return FAILURE;
    }

    /** imaging options **/
    if ((exist(opfast) != PSD_ON) && existcv(opfast)) {
        epic_error(use_ermes,
                   "The fast option must be selected for this sequence",
                   EM_PSD_FGRE_SELECTION,EE_ARGS(0));
        return FAILURE;
    }

    /* MRIge20264 - locks out Graphic ROI */  
    if ((exist(opgrxroi) == PSD_ON) && existcv(opgrxroi)) {
        epic_error(use_ermes,
                   "The Graphic ROI Option is not available with this sequence",
                   EM_PSD_OPGRXROI_INCOMPATIBLE,EE_ARGS(0));
        return FAILURE;
    }

    /* IR PREP (pjg) */
    if( (exist(opdeprep) == PSD_ON) && existcv(opdeprep)) {
        epic_error(use_ermes, "The DE Prep Option is not available with this pulse sequence", 
                   EM_PSD_OPDEPREP_INCOMPATIBLE, EE_ARGS(0));
        return FAILURE;
    }

    if (bravo_flag)
    {
        if( PSD_ON == exist(opfat) ) {
            epic_error( use_ermes,
                        "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "FAT Suppression",
                        STRING_ARG, "BRAVO" );
            return FAILURE;
        }
    
        if( PSD_ON == exist(opwater) ) {
            epic_error( use_ermes,
                        "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Water Suppression",
                        STRING_ARG, "BRAVO" );
            return FAILURE;
        }

        if( sp_sat ) {
            epic_error( use_ermes,
                        "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "SAT",
                        STRING_ARG, "BRAVO" );
            return FAILURE;
        }
    }

    /* MRIge66079 - ATV: RTIA3D/ftMRA */
    if( (PSD_ON == irprep_flag) && (!ifir_flag) && (!(bravo_flag && bravo_fatsat)) &&
        ((exist(opsat) == PSD_ON) && existcv(opsat)) && (ftmra_flag == PSD_OFF) ) {
        epic_error(use_ermes, "Sat is not available with IR Prep.",
                   EM_PSD_3DPREP_SAT_ERROR, EE_ARGS(0));
        return FAILURE;
    }

    if((exist(opblim) == PSD_ON) && existcv(opblim)) {
        epic_error(use_ermes,"Classic is not an option",
                   EM_PSD_CLASSIC_INCOMPATIBLE,EE_ARGS(0));
        return FAILURE;
    }

    if (exist(opmph) &&  exist(oprtcgate)) {
        epic_error(use_ermes,"Multi-Phase and Respiratory Gating are incompatible.",
                   EM_PSD_GATING_MPH_INCOMPATIBLE,EE_ARGS(0));
        return FAILURE;
    }

    if((exist(opirmode) == PSD_ON) && existcv(opirmode)) {
        epic_error(use_ermes,"Sequential is not supported for this combination of Image Mode and Pulse Sequence.", 
                   EM_PSD_SEQTL_INCOMPATIBLE, EE_ARGS(0));
        return FAILURE;
    }

    if((exist(oppomp) == PSD_ON) && existcv(oppomp)) {
        epic_error(use_ermes,"Pomp is not supported with gradient recalled scans",
                   EM_PSD_POMPGR_INCOMPATABLE,EE_ARGS(0));
        return FAILURE;
    }

    if ( existcv(opcgate) && (PSD_ON == exist(opcgate)) ) {
        if( ellipt_flag ) {
            epic_error(use_ermes, "%s is incompatible with %s.",
                       EM_PSD_INCOMPATIBLE,EE_ARGS(2),STRING_ARG, "Cardiac gating",
                       STRING_ARG,"Elliptic Centric View Ordering");
            return FAILURE;
        }

        if( reverse_ellipt_flag ) {
            epic_error(use_ermes, "%s is incompatible with %s.",
                       EM_PSD_INCOMPATIBLE,EE_ARGS(2),STRING_ARG, "Cardiac gating",
                       STRING_ARG,"Reverse Elliptic Centric View Ordering");
            return FAILURE;
        }

        /* 3d Oblique - gating and multi-slab made incompatible - latha@mr */
        if( (exist(opvquant) > 1) && existcv(opvquant) && (!heart3d_flag) && (!cine3d_flag) ) {
            epic_error(use_ermes,
                       "%s does not support multi-slab acquisitions.",
                       EM_PSD_NO_MULTI_SLAB,EE_ARGS(1),STRING_ARG,
                       "Gated Scan");
            return FAILURE;
        }
        /* end 3d Oblique */

        if( PSD_ON == smartprep_flag ) {
            epic_error(use_ermes, "%s is incompatible with %s.",
                       EM_PSD_INCOMPATIBLE,EE_ARGS(2),STRING_ARG, "Cardiac gating",
                       STRING_ARG,"Smartprep");
            return FAILURE;
        }

        /* MRIge81273 - Prevent Centric/Reverse Centric with 0.5 or 0.75 NEX */
        if( existcv(opnex) && ( (0.5 == exist(opnex)) || (0.75 == exist(opnex)) ) &&
            ((phorder == CENTRIC) || (phorder == REVERSE_CENTRIC)) &&
            (PSD_OFF == vast_mode) ) {
            epic_error( use_ermes, "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Centric ordering",
                        STRING_ARG, "Fractional NEX" );
            return FAILURE;
        }

        /* MRIge66079 - ATV: RTIA3D/ftMRA */
        if( PSD_ON == ftmra_flag ) {
            epic_error(use_ermes, "%s is incompatible with %s.",
                       EM_PSD_INCOMPATIBLE,EE_ARGS(2),STRING_ARG, "Cardiac gating",
                       STRING_ARG,"ftMRA");
            return FAILURE;
        }
        /* End RTIA3D/ftMRA */

        if (exist(opmph) == PSD_ON) {
            epic_error(use_ermes, "%s is incompatible with %s.",
                       EM_PSD_INCOMPATIBLE,EE_ARGS(2),STRING_ARG, "Cardiac gating",
                       STRING_ARG,"MPH");
            return FAILURE;
        }

        if (exist(opmultistation) == PSD_ON) {
            epic_error(use_ermes, "%s is incompatible with %s.",
                       EM_PSD_INCOMPATIBLE,EE_ARGS(2),STRING_ARG, "Cardiac gating",
                       STRING_ARG,"Multistation");
            return FAILURE;
        }

    }

    if ((exist(oprtarr)*respgate_flag) > GATE_TRIGGER_WINDOW_MAX){
        epic_error(use_ermes,"Respiratory trigger window is out of range",
                   EM_PSD_RESPTRIG_WINDOW_RANGE, EE_ARGS(2), INT_ARG, 
                   0, INT_ARG, GATE_TRIGGER_WINDOW_MAX);
        return FAILURE;
    }

    if ( existcv(opexor) && (exist(opexor) == PSD_ON) ) {
        epic_error(use_ermes,"The RESP COMP is not supported in Volume.",
                   EM_PSD_RESP_INCOMPATIBLE,EE_ARGS(0));
        return FAILURE;
    }

    if (exist(opnopwrap) == PSD_ON && !rectfov_npw_support) { /* rectFOV&NPW  05/11/2005 YI */
        if ( (exist(opsquare) == PSD_ON) && existcv(opsquare) ) {
            epic_error(use_ermes,"Square Pixel and NPW are incompatible.",
                       EM_PSD_NPW_SQPXL_INCOMPATIBLE, EE_ARGS(0));
            return FAILURE;
        } else if ( (exist(opphasefov) != 1.0) && existcv(opphasefov) &&
                    (exist(opsquare) == PSD_OFF) && (existcv(opsquare)) ) {
            epic_error(use_ermes,"Variable FOV and NPW are incompatible.",
                       EM_PSD_NPW_VARFOV_INCOMPATIBLE, EE_ARGS(0));
            /* 4/21/96 RJL - Set values to be placed into Popup List as event handler */
            avminphasefov = 1.0;
            avmaxphasefov = 1.0;
            return ADVISORY_FAILURE;
        }
    }


    /** image mode and pulse sequence **/					/* NEW */
    if( (exist(oppseq) != PSD_GE) && (exist(oppseq) != PSD_SPGR) && 
        (exist(oppseq) != PSD_TOF) && (exist(oppseq) != PSD_TOFSP) &&  
        (exist(oppseq) != PSD_SSFP) && (exist(oppseq) != PSD_PC) && existcv(oppseq) ) {
        epic_error( use_ermes,
                    "GRE, FIESTA, SPGR, Vasc TOF, and Vasc TOF SPGR are the valid pulse seqs for FGRE3D.", 
                    EM_PSD_FGRE3D_INCOMPATIBLE, EE_ARGS(0) );
        return FAILURE;
    }

    /*
     * Navigator checks
     */
    /* MRIge85378 : Option key check for Nav + MDE :AK */
    if( exist(opcgate) == PSD_ON ) {
        if( (exist(oppseq) == PSD_GE) || (exist(oppseq) == PSD_SPGR) ) {
            if( (Absent == MDEKey) && (Absent == Heart3DKey) &&
                (navgate_flag == PSD_ON) &&
                (PSD_ON == irprep_flag) ) {
                epic_error( use_ermes,
                            "%s is not available without the option key.",
                            EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1),
                            STRING_ARG, "3D Delayed Enhancement" );
                return FAILURE;
            }
        }
    }
    if( PSD_ON == navgate_flag ) {
        /* MRIge84546 */
        if( (PSD_ON == exist(opt2prep)) && (!heart3d_flag)) {
            epic_error( use_ermes,
                        "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Navigator",
                        STRING_ARG, "T2Prep" );
            return FAILURE;
        }
        /* MRIge84180 - PL: trap non Fat SAT 3D FIESTA with navigators */
        if( (PSD_OFF == vast_mode) && (PSD_ON == ssfp_flag) ) {
            epic_error( use_ermes,
                        "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Navigator",
                        STRING_ARG, "Non Fat SAT FIESTA" );
            return FAILURE;
        }
    }

    /** image mode and pulse sequence **/ 
    if (((exist(opimode) != PSD_3D)) && existcv(opimode)) {
        epic_error(use_ermes, "Invalid image mode selected (3D only).", 
                   EM_PSD_IM3D_NECESSARY, EE_ARGS(0));
        return FAILURE;
    }

    /* patient parameters */
    if (!UnLocked) {
        if ( existcv(opplane) && (exist(opplane) == PSD_OBL) ) {
            epic_error(use_ermes,"Oblique imaging is not allowed in volume scans.",EM_PSD_VOLOBL_INCOMPATIBLE,EE_ARGS(0));
            return FAILURE;
        }
    }

    /* MRIge66936 */
    if ( (exist(opstation) > 1) &&
         (exist(opmultistation) == PSD_ON) &&
         (smartprep_flag == PSD_ON) ) {
        epic_error(use_ermes,"Smart Prep option is an invalid option at this time.",
                   EM_PSD_INVALID_SMARTPREP,EE_ARGS(0));
        return FAILURE;
    }

    if (!UnLocked) {
        if ((exist(opmph) == PSD_ON) && existcv(opmph)) {
            epic_error(use_ermes, "The Multi-Phase Option is not available with this pulsesequence", 
                       EM_PSD_OPMPH_INCOMPATIBLE, EE_ARGS(0));
            return FAILURE;
        }

        if ((exist(opblim) == PSD_ON) && existcv(opblim)) {
            epic_error(use_ermes,"Classic is not an option",EM_PSD_CLASSIC_INCOMPATIBLE,EE_ARGS(0));
            return FAILURE;
        }

        if (exist(oprtcgate) && existcv(oprtcgate) ) {
            epic_error(use_ermes,"Respiratory triggering is not supported by this pulse sequence",
                       EM_PSD_RESPTRIG_INCOMPATIBLE,EE_ARGS(0));
            return FAILURE;
        }
    }
    /* MRIge66079 - ATV: RTIA3D/ftMRA */
    if (exist(oprtcgate) && existcv(oprtcgate) && (ftmra_flag == PSD_ON) ) {
        epic_error(use_ermes,"Respiratory triggering is not supported by this pulse sequence",
                   EM_PSD_RESPTRIG_INCOMPATIBLE,EE_ARGS(0));
        return FAILURE;
    }
    /* End RTIA3D/ftMRA */

    /*
     * SPEC IR (SPECIAL and Extra SPECIAL) checks
     */
    if( (PSD_ON == specir_flag) || (PSD_ON == irprep_flag) ) {
        if( existcv(opti) && (exist(opti) < avminti) ) {
            epic_error( use_ermes, "Minimum TI is %-d",
                        EM_PSD_TI_OUT_OF_RANGE1, EE_ARGS(1),
                        INT_ARG, avminti / 1ms );
            return ADVISORY_FAILURE;
        }

        if( existcv(opti) && (PSD_ON == irprep_flag) && (exist(opti) > avmaxti) ) {
            epic_error( use_ermes, "Maximum TI is %-d.",
                        EM_PSD_TI_OUT_OF_RANGE2, EE_ARGS(1),
                        INT_ARG, avmaxti / 1ms );
            return ADVISORY_FAILURE;
        }

        if( existcv(opti) && (PSD_ON == specir_flag) && existcv(opnex) && (exist(opti) > avmaxti) ) {
            epic_error( use_ermes, "Maximum TI is %-d.",
                        EM_PSD_TI_OUT_OF_RANGE2, EE_ARGS(1),
                        INT_ARG, avmaxti / 1ms );
            return ADVISORY_FAILURE;
        }
    }
    /* MRIge51415 - SpecIR is incompatible with IR Prep - latha@mr */
    if( specir_flag && irprep_flag && (!ifir_flag) && (!(bravo_flag && bravo_fatsat)) ) {
        epic_error( use_ermes, "IR Prep is incompatible with Spec IR.",
                    EM_PSD_IRPREP_SPECIR_INCOMPATIBLE, EE_ARGS(0) );	
        return FAILURE;
    }

    if( (PSD_ON == extraspecial_flag) || brava_flag  ) {
        if( existcv(opsquare) && (PSD_ON == exist(opsquare)) ) {
            epic_error( use_ermes, "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Square Pixel",
                        STRING_ARG, "SPECIAL" );
            return FAILURE;
        }
        if( existcv(opzip1024) && (PSD_ON == exist(opzip1024)) ) {
            epic_error( use_ermes, "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "ZIP 1024",
                        STRING_ARG, "SPECIAL" );
            return FAILURE;
        }
        if( existcv(opslzip4) && (PSD_ON == exist(opslzip4)) ) {
            epic_error( use_ermes, "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "ZIP 4",
                        STRING_ARG, "SPECIAL" );
            return FAILURE;
        }
        if( existcv(opfluorotrigger) && (PSD_ON == exist(opfluorotrigger)) ) {
            epic_error( use_ermes, "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Fluoro Trigger",
                        STRING_ARG, "SPECIAL" );
            return FAILURE;
        }
        if( existcv(opmultistation) && (PSD_ON == exist(opmultistation)) ) {
            epic_error( use_ermes, "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Multi Station",
                        STRING_ARG, "SPECIAL" );
            return FAILURE;
        }
        if( existcv(opscic) && (PSD_ON == exist(opscic)) ) {
            epic_error( use_ermes, "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "SCIC",
                        STRING_ARG, "SPECIAL" );
            return FAILURE;
        }
        if( existcv(oprtcgate) && (PSD_ON == exist(oprtcgate)) ) {
            epic_error( use_ermes, "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Respiratory gating",
                        STRING_ARG, "SPECIAL" );
            return FAILURE;
        }
        if( existcv(opcgate) && (PSD_ON == exist(opcgate)) ) {
            epic_error( use_ermes, "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Cardiac gating",
                        STRING_ARG, "SPECIAL" );
            return FAILURE;
        }
        if( existcv(opmt) && (PSD_ON == exist(opmt)) ) {
            epic_error( use_ermes, "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Magnetization Transfer",
                        STRING_ARG, "SPECIAL" );
            return FAILURE;
        }
        if( ((PSD_ON == navgate_flag) || (PSD_ON == navtrig_flag)) && (PSD_OFF == exist(opcgate)) ) {
            epic_error( use_ermes, "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Navigator",
                        STRING_ARG, "SPECIAL" );
            return FAILURE;
        }
    }

    if(ugfsf_flag) {
        if( existcv(opfluorotrigger) && (PSD_ON == exist(opfluorotrigger)) ) {
            epic_error( use_ermes, "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Fluoro Trigger",
                        STRING_ARG, "SPECIAL" );
            return FAILURE;
        }
        if( existcv(opmultistation) && (PSD_ON == exist(opmultistation)) ) {
            epic_error( use_ermes, "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Multi Station",
                        STRING_ARG, "SPECIAL" );
            return FAILURE;
        }
        if( existcv(opnex) && oddnex_npw ){
            epic_error( use_ermes, "Odd NEX is not valid for No Phase Wrap.", EM_PSD_NPW_INCOMPATIBLE, 0);
            return FAILURE;
        }
        if( existcv(opnex) && nop==2 && exist(opnex)==1.5 ){
            epic_error( use_ermes, "This NEX is not valid for No Phase Wrap.", EM_PSD_NPW_INCOMPATIBLE, 0);
            return FAILURE;
        } 
    }

    /*
     * Checks for VAST
     */
@inline VAST.e VASTcvcheck

    /*  MRIhc13906: Check for mutually exclusive option type ins */
    if ( (PSD_ON == exist(opslzip2)) && (PSD_ON == exist(opslzip4)) ) {
        epic_error( use_ermes, "The slice ZIP options of x2 and x4 cannot both be selected.",
                   EM_PSD_MUTUALLY_EXCL_ZIP, EE_ARGS(0));
        return FAILURE ;
    }
    
    if ( (PSD_ON == exist(oprtcgate)) && (PSD_ON == exist(opmultistation)) ) {
        epic_error( use_ermes, "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Respiratory Gating/Triggering",
                        STRING_ARG, "Multistation");
        return FAILURE ;
    }

    /*
     * Checks for ZIP 1024
     */
    if ((exist(opzip512)==PSD_ON ) && (exist(opzip1024)==PSD_ON)) {
        epic_error(use_ermes,"The ZIP options of 1024 and 512 cannot both be selected",
                   EM_PSD_ZIP1024_ZIP512_MUTUALLY_EXCLUSIVE,EE_ARGS(0));
        return FAILURE ;
    }

    if ((exist(opzip1024)==PSD_ON) && (exist(opnopwrap) == PSD_ON)) {
        epic_error(use_ermes,"1024 ZIP is not available with No Phase Wrap",
                   EM_PSD_ZIP1024_NPW_INCOMPATIBLE,EE_ARGS(0));
        return FAILURE;

    }
    
    /*  1024 Support */
    if ( ((existcv(opxres) && exist(opxres) > 512) || (existcv(opyres) && exist(opyres) > 512)) &&
         (existcv(opnopwrap) && exist(opnopwrap) != 0) ) {
        epic_error(use_ermes,"%s is incompatible with %s",EM_PSD_INCOMPATIBLE,
                   EE_ARGS(2),STRING_ARG,"1024 Res",STRING_ARG,"No Phase Wrap");
        return FAILURE;
    }

    if ( (exist(opzip512) == PSD_ON) && ((existcv(opxres) && exist(opxres)> 512) || (existcv(opyres) && exist(opyres) > 512 ) ) ) {
        epic_error(use_ermes,"%s is incompatible with %s",EM_PSD_INCOMPATIBLE,
                   EE_ARGS(2),STRING_ARG,"512 ZIP",STRING_ARG,"larger than 512 Resolution");
        return FAILURE;
    }

    /* Asset incompatible with xres or yres > 512 */
    if ( ( ( existcv(opxres) && exist(opxres) > 512 ) || ( existcv(opyres) && exist(opyres) > 512 ) 
        ||  ( (existcv(opyres) && existcv(opphasefov)) && ((exist(opyres)*exist(opphasefov) > 512 ))) ) &&
         (exist(opasset) > 0) ) {
        epic_error(use_ermes,"%s is incompatible with %s",EM_PSD_INCOMPATIBLE,
                   EE_ARGS(2),STRING_ARG,"ASSET",STRING_ARG,"an image matrix larger than 512");
        return FAILURE;
    }

    /* HCSDM00353043 */
    if ( (ASSET_SCAN == exist(opasset)) && !vibrant_flag
         && !( aspir_override && (PSD_SAG == opplane) && brava_flag) )
    {
        if ( ((strstr( coilInfo[0].coilName, "BREAST") != NULL) ||
             (strstr( coilInfo[0].coilName, "Breast") != NULL)) &&
             ((exist(opplane) == PSD_SAG) || ((exist(opplane) == PSD_OBL) &&
             (exist(opobplane) == PSD_SAG))) )
        {
            epic_error( use_ermes,
                    "%s is incompatible with %s",
                    EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                    STRING_ARG, "ASSET",
                    STRING_ARG, "selected coil" );
            return FAILURE;
        }
    }    
    if ( (strstr(coilInfo[0].coilName, "R_BREAST") != NULL) ||
         (strstr(coilInfo[0].coilName, "L_BREAST") != NULL) ||
         (strstr(coilInfo[0].coilName, "BreastLeft") != NULL) ||
         (strstr(coilInfo[0].coilName, "BreastRight") != NULL) ||
         (strstr(coilInfo[0].coilName, "7Ch BreastL") != NULL) ||
         (strstr(coilInfo[0].coilName, "7Ch BreastR") != NULL) ||
         (strstr(coilInfo[0].coilName, "breast L") != NULL) ||
         (strstr(coilInfo[0].coilName, "breast R") != NULL) ||
         (strstr(coilInfo[0].coilName, "BrstL") != NULL) ||
         (strstr(coilInfo[0].coilName, "BrstR") != NULL) ||
         (strstr(coilInfo[0].coilName, "BREASTPA R") != NULL) ||
         (strstr(coilInfo[0].coilName, "BREASTPA L") != NULL) )
    {
        if(ASSET_SCAN == exist(opasset)) 
        {
            epic_error( use_ermes,
                    "%s is incompatible with %s",
                    EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                    STRING_ARG, "ASSET",
                    STRING_ARG, "selected coil" );
            return FAILURE;
        }
    }
    
    /* T2 Prep and IR Prep (NDG) */
    if( irprep_flag && t2prep_flag && (!heart3d_flag) ) {
        epic_error( use_ermes,
                    "%s is incompatible with %s.",
                    EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                    STRING_ARG, "T2 Prep",
                    STRING_ARG,"IR Prep" );
        return FAILURE;
    }


    /* MRIge66079 - ATV: RTIA3D/ftMRA */
    if ((exist(oprealtime)==PSD_ON) && (ftmra_flag==PSD_OFF) && (maskv_ftmra_flag==PSD_OFF) ) {
        epic_error(use_ermes,"Realtime is not available with this sequence",
                   EM_PSD_RTIA_REALTIME_NOT_AVAILABLE,EE_ARGS(0));
        return FAILURE;
    }

    /* ATV - only allow FTMRA imaging option on the first station of multi-station prescription */
    if ( (exist(opstation) > 1) &&
         (exist(opmultistation) == PSD_ON) &&
         (ftmra_flag == PSD_ON) ) {
        epic_error(use_ermes,"Fluoro-trigger option is an invalid option at this time.",
                   EM_PSD_INVALID_FTMRA,EE_ARGS(0));
        return FAILURE;
    }

    /* MRIge68676 */
    if ( (sp_sat == PSD_ON) && (intermittant_chemsat == PSD_ON) &&
         (!ifir_flag) && (!osfp_flag) && (ftmra_flag == PSD_OFF) && (maskv_ftmra_flag == PSD_OFF) ) {
        epic_error(use_ermes,
                   "Spatial saturation and SpecIR are incompatible.",
                   EM_PSD_SAT_NO_SPECIR,EE_ARGS(0));
        return FAILURE;

    }
    /* End RTIA3D/ftMRA */

@inline Tricks.e TricksCheck

    /*
     * FIESTA-C (Phase Cycling) checks
     */
    if( PSD_ON == pcfiesta_flag ) {
        /*  MRIge83237 - lockout for Fiesta-C  */
        if( existcv(opcgate) && (PSD_ON == exist(opcgate)) ) {
            epic_error( use_ermes,
                        "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Fiesta-C",
                        STRING_ARG, "Cardiac Gating" );
            return FAILURE;
        }

        /* MRIge83457 - lockout's for Fiesta-C */
        if( existcv(oprtcgate) && (PSD_ON == exist(oprtcgate)) ) {
            epic_error( use_ermes,
                        "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Fiesta-C",
                        STRING_ARG, "Respiratory Gating/Triggering" );
            return FAILURE;
        }

        if( existcv(opmultistation) && (PSD_ON == exist(opmultistation)) ) {
            epic_error( use_ermes,
                        "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Fiesta-C",
                        STRING_ARG, "Multistation" );
            return FAILURE;
        }

        if( existcv(opfluorotrigger) && (PSD_ON == exist(opfluorotrigger)) ) {
            epic_error( use_ermes,
                        "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Fiesta-C",
                        STRING_ARG, "Fluoro Trigger" );
            return FAILURE;
        }
    }

    /* MRIhc00484 *//* FIESTA-C  06/10/2005 YI */
    if( ((ASSET_SCAN_PHASE == exist(opasset)) || 
         (ASSET_SCAN_SLICE == exist(opasset))) && (exist(opnex) > 1) && (pc_mode == PC_BASIC) ) {
        epic_error( use_ermes,
                    "%s is incompatible with %s",
                    EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                    STRING_ARG, "ASSET",
                    STRING_ARG, "a multiple NEX prescription" );
        return FAILURE;
    }

    /* MRIhc13444 */
    if( ((ASSET_SCAN_PHASE == exist(opasset)) ||
         (ASSET_SCAN_SLICE == exist(opasset))) && arc_flag) {
        epic_error( use_ermes,
                    "%s is incompatible with %s",
                    EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                    STRING_ARG, "ASSET",
                    STRING_ARG, "this prescription" );
        return FAILURE;
    }

    if( ((ASSET_SCAN_PHASE == exist(opasset)) ||
         (ASSET_SCAN_SLICE == exist(opasset))) && PSD_ON == opcosmic) {
        epic_error( use_ermes,
                    "%s is incompatible with %s",
                    EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                    STRING_ARG, "ASSET",
                    STRING_ARG, "this prescription" );
        return FAILURE;
    }

    if( arc_flag && (PSD_ON == oplava) && (PSD_OFF == exist(opmedal)) ) {
        if( (PSD_ON == exist(opcgate)) ) {
                        epic_error( use_ermes,
                        "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "LAVA-XV",
                        STRING_ARG, "Cardiac Gating" );
            return FAILURE;
         }
        if( (PSD_ON == exist(oprtcgate)) ) {
                        epic_error( use_ermes,
                        "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "LAVA-XV",
                        STRING_ARG, "Respiratory Triggering" );
            return FAILURE;
         }
        if( (PSD_ON == exist(opsmartprep)) && (PSDDVMR != psd_board_type) ) { /*only DV support SMARTPREP with EDR*/
                        epic_error( use_ermes,
                        "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "LAVA-XV",
                        STRING_ARG, "SmartPrep" );
            return FAILURE;
         }
    }
    if( PSD_ON == bravo_flag ) {
        if( (PSD_ON == exist(opcgate)) ) {
                        epic_error( use_ermes,
                        "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "BRAVO",
                        STRING_ARG, "Cardiac Gating" );
            return FAILURE;
         }
        if( (PSD_ON == exist(opmultistation)) ) {
                        epic_error( use_ermes,
                        "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "BRAVO",
                        STRING_ARG, "MultiStation" );
            return FAILURE;
         }
        if( (PSD_ON == exist(opfluorotrigger)) ) {
                        epic_error( use_ermes,
                        "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "BRAVO",
                        STRING_ARG, "Fluoro-Triggering" );
            return FAILURE;
         }
        if( (PSD_ON == exist(oprtcgate)) ) {
                        epic_error( use_ermes,
                        "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "BRAVO",
                        STRING_ARG, "Respiratory Triggering" );
            return FAILURE;
         }
    }    

    /* MRIhc07357 */
    if( PSD_ON == exist(opdynaplan) && (PSD_ON == exist(opmultistation)) ) {
            epic_error( use_ermes,
                        "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Dynamic Plan",
                        STRING_ARG, "Multistation" );
            return FAILURE;
    }

    if (arc_cal_echo >= opnecho)
    {
        epic_error( use_ermes, "%s is out of range",
                    EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "arc_cal_echo");
        return FAILURE;
    }

    if (existcv(opfov))
    {
@inline ZoomGradLimit.e ZoomGradPrep

        /* MRIge67141 */
        off_cent_dist = (opslthick*(exist(opslquant) - 2*opslblank))/slab_fact;

@inline ZoomGradLimit.e ZoomGradCheck
    }

    /* MRIhc16353 - RV: IDEAL change... needed for TERRA, but may not be needed for NEUVO
    database */
    if((PSD_ON == ideal_flag)&&
	((rhrcctrl & RHRCQMAG)&&(rhrcctrl & RHRCIMAG)&&(rhexecctrl & RHXC_INTERMEDIATE)))
    {
       int ideal_ncoils;
       ideal_debug = 1;
       if(existcv(opasset) && (exist(opasset) > 1)) {
           if (rhdab0s != rhdab0e)
           {
               ideal_ncoils = rhdab0e-rhdab0s+1;
           }
           else
           {
               ideal_ncoils = 0;
           }
       } else {
            ideal_ncoils = 0;
       }
       /* RV: MRIhc19003 - Replaced opnecho with ideal_necho */
       if ( ((ideal_necho*(3-ideal_no_mag_im)*(1+ideal_ncoils) * slicezp * exist(opslquant)) > ideal_max_im) &&
                      existcv(opslquant) && existcv(opasset) ) {
           ideal_max_locs = (int)(ideal_max_im/(ideal_necho*(3-ideal_no_mag_im)*slicezp*(1+ideal_ncoils))) ;
           epic_error(0, "Too many images. Reduce Locs to %d",
                      0, EE_ARGS(1), INT_ARG, ideal_max_locs);
           return FAILURE;
       }
    } else if((PSD_ON == ideal_flag)&&
        ((rhrcctrl & RHRCQMAG)&&(rhrcctrl & RHRCIMAG))) {
       if(existcv(opasset) && (exist(opasset) > 1)) {
          ideal_debug = 1;
       }
    }

    /* GEHmr01771 */
    if( (PSD_OFF == ftmra_enable_flag) && (PSD_ON == exist(opfluorotrigger)) )
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "Fluoro Trigger");
        return FAILURE;
    }

    if( ((PSD_ON==exist(opwater)) || (PSD_ON==exist(opfat))  )
        && (PSD_ON==ss_rf1) )
    {
        epic_error( use_ermes,
                    "%s is incompatible with %s.",
                    EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                    STRING_ARG, "Chem Sat",
                    STRING_ARG, "Water Excitation" );
        return FAILURE;
    }

    if( (Absent == PhaseImageKey) && (PSD_OFF != exist(opphaseimage)) && (PSD_ON == existcv(opphaseimage)))
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "SWAN: Phase Imaging");
        return FAILURE;
    }

@inline MSDE.e MSDE_CVcheck

    if ((PSD_ON == exist(opmsde)) || msde_flag)
    {
        if (existcv(opvquant) && (exist(opvquant) != 1))
        {
            epic_error( use_ermes, "%s does not support multi slab acquisitions.",
                        EM_PSD_NO_MULTI_SLAB, EE_ARGS(1),
                        STRING_ARG, "MSDE" );
            return FAILURE;
        }
        if (PSD_ON == exist(opfat))
        {
            epic_error( use_ermes, "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "MSDE",
                        STRING_ARG, "FAT Suppression");
            return FAILURE;
        }
    }
 
    /* Return failure if Minimum TE is selected
     * It's possible when MERGE/SWAN application is called from other application.
     */
    if ( merge_flag && (PSD_MINTE == exist(opautote)) )
    {
        epic_error( use_ermes, "%s is incompatible with %s.",
                    EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                    STRING_ARG, "MERGE/SWAN",
                    STRING_ARG, "Minimum TE" );
        return FAILURE;
    }

@inline FastCINE3D.e fcine3d_cvcheck

    if( headneck_pos_scan || (0 != rhposition_detection) )
    {
        static const double HEADNECK_MIN_FOV_XY = 150.0;
        static const double HEADNECK_MIN_FOV_Z = 400.0;
        static const double HEADNECK_MAX_VOXEL_LENX = 5.0;
        static const double HEADNECK_MAX_VOXEL_LENY = 10.0;
        static const double HEADNECK_MAX_VOXEL_LENZ = 10.0;

        if( !is_iopt_selected( PSD_IOPT_MILDNOTE ) )
        {
            //Log compatibility error
            epic_error( use_ermes, "The %s option must be selected with %s psd.",
                        EM_PSD_IMGOPT_PSD, EE_ARGS(2),
                        STRING_ARG, "ART",
                        STRING_ARG, "Head Scout" );
            //return FAILURE;
        }
        if( !is_iopt_selected( PSD_IOPT_SLZIP_X2 ) && !is_iopt_selected( PSD_IOPT_SLZIP_X4 ) )
        {
            //Log compatibility error
            epic_error( use_ermes, "The %s option must be selected with %s psd.",
                        EM_PSD_IMGOPT_PSD, EE_ARGS(2),
                        STRING_ARG, "ZIPx2(4)",
                        STRING_ARG, "Head Scout" );
            //return FAILURE;
        }
        if( !is_iopt_selected( PSD_IOPT_EDR ) )
        {
            //Log compatibility error
            epic_error( use_ermes, "The %s option must be selected with %s psd.",
                        EM_PSD_IMGOPT_PSD, EE_ARGS(2),
                        STRING_ARG, "EDR",
                        STRING_ARG, "Head Scout" );
            //return FAILURE;
        }

        if( existcv(opplane) && PSD_COR != opplane )
        {
            //Log scan plane error EM_PSD_INCOMPATIBLE
            epic_error( use_ermes, "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Head Scout",
                        STRING_ARG, PSD_AXIAL == opplane
                                    ? "Axial"
                                    : (PSD_SAG == opplane
                                       ? "Sagittal"
                                       : "Oblique") );
            //return FAILURE;

        }
        if( existcv(opspf) && 1 == opspf )
        {
            //Default swap phase-frequency for coronal should be 0 regardless of coil
            //Log SPF error
            epic_error( use_ermes, "Please change frequency direction to S/I",
                        EM_PSD_ZOOM_CTL_COIL_NONAXIAL2, EE_ARGS(0) );
            //return FAILURE;
        }

        avminfov = HEADNECK_MIN_FOV_XY;

        if( existcv(opfov) && (opfov < avminfov) )
        {
            //Log miniumum FOV error EM_PSD_FOV_OUT_OF_RANGE
            epic_error( use_ermes, "The FOV needs to be increased to "
                        "%3.1f cm for the current prescription, or receive "
                        "bandwidth can be decreased.",
                        EM_PSD_FOV_OUT_OF_RANGE, EE_ARGS(1),
                        FLOAT_ARG, avminfov / 10.0 );
            //return ADVISORY_FAILURE;
        }

        avminxres = opfov / HEADNECK_MAX_VOXEL_LENX;
        if( existcv(opfov) && existcv(opxres) && (opxres < avminxres) )
        {
            //Log minimum Xres error
            epic_error( use_ermes,
                        "The frequency encoding steps must be increased "
                        "to %d for the current prescription.",
                        EM_PSD_XRES_OUT_OF_RANGE2, EE_ARGS(1), INT_ARG, avminxres );
            //return ADVISORY_FAILURE;
        }

        avminyres = (opfov * opphasefov) / HEADNECK_MAX_VOXEL_LENY;
        if( existcv(opfov) && existcv(opxres) && existcv(opyres) && existcv(opphasefov) )
        {
            if( opyres < avminyres )
            {
                //Log minimum Yres error
                epic_error( use_ermes,
                            "The phase encoding steps must be increased "
                            "to %d for the current prescription.",
                            EM_PSD_YRES_OUT_OF_RANGE2, EE_ARGS(1), INT_ARG, avminyres );
                //return ADVISORY_FAILURE;
            }
        }

        avminslquant = HEADNECK_MIN_FOV_Z / opslthick;
        if( existcv(opslthick) && existcv(opslquant) && (opslquant < avminslquant) )
        {
            //Log minimum slice quantity error
            epic_error( use_ermes,
                        "Minimum number of slices is %d.",
                        EM_PSD_MIN_SLICE, EE_ARGS(1), INT_ARG, avminslquant );
            //return ADVISORY_FAILURE;
        }

        avmaxslthick = HEADNECK_MAX_VOXEL_LENZ;
        if( existcv(opslthick) && (opslthick > HEADNECK_MAX_VOXEL_LENZ) )
        {
            //Throw minimum slice thickness error EM_PSD_SLTHICK_OUT_OF_RANGE2
            epic_error( use_ermes, "The Slice thickness must be decreased to "
                        "%.2f mm for the current prescription.",
                        EM_PSD_SLTHICK_OUT_OF_RANGE2, EE_ARGS(1),
                        FLOAT_ARG, avmaxslthick );
            //return ADVISORY_FAILURE;
        }
    }

    return SUCCESS;
}   /* end cvcheck() */


STATUS
calcPulseParams( int encode_mode )
{
    /* Include insert code */
#include "predownload.in"

    if(MAXIMUM_POWER == encode_mode)
    {
        grady[GY1_SLOT].scale = 1.0;
        grady[GY1R_SLOT].scale = 1.0;
        gradz[GZCOMB_SLOT].scale = 1.0;
        gradz[GZP_SLOT].scale = 1.0;
    }
    else
    {
        grady[GY1_SLOT].scale = ave_grady_gy1_scale;
        grady[GY1R_SLOT].scale = ave_grady_gy1_scale;
        gradz[GZCOMB_SLOT].scale = ave_gradz_gzcomb_scale;
        gradz[GZP_SLOT].scale = ave_gradz_gzp_scale;
    }

@inline FastCINE3D.e fcine3d_calcPulse

    /* Set waveform amps to full scale, overriding the TRAPEZOID2 settings */
    if (flow4D_flag) ia_gzcombwa = max_pg_wamp;  /* in 4dflow mode, gzcomb is nNOT ramped-trapezoid */
    else ia_gzcombwa = PSDRAMPEDTRAP*max_pg_wamp;
    ia_gzcombwb = max_pg_wamp;

    ia_gzpwa = PSDRAMPEDTRAP*max_pg_wamp;
    ia_gzpwb = max_pg_wamp;

    /* GEHmr01779 */
    if ( (value_system_flag == VALUE_SYSTEM_SVEM) || (value_system_flag == VALUE_SYSTEM_SVDM) )
    {
         gradz[GZCOMB_SLOT].scale = 1.0;
         gradz[GZP_SLOT].scale = 1.0;
    }

    /* (just refocus for heating, combined refocus/phase for dbdt) */
    /* Add minus in order to get the correct waveform after download */
    ia_gzcomb = -a_gzcomb/loggrd.tz * gradz[GZCOMB_SLOT].scale * max_pg_iamp;
    /* (just killer for heating, combined killer/rephase for dbdt) */
    ia_gzp = a_gzp/loggrd.tz * gradz[GZP_SLOT].scale * max_pg_iamp;

    /* Scale the phase encode according to the average power over time
       MRIge63197 -- use full endview instruction amplitude for dB/dt
       calculations (scale = 1) and derated for gradient heating
       (scale set by avepepowscale). copysign is math.h function for
       preserving the sign bit. */
    ia_gy1  = copysign(sqrt(grady[GY1_SLOT].scale),a_gy1) * endview_iamp;
    
    /* Using a_gy1 to calculate ia_gy1r since the waveform memory is already reversed */
    ia_gy1r = copysign(sqrt(grady[GY1R_SLOT].scale),a_gy1) * endview_iamp;

    ia_rf1 = max_pg_iamp*(*rfpulse[RF1_SLOT].amp);

    SpSatIAmp();

    if (cs_sat == PSD_ON) {
        ia_rfcssat = max_pg_iamp*(*rfpulse[RFCSSAT_SLOT].amp);
    }

    if (ftmra_flag && rtia3d_irp_flag)
       ia_hard180 = max_pg_iamp*(*rfpulse[HARD180_SLOT].amp);

    if( vast_mode ) {
        /* 3D FIESTA + VAST already incorporates tdel1_time in scancore */
        pos_start_ir = pos_start_ir_min;
        cs_satstart = cs_satstart_min;

        if (ssfp_flag)
        {
            /* Half alpha Half TR */
            ia_gzcombhtrwa = ia_gzcombwa;
            ia_gzcombhtrwb = ia_gzcombwb;
            ia_gzphtrwa = ia_gzpwa;
            ia_gzphtrwb = ia_gzpwb;
        }
    } else {
        pos_start_ir = pos_start_ir_min + tdel1_time;

        /* MRIhc38427: Navigator + FAT + Trigger Delay set to Recommended mode was causing download
           failure because of improper handling of tdel1_time. The trigger delay time is handled as
           dda's when vast_mode is ON. Hence the trigger delay time (tdel1_time) should not be part of
           cs_satstart. */
        /* The bracket was missed, which was causing download failures
         * because of pulse overlaps  */
        cs_satstart = cs_satstart_min + ((vast_mode == PSD_ON) ? 0 : tdel1_time);
    }

    if (FAILURE == t2prep_calcPulse())
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "t2prep_calcPulse");
        return FAILURE;
    }

    /* SVBranch, Smart Burst Mode */
    /* SBM: multipled by additional scale to let minseq() calculate min_seqgrad
            for different phase/slice encoding */
    if(sbm_flag)
    {
        ia_gx1 = ia_gx1 * sbm_gx1_scale;
        ia_gxw = ia_gxw * sbm_gxw_scale;
        ia_gxwex = ia_gxwex * sbm_gxwex_scale;
        ia_gy1 = ia_gy1 * sbm_gy1_scale;
        ia_gy1r = ia_gy1r * sbm_gy1r_scale;
        ia_gzcomb = ia_gzcomb * sbm_gzcomb_scale;
        ia_gzp = ia_gzp * sbm_gzp_scale;
    }

    return SUCCESS;
}   /* end calcPulseParams() */

/* Begin dBdtOpt - RJF */
/*  This function is not used in the 'PSD' - this is the global interface 
    for the SlewRate optimization based on actual dB/dt provided by 
    the support routine calcOptimizedPulses() in psdsupport 
*/
STATUS
setPulseParams( void ) 
{
    if ( use_dbdt_opt == PSD_OFF ) { 
        xrt = loggrd.xrt;
        yrt = loggrd.yrt; 
        zrt = loggrd.zrt;
    } else { 
        xrt = loggrd.opt.xrt;
        yrt = loggrd.opt.yrt;
        zrt = loggrd.opt.zrt;
    }

    /* MRIge67548 */ /* MRIge91682 */
    if( ( (opetl ==1 )
          && ( spgr_flag && (oprbw > 63.0) && (turbo_flag > 1)
               &&  !lava_flag && !brava_flag && !vibrant_flag && !specir_flag
               && !irprep_flag && !medal_flag && !merge_flag && !ideal_flag
               && !msde_flag && !flow4D_flag
               && ( ( (opflip <= 10) && !reverse_ellipt_flag && !ellipt_flag )
                    || ( (opflip <= 5)
                         && (reverse_ellipt_flag || ellipt_flag) ) ) ) )
        || (vstrte_flag && !ssfp_flag) )
    {
        zkiller_flag = PSD_OFF;
        zrewind_flag = PSD_OFF;
        rewinder_flag = PSD_OFF;
    } else {
        zkiller_flag = PSD_ON;
        zrewind_flag = PSD_ON;
        rewinder_flag = PSD_ON;
    }

    /* SVBranch, Smart Burst Mode */
    /* in order to shorten respond time, keep same SR when change of SR caused by dbdtopt is small enough */
    if(sbm_flag)
    {
        gradOpt_slewRate_tmp = loggrd.tx_xyz / xrt;
        if( ((fabs(gradOpt_slewRate_tmp-gradOpt_slewRate)/gradOpt_slewRate) > gradOpt_slewRate_limit) ||
            (gradOpt_slewRate <= 0) )
        {
            gradOpt_slewRate = gradOpt_slewRate_tmp;
        }
    }
    else
    {
        gradOpt_slewRate = loggrd.tx_xyz / xrt;
    }

    /* SVBranch, HCSDM00100051 */
    if( (VALUE_SYSTEM_SVEM == value_system_flag) ||
        (VALUE_SYSTEM_SVDM == value_system_flag) )
    {
        /* fix slewRate for adaptive TE/TR to avoid oscillation from dBdt Optimization */
        gradOpt_slewRate = loggrd.tx_xyz / (myhw.yrt);
    }
    else
    {
        gradOpt_slewRate = loggrd.tx_xyz / xrt;
    }

    if( pgen_for_dbdt_opt  && gradOpt_flag)  
    {
        int ratio_num;
        float old_ratio, tmp_scale, tmp_scale1;
        ratio_num = 0; 
        do
        {
            tmp_scale = gradOpt_scale*gradOpt_TEfactor;
            tmp_scale = FMin(2, tmp_scale, gradOpt_scale_Max);
            tmp_scale = FMax(2, tmp_scale, gradOpt_scale_Min);
 
            tmp_scale1 = gradOpt_scale*gradOpt_TRfactor;
            tmp_scale1 = FMin(2, tmp_scale1, gradOpt_scale_Max);
            tmp_scale1 = FMax(2, tmp_scale1, gradOpt_scale_Min);

            /* SVBranch, HCSDM00100058: add gradOpt_flag as input param */
            if (setOptimizedGradientScalingFactor(
                    a_gx1,  pw_gx1a,  pw_gx1,  pw_gx1d,
                    a_gxfc,  pw_gxfca,  pw_gxfc,  pw_gxfcd,
                    a_gxw,  pw_gxwa,  pw_gxw,  pw_gxwd,
                    a_gxwex, pw_gxwexa, pw_gxwex, pw_gxwexd,
                    a_gy1a,  pw_gy1a,  pw_gy1_tot,
                    a_gy1ra,  pw_gy1ra,  pw_gy1r_tot,
                    a_gzrf1,  pw_gzrf1d,
                    a_gz1,  pw_gz1a,  pw_gz1,  pw_gz1d,
                    a_gzcomba,  pw_gzcomba,  pw_gzcomb,  pw_gzcombd,  pw_gzcomb_tot,
                    a_gzpa, pw_gzpa, pw_gzp, pw_gzpd, gzptime,
                    phaseres,  exist(opfov),  exist(opphasefov),  fov_phase_scale,  asset_factor,  nop,
                    equant,  ethick,  refocus, aTEopt_flag, aTRopt_flag, gxwex_bridge,
                    fecho_factor, GAM, (flow_comp_type==TYPFC), ogsfMin, ogsfMax,
                    (tmp_scale*loggrd.tx_xyz), (tmp_scale*loggrd.ty_xyz), (tmp_scale*loggrd.tz_xyz),
                    (tmp_scale1*gxwex_target), (tmp_scale1*loggrd.ty_xyz), (tmp_scale1*loggrd.tz_xyz),
                    gradOpt_slewRate, gradOpt_aTETR_method, gradOpt_flag, 
                    &ogsfX1, &ogsfXw, &ogsfXwex, &ogsfY, &ogsfYk, &ogsfZ, &ogsfZk,
                    &gradOpt_powerTE, &gradOpt_powerTR) == FAILURE )
            {
                return FAILURE;
            }

            /* SVBranch, HCSDM00100051 */
            /* when smart derating does not update gradOpt_scale, does not update gradOpt_TEfactor etc. */
            if(!gradOpt_run_flag)
            {
                break;
            }

            old_ratio = gradOpt_ratio;
            gradOpt_ratio = gradOpt_ratio * ((sqrt(gradOpt_powerTR/gradOpt_powerTE)-1.0) * gradOpt_Pweight+1.0);

            if (gradOpt_ratio < 1.0)
            {
                gradOpt_TEfactor = 1.0;
                gradOpt_TRfactor = 1.0/gradOpt_ratio;
            }
            else
            {
                gradOpt_TRfactor = 1.0;
                gradOpt_TEfactor = gradOpt_ratio;
            }

            if (gradOpt_TEfactor * gradOpt_scale > 1.0)
            {
                gradOpt_TEfactor = 1.0/gradOpt_scale;
                gradOpt_ratio = gradOpt_TEfactor;
            }

            if (gradOpt_TRfactor * gradOpt_scale > 1.0)
            {
                gradOpt_TRfactor = 1.0/gradOpt_scale;
                gradOpt_ratio = 1.0/gradOpt_TRfactor;
            }

            gradOpt_TEfactor = FMin(2, gradOpt_TEfactor, gradOpt_TEfactor_Max);
            gradOpt_TEfactor = FMax(2, gradOpt_TEfactor, gradOpt_TEfactor_Min);
            gradOpt_TRfactor = FMin(2, gradOpt_TRfactor, gradOpt_TRfactor_Max);
            gradOpt_TRfactor = FMax(2, gradOpt_TRfactor, gradOpt_TRfactor_Min);

            if (fabs(gradOpt_ratio -old_ratio) < gradOpt_Ptor)
            {
                gradOpt_ratio = old_ratio;
            }

            if ((PSD_OFF == gradOpt_powerOpt_flag) || (1 == initialize_scale))
            {
                gradOpt_ratio = 1.0;
                gradOpt_TEfactor = 1.0;
                gradOpt_TRfactor = 1.0;
            }

            ratio_num++;

        } while((ratio_num < gradOpt_Piter_count) && (fabs(gradOpt_ratio-old_ratio) > 0.00001) && gradOpt_powerOpt_flag);

        if(1 == initialize_scale)
        {
            ogsfX1   = 1.0;
            ogsfY    = 1.0;
            ogsfZ    = 1.0;
            ogsfX2   = 1.0;
            ogsfXwex = 1.0;
            ogsfYk   = 1.0;
            ogsfZk   = 1.0;
            initialize_scale = 0;
        }
        else
        {
            if (PSD_ON == gradOpt_TE)
            {
                ogsfX1 = FMax(2, ogsfX1*gradOpt_scale*gradOpt_TEfactor, ogsf_limit_Min);
                ogsfX1 = FMin(2, ogsfX1, ogsf_limit_Max);
                ogsfY  = FMax(2, ogsfY*gradOpt_scale*gradOpt_TEfactor, ogsf_limit_Min);
                ogsfY  = FMin(2, ogsfY, ogsf_limit_Max);
                ogsfZ  = FMax(2, ogsfZ*gradOpt_scale*gradOpt_TEfactor, ogsf_limit_Min);
                ogsfZ  = FMin(2, ogsfZ, ogsf_limit_Max);
            }
            if (PSD_ON == gradOpt_GX2)
            {
                /* Gx2 smart derating currently does not support power optimization */
                ogsfX2 = FMax(2, gradOpt_scale, ogsfX2_limit_Min);
                ogsfX2 = FMin(2, ogsfX2, ogsf_limit_Max);
            }
            else
            {
                ogsfX2 = 1.0;
            }
            ogsfXwex = FMax(2, ogsfXwex*gradOpt_scale*gradOpt_TRfactor,ogsf_limit_Min);
            ogsfXwex = FMin(2, ogsfXwex, ogsf_limit_Max);
            ogsfYk   = FMax(2, ogsfYk*gradOpt_scale*gradOpt_TRfactor, ogsf_limit_Min);
            ogsfYk   = FMin(2, ogsfYk, ogsf_limit_Max);
            ogsfZk   = FMax(2, ogsfZk*gradOpt_scale*gradOpt_TRfactor, ogsf_limit_Min);
            ogsfZk   = FMin(2, ogsfZk, ogsf_limit_Max);
        }
        /* GEHmr02676: turn off pgen_for_dbdt_opt to ensure setOptimizedGradientScalingFactor() is called only one time
                       during dbdt optimization */
        pgen_for_dbdt_opt = 0;
    }

@inline FastCINE3D.e fcine3d_setPulseParams

    if  (existcv(opfcomp) && exist(opfcomp))  {
        if (flow4D_flag) flow_comp_type = TYPNFC;
        else flow_comp_type = TYPFC;
    } else {
        flow_comp_type = TYPNFC;
    }

    if ( set_gzrf1_params() == FAILURE ) { 
        return FAILURE;
    }

    if ( set_gzcomb_params() == FAILURE ) { 
        return FAILURE;
    }

    if ( set_gzk_gzp_params() == FAILURE ) { 
        return FAILURE;
    }

    if ( set_gy1_gy1r_params () == FAILURE ) { 
        return FAILURE;
    }

    if ( set_rdout_and_tmin() == FAILURE ) { 
        return FAILURE;
    }

    if ( calcPulseParams (AVERAGE_POWER) == FAILURE ) { 
        return FAILURE;
    }

    /* GEHmr02509: smart derating */
    if ( PSD_OFF == gradOpt_flag )
    {
        /* Initialize ogsfX2 */
        ogsfX2 = 1.0;

        /* SVBranch, HCSDM00100058: add gradOpt_flag as input param */
        if (setOptimizedGradientScalingFactor( 
                    a_gx1,  pw_gx1a,  pw_gx1,  pw_gx1d,
                    a_gxfc,  pw_gxfca,  pw_gxfc,  pw_gxfcd,
                    a_gxw,  pw_gxwa,  pw_gxw,  pw_gxwd,
                    a_gxwex, pw_gxwexa, pw_gxwex, pw_gxwexd,
                    a_gy1a,  pw_gy1a,  pw_gy1_tot,
                    a_gy1ra,  pw_gy1ra,  pw_gy1r_tot,
                    a_gzrf1,  pw_gzrf1d,
                    a_gz1,  pw_gz1a,  pw_gz1,  pw_gz1d,
                    a_gzcomba,  pw_gzcomba,  pw_gzcomb,  pw_gzcombd,  pw_gzcomb_tot,
                    a_gzpa, pw_gzpa, pw_gzp, pw_gzpd, gzptime,
                    phaseres,  exist(opfov),  exist(opphasefov),  fov_phase_scale,  asset_factor,  nop,
                    equant,  ethick,  refocus, aTEopt_flag, aTRopt_flag, gxwex_bridge,
                    fecho_factor, GAM, (flow_comp_type==TYPFC), ogsfMin, ogsfMax,
                    loggrd.tx_xyz, loggrd.ty_xyz, loggrd.tz_xyz,
                    gxwex_target, loggrd.ty_xyz, loggrd.tz_xyz,
                    gradOpt_slewRate, gradOpt_aTETR_method, gradOpt_flag, 
                    &ogsfX1, &ogsfXw, &ogsfXwex, &ogsfY, &ogsfYk, &ogsfZ, &ogsfZk,
                    &gradOpt_powerTE, &gradOpt_powerTR) == FAILURE )
        {
            return FAILURE;
        }

        /* SVBranch, HCSDM00100051 */
        ogsfX2 = 1.0;
    }

    return SUCCESS;
}   /* end setPulseParams() */

STATUS
ftmra_init( void )
{
    if (value_system_flag)
    {
        cvmax(opfluorotrigger, PSD_ON);
    }

    /* MRIge66079 - ATV: RTIA3D/ftMRA */
    if ((ftMRAKey == Present) || 
        ((QUICKSTEPKey == Present) && existcv(opquickstep) && (PSD_ON == exist(opquickstep))))
    {
        if (value_system_flag == NON_VALUE_SYSTEM)
        {
            cvmax(opfluorotrigger, PSD_ON);
        } 
        ftmra_enable_flag = PSD_ON;
    }
    else
    {
        if (value_system_flag == NON_VALUE_SYSTEM)
        {
            cvmax(opfluorotrigger, PSD_OFF);
        }
        ftmra_enable_flag = PSD_OFF;
    }

    if ( (exist(opfluorotrigger)==PSD_ON) )
    {
        ftmra_flag = PSD_ON;
        plane_type = PSD_OBL;

        if( ssfp_flag == PSD_ON )
        {
            rtia3d_turbo = FALSE;
        }
        else
        {
            rtia3d_turbo = TRUE;
        }
    }
    else
    {
        ftmra_flag = PSD_OFF;
        plane_type = opphysplane;
        cvoverride(oprealtime, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
    }

    /* End RTIA3D/ftMRA */

    return SUCCESS;
}   /* end ftmra_init() */

STATUS
ftmra_eval( void )
{
    /* MRIge66079 - ATV: RTIA3D/ftMRA */

    /* ATV - in ftMRA mode, allow default explicit or concatnated SAT */

    if ( (exist(opfluorotrigger)==PSD_ON) )
    {
        if( ssfp_flag == PSD_ON )
        {
            if(!value_system_flag)
            {
                cvoverride(opsat, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
                cvoverride(opsatz, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
                cvoverride(opsatx, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
                cvoverride(opsaty, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
                cvoverride(opexsatmask, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
                cvoverride(opfat, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
                cvoverride(opwater, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
            }
            ftmra_exsat_flag = PSD_OFF;
            ftmra_dfsat_flag = PSD_OFF;
        }
        else
        {
            if ( (exist(opsat) == PSD_OFF) ) {
                cvoverride(opsat, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
                ftmra_sat_flag = PSD_ON;
            }

            if (exist(opuser19)==1.0)
            {
                if (exist(opsatz)==PSD_OFF )
                {
                    cvoverride(opsatz, PSD_SATHAD, PSD_FIX_ON, PSD_EXIST_ON);
                    ftmra_dfsat_flag = PSD_ON;
                    if (ftmra_exsat_flag )
                    {
                        cvoverride(opexsatmask, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
                        cvoverride(opexsatparal, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
                        ftmra_exsat_flag = PSD_OFF;
                    }
                }
            }
            else
            {
                if (exist(opexsatmask)==PSD_OFF) 
                {
                    cvoverride(opexsatmask, PSD_EXPLICIT_1, PSD_FIX_ON, PSD_EXIST_ON);
                    cvoverride(opexsatparal, PSD_1_PARALLEL, PSD_FIX_ON, PSD_EXIST_ON);
                    /* MRIge88393 */
                    cvoverride(opexsathick1, 80.0, PSD_FIX_ON, PSD_EXIST_ON);
                    cvoverride(opexsathick2, 80.0, PSD_FIX_ON,PSD_EXIST_ON);
                    ftmra_exsat_flag = PSD_ON;
                    if (ftmra_dfsat_flag)
                    {
                        cvoverride(opsatz, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
                        ftmra_dfsat_flag = PSD_OFF;
                    }
                }
            }
        }

    }
    else /* non-FTMRA */
    {
        if ( (existcv(opsat) && (exist(opsat) == PSD_OFF)) ) {
            cvoverride(opsatx, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
            cvoverride(opsaty, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
            cvoverride(opexsatmask, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
            cvoverride(opsat, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
            cvoverride(opsatz, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
            cvoverride(opfat, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
            cvoverride(opwater, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
        }
        else
        {
            if (ftmra_sat_flag && (exist(opfat)==PSD_OFF) ) 
            {
                cvoverride(opsat, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
                ftmra_sat_flag = PSD_OFF;
            } 
            if (ftmra_exsat_flag)
            {
                cvoverride(opexsatmask, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
                ftmra_exsat_flag = PSD_OFF;
            }
            if (ftmra_dfsat_flag)
            {
                cvoverride(opsatz, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
                ftmra_dfsat_flag = PSD_OFF;  
            }  
        }
    }

    {
        /* MRIhc20325 Remove UserCV for Multi Station on DVMR or forward only */
        int maskOrVenous = TRUE;
        if (!wfmMultistationFlag)
        {
            maskOrVenous = ( (PSD_ON == exist(opuser17)) || (PSD_ON == exist(opuser18)) );
        }

        /* ATV - set maskv_ftmra_flag for 1st station
           in a multi-stations experiment to ensure that the mask/venous
           acquisition will be indentical to that of the arterial acquisition (with
           the exception of the real-time part).
           Otherwise, when SCN deselects FTMRA imaging option for mask and venous
           acquisition, they will go toward non-FTMRA path with respect to
           gradient waveforms generation, heating etc.  */
        if ( (exist(opmultistation)==PSD_ON) && maskOrVenous &&
             (exist(opfluorotrigger)== PSD_ON) && (exist(opstation) == 1) )
        {
            maskv_ftmra_flag = PSD_ON;
        }

        /* ATV - if 2nd or later station maskv_ftmra_flag should be off */
        if ( ((exist(opstation) > 1) && (ftmra_flag == PSD_OFF)) ||
             ((exist(opmultistation)==PSD_ON) && (exist(opstation) == 1) && (exist(opfluorotrigger) == PSD_OFF) && 
              ((exist(opmask) == PSD_OFF) && (exist(opvenous) == PSD_OFF)))
             || !maskOrVenous )
        {
            maskv_ftmra_flag = PSD_OFF;
        }
    }

    if (rtia3d_irp_flag)
       rtia3d_phorder = CENTRIC;
    else
       rtia3d_phorder = REVERSE_CENTRIC;

    /* End RTIA3D/ftMRA */

    return SUCCESS;
}   /* end ftmra_eval() */

/* MRIge91682 */
STATUS
labrava_init( void )
{
    cvmax(oplava, PSD_ON); /* MRIhc22382  */
    cvmax(opvibrant, PSD_ON);

    cvmax(vibrantxv_flag, PSD_OFF);

    /* Activate LAVA flag */
    if( (exist(oppseq) == PSD_SPGR) &&
        (existcv(oplava) && (PSD_ON == exist(oplava))) && (PSD_OFF == exist(opmedal)) ) {
        cvoverride(lava_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
    } else {
        cvoverride(lava_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
    }
    
    /* Activate Axial VIBRANT flag */
    if( (PSD_SPGR == exist(oppseq)) &&
        (existcv(opvibrant) && (PSD_ON == exist(opvibrant)))  && (PSD_OFF == exist(opmedal)) &&
        ((existcv(opplane) && (PSD_AXIAL == exist(opplane))) || aspir_override) ) { 
        cvoverride(brava_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
        if ( (B0_30000 == (int)cffield) && !aspir_override )
        {
            cvmax(vibrantxv_flag, PSD_ON);
        }
    } else {
        cvoverride(brava_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
    }

    /* Activate Sagittal VIBRANT flag */
    if( (PSD_SPGR == exist(oppseq)) &&
        ((existcv(opplane) && (PSD_SAG == exist(opplane))) && !aspir_override) &&
        (existcv(opvibrant) && (PSD_ON == exist(opvibrant)))  && (PSD_OFF == exist(opmedal)) ) {
        cvoverride(vibrant_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
    } else {
        cvoverride(vibrant_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
    }

    asset_supported_direction = ASSET_SUPPORT_PHASE;
    /*ZZ: brava with aspir_override for Sag VIBANT ASPIR*/
    if( ((PSD_ON == vibrant_flag) ||
         ((PSD_SAG==opplane) && brava_flag && aspir_override))
        && (cfaccel_sl_maxstride > 1.0) )
    {
        if( PSD_ON == exist(opassetscan) )
        {
            /* For Sag VIBRANT, use Slice ASSET if available */
            accel_sl_defstride = FMin(2, 2.0, cfaccel_sl_maxstride);
            asset_supported_direction = ASSET_SUPPORT_SLICE;
        }
        else if( arc_flag && (cfaccel_ph_maxstride <= 1.0) )
        {
            /* 
             * In case of HDBreast, Cor is 4x1, Axial is 4x1, Sag is 1x4
             * for ARC.  If there's phase acceleration, go 2x1, if there is
             * no phase acceleration and only slice acceleration is
             * available, use 1x2
             */
            accel_sl_defstride = FMin(2, 2.0, cfaccel_sl_maxstride);
        }
        else 
        {
            accel_sl_defstride = 1.0;
        }
    }

    return SUCCESS;
}   /* end labrava_init() */

STATUS
bravo_init ( void )
{
    /* Currently, no option key check */
    cvmax(opbravo, PSD_ON);

    /* Activate BRAVO flag */
    if( existcv(opbravo) && (PSD_ON == exist(opbravo)) ) {
        cvoverride(bravo_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
    } else {
        cvoverride(bravo_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
    }

    return SUCCESS;
}    /* end bravo_init() */

/**********************************************************************/
STATUS
arc_init( void )
{
 
    cvoverride(arc_research_flag, PSD_OFF, PSD_FIX_OFF, PSD_EXIST_ON);
    cal_shape = CROSS_CAL;
    ktarc_flag = PSD_OFF;

    if ( ( (Present == BRAVOKey) && exist(opbravo) ) ||
         ( (Present == FiestaCKey) && exist(opphasecycle) ) ||
         (merge_flag && !swan_flag) )
    {
        cvmax(arc_flag, PSD_ON);
        cal_shape = CROSS_CAL;
    }
    else if ( ( (Present == VIBRANTDEKey) && exist(opvibrant) && exist(opmedal) ) ||
              ( (Present == COSMICKey) && exist(opcosmic) ) ||
              ( (Present == QUICKSTEPKey) && exist(opquickstep) ) ||
              idealiq_flag ||
              disco_flag )
    {
        cvmax(arc_flag, PSD_ON);
        cal_shape = ELLIPTICAL_CAL; 
    }
    else if ( ( (Present == LAVAXVKey) && exist(oplava) ) ||
              ( medal_flag && !exist(opvibrant) ) )
    {
        cvmax(arc_flag, PSD_ON);

        if (pfkr_yz_flag)
        {
            cal_shape = ELLIPTICAL_CAL;
        }
        else
        {
            cal_shape = CROSS_CAL;
        }
    }
    else if ( (BREAST2Key == Present) && brava_flag &&
              (( B0_30000 == (int)cffield ) || (aspir_override && (PSD_SAG == opplane))))
    {
        cvmax(arc_flag, PSD_ON);
        cal_shape = (pfkr_yz_flag) ?  ELLIPTICAL_CAL : CROSS_CAL;
    }
    else if ( (exist(oppseq) == PSD_TOF) || (exist(oppseq) == PSD_TOFSP) )
    {
        if( (!value_system_flag) && (!vast_mode) && (!ugfsf_flag) )
        {
             cvmax(arc_flag, PSD_ON);
             if (turbo_cemra_flag)
             {
                 cal_shape = ELLIPTICAL_CAL;
             } else if ( (exist(opfat) == PSD_ON) || (exist(opspecir) == PSD_ON) || 
                  (exist(opirprep) == PSD_ON) || (exist(opwater) == PSD_ON) || 
                  (exist(opsatx) == PSD_ON) || (exist(opsaty) == PSD_ON) || (exist(opsatz)  == PSD_ON) )
             {
                  cal_shape = CROSS_CAL;
             } else {
                  cal_shape = BOX_CAL;
             }
        }
    }
    else if ( ((Present == cine3DKey) && cine3d_flag) || ( (Present == flow4DKey) && flow4D_flag) )
    {
        cal_shape = ELLIPTICAL_CAL ;
        ktarc_flag = PSD_ON;
    }
    else
    {
        cvmax(arc_flag, PSD_OFF);
    }

    if (BOX_CAL == cal_shape)
    {   
        arc_ph_mincalwidth = 36;
        arc_sl_mincalwidth = (arc_sl_stride >= 3) ? 28 : 24;  
    }
    else if (ELLIPTICAL_CAL == cal_shape)
    {
        if (pfkr_yz_flag || turbo_cemra_flag)
        {
            arc_ph_mincalwidth = 24;
            arc_sl_mincalwidth = 24;
        }
        else
        {
            arc_ph_mincalwidth = (osfp_flag) ? 72 : 32;
            arc_sl_mincalwidth = (osfp_flag) ? 40 : 32;
        }
    }
    else 
    {
        arc_ph_mincalwidth = (arc_ph_stride >= 3) ? 28 : 24;
        arc_sl_mincalwidth = (arc_sl_stride >= 3) ? 28 : 24; 
    }
    
    /* Note on ARC modes:
       arc_flag is set for all ARC scans
       arc_research_flag is set for research psd (through type-in)
       Phase and slice accelleration factors specified using UserCVs
    */
 

    if ( (PSD_ON == exist(oparc)) && (ktarc_flag == PSD_OFF) )
    {
        cvoverride(arc_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
    }
    else
    {
        cvoverride(arc_flag, PSD_OFF, PSD_FIX_OFF, PSD_EXIST_ON);
    }

    autocal_mode = ACCEL_ARC; /* Initialize to ARC */
    if ( !strncmp("efgre3darc",psd_name,10)
         && (ARCKey == Present) && (PSD_ON == exist(opresearch)) )
    {
        cvoverride(oparc, PSD_ON, PSD_FIX_OFF, PSD_EXIST_ON);
        cvmax(arc_flag, PSD_ON);
        cvoverride(arc_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
        cvoverride(arc_research_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);

        /* For efgre3darc type in PSD, we dont get limits from Host. We
         * set it here, accordingly set it for avmaxaccel variables too
         * */
        autocal_mode = ACCEL_ARC;
    }
    else
    {
        cvoverride(arc_research_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
    }
    
    return SUCCESS;
}   /* end arc_init() */


STATUS disco_init( void )
{
    cvmax(opdisco, PSD_ON);

    if (existcv(opdisco) && exist(opdisco))
    {
        cvoverride(disco_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
    }
    else
    {
        cvoverride(disco_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
    }
    
    if (disco_flag)
    {
        /* DISCO uses elliptical view order */
        cvoverride(ellipt_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
        cvoverride(opdynaplan, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
        cvoverride(opmph, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
    }

    return SUCCESS;
}   /* end disco_init() */


STATUS cine3d_init( void )
{
    cvmax(op3dcine_fiesta, PSD_ON);
    cvmax(op3dcine_spgr, PSD_ON);
    cvmax(op4dflow, PSD_ON);

    if ( ((exist(op3dcine_fiesta)==PSD_ON) && existcv(op3dcine_fiesta)) ||
        ((exist(op3dcine_spgr) == PSD_ON) && existcv(op3dcine_spgr)) ||
        ((exist(op4dflow)==PSD_ON) && existcv(op4dflow)) )
    {
        cvoverride(cine3d_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
        ktarc_flag = PSD_ON;
        if (exist(op3dcine_fiesta)==PSD_ON) {
           /* Scan sets opfast=1, oppseq=4 (ssfp) */
            cvoverride(flow4D_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
            nflow4D = 1;
        } else if (exist(op3dcine_spgr) == PSD_ON) {
            /* Scan sets opfast=1, oppseq=5 (spgr) */
            cvoverride(flow4D_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
            nflow4D = 1;
        } else if (exist(op4dflow)==PSD_ON) {
           /* Scan sets opfast=1, oppseq=7 (pc) */
            cvoverride(flow4D_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
            nflow4D = 4;
         } else { /*we should never be here */
              epic_error(0, "Invalid Application Selection",
                      0, EE_ARGS(0) );
              return FAILURE;
         }
    }
    else
    {
         cvoverride(cine3d_flag, PSD_OFF, PSD_FIX_OFF, PSD_EXIST_ON);
         cvoverride(flow4D_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
         nflow4D = 1;
         ktarc_flag = PSD_OFF;
    }
    return SUCCESS;
}   /* end cine3d_init() */

STATUS
quickstep_init( void )
{
    cvmax(opquickstep, PSD_ON); /* MRIhc28474 */

    if( /*(exist(oppseq) == PSD_TOFSP) && */
        (existcv(opquickstep) && (PSD_ON == exist(opquickstep))) ) {
        cvoverride(quickstep_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
        cvoverride(ns3d_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
    } else {
        cvoverride(quickstep_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
    }

    return SUCCESS;
}   /* end quickstep_init() */

STATUS
cosmic_init( void )
{
    cvmax(opcosmic, PSD_ON); /* MRIhc16236 */

    if( (exist(oppseq) == PSD_SSFP) &&
        (existcv(opcosmic) && (PSD_ON == exist(opcosmic))) ) {
        cvoverride(osfp_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
    } else {
        cvoverride(osfp_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
    }

    return SUCCESS;
}   /* end cosmic_init() */

STATUS
vstrte_init( void )
{
    if( (exist(opfov) >= 480) && (exist(opflip) <= 1.0) &&
        ((exist(opslquant) * exist(opslthick)) > 400.0) &&
        (exist(opslthick) >= 15.0) && (exist(opetl)==1) && (1 == exist(opfphases)) &&
        (exist(opvquant)==1) &&
        ((exist(oppseq) == PSD_TOFSP) || (exist(oppseq) == PSD_TOF) || (exist(oppseq) == PSD_SSFP) ||
        ((exist(oppseq) == PSD_GE) && ((VALUE_SYSTEM_SVEM == value_system_flag) || (VALUE_SYSTEM_SVDM == value_system_flag)))) && /* SVBranch, HCSDM00112662 - WJZ */
        !lava_flag && !brava_flag && !vibrant_flag && !specir_flag &&
        !irprep_flag && !medal_flag && !merge_flag && !ideal_flag &&
        !msde_flag &&
        !ftmra_flag && !maskv_ftmra_flag && !idealiq_flag ) {
        vstrte_flag = 1;
        if(PSD_ON == minseqrf_cal)
        {
            rfb1opt_flag = 2;
        }
        else
        {
            rfb1opt_flag = 1; /* Looks like HDx has it as 0, 
                                 but lot of it has changed hence keeping it as 1*/
        }
        rf1_pulse_type = RF_HARD24;
        tlead = 12us;
        psd_grd_wait = 60us;
        if (ssfp_flag) {
           config_update_mode = CONFIG_UPDATE_TYPE_VSTRTE_DEFAULT;
        } else {
           config_update_mode = CONFIG_UPDATE_TYPE_VSTRTE_AMP20SR150;
        }
    } else {
        vstrte_flag = 0;
        config_update_mode = CONFIG_UPDATE_TYPE_DVW_DEFAULT;
    }

    if( FAILURE == inittargets(&loggrd, &phygrd) ) {
        return FAILURE;
    }

    return SUCCESS;
}   /* end ustrte() */


STATUS
multiEcho_init( void )
{
    bridge_gxw2_gxwex_3dde = PSD_OFF;

    if ( PSD_SR200 == cfsrmode ) 
    {   /* XRMB */
        ogsfMax = 0.9;
    } else {
        ogsfMax = 1.0;
    }

    if ( value_system_flag == VALUE_SYSTEM_HDE )
    {   /* YMSmr11391 */
        ogsfMin = 0.3;
    } else {
        ogsfMin = 0.2;
    }

    /* MRIhc16353 - RV: IDEAL change */
    if(Present == IDEAL3DKey) {
        cvmax(opdixon, PSD_ON);
    } else if (exist(opdixon)){ /* MRIhc32324 */
        cvmax(opdixon, PSD_OFF);
    }

    if ( existcv(opidealiq) && (PSD_ON==exist(opidealiq)) )
    {
        cvoverride(idealiq_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
    }
    else
    {
        cvoverride(idealiq_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
    }

    if(existcv(opdixon) && (exist(opdixon) == PSD_ON) && (!idealiq_flag)) {
        cvoverride(ideal_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
    }

    if ((Present == LAVADEKey) || (Present == VIBRANTDEKey) || (Present == DISCOKey)) 
    {
        cvmax(opmedal,PSD_ON);
    }
    else
    {
        cvmax(opmedal,PSD_OFF);
    }

    if (disco_flag)
    {
        cvoverride(disco_1echo_flag, !exist(opmedal), PSD_FIX_ON, PSD_EXIST_ON);
    }
    else
    {
        cvoverride(disco_1echo_flag, PSD_OFF, PSD_FIX_OFF, PSD_EXIST_OFF);
    }
  
    if( (exist(oppseq) == PSD_GE) && 
        ((existcv(opmerge) && (PSD_ON == exist(opmerge))) || (existcv(opswan) && (PSD_ON == exist(opswan)))) ) {
        cvoverride(merge_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
    } else {
        cvoverride(merge_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
    }

    if( (existcv(opswan) && (PSD_ON == exist(opswan))) ) {
        cvoverride(swan_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
        cvoverride(spgr_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
    } else {
        cvoverride(swan_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
    }

    if (merge_flag) 
    {
       cvoverride(opfcomp,PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
       if( existcv(opautote) && (PSD_OFF == exist(opautote)) && existcv(opte) ) {
           merge_targetTE = exist(opte);
       }
       else
       {
           if (cffield < B0_30000)
           {
               if (swan_flag)
                   merge_targetTE = SWAN_TE_1HT;
               else
                   merge_targetTE = MERGE_TE_1HT;
           }
           else
           {
               if (swan_flag)
                   merge_targetTE = SWAN_TE_3T;
               else
                   merge_targetTE = MERGE_TE_3T;
           }
       }
    } 

    if (merge_flag)
    {
       cvoverride(flextr_flag,PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
       cvoverride(flexte_flag,PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
    } else {
       cvoverride(flextr_flag,PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
       cvoverride(flexte_flag,PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
    }

    if ( ( (exist(oppseq) == PSD_SPGR) || (exist(oppseq) == PSD_GE) )  &&
         (PSD_OFF == (exist(opectricks) || exist(opswift) || exist(opmerge) || exist(opswan)) ) &&
         (existcv(opmedal) && (PSD_OFF == exist(opmedal))) && !idealiq_flag &&
         (exist(opnecho)==2) ) {
        cvoverride(de3d_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
    } else {
        cvoverride(de3d_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
    }

    if( existcv(opmedal) && (PSD_ON == exist(opmedal)) ) {
        cvoverride(medal_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
    } else if ( PSD_ON == de3d_flag ) {
        cvoverride(medal_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
    } else {
        cvoverride(medal_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
    }

    if (medal_flag)
    {
       /* "Flex" is imaging option, and oplava and opmedal are both ON */
       if (PSD_OFF == exist(opmedal))
       {
           cvoverride(oplava, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
       }
       cvoverride(lava_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
       cvoverride(brava_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
       cvoverride(vibrant_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
       cvoverride(opspecir, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
       if(value_system_flag == VALUE_SYSTEM_HDE) {
           aTEopt_flag = PSD_OFF; /* HDe2 does not use adaptive TE optimization */
           bridge_gxw2_gxwex_3dde = PSD_ON;
       } else {
           aTEopt_flag = PSD_ON;
           bridge_gxw2_gxwex_3dde = PSD_OFF;
       }
    }

    if ( (!strncmp("efgre3dME",psd_name,9)) || ((exist(opetl)>=3) && !merge_flag && !ideal_flag) || idealiq_flag )
    {
       multiEcho_flag = PSD_ON;
    }
    else
    {
       multiEcho_flag = PSD_OFF;
    }

    if(ideal_flag) {
        pite1nub = 6;
        pite1val2 = PSD_MINIMUMTE;
        pite1val3 = PSD_MINFULLTE;
        /* MRIhc23627, MRIhc25344 */
        pisupnub = 0;
    } else if(medal_flag) {
        cvoverride(ideal_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
        pite1nub = 6;
        pite1val2 = PSD_MINIMUMTE;
        pite1val3 = PSD_MINFULLTE;
        /* MRIhc23627, MRIhc25344 */
        pisupnub = 0;
    } else if (cine3d_flag)  {
        if ( ((exist(op4dflow)==PSD_ON)) || (exist(op3dcine_spgr) == PSD_ON) )
        {
           pisupnub = 1;
           pichemsatopt = 4;
           intermittant_chemsat = PSD_ON;
        }
        else
        {
           pisupnub = 0;
           pichemsatopt = 0;
           intermittant_chemsat = PSD_OFF;
        }
    }
    else
    {
        cvoverride(ideal_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
        /* MRIhc23627, MRIhc25344 */
        pisupnub = 1;
    }

    /* RV: MRIhc19003 - Added IDEAL off condition to avoid Advisory Panel
       Error with Respiratory Triggering/Gating Imaging Option and IDEAL */
    if (lava_flag || brava_flag || bravo_flag || vibrant_flag || vast_mode ||
                  ssfp_flag || osfp_flag || headneck_pos_scan ||
                  ( ((exist(oppseq) == PSD_TOF) || (exist(oppseq) == PSD_TOFSP)) && !tricks_flag ) ||
                  (exist(opcgate) == PSD_ON) || ((exist(oprtcgate) == PSD_ON) && (PSD_OFF == ideal_flag))) {
       avminnecho = 1;
       avmaxnecho = 1;
       piechnub = 0;
       piechdefval = 1;   /* default value */ 
       _opnecho.fixedflag = PSD_FIX_ON; /* HCSDM00172035 */
    }
    else if (idealiq_flag)
    {
       avminnecho = 1;
       avmaxnecho = 16;
       avminnshots = 1;
       avmaxnshots = 16;

       /* SVBranch, HCSDM00118534 */
       if( (VALUE_SYSTEM_SVEM == value_system_flag) ||
           (VALUE_SYSTEM_SVDM == value_system_flag) )
       {
           avmaxnshots = 1;
           cvmax(opnshots, 1);
       }
       piechnub = 0;
       piechdefval = 6;   /* default value */ 
    }
    else if (multiEcho_flag)
    {
       avminnecho = 1;
       avmaxnecho = MAX_ECHOES;
       piechnub = avmaxnecho;
       piechnub = 1+2+4+8+16+32; /* allow type-in & pull down */
       piechdefval = 1;   /* default value */ 
    }
    else if (merge_flag)
    {
       uniPolar_flag = merge_flag;
       avminnecho = 3;
       avmaxnecho = MAX_ECHOES;
       piechnub = 0;
       piechdefval = 3;   /* default value */
    }
    else if (medal_flag)
    {
       avminnecho = 1;
       avmaxnecho = 2;
       if (exist(opmedal)) {
          piechnub = 0;
       } else {
          piechnub = 2+4;
       }
       piechdefval = 1;   /* default value */ 
    }
    else if (ideal_flag)
    {
       avminnecho = 3;
       avmaxnecho = 3;
       piechnub = 0;
       piechdefval = 3;   /* default value */ 
    }
    else if (tricks_flag)
    {
       avminnecho = 1;
       avmaxnecho = MAX_ECHOES;
       piechnub = 0;
       opautonecho = PSD_OFF;
       piechdefval = 1;   /* default value */ 
    }
    else
    {
       if ( ((exist(oppseq) == PSD_SPGR) || (exist(oppseq) == PSD_GE)) &&
             ((exist(opmultistation)==PSD_ON) || (exist(opfluorotrigger)==PSD_ON) ||
              (exist(opsmartprep)==PSD_ON) || (exist(opirprep)==PSD_ON) ||
              (!value_system_flag && exist(opassetscan)==PSD_ON) ||
              msde_flag) )
       {
           avminnecho = 1;
           avmaxnecho = 1;
           piechnub = 0;
       } else {
           avminnecho = 1;
           avmaxnecho = 2;
           piechnub = 2+4;
       }
       piechdefval = 1;   /* default value */ 

       /* cvoverride(opnecho, 1, PSD_FIX_OFF, PSD_EXIST_ON); */ /* HCSDM00172035 */
       opnecho = 1;
       _opnecho.existflag = PSD_EXIST_ON;
    }

    if (idealiq_flag)
    {
       pishotnub = 1+2+4+8+16;
       pishotval2 = 1;
       pishotval3 = 2;
       pishotval4 = 3;
       pishotval5 = 4;
       /* SVBranch, HCSDM00118534 */
       if( (VALUE_SYSTEM_SVEM == value_system_flag) ||
           (VALUE_SYSTEM_SVDM == value_system_flag) )
       {
           pishotnub = 2;
       }
    }
    else
    {
       pishotnub = 0;
    }

    /* MRIhc16353 - RV: IDEAL change */
    if( (PSD_ON == ideal_flag) ||  (PSD_ON == tricks_flag) || (PSD_ON == cine3d_flag) )
    {
       cvmin(opetl,1);
       cvmax(opetl,1);
       cvdef(opetl,1);
    }
    else
    {
       if(idealiq_flag)
       {
           cvmin(opetl,1);
           cvmax(opetl,avmaxnecho);
           cvdef(opetl,3);
       }
       else
       {
           cvmin(opetl,avminnecho);
           cvmax(opetl,avmaxnecho);
           cvdef(opetl,avmaxnecho);
       }
    }

    /* RV: MRIhc19003 - Do not impose cvmin or cvmax of opnecho for IDEAL */
    if(PSD_OFF == ideal_flag) {
       cvmin(opnecho,avminnecho);
       cvmax(opnecho,avmaxnecho);
       cvdef(opnecho,avmaxnecho);
    }

    if (PSD_ON == ideal_flag) {
        cvdef(opdixproc, 3);
        rhrcideal = IDEAL_ON_OFF_FLAG;
        pidixproc = 1;
    } else if (idealiq_flag) {
        cvdef(opdixproc, 15);
        rhrcideal = IDEAL_ON_OFF_FLAG;
        pidixproc = 1;
    } else if (PSD_ON == medal_flag) {
        cvdef(opdixproc, 3);
        pidixproc = 1;
        rhrcideal = 0;
    } else {
        cvdef(opdixproc, 0);
        /* RV: MRIhc19003 - Ensure that opdixproc value is reset to default value of 0 */
        cvoverride(opdixproc, 0, PSD_FIX_ON, PSD_EXIST_ON);
        pidixproc = 0;
        rhrcideal = 0;
    }

    if (merge_flag||medal_flag||multiEcho_flag) {
       pfkr_flag = PSD_ON;
    }

    if (idealiq_flag)
    {
        float pi_esp;

        dix_freq = FATWATER_MPFREQ_1_5T * cffield/B0_15000;
        pi_esp = 1.0s/dix_freq/2;
        idealiq_min_esp = (int)(IDEALIQ_MIN_ESP_COEFF * pi_esp);
        idealiq_max_esp = (int)(IDEALIQ_MAX_ESP_COEFF * pi_esp);

        if(B0_15000 == (int)cffield)
        {
            idealiq_pc_flag = PSD_OFF;
            cvdef(opnshots, 1);
            opnshots = 1;
        }
        else
        {
            idealiq_pc_flag = PSD_ON;
            cvdef(opnshots, 2);
            opnshots = 2;
        }
    }

    return SUCCESS;
}

STATUS
multiEcho_eval( void )
{
    if(Present == IDEAL3DKey) {
       cvmax(opdixon, PSD_ON);
    } else if (exist(opdixon)){ /* MRIhc32324 */    
       cvmax(opdixon, PSD_OFF);
    }
    
    if ( ( (exist(oppseq) == PSD_SPGR) || (exist(oppseq) == PSD_GE) )  &&
           (PSD_OFF == (exist(opectricks) || exist(opswift) || exist(opmerge) || exist(opswan)) ) && 
           (existcv(opmedal) && (PSD_OFF == exist(opmedal))) && !idealiq_flag &&
           (exist(opnecho)==2) ) {
        cvoverride(de3d_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
    } else {
        cvoverride(de3d_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
    }

    if( (PSD_ON == de3d_flag) || (existcv(opmedal) && (PSD_ON == exist(opmedal))) ) {
        cvoverride(medal_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
    } else {
        cvoverride(medal_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
    }

    if(existcv(opdixon) && (exist(opdixon) == PSD_ON) && (!idealiq_flag)) {
        cvoverride(ideal_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
        ideal_necho = 3;
        pite1nub = 6;
        pite1val2 = PSD_MINIMUMTE;
        pite1val3 = PSD_MINFULLTE;
        /* MRIhc23627, MRIhc25344 */
        pisupnub = 0;
    } else if(idealiq_flag) {
        cvoverride(ideal_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
        ideal_necho = 1;
        pite1nub = 6;
        pite1val2 = PSD_MINIMUMTE;
        pite1val3 = PSD_MINFULLTE;
        pisupnub = 0;
    } else if(medal_flag) {
        cvoverride(ideal_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
        ideal_necho = 1;
        pite1nub = 6;
        pite1val2 = PSD_MINIMUMTE;
        pite1val3 = PSD_MINFULLTE;

        /* MRIhc23627, MRIhc25344 */
        pisupnub = 0;
    } else {
        cvoverride(ideal_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
        cvoverride(opdixproc, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
        ideal_necho = 1;
        /* MRIhc23627, MRIhc25344 */
        pisupnub = 1;
    }

    if( (PSD_ON == ideal_flag) ||  (PSD_ON == tricks_flag) )
    {
       cvoverride(opetl,1,PSD_FIX_ON,PSD_EXIST_ON);
       etl_override = PSD_ON;
    }
    else if(idealiq_flag)
    {
        if(etl_override)
        {
            cvoverride(opetl, 3, PSD_FIX_OFF, PSD_EXIST_OFF);
            etl_override = PSD_OFF;
        }
    }
    else if(medal_flag) 
    {
       if (medal_multitr_flag) {
          cvoverride(medal_necho,2,PSD_FIX_ON,PSD_EXIST_ON);
          cvoverride(medal_etl,1,PSD_FIX_ON,PSD_EXIST_ON);
       } else {
          cvoverride(medal_necho,1,PSD_FIX_ON,PSD_EXIST_ON);
          cvoverride(medal_etl,2,PSD_FIX_ON,PSD_EXIST_ON);
       }
       cvoverride(opetl,medal_etl,PSD_FIX_ON,PSD_EXIST_ON);
       etl_override = PSD_ON;
    }
    else
    {
       cvoverride(opetl,exist(opnecho),PSD_FIX_ON,PSD_EXIST_ON);
       etl_override = PSD_ON;
    }

    if ( (!strncmp("efgre3dME",psd_name,9)) || ((exist(opetl)>=3) && !merge_flag && !ideal_flag) || idealiq_flag )
    {
       multiEcho_flag = PSD_ON;
    }
    else
    {
       multiEcho_flag = PSD_OFF;
    }

    /* RV: MRIhc19003 - Added IDEAL off condition to avoid Advisory Panel
       Error with Respiratory Triggering/Gating Imaging Option and IDEAL */
    if (lava_flag || brava_flag || bravo_flag || vibrant_flag || vast_mode ||
                  ssfp_flag || osfp_flag || headneck_pos_scan ||
                  ( ((exist(oppseq) == PSD_TOF) || (exist(oppseq) == PSD_TOFSP)) && !tricks_flag ) ||
                  (exist(opcgate) == PSD_ON) || ((exist(oprtcgate) == PSD_ON) && (PSD_OFF == ideal_flag)) ) {
       avminnecho = 1;
       avmaxnecho = 1;
       piechnub = 0;
    }
    else if (idealiq_flag)
    {
       avminnecho = 1;
       avmaxnecho = 16;
       avminnshots = 1;
       avmaxnshots = 16;

       /* SVBranch, HCSDM00118534 */
       if( (VALUE_SYSTEM_SVEM == value_system_flag) ||
           (VALUE_SYSTEM_SVDM == value_system_flag) )
       {
           avmaxnshots = 1;
           cvmax(opnshots, 1);
       }
       piechnub = 0;
       piechdefval = 6;   /* default value */ 
    }
    else if (multiEcho_flag)
    {
       avminnecho = 1;
       avmaxnecho = MAX_ECHOES;
       piechnub =  1+2+4+8+16+32;
    }
    else if (merge_flag)
    {
       uniPolar_flag = merge_flag;
       avminnecho = 3;
       avmaxnecho = MAX_ECHOES;
       piechnub = 0;
    }
    else if (medal_flag)
    {
       avminnecho = 1;
       avmaxnecho = 2;
       if (exist(opmedal)) {
          piechnub = 0;
       } else {
          piechnub = 2+4;
       }
    }
    else if (ideal_flag)
    {
       avminnecho = ideal_necho;
       avmaxnecho = ideal_necho;
       piechnub = 0;
    }
    else if (tricks_flag)
    {
       avminnecho = 1;
       avmaxnecho = MAX_ECHOES;
       piechnub = 0;
       opautonecho = PSD_OFF;
    }
    else if (disco_flag && disco_1echo_flag) /* disco single echo mode */
    {
        avminnecho = 1;
        avmaxnecho = 1;
        piechnub = 0;
    }
    else
    {
       if ( ((exist(oppseq) == PSD_SPGR) || (exist(oppseq) == PSD_GE)) &&
             ((exist(opmultistation)==PSD_ON) || (exist(opfluorotrigger)==PSD_ON) ||
              (exist(opsmartprep)==PSD_ON) || (exist(opirprep)==PSD_ON) ||
              (!value_system_flag && exist(opassetscan)==PSD_ON) ||
              msde_flag) )
       {
           avminnecho = 1;
           avmaxnecho = 1;
           piechnub = 0;
       } else {
           avminnecho = 1;
           avmaxnecho = 2;
           piechnub = 2+4;
       }
    }

    if (idealiq_flag)
    {
       pishotnub = 1+2+4+8+16;
       pishotval2 = 1;
       pishotval3 = 2;
       pishotval4 = 3;
       pishotval5 = 4;
       /* SVBranch, HCSDM00118534 */
       if( (VALUE_SYSTEM_SVEM == value_system_flag) ||
           (VALUE_SYSTEM_SVDM == value_system_flag) )
       {
           pishotnub = 2;
       }
       idealiq_nshots = exist(opnshots);
    }
    else
    {
       pishotnub = 0;
    }

    /* MRIhc16353 - RV: IDEAL change */
    if( (PSD_ON == ideal_flag) ||  (PSD_ON == tricks_flag) || (PSD_ON == cine3d_flag) )
    {
       cvmin(opetl,1);
       cvmax(opetl,1);
       cvdef(opetl,1);
    }
    else
    {
       if(idealiq_flag)
       {
           cvmin(opetl,1);
           cvmax(opetl,avmaxnecho);
           cvdef(opetl,3);
           /* SVBranch, HCSDM00118534 */
           if( (VALUE_SYSTEM_SVEM == value_system_flag) ||
               (VALUE_SYSTEM_SVDM == value_system_flag) )
           {
               cvmin(opetl,6);
               cvmax(opetl,6);
               cvdef(opetl,6);
           }
       }
       else
       {
           cvmin(opetl,avminnecho);
           cvmax(opetl,avmaxnecho);
           cvdef(opetl,avmaxnecho);
       }
    }

    if (merge_flag)
    {
       if( existcv(opautote) && (PSD_OFF == exist(opautote)) && existcv(opte) ) {
           merge_targetTE = exist(opte);
       }
       else
       {
           if (cffield < B0_30000)
           {
               if (swan_flag)
                   merge_targetTE = SWAN_TE_1HT;
               else
                   merge_targetTE = MERGE_TE_1HT;
           }
           else
           {
               if (swan_flag)
                   merge_targetTE = SWAN_TE_3T;
               else
                   merge_targetTE = MERGE_TE_3T;
           }
       }
    }

    /* RV: MRIhc19003 - Don't impose cvmin and cvmax of opnecho for IDEAL */
    if(PSD_OFF == ideal_flag) {
       cvmin(opnecho,avminnecho);
       cvmax(opnecho,avmaxnecho);
       cvdef(opnecho,avmaxnecho);
    }

    if(PSD_ON == ideal_flag)
    {
       ideal_opt_te = 1;
       if (spgr_flag == PSD_ON) {
          ideal_echo_mode = 0;
       } else {
          ideal_echo_mode = 1;
       }
       if (ideal_echo_mode == 1) { /* seq mode - do echo loop on outer loop */
          seq_necho = ideal_necho;
          inter_necho = 1;
          threedpktdly = arc_equant*(rhnframes+ rhhnover);
       } else {  /* interleaved mode - do echo on inner loop */
          seq_necho = 1;
          inter_necho = ideal_necho;
          threedpktdly = 1;
       }
    }
    else if (idealiq_flag)
    {
        seq_necho = 1;
        inter_necho = idealiq_nshots;
        threedpktdly = 1;
    }
    else if (medal_flag && medal_multitr_flag)
    {
       medal_echo_mode = 0;
       ideal_opt_te = 0;
       medal_necho = 2;
       if (medal_echo_mode) {
          seq_necho = medal_necho;
          inter_necho = 1;
          threedpktdly = arc_equant*(rhnframes+ rhhnover);
       } else {
          seq_necho = 1;
          inter_necho = medal_necho;
          threedpktdly = 1;
       }
    }
    else
    {
       ideal_opt_te = 0;
       ideal_necho = 1;
       inter_necho = 1;
       seq_necho = 1;
       medal_necho = 1;
    }

    if(exist(opmedal)) {
        cvoverride(opnecho, (medal_necho*medal_etl), PSD_FIX_ON, PSD_EXIST_ON);
    } else if ((exist(oplava) == PSD_ON) || (exist(opvibrant) == PSD_ON) || (exist(opdisco) == PSD_ON)) {
        cvoverride(opnecho, 1, PSD_FIX_ON, PSD_EXIST_ON);
    }

    if(idealiq_flag)
    {
        if( existcv(opetl) && existcv(opnshots) && exist(opetl)*exist(opnshots)<=IDEALIQ_MAX_NECHO )
        {
            cvoverride(opnecho, exist(opnshots)*exist(opetl), PSD_FIX_ON, PSD_EXIST_ON);
        }
    }

    return SUCCESS;
}

/* *********************************************************************
   PREDOWNLOAD
   
   This section will be executed before a download.  Its purpose is to 
   execute all operations that are not needed for the advisory panel
   results.  All code created by the pulsegen macro exspansions for 
   the predownload section will be executed here.  All internal
   amplitudes, slice ordering, prescan slice calculation, sat placement
   calculation are done here.
   
   Setting up the time anchors also for pulsegen will be done here.
   ******************************************************************* */
STATUS
predownload( void )
{
    /* MRIhc11575 - Added local variable zy_export */
    int slice;                      /* IR PREP (pjg) */
    int half_slice_sign;
    int i,j;
    int app_tr;
     
    /* SVBranch, HCSDM00092046 */     
    short viewtable1[1025];
    int slice1;
    int min_seqgrad_no, min_seqgrad_mps2, min_seqgrad_seq[500], y_index[30], z_index[30];
    int ii,jj, p_index, s_index;
    FILE *myf = NULL;

    /*  Use dynamic memory allocation for zy_export */
    ZY_EXPORT *zy_export = NULL;
    PARAM4D param4d;

@inline vmx.e PreDownLoad  /* vmx 12/28/94 YI */
 
    /* SVBranch, Smart Burst Mode */
    if(sbm_flag)
    {
        int changed_flag; /* backup get_cvs_changed_flag() */
        int min_seqgradtime, max_seqgradtime;  /* minimal/maximal min_seqgrad in all view and phase encoding */

        /* calculate number of sampled points in phase/slice encoding direction */
        sbm_z_num = (int)(equant/16.0 + 0.5);

        if(sbm_z_num < HEAT_Z_NUM_MIN)
        {
            sbm_z_num = HEAT_Z_NUM_MIN;
        }
        if(sbm_z_num > HEAT_Z_NUM_MAX)
        {
            sbm_z_num = HEAT_Z_NUM_MAX;
        }

        sbm_y_num = (int)(phaseres/16.0 + 0.5);

        if(sbm_y_num < HEAT_Y_NUM_MIN)
        {
            sbm_y_num = HEAT_Y_NUM_MIN;
        }
        if(sbm_y_num > HEAT_Y_NUM_MAX)
        {
            sbm_y_num = HEAT_Y_NUM_MAX;
        }

        if(sbm_debug)
        {   
            myf = fopen("/usr/g/service/log/sbm_minseqgrad.txt", "w");
            /* SVBranch, HCSDM00300336 */
            if( NULL == myf)
            {
                epic_error(0,"file %s open failed.",
                           0,EE_ARGS(1),INT_ARG, "/usr/g/service/log/sbm_minseqgrad.txt");
                return FAILURE;
            }
        }


        /* setup view/slice encoding amplitude to keep consistent as scan() */
        setupphasetable(viewtable1, TYPNORM, phaseres);
        for (slice1 = 0; slice1 < equant; slice1 ++)
        {
            volumetab[slice1] = (((float)slice1*(a_comb - a_end)/
                                     (float)(equant-1) - a_comb)/loggrd.tz)*max_pg_iamp;

            volumetab2[slice1] = (((float)slice1*(-a_comb2 + a_end2)/
                                  (float)(equant-1) + a_comb2)/loggrd.tz)*max_pg_iamp;
        }

        changed_flag = get_cvs_changed_flag();
        set_cvs_changed_flag(TRUE);  /* to make minseq() work */


        /* calculate min_seqgrad for waiting sequence */
        sbm_gx1_scale = 0.0;
        sbm_gxw_scale = 0.0;
        sbm_gxwex_scale = 0.0;
        sbm_gy1_scale = 0.0;
        sbm_gy1r_scale = 0.0;
        sbm_gzcomb_scale = volumetab[equant/2] / ((fabs(a_gzcomb)/loggrd.tz)*(float)max_pg_iamp);
        sbm_gzp_scale = volumetab2[equant/2] / ((fabs(a_gzp)/loggrd.tz)*(float)max_pg_iamp);

        if ( FAILURE == minseq( &min_seqgrad_no,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, idx_seqcore, tsamp, tmin,
                                use_ermes, seg_debug ) )
        {
            epic_error( use_ermes, "minseq failed.",
                        EM_PSD_ROUTINE_FAILURE, EE_ARGS(1),
                        STRING_ARG, "minseq" );
            return FAILURE;
        }

        if(sbm_debug)
        {
            fprintf(myf, "--------------------------min_seqgrad*** begin-------------------\n");
            fprintf(myf, "min_seqgrad_no=%d \n\n\n", min_seqgrad_no);
        }


        /* calculate min_seqgrad for sampled view and slice encoding.
           here, number of sampled points for slice encoding is sbm_z_num;
           number of sampled points for phase encoding is sbm_y_num;
           At result, total sbm_z_num * sbm_y_num points will be sampled */

        sbm_gx1_scale = 1.0;
        sbm_gxw_scale = 1.0;
        sbm_gxwex_scale = 1.0;

        min_seqgradtime = 100000000;
        max_seqgradtime = -1;


        for(ii = 0; ii < sbm_y_num; ii ++)
        {
            p_index = (int)( (float)ii*phaseres/(sbm_y_num-1) + 1.5 );
            if(p_index >= phaseres)
            {
               p_index = phaseres;
            }

            y_index[ii] = p_index-1;  /* if viewtable1 is from 1~256, zy_export is from 0~255 */

            for(jj = 0; jj < sbm_z_num; jj ++)
            {
                s_index = (int)( (float)jj*equant/(sbm_z_num-1) + 1.5 );
                if(s_index >= equant)
                {
                    s_index = equant;
                }

                z_index[jj] = s_index-1;

                sbm_gy1_scale = viewtable1[p_index] / (float)endview_iamp;
                sbm_gy1r_scale = sbm_gy1_scale;
                sbm_gzcomb_scale = volumetab[s_index-1] / (fabs(a_gzcomb)/loggrd.tz*(float)max_pg_iamp);
                sbm_gzp_scale = volumetab2[s_index-1] / (fabs(a_gzp)/loggrd.tz*(float)max_pg_iamp);

                if ( FAILURE == minseq( &(min_seqgrad_seq[sbm_z_num*ii+jj]),
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, idx_seqcore, tsamp, tmin,
                                use_ermes, seg_debug ) )
                {
                    epic_error( use_ermes, "minseq failed.",
                            EM_PSD_ROUTINE_FAILURE, EE_ARGS(1),
                            STRING_ARG, "minseq" );
                    return FAILURE;
                }

                if(min_seqgrad_seq[sbm_z_num*ii+jj] > max_seqgradtime)
                {
                    max_seqgradtime = min_seqgrad_seq[sbm_z_num*ii+jj];
                }

                if(min_seqgrad_seq[sbm_z_num*ii+jj] < min_seqgradtime)
                {
                    min_seqgradtime = min_seqgrad_seq[sbm_z_num*ii+jj];
                }

                if(sbm_debug)
                {
                    fprintf(myf, "gy1_scale=%f, gy1r_scale=%f, gzcomb_scale=%f, gzp_scale=%f, seq%d=%d  \n ",
                            sbm_gy1_scale,sbm_gy1r_scale,sbm_gzcomb_scale,sbm_gzp_scale,sbm_z_num*ii+jj, min_seqgrad_seq[sbm_z_num*ii+jj]);
                }
            }
        }

        /* based on minimal and maximal min_seqgrad to optimize sbm_time_limit
           Basic principle:
           When heating is big, increase sbm_time_limt to reduce amount of "waiting period"
                                and keep IQ
           When heating is small, reduce sbm_time_limit to protect Hardware.
           At this situation, accumulated heating is difficult to reach limitation
           and cause long lead time. Reduce sbm_time_limit to shorten lead time. */

        if(tmin_total < min_seqgradtime)
        {
            sbm_time_limit = sbm_time_limit_max;
        }
        else if(tmin_total > max_seqgradtime)
        {
            sbm_time_limit = sbm_time_limit_min;
        }
        else
        {
            sbm_time_limit = sbm_time_limit_max +
                              ( ((sbm_time_limit_min - sbm_time_limit_max) / (max_seqgradtime-min_seqgradtime)) *
                                (tmin_total - min_seqgradtime) );
        }

        /* calculate min_seqgrad for aps2/mps2 imaging sequence */
        sbm_gx1_scale = 1.0;
        sbm_gxw_scale = 1.0;
        sbm_gxwex_scale = 1.0;
        sbm_gy1_scale = 0.0;
        sbm_gy1r_scale = 0.0;
        sbm_gzcomb_scale = volumetab[equant/2] / (fabs(a_gzcomb)/loggrd.tz*(float)max_pg_iamp);
        sbm_gzp_scale = volumetab2[equant/2] / (fabs(a_gzp)/loggrd.tz*(float)max_pg_iamp);

        if ( FAILURE == minseq( &min_seqgrad_mps2,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, idx_seqcore, tsamp, tmin,
                                use_ermes, seg_debug ) )
        {
                epic_error( use_ermes, "minseq failed.",
                            EM_PSD_ROUTINE_FAILURE, EE_ARGS(1),
                            STRING_ARG, "minseq" );
                return FAILURE;
        }

        if(sbm_debug)
        {
            fprintf(myf, "\n\n");
            fprintf(myf, "min_seqgrad_mps2=%d \n", min_seqgrad_mps2);
        }

        /* In APS2/MPS2, calculate TR number for imaging sequence */
        if(min_seqgrad_mps2 <= tmin_total)
        {
            sbm_mps2_imaging_num = SBM_MPS2_MAX_LOOP;
        }
        else
        {
            sbm_mps2_imaging_num = (int)((sbm_time_limit * 1000000.0) / (min_seqgrad_mps2 - tmin_total));
        }

        if(sbm_debug)
        {
            fprintf(myf, "--------------------------min_seqgrad** end-------------------\n\n");
            fclose(myf);
        }

        /* set all scales to turn off all phase/slice encoding to pass system safety check */
        sbm_gx1_scale = 0.0;
        sbm_gxw_scale = 0.0;
        sbm_gxwex_scale = 0.0;
        sbm_gy1_scale = 0.0;
        sbm_gy1r_scale = 0.0;
        sbm_gzcomb_scale = volumetab[equant/2] / (fabs(a_gzcomb)/loggrd.tz*(float)max_pg_iamp);
        sbm_gzp_scale = volumetab2[equant/2] / (fabs(a_gzp)/loggrd.tz*(float)max_pg_iamp);
        /* recover cvs_changed_flag */
        set_cvs_changed_flag(changed_flag);
    }
    else
    {
        sbm_gx1_scale = 1.0;
        sbm_gxw_scale = 1.0;
        sbm_gxwex_scale = 1.0;
        sbm_gy1_scale = 1.0;
        sbm_gy1r_scale = 1.0;
        sbm_gzcomb_scale = 1.0;
        sbm_gzp_scale = 1.0;
    }

 
    /* **************************************
       Image Header CVs
       ************************************** */
    slquant1 = slquant_per_trig;

    /* MRIhc16353 - RV: IDEAL change */
    if(PSD_ON == ideal_flag)
    {
       ideal_shift1 = ideal_te1 - act_te;
       ideal_shift2 = ideal_te2 - act_te;
       ideal_shift3 = ideal_te3 - act_te;
       ideal_shift_max = ideal_max - act_te;
    }

    if (medal_flag && medal_multitr_flag)
    {
       medal_shift1 = 0;
       medal_shift2 = medal_max - medal_min;
    }

    ihtr = act_tr + ((gating==TRIG_LINE) ? TR_SLOP : 0);

    if (merge_flag) {
        if (satview==1)
        ihtr += sp_sat*sp_sattime;
    }

    if (merge_flag) {
        if ( merge_echoIndex > 0 ) 
           ihte1 = act_te + (int) (merge_echoIndex*esp);
        if ( (pinecho>1) && (0==rhfiesta) && (exist(opetl) > 1) )
        {
           ihte1  = act_te;
           ihte2  = act_te + 1  * esp; 
           ihte3  = act_te + 2  * esp; 
           ihte4  = act_te + 3  * esp; 
           ihte5  = act_te + 4  * esp; 
           ihte6  = act_te + 5  * esp; 
           ihte7  = act_te + 6  * esp; 
           ihte8  = act_te + 7  * esp; 
           ihte9  = act_te + 8  * esp; 
           ihte10 = act_te + 9  * esp; 
           ihte11 = act_te + 10 * esp; 
           ihte12 = act_te + 11 * esp; 
           ihte13 = act_te + 12 * esp; 
           ihte14 = act_te + 13 * esp; 
           ihte15 = act_te + 14 * esp; 
           ihte16 = act_te + 15 * esp; 
        }
    } else {
            ihte1 = opte;
            ihte2  = act_te2;
            ihte3  = act_te2 + 1  * esp;
            ihte4  = act_te2 + 2  * esp;
            ihte5  = act_te2 + 3  * esp;
            ihte6  = act_te2 + 4  * esp;
            ihte7  = act_te2 + 5  * esp;
            ihte8  = act_te2 + 6  * esp;
            ihte9  = act_te2 + 7  * esp;
            ihte10 = act_te2 + 8  * esp;
            ihte11 = act_te2 + 9  * esp;
            ihte12 = act_te2 + 10 * esp;
            ihte13 = act_te2 + 11 * esp;
            ihte14 = act_te2 + 12 * esp;
            ihte15 = act_te2 + 13 * esp;
            ihte16 = act_te2 + 14 * esp;
    }

    /* MRIhc16353 - RV: IDEAL change */
    if(PSD_ON == ideal_flag)
    {
       ihte1 = ideal_te1;
       ihte2 = ideal_te2;
       ihte3 = ideal_te3;
       ihdixonte = (int)floorf((ihte1+ihte2+ihte3)/3.0);
       /*  MRIhc27316 */
       ihdixonipte = ihdixonte;
       ihdixonoopte = ihdixonte;
       if(PSD_ON == ideal_debug) {
	  /* RV: equiv of userCV 31 to userCV 39 in host recon code */
          ih_idealdbg_cv1 = 1;
          ih_idealdbg_cv3 = (float)(ideal_necho+1024*ideal_no_mag_im);
          ih_idealdbg_cv4 = (float)slicezp;
	  if(0 == opasset) {
	     ih_idealdbg_cv5 = (float)(1+(rhdab0e-rhdab0s));
	  }else {
	     ih_idealdbg_cv5 = 1.0;
	  }
	  ih_idealdbg_cv6 = (float)ideal_te1;
	  ih_idealdbg_cv7 = (float)ideal_te2;
	  ih_idealdbg_cv8 = (float)ideal_te3;
	  ih_idealdbg_cv9 = 0.0;
	  ih_idealdbg_cv10 = 0.0;
          if (exist(opphasefov)!=1.0) {
             int tmp_rhnframes;
             tmp_rhnframes = (int)(ceil( eg_phaseres * yfov_aspect * asset_factor /
                            2.0 ) * 2.0);
             ih_idealdbg_cv11 = (float)(int)((float)(tmp_rhnframes)/asset_factor + 0.5);
          } else {
             ih_idealdbg_cv11 = 0.0;
          }
       } else {
           ih_idealdbg_cv1 = 0;
           ih_idealdbg_cv2 = 0;
           ih_idealdbg_cv3 = 0;
           ih_idealdbg_cv4 = 0;
           ih_idealdbg_cv5 = 0;
           ih_idealdbg_cv6 = 0;
           ih_idealdbg_cv7 = 0;
           ih_idealdbg_cv8 = 0;
           ih_idealdbg_cv9 = 0;
           ih_idealdbg_cv10 = 0;
           ih_idealdbg_cv11 = 0;
        } 
    } else if(idealiq_flag) {
        int ihte[MAX_ECHOES];
        int i,j,k;
        int two_pi_te;
        int te_shift, min_te_shift;

        for(i=0;i<MAX_ECHOES;i++) {
           ihte[i]=0;
        }

        for (i=0;i<exist(opetl);i++) {
            for(j=0;j<idealiq_nshots;j++) {
                ihte[i*idealiq_nshots+j] = ihte1+i*esp + j*idealiq_esp;
            }
        }

        ihte2 = ihte[1];
        ihte3 = ihte[2];
        ihte4 = ihte[3];
        ihte5 = ihte[4];
        ihte6 = ihte[5];
        ihte7 = ihte[6];
        ihte8 = ihte[7];
        ihte9 = ihte[8];
        ihte10 = ihte[9];
        ihte11 = ihte[10];
        ihte12 = ihte[11];
        ihte13 = ihte[12];
        ihte14 = ihte[13];
        ihte15 = ihte[14];
        ihte16 = ihte[15];

        /* use average TE */
        ihdixonte = 0;
        for(i=0;i<exist(opnecho);i++) {
            ihdixonte += ihte[i];
        }
        ihdixonte = (int)(ihdixonte/exist(opnecho));

        ihdixonipte = ihdixonte;
        ihdixonoopte = ihdixonte;

        k = 0;
        idealiq_ps_echo = 0; 
        two_pi_te = (int)( 0.5 + (1.0s/dix_freq) ) ;
        min_te_shift = two_pi_te;
        /* find TE closest to in-phase for scan TR */
        while( ihte[k] < ihte[0]+two_pi_te )
        {
            te_shift = IMin(2, ihte[k]%two_pi_te, two_pi_te-(ihte[k]%two_pi_te));
            if(te_shift<min_te_shift)
            {
                min_te_shift = te_shift;
                idealiq_ps_echo = k; 
            }
            k++;
        }
    } else if(PSD_ON == medal_flag) {
       if (medal_multitr_flag) {
          int ihte[MAX_ECHOES];
          int i,j;

          for(i=0;i<MAX_ECHOES;i++) {
             ihte[i]=0;
          }

          for(i=0;i<medal_necho;i++) {
              for (j=0;j<medal_etl;j++) {
                  ihte[i*medal_etl+j] = ihte1+i*medal_shift2 + j*esp ;
              }
          }

          ihte2 = ihte[1];
          ihte3 = ihte[2];
          ihte4 = ihte[3];
          ihte5 = ihte[4];
          ihte6 = ihte[5];
          ihte7 = ihte[6];
          ihte8 = ihte[7];
          ihte9 = ihte[8];
          ihte10 = ihte[9];
          ihte11 = ihte[10];
          ihte12 = ihte[11];
          ihte13 = ihte[12];
          ihte14 = ihte[13];
          ihte15 = ihte[14];
          ihte16 = ihte[15];
       }

       if (rhmedal_echo_order) {
          ihdixonipte = ihte1;
          ihdixonoopte = ihte2;
       } else {
          ihdixonoopte = ihte1;
          ihdixonipte = ihte2;
       }
       ihdixonte = (int)floorf((ihte1+ihte2)/2.0);
    } else {
       ihdixonte = 0;
       ihdixonoopte = 0;
       ihdixonipte = 0;
    }

    if ( vstrte_flag )
    {
        ihtr = (int) 10.0*floor(ihtr/10.0);
        /* MRIhc16353 - RV: IDEAL change */
        if(PSD_OFF == ideal_flag)
        {
           ihte1 = (int) 10.0*floor(opte/10.0);
        }
    }

    if (ifir_flag)
    {
        ihbspti = opbspti;
        setexist(ihbspti, PSD_ON);

        if (PSD_ON == specir_flag)
        {
            ihti = opti;
            if (extraspecial_flag == PSD_ON)
            {
                ihti = min_specirti;
            }
            else
            {
                ihti = opti;
            }
            setexist(ihti, PSD_ON);
        }
        else
        {
            setexist(ihti, PSD_OFF);
        }
    } else {
        /* IR PREP (pjg) */
        if( (irprep_flag == PSD_ON) || (specir_flag == PSD_ON) )
        {
            ihti = opti;
            if (extraspecial_flag == PSD_ON) {
                ihti = min_specirti;
            } else {
                ihti = opti;
            }
            setexist(ihti,PSD_ON);
        }
        else
        {
            setexist(ihti,PSD_OFF);
        }
    }

    ihvbw1 = oprbw;

    ihvbw2 = oprbw;
    ihvbw3  = oprbw;
    ihvbw4  = oprbw;
    ihvbw5  = oprbw;
    ihvbw6  = oprbw;
    ihvbw7  = oprbw;
    ihvbw8  = oprbw;
    ihvbw9  = oprbw;
    ihvbw10 = oprbw;
    ihvbw11 = oprbw;
    ihvbw12 = oprbw;
    ihvbw13 = oprbw;
    ihvbw14 = oprbw;
    ihvbw15 = oprbw;
    ihvbw16 = oprbw;
    
    /* MRIhc16353 - RV: IDEAL change */
    if(PSD_ON == ideal_flag)
    {
       ihvbw2 = oprbw;
       ihvbw3 = oprbw;
    }

    ihflip = opflip;

    /* turn dither on for intern gating */
    if (gating == TRIG_INTERN)
        dither_on = PSD_ON;
    else
        dither_on = PSD_OFF;

    /* *************************
       Recon variables
       *********************** */  
    /* JAH: Fermi radius should always be set according to the distance
       from the center of K-space to the edge of k-space. This is opxres
       regardless of fractional echoes because whether natural full echo,
       zero-padded, or homodyned to full echo, we always have one complete
       half of k-space constituted by opxres/2 points. */

    fermi_rc = (float)(1.0 / 2.0);
    fermi_wc = (float)1.0;

    /* processing for ZIP 1024 :pradeeps@wiproge */
    /* Only extend the Fermi radius for ZIP if the ZIP is unnatural;
       that is, if the acquisition would not be automatically filled
       to the next power of 2 anyway. */

    if ((recon_1024 == PSD_ON) && (rhmeth == 1 ))  /* Homodyne */
    {
        if (fn == 0.5)
        {
            fermi_wc = (float)2.0;
        }
    }

    if ((recon_1024 == PSD_ON) && (rhmeth == 0 ))   /* Non- Homodyne */
    {
        if (fn == 0.5)
        {
            fermi_rc = (float)(27.0 / 64.0);
            fermi_wc = (float)2.0;
        }
        else
        {
            fermi_rc = (float)((double)exist(fermr_coef_1024) / 64.0);
        }
    }
    if( ((fn == 0.5) || (fn == 0.75)) && (tfe_extra > 0) )
    {
        fermi_rc = (float)(1.0 / 2.0);
    }

    /* PURE Mix */
    model_parameters.gre3d.de3d_flag = de3d_flag;
    model_parameters.gre3d.disco_flag = disco_flag;
    model_parameters.gre3d.irprep_flag = irprep_flag;
    model_parameters.gre3d.lava = exist(oplava);
    model_parameters.gre3d.phorder = phorder;
    model_parameters.gre3d.slorder = slorder;
    model_parameters.gre3d.spgr_flag = spgr_flag;

@inline loadrheader.e rheaderinit
@inline Asset.e AssetSetRhVars

    /* image intensity scaling */

    if ( (exist(opnopwrap) == PSD_ON) && (osfp_flag||pfkr_flag||pfkyz2kr_flag) )
       rhferme *= ((float) exist(opyres)) / ((float) eg_phaseres);
    
    if (pfkr_flag && (krfermecorr_factor < 1.0))
       rhferme /= krfermecorr_factor;

    rhfermr *= exist(opfreqfov);
    rhferme *= exist(opfreqfov);

    /* MRIhc18622 Identify VIBRANT scans for recon */
    rhvibrant = ((PSD_ON == brava_flag));

    /* Disable acquisition to disk feature on iVRF - LAVA-FLEX uses 2nd bit to control */
    if ( (exist(opvibrant) && exist(opmedal)) && !(0 < cfacqtodisksize) && (arc_flag) &&
        ((mph_flag) && !(exist(opdynaplan))) )
    {
        rhvibrant = 2;
    }

    
    /* MRIhc02932 -- turn off pure filter for tof scans */
    if( (exist(oppseq) == PSD_TOF) || (exist(oppseq) == PSD_TOFSP) ) {
        rhpurefilter = PSD_OFF;
    } else {
        rhpurefilter = PSD_ON;
    }

    rhscancent = piscancenter;

    rhnslices = exist(opslquant)*exist(opvquant)*exist(opfphases);

    if ( arc_flag && ((arc_sl_stride > 1.0) || (arc_ph_stride > 1.0)) ) {
        rhasset = ( (15 == arc_pack_bam) ? ACCEL_DVCARC : autocal_mode );
    }

    rhnpasses = acqs;
    rhnphases = 1;  /* MRIhc13690: Reset number of phases when switching applications */
    rhvquant = 1;

    rhchannel_combine_method = RHCCM_SUM_OF_SQUARES;
    rhchannel_combine_filter_type = RHCHANNEL_COMBINE_FILTER_TYPE_NONE;
    rhchannel_combine_filter_beta = 3.47;

    /* HCSDM00370378 */
    if(PSD_ON == annefact_c3_recon_flag)
    {
        rhchannel_combine_method = RHCCM_C3_RECON_FOR_MAG_PHASE_I_Q_IMAGES;
        rhchannel_combine_filter_type = RHCHANNEL_COMBINE_FILTER_TYPE_BESSEL;
        rhchannel_combine_filter_beta = 10.0;
        rhchannel_combine_filter_width = 0.1;
    }
    else if (PSD_ON == channel_combine_mode)
    {
        rhchannel_combine_method = RHCCM_C3_RECON_FOR_MAG_PHASE_I_Q_IMAGES;
        rhchannel_combine_filter_type = RHCHANNEL_COMBINE_FILTER_TYPE_BESSEL;
        rhchannel_combine_filter_beta = 2.0f;
        rhchannel_combine_filter_width = 0.1;
    }
    else
    {
        rhchannel_combine_method = RHCCM_SUM_OF_SQUARES;
        rhchannel_combine_filter_type = RHCHANNEL_COMBINE_FILTER_TYPE_NONE;
        rhchannel_combine_filter_beta = 3.47;
        rhchannel_combine_filter_width = 0.3;
    }

    /* HK for Fiesta-C */
    if( PSD_ON == pcfiesta_flag ) {
        
        rhfiesta = RHFIESTA_MIP;
        /* VAL15 12/14/2004 YI */
        if(pc_mode == PC_APC)
        {
            rhfiesta = RHFIESTA_AVE;
        }
        else if(pc_mode == PC_SGS)
        {
            rhfiesta = RHFIESTA_1ST_LAST;
            rhfiesta |= RHFIESTA_ECHO_DFT;
        }
        
        rhtype = rhtype | RHTYPCHP;

        eeff = 0;
        eepf = 0;
        oeff = 0;
        oepf = 0;

        rhnecho = exist(opnecho) * phase_cycles;
        if(pc_mode < PC_BASIC)rhnecho = truenex; /* VAL15 12/14/2004 YI */

        /* MRIhc36459 */
        rhrawsize = (n64)ceil((float)(1 + (rhbline * rawdata) + rhnframes + rhhnover)
                              * ((exnex * (float)(1-rawdata)) + (truenex * (float)rawdata)))
            * (n64)slquant1 * (n64)rhnecho * (n64)rhfrsize * (n64)(2*rhptsize);
    } 
    else 
    {
        if (merge_flag)
        {
           rhfiesta = RHFIESTA_RMS;
           if((PSD_OFF != exist(opphaseimage)) && (PSD_ON == existcv(opphaseimage)))
           {
               rhchannel_combine_filter_type = RHCHANNEL_COMBINE_FILTER_TYPE_BESSEL;

               rhchannel_combine_filter_width = 0.1;
               
               rhrcctrl |= RHRCPHS;
               
	       if(exist(opphaseimage)==2)
	       {
	          rhrcctrl |= RDB_PHASE_IM_INVERT;
	       }
	       else
	       {
		  rhrcctrl &= ~RDB_PHASE_IM_INVERT;
	       }

	       if(PSD_ON == phmask)
               {
	          rhtype1 |= RDB_PHASE_MASK;
	       }
               else
               {
                  rhtype1 &= ~RDB_PHASE_MASK;
               }
               
               /* Performs SOS combine of echos for magnitude
                  images and Average echo combine for phase images*/
               rhfiesta = RHFIESTA_RMS_AVE; 
               
               /* Puts the phase images in a new series */
               ihnew_series |= PSD_IHNEWSERIES_PHASE; 

               /* To perform filtered phase reconstruction using C3
                * framework. C3 framework is not correct for ASSET, ARC
                * and single channel coils, hence it should not be set
                * to 1*/
               if((PSD_OFF == exist(opassetscan)) && (PSD_OFF == exist(oparc)) && (rhdab0e > rhdab0s))
               {
                   rhchannel_combine_method = RHCCM_C3_RECON_FOR_PHASE_I_Q_IMAGES;
               }
           }
           else
           {
               rhrcctrl &= ~RHRCPHS;
	       rhrcctrl &= ~RDB_PHASE_IM_INVERT;
	       rhtype1 &= ~RDB_PHASE_MASK;
               ihnew_series &= ~PSD_IHNEWSERIES_PHASE;
           }
        }
        else
        {
           rhfiesta = 0;
        }
        /* RV: MRIhc19003 - Replaced opnecho with ideal_necho in case of IDEAL */
        if (ideal_flag)
           rhnecho = ideal_necho;
        else if (flow4D_flag)
           rhnecho = nflow4D;
        else if (medal_flag)
           rhnecho = medal_necho*medal_etl;
        else 
           rhnecho = exist(opnecho);

        eeff = (!uniPolar_flag);
    }

    /* RV: MRIhc19003 */
    if(PSD_ON == ideal_flag) {
       /* MRIhc36459 */
       rhrawsize *= (n64)(ideal_necho);
    }

    rhuser0 = (osfp_flag && ( PSD_SR200 == cfsrmode )) ? 1.5 : 1.0; /* sqrt(equant); */
    /* scale down 3D by rh3dscale and and up at 2D back */
    rh3dscale = (medal_flag) ? FMin(2, sqrt((float)equant), 8.0) : FMin(2, 0.5*sqrt((float)equant), 4.0);
    if (rh3dscale < 1.0) {
        rh3dscale = 1.0;
    }

    if (RDB_DISK_ACQ_OVERFLOW == (rhdiskacqctrl & RDB_DISK_ACQ_OVERFLOW))
    {
        rhinitpass = DISK_ACQ_RHINITPASS;
    }
    else if ( rhnpasses > 1 ) 
    {
        /* MRIhc50672
           All phases/slabs of certain types of acquisitions must entirely fit in BAM.
           For example, Dynaplan with multiple slabs. */
        if ( exist(opdynaplan) || medal_flag || quickstep_flag ||
             ( ((rhdab0e - rhdab0s + 1) >= 16) && (ACCEL_ARC == rhasset) ) ) 
        {
            rhinitpass = rhnpasses;
        }
        else
        {
            rhinitpass = IMin( 2, exist(optphases) * exist(opfphases) * exist(opvquant), 3 );
        }
        rhtype1 |= RHTYP3DM; /* 3d oblique - changed this from 0 to RHTYP3DM - latha@mr */
    }
    else
    {
        rhinitpass = 1;
        rhtype1 &= ~RHTYP3DM;
    }

    /* MRIge91682 */
    if (pfkz_flag || pfkr_flag || (ACCEL_ARC == rhasset) || (ACCEL_DVCARC == rhasset)) {
        rhtype1 |= RHTYP1BAM0FILL;
    }

    rhasset_slwrap = (float) (slab_wrap_corr/exist(opslquant)); 

    /* Increase rhslblank for slice zero-filling */
    /* Change rhslblank based on vast_mode ALP MS */
    if (osfp_flag || arc_flag || merge_flag || pcfiesta_flag) {
       rhslblank *= slicezp;
    } else {
       rhslblank = 2*slicezp/(1 + vast_mode);
    }
    rhzipfact = (float)slicezp;

    /* YMSmr07288 07/17/2005 YI */
    if((value_system_flag && ssfp_flag) || heart3d_flag )
    {
      rhslblank = opslblank * slicezp;
    }

    /* BBA - Slice ASSET */
    if( ns3d_flag || quickstep_flag || ( (rhassetsl_R < 1) && (PSD_ON == assetsl_flag) ) )
    {
        rhslblank = 0;
    }

    /* make sure the following recon cvs are set for homodyne recon */
    rhmeth = ( (xres != 256) && ( xres != 512 ) )? 1: 0;
    /* 0=standard recon(key the filter size off x_acq_size), 
       1=homodyne recon (key the filter size off fft size) */

    rhdaxres = rhfrsize;

    rhdayres = rhnframes + rhhnover + 1;

    if (arc_flag && !(arc_pack_bam & BAM_REDUCE_Y))
    {
        /* Sort/Nex into fully sampled y therefore use unaccelerated sizes */
        rhdayres = unaccel_rhnframes + rhhnover + 1;

        if(idealiq_flag && idealiq_pc_flag)
        {
            rhdayres += idealiq_pc_ylines;
        }
    }

    if (arc_flag && (arc_pack_bam == 15)) {
        /* for DVC ARC */
        unaccel_dayres = unaccel_rhnframes + rhhnover + 1;
    }

    /* x pixel size / z pixel size for projection */
    /* added backward compatibility - latha@mr */
    if (UnLocked)
    {
        int totalPhase = (phasefovgt1_flag && (opphasefov > 1) ) ? 
            (int)(exist(opyres)*exist(opphasefov)) : exist(opyres);
               
        if (exist(opxres) >= totalPhase)
        {
            rhrcxres = ((exist(opxres) <= 256) ? 256 : 512);
            if ((hires_recon == PSD_ON) || exist(opxres) > 256) /* MAB */
                rhrcxres = 512;
            if ( (recon_1024 == PSD_ON) || (exist(opxres) > 512) ) 
                rhrcxres = 1024;
            rhuser1 = (float)slicezp*exist(opfov) / (exist(opslthick) * (FLOAT)rhrcxres);
            rhimsize = rhrcxres;
            /* If we are doing full-echo we won't be doing homodyne so fermi
               radius should be keyed off of rhfrsize */
        }
        else      
        {
            rhimsize = ((totalPhase <= 256) ? 256 : 512);
            if ((hires_recon == PSD_ON) || (totalPhase > 256) ) {
                rhimsize = 512;
            }
            /* MRIge82977 Initialise rhrcxres -Venkat */
            if ( (recon_1024 == PSD_ON) || (totalPhase > 512) ) {
                rhimsize = 1024;
            }
            rhuser1 = (float)slicezp*exist(opfov) / (exist(opslthick) * (FLOAT)rhimsize);
            rhrcxres = ((exist(opxres) <= 256) ? 256 : 512);
        }

        if (phasefovgt1_flag && (opphasefov > 1) )
        {
            rhrcyres = (int)(exist(opyres) * (1 + opnopwrap)*(exist(opphasefov)));
            rhrcyres = rhrcyres + rhrcyres % 2;
        }
        else
        {
            rhrcyres = rhimsize * (1 + opnopwrap)*(exist(opphasefov));
        }

    } else {
        rhuser1 = exist(opfov) / (exist(opslthick) * (FLOAT)exist(opxres));
        rhrcyres = exist(opxres) * (1 + opnopwrap) * (exist(opphasefov));
    }

    /* Future: Support pFOV > 1 where yres*pFOV may be > yres
       May be okay for all option.  Need to test */
    /*  if ( PSD_ON == phasefovgt1_flag && opphasefov > 1 ) {
        rhimsize = IMax(2, rhrcxres, rhrcyres);
        }
    */
   
    if (arc_flag) {
        if( rhrcyres % 2 == 1) {
            rhrcyres += 1;
        }
    }

    /* Turn off homodyne recon along x if we are doing fractional nex */
    if( ((fn == 0.5) || (fn == 0.75) || (act_echofrac>=0.74)) && (tfe_extra > 0) )
    {
        rhtype &= ~RHTYPFRACTECHO;

        /* Recalculate rhnwin and rhntran */
        rhnwin = 0;
        rhntran = 2;

    }
 
    if (ifir_flag && (fn<1.0))
    {
        rhtype &= ~RHTYPFRACTNEX;
    }

    /* MRIge81744 - 3D slice data windowing for fiesta-c */
    /* MRIhc24880 - 3D slice data windowing for MEDAL */
    if ( (pcfiesta_flag == PSD_ON) || ( (medal_flag == PSD_ON) && (exist(opslthick)>=3.0) )  )
    {
        rh3dwintype = 1.0;
        rh3dwina = 0.75;
        rh3dwinq = 0.25;
    }
    else  
    {
        rh3dwintype = 0;
        rh3dwina = 0.1;
        rh3dwinq = 0.0;
    }

    if( PSD_ON == swap_fat_cs )
    {
        eepf = 0;
        oepf = 0;
        eeff = 0;
        oeff = 1;  /* set oeff ON */
    }

    oeff = (a_gxw > 0) ? 0:1;  /* set oeff ON */

    /* MRIhc16353 - RV: IDEAL change */
    if ( (PSD_ON == ideal_flag) || (medal_flag && medal_multitr_flag) || idealiq_flag || flow4D_flag )
    {
        eeff = 0;  /* turn off eeff */
    }

    set_echo_flip(&rhdacqctrl, &chksum_rhdacqctrl, eepf, oepf, eeff, oeff);

    if (exist(use_myscan)==1) myscan3d();

    if (debug_scan)
    {
        psd_dump_scan_info();
    }

    /* Generate unique ID for this scan for naming kacq files and debug files.
       Use the current date and time (MMDDHHMMSS).  Cannot include the year
       because this is larger than a signed 32-bit integer */
    {
        int uid;
        time_t now_epoch = time(NULL);
        struct tm now;
        struct timeval now2;

        localtime_r(&now_epoch, &now);
        gettimeofday(&now2, NULL);
        uid = (floor)(now2.tv_usec/1000) +
            now.tm_sec      * 1000 +
            now.tm_min      * 100000 +
            now.tm_hour     * 10000000;
        rhkacq_uid = uid;
        kacq_uid_washin = rhkacq_uid + KACQ_UID_OFFSET_DYNAPLAN;
    }

    /* *****************************
       Slice Ordering
       *************************** */  

    /* 3d oblique - added opvquant - latha@mr*/
    if (orderslice(seq_type, (exist(opslquant)*exist(opvquant)), slquant1, gating) == FAILURE)
    {
        epic_error(use_ermes,"%s failed",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"orderslice");
        return FAILURE;
    }

    if( PSD_ON == ftmra_flag )
    {
        rtia_orig_tloc    = rsp_info[0].rsptloc;
        rtia_orig_rloc    = rsp_info[0].rsprloc;
        rtia_orig_phasoff = rsp_info[0].rspphasoff;

        rtia_init_tloc    = ( scan_info[exist(opslquant)*exist(opvquant)/2].optloc
                            + scan_info[exist(opslquant)*exist(opvquant)/2-1].optloc) / 2;
        rtia_init_rloc    = ( scan_info[exist(opslquant)*exist(opvquant)/2].oprloc
                            + scan_info[exist(opslquant)*exist(opvquant)/2-1].oprloc) / 2;
        rtia_init_phasoff = ( scan_info[exist(opslquant)*exist(opvquant)/2].opphasoff
                            + scan_info[exist(opslquant)*exist(opvquant)/2-1].opphasoff) / 2;
    }

    if (flow4D_flag)
    {
        if (maxpc_cor == PSD_ON)
        {
            /* calculate rhuser coefficient for recon-based
               Maxwell correction */
            if (maxwell_pc_calc(maxpc_cor,maxpc_points, maxpc_debug,
                        pw_gx1a, pw_gx1, pw_gx1d,
                        pw_gxfca, pw_gxfc, pw_gxfcd,
                        pw_gz1a, pw_gz1, pw_gz1d,
                        pw_gzfca, pw_gzfc, pw_gzfcd,
                        pw_gyfe1a, pw_gyfe1, pw_gyfe1d,
                        pw_gxwa, pw_gy1a, pw_gy1, pw_gy1d, pw_gzrf1d,
                        flow_wdth_x, flow_wdth_z,
                        ia_gx1fen, ia_gx1feu,   ia_gx1fed,
                        ia_gx2fen, ia_gx2feu, ia_gx2fed,
                        ia_gz1fen, ia_gz1feu, ia_gz1fed,
                        ia_gz2fen, ia_gz2feu, ia_gz2fed,
                        ia_gy1feu, ia_gy1fed,
                        ia_gy2feu, ia_gy2fed,
                        a_gxw, a_gzrf1,rsprot[0],
                        &rhmaxcoef1a, &rhmaxcoef1b, &rhmaxcoef1c, &rhmaxcoef1d,
                        &rhmaxcoef2a, &rhmaxcoef2b, &rhmaxcoef2c, &rhmaxcoef2d,
                        &rhmaxcoef3a, &rhmaxcoef3b, &rhmaxcoef3c, &rhmaxcoef3d) == FAILURE)
            {
                epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "maxwell_pc_calc");
                return FAILURE;
            }
        }
        else
        {   /* turn off maxwell correction coef */
            rhmaxcoef1a = 0.0;
            rhmaxcoef1b = 0.0;
            rhmaxcoef1c = 0.0;
            rhmaxcoef1d = 0.0;
            rhmaxcoef2a = 0.0;
            rhmaxcoef2b = 0.0;
            rhmaxcoef2c = 0.0;
            rhmaxcoef2d = 0.0;
            rhmaxcoef3a = 0.0;
            rhmaxcoef3b = 0.0;
            rhmaxcoef3c = 0.0;
            rhmaxcoef3d = 0.0;
        }
    }/* end flow4D_flag check */

    if(scalerotmats(rsprot, &loggrd, &phygrd, opvquant, obl_debug)  == FAILURE)
    {
        epic_error(use_ermes,"System configuration data integrity violation detected in PSD.\nPlease try again or restart the system.", 
                   EM_PSD_PSDCRUCIAL_CONFIG_FAILURE,EE_ARGS(0));
        return FAILURE;
    }

    trig_scan = gating;

    if (debug_scan)
        psd_dump_rsp_info();


    if (mph_flag == PSD_ON)
    {
        ihtr = act_tr + ((gating==TRIG_LINE) ? TR_SLOP : 0);

        if ( vstrte_flag )
        {
            ihtr = (int) 10.0*floor(ihtr/10.0);
        }

        free(ihtdeltab);
        ihtdeltab = (int *)malloc(opslquant*opvquant*slicezp*sizeof(int));
        exportaddr(ihtdeltab, (int)(opslquant*opvquant*slicezp*sizeof(int)));
        for (i = 0; i < opslquant*opvquant; i++) {
            /* Time from the start of data acquisition */
            /* Account for slice zero-filling here since it is not taken
               care of in ifcc or recon */
            /* MRIge83805 - Added tdel calculation for specir pulse */
            if( specir_flag ) {
                /* MRIhc17394: For Vibrant cases: Calculate the ihtdel from the Total Scan time. 
                 * sldeltime is the actual delay time after TR_PASS (opsldelay - TR_pass), 
                 * this is added to the total scan time and then divide it by the number of
                 * Multiphases selected (opfphases). With this implementation
                 * the ihtdel will always match with the actual start time of a multi-phase 
                 * series, as this is back calculated from total scan time.
                 * Limiting this only for Vibrant cases, to minimize risk, 
                 * eventually this implmentation could possibly replace all
		 * cases (specir or non-specir, vibrant or non-vibrant). */
		if ( vibrant_flag  || brava_flag || lava_flag ) {
		    ihtdeltab[i*slicezp] = (pitscan + (float)sldeltime)/(float)opfphases; 
		} else { 
		    ihtdeltab[i*slicezp] =
			(1*slquant1)
			* (act_tr*((float)nreps/(float)rhnslices) + 
				(cs_sattime + cs_satstart) * (float)nreps/((float)rhnslices * (float)slfreq))
			+ 1*(float)(TR_PASS+sldeltime); 
		}
	    } else {
		ihtdeltab[i*slicezp] =
		    (1*slquant1)
		    * act_tr*((float)nreps/(float)rhnslices)
		    + 1*(float)(TR_PASS+sldeltime);
	    }
	    for (j=1;j<slicezp;j++) {
		ihtdeltab[i*slicezp+j] = ihtdeltab[i*slicezp];
	    } /* j */
	} /* i */
    }  /* mph_flag == PSD_ON */

@inline Tricks.e TricksPredownload
@inline cal3d.e cal3d_predownload

    if(debug_tdel && enable_1024 )
    {
        for(i=0;i<(opslquant*opvquant*slicezp);i++)
        {
            printf("ihtdeltab[%d]=%d\n",i,ihtdeltab[i]);
        }
        fflush(stdout);
    }

    if (debug_order) {
        int i;
        printf("i\tslpass\tsltime\tslloc\n");
        /* > 1024 im/ser Venkat
           for (i = 0; i < opslquant * opvquant * opfphases; i++)
        */
        
	for (i = 0; i < opslquant * opvquant; i++) {
            printf("%d\t %d\t %d\t %d\t \n",i,data_acq_order[i].slpass,data_acq_order[i].sltime,
                   data_acq_order[i].slloc);
        }


        fflush(stdout);
    }

    /* > 1024 im/ser -Venkat*/
    /*
     * rhformat(14th bit) : 0=Normal 1=Multiphase scan
     * rhmphasetype       : 0=Int MPh 1=Seq Mph
     * rhnphases          : No of phases in a multiphase scan
     */
    if (cal3d_flag)
    {
        /* The scan is considered to be multi-pass, not multi-phase, from a reconstruction perspective. */
        rhformat |= RHF_SINGLE_PHASE_INFO;
        rhmphasetype = 0;
        rhnphases = 1;
        rhnpasses = exist(opfphases);
    }
    else if (mph_flag)
    {
        rhformat |= RHF_SINGLE_PHASE_INFO;
        rhmphasetype = 0;             /* Interleaved multiphase*/
        rhnphases = exist(opfphases); /* No of phases in a multiphase scan*/
    }
    else if (!enable_1024)
    {
        rhformat &= ~RHF_SINGLE_PHASE_INFO;
    }

    /* If accelerated points expand the calibration region for cross sampling */ 
    if (CROSS_CAL == cal_shape) 
    {
        if (arc_ph_stride > 1.0) 
        {
            crossCalBoundary(&arc_ph_callower, &arc_ph_calupper, 
                             arc_ph_stride, zy_views);
        }
        if (arc_sl_stride > 1.0) 
        {
            crossCalBoundary(&arc_sl_callower, &arc_sl_calupper, 
                             arc_sl_stride, zy_slices);
        }
    }

    /* Adjust fermi filter for pfkr */
    krfermecorr_factor = sqrt(pfkr_fraction*4.0/PI);
    if (krfermecorr_factor > 1.0)
    {
        krfermecorr_factor = 1.0;
    }

    if (PSD_ON == ellipt_flag)
    {
        delay_ec_frames = 2*(delay_ec_period*1s/(2*optr));
    }

    if ((zy_export = (ZY_EXPORT *) malloc(sizeof(ZY_EXPORT) * zy_views * zy_slices)) == NULL) {
        epic_error( use_ermes, "Malloc %s failed.",
                    EM_PSD_MALLOC_FAILURE, EE_ARGS(1),
                    STRING_ARG, "zy_export" );
        return FAILURE;
    }
    memset(zy_export, 0, sizeof(ZY_EXPORT) * zy_views * zy_slices); 

    /* Initialize the param4d structure */
    smoothec = disco_flag ? TRUE : FALSE;
    
    param4d.vieworder_mode = disco_flag ? DISCO_ORDER : VIEWSHARING_OFF;
    param4d.aregion_fraction = aregion_fraction;
    param4d.num_outer_regions = num_regions-1;  /* This is excluding the A region */
    param4d.num_sub_regions = num_sub_regions;
    param4d.smoothec = smoothec;
    param4d.num_transition_fraction = num_transition_fraction;
    param4d.reverse_first_region_flag = reverse_first_region_flag;
    param4d.regViewOrderMode = regViewOrderMode;
    param4d.nr_of_segA = nr_of_segA;

    /* Generate zy_export table with playout order */
    if (FAILURE == generateZyExport( zy_export,
                                     &delay_ec_frames,
                                     zy_views,
                                     zy_slices,
                                     ellipt_flag,
                                     reverse_ellipt_flag,
                                     radfb_flag,
                                     fn,
                                     pfky_total_unaccel,
                                     ((PSD_ON == pfkz_flag) && (pfkz_fraction < 1.0)),
                                     pfkz_total_unaccel,
                                     pfkz_total,
                                     pfkz_segments,
                                     pfkz_views_per_segment,
                                     ((PSD_ON == pfkr_flag) && (pfkr_fraction < 1.0)),
                                     pfkr_fraction,
                                     pfkr_yz_flag,
                                     echo_sort_dir,
                                     seg_sort_dir,
                                     get_act_phase_fov() * nop,
                                     ethick,
                                     phaseres,
                                     equant,
                                     delay_ec_flag,
                                     segmented_flag,
                                     nr_of_segments,
                                     views_per_segment,
                                     encode_group,
                                     phorder,
                                     viewoffs,
                                     rhnframes,
                                     rhhnover,
                                     slorder,
                                     nsegments,
                                     chemseqs,
                                     chemseq0,
                                     linestodiscard,
                                     arc_flag,
                                     calRegion,
                                     arc_ph_stride,
                                     arc_sl_stride,
                                     tricks_flag,
                                     mask_regions,
                                     tricks_transition_views,
                                     ellipt_debug_files,
                                     extraspecial_slice,
                                     &param4d))
    {
        epic_error(use_ermes, "%s failed",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "generateZyExport");
        free(zy_export);
        return FAILURE;
    }

    /* Count the number of accelerated, calibration, and mask lines */
    sampledPoints = 0;
    calibrationPoints = 0;
    maskPoints = 0; 
    sampledPointsNoMask = 0;
    for (i = 0; i < zy_views * zy_slices; i++)
    {
        if (zy_export[i].flags & ZY_FLAGS_MASK)
        {
            maskPoints++;
        }
        else
        {
            if (zy_export[i].flags & ZY_FLAGS_SAMPLED) 
            {
                sampledPoints++;
            }
            if (zy_export[i].flags & ZY_FLAGS_CAL) 
            {
                calibrationPoints++;
            }
        }

        if (zy_export[i].flags & ZY_FLAGS_SAMPLED) 
        {
            sampledPointsNoMask++;
        }
    }
 
    if(arc_flag) 
    {
        n64 nFramesTimesNex;
        int packedPhases = 0;
        int packedSlices = 0;

        rhasset_R = FMin(2, 1.0/arc_ph_stride, 1.0);
        rhassetsl_R =  FMin(2, 1.0/arc_sl_stride, 1.0);

        if (CROSS_CAL != cal_shape)
        {
            /*MRIhc42465  -  with PIUI changes report outer accel to
             * annotation */
            /* Update total accel  based on actual sampling pattern */
            piaccel_total_stride = (float)(zy_views * zy_slices)/ (float) sampledPointsNoMask;
        }

        if (arcPackBam(arcPhaseRemapTable, &packedPhases,
                       arcSliceRemapTable, &packedSlices,
                       zy_export, sampledPoints + maskPoints, 
                       phaseres, equant) == FAILURE)
        {
            epic_error(use_ermes, "%s failed",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "arcPackBam");
            free(zy_export);
            return FAILURE;
        }

        /* If reducing the BAM alloction, one must pack the view/slice as well */
        if ((arc_pack_bam & BAM_REDUCE_Y) && !(arc_pack_bam & BAM_PACK_Y))
        {
            cvoverride(arc_pack_bam, arc_pack_bam | BAM_PACK_Y, PSD_FIX_OFF, PSD_EXIST_ON);
        }

        if ((arc_pack_bam & BAM_REDUCE_Z) && !(arc_pack_bam & BAM_PACK_Z))
        {
            cvoverride(arc_pack_bam, arc_pack_bam | BAM_PACK_Z, PSD_FIX_OFF, PSD_EXIST_ON);
        }

        if (rawdata)
        {
            nFramesTimesNex = (n64)ceil((double)sampledPoints * (double)truenex);
        }
        else
        {
            nFramesTimesNex = (n64)ceil((double)rhdayres * (double)exnex);
            
            if (arc_pack_bam & BAM_REDUCE_Z)
            {
                nFramesTimesNex *= (n64)packedSlices;
            }
            else
            {
                nFramesTimesNex *= (n64)slquant1;
            }
        }
        /* MRIhc36459 */
        rhrawsize = nFramesTimesNex * (n64)rhnecho * (n64)rhfrsize * (n64)(2*rhptsize);
    }

    /* MRIhc43145: Delay sending 3D packets for acquired kx-kz planes 3D packets 
       if segmented or radial fanbeam order due to complicated view order.
       ARC ignores 3D packets so there is no need to delay packets. encode_group 
       view orders do not need the delay either as calculations are correct */
    if ( ((segmented_flag || radfb_flag) && 
          (ACCEL_ARC != rhasset) && (ENCODE_GROUP_NONE == encode_group) && (PSD_OFF == pfkr_yz_flag))
         || ((PSD_OFF == exist(opcgate)) && (PSD_ON == navgate_flag)) )
    {
        threedpktdly = zy_views * zy_slices;
        delay3Drecon_flag = PSD_ON;
    }
    else
    {
        if (!delay_ec_flag)
        {
            threedpktdly = 1;
        }
        delay3Drecon_flag = PSD_OFF;
    }

    if (fn < 1)
    {
        ihnex = nop * fn;
        if (ifir_flag && (1==exist(oprtrep)))
        {
            ihnex = nop * (float)(rhnframes+rhhnover) / (float)(rhnframes*2);
        }
    }
    else
    {
        ihnex = truenex * nop;
    }

    /* MRIge91682 */
    if (pfkz_flag)
        ihnex *= pfkz_fraction;

    if (pfkr_flag && (!(pfkr_yz_flag || turbo_cemra_flag)))
    {
        pfkr_fraction_act  = (float) (zy_views * zy_slices - maskPoints)/ (float) (zy_views * zy_slices); 
        ihnex *= pfkr_fraction_act;
    }

    if (lava_flag || osfp_flag || pfkr_flag)
        ihnex *= pfky_fraction;
 
    if(PSD_ON == ideal_flag) {
       ihnex *= 3;
    }

@inline cal3d.e cal3d_predownload_nex

    /* ***************************
    Prescan slice calculation
    ************************* */
    /* there is only one slab, use 1 instead of opslquant */
    if (prescanslice(&pre_pass, &pre_slice, opvquant*arc_equant) == FAILURE)
    {
        epic_error(use_ermes,"%s failed",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"prescanslice");
        free(zy_export);
        return FAILURE;
    }



    /* ***************************************
       Slab offsets
       *************************************** */
    for (i = 0; i< opvquant; i++)
    {
        /* set up phase offset arrays */
        if (rsp_info[i].rspphasoff >=0) {
            phase_off[i].ysign = -1;
        } else {
            phase_off[i].ysign = 1;
        }

        /* phase offset increment */
        /* ASSET */
        if (FAILURE == calcrecphase(&yoffs1, rsp_info[i].rspphasoff, opfov, opphasefov, nop, asset_factor))
        {
            return FAILURE;
        }

        /* offset in range */
        phase_off[i].yoffs = (yoffs1 + FS_2PI + FS_PI)%FS_2PI-FS_PI;

        zoffs1 = .5 + fabs(FS_2PI*rsp_info[i].rsptloc/(opvthick*assetsl_factor));/* slab offset increment */
        if (rsp_info[i].rsptloc >= 0) {
            zsign = 1;
        } else {
            zsign = -1;
        }

        if ( (heart3d_flag) || (cine3d_flag) )
        {
            /* mslab is using the MOTSA recon to enable the negative slab overlap. 
             * However, the MOTSA recon can not handle the reverse slabs case. 
             * Therefore, need to reverse the slice encoding from PSD side */ 
            rvssliceenc = (rsp_info[0].rsptloc<=rsp_info[opvquant-1].rsptloc) ? 0 : 1;
            half_slice_sign = rvssliceenc ? -zsign : zsign;

            /* Correct for half-pixel shift in 3D */
            zoffs = ( zoffs1 + FS_2PI
                  + (int)((float)FS_PI*(1.0 + ((float)half_slice_sign)/((float)opslquant))) )%FS_2PI;  /* offset in range 0 - 2pi */
        } 
        else 
        {
            rvssliceenc = (rsp_info[1].rsptloc<=rsp_info[opslquant-1].rsptloc) ? 0 : 1;
            half_slice_sign = rvssliceenc ? -zsign : zsign;

            /* Correct for half-pixel shift in 3D */
            zoffs = ( zoffs1 + FS_2PI
                  + (int)((float)FS_PI*(1.0 + ((float)zsign)/((float)opslquant))) )%FS_2PI;  /* offset in range 0 - 2pi */
        }

        slab_off[i].zsign = zsign;
        slab_off[i].zoffs = zoffs;

    }
    /* ****************************
       Timing for SCAN entrypoint
       *************************** */  

    /*  start time on boards
        Don't be concerned with creating a cardiac trigger delay time
        in pulsegen.  We will simply build a 4us wait at the beginning of the
        boards that can be expanded to length td0 on the first slice of an R-R.
        Start the first gradient in pulsegen at (tlead + the minimum length of 
        the td0 wait instruction (4us)) and add rfupa time */

    /* *********************
       SAT Positioning
    *********************/
    if(SatPlacement(acqs) == FAILURE)
    {
        epic_error(use_ermes,"%s failed",EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"SatPlacement");
        return FAILURE;
    }
 
    /* IFIR GRx */
    if (ifir_flag == PSD_ON)
    {
        InversionGRxPredownload();
    }

    /* *****************************
       Auto Prescan Init
       Inform Auto Prescan about
       prescan parameters.
       *************************** */  
    picalmode = 0;

    /* vmx 06/19/95 YI  changed slquant1 to acqs for prescan */
    pislquant = acqs; /* Number of slices in 2nd pass prescan */

    /* fast-receiver:set these as follows prior to the entrytabinit() call */
    rhdab0s = cfrecvst;
    rhdab0e = cfrecvend;

    if( PSD_ON == ftmra_flag )
    {
        /*
         * turn this off before entrytabinit since ftmra is not open-ended.
         * oprealtime will be turned on for recon purposes later
         */
        cvoverride(oprealtime, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
    }

    /* *******************************
       Entry Point Table Evaluation
       ******************************* */
    /* Initialize the entry point table */
    if (entrytabinit(entry_point_table, (int)ENTRY_POINT_MAX) == FAILURE)
    {
        epic_error(use_ermes,"%s failed",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"entrytabinit");
        free(zy_export);
        return FAILURE;
    }

    /* Keep body coil tuned for all entry points. */
    if (cal3d_flag && cal3d_interleave)
    {
        int i;
        for (i = 0; i < ENTRY_POINT_MAX; i++)
        {
            entry_point_table[i].epRxCoilType = (n32)volRecCoilInfo[0].rxCoilType;
        }
    }

    rhyoff = 0;
    rhblank = 0;
    baseline = 0;

    /* Scan entry point */
    strcpy(entry_point_table[L_SCAN].epname, "scan");

@inline Tricks.e TricksEntrytab

    /* Set xmtadd according to maximum B1 and rescale for powermon,
       adding additional (audio) scaling if xmtadd is too big.
       Add in coilatten, too. */
    xmtaddScan = -200*log10(maxB1[L_SCAN]/maxB1Seq) + getCoilAtten(); 

    if (xmtaddScan > cfdbmax) {
        extraScale = (float) pow(10.0, (cfdbmax - xmtaddScan)/200.0);
        xmtaddScan = cfdbmax;
    } else {
        extraScale = 1.0;
    }

    if (setScale(L_SCAN, RF_FREE, rfpulse, maxB1[L_SCAN], 
                 extraScale) == FAILURE) {
        epic_error(use_ermes, "%s failed",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "setScale");
        free(zy_export);
        return FAILURE;
    }

    entry_point_table[L_SCAN].epxmtadd = (short) rint((double)xmtaddScan);

    /* Reset the num fields for RF pulses to support
       running the psd predownload section multiple times
       without cveval. */
    rfpulse[RF1_SLOT].num = 1;

    /* Power Monitor and SAR for SCAN entry point */

    /* power monitor:
       The power monitor values are calculated with a second call to
       the powermon() routine.  However, the pulses are not
       weighted so that the power monitor gets the worst case pulse
       information. */

    /*
     * MRIhc42752 - Use the setupPowerMonitor function so we can pass
     * the established average SAR for pulse monitor guard band calculations. 
     */
    if( setupPowerMonitor( &entry_point_table[L_SCAN], L_SCAN, (int)RF_FREE,
                           rfpulse, (int)(adj_act_tr),
                           (double)piasar, (double)picasar, (double)pipsar )
        != SUCCESS)
    { 
        epic_error(use_ermes, "%s failed",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "setupPowerMonitor");
        free(zy_export);
        return FAILURE;  
    }

    /* MRIge62874, JAH/DCZ: This powermon() is for the calculation of duty
       cycle purpose, not for the SAR calcuation.*/

    if ((PSD_OFF == opcgate) && (PSD_ON == navgate_flag)) {
        app_tr = act_tr * (int)(1.0 + (float)mon_tr / (float)act_navgate_tr);
    } else if (PSD_ON == navgate_flag) {
        app_tr = act_tr + (int)((float)mon_tr / pe_acq2);
    } else {
        app_tr = act_tr;
    }

    if (FAILURE == Monitor_Predownload( rfpulse, entry_point_table, (int)RF_FREE, app_tr,
                                        &monave_sar, &moncave_sar, &monpeak_sar ))
    {
        epic_error(use_ermes, "%s failed",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), 
                   STRING_ARG, "Monitor_Predownload");
        free(zy_export);
        return FAILURE;
    }

    /* For the prep pulse, a fudge factor has been introduced for SAR width
       since the power monitor seems to have a problem measuring hard pulses,
       especially if they are imperfect (NDG) */

    if ((t2prep_flag) && (compositeon || comptipupon)) 
    {
        entry_point_table[L_SCAN].epwidthh *= 1.1;
        entry_point_table[L_SCAN].epwidthb *= 1.1;
        entry_point_table[L_SCAN].epwidths *= 1.1;
    }

    /* Store SAR power monitor values in CVs for debugging */
    /* sar_amp, sar_width and sar_cycle were 0 with the previous
       implementation(for body coil). MRIge50281 */
    extractActivePowerMonValues( &entry_point_table[L_SCAN],
                                 txCoilInfo[getTxIndex(coilInfo[0])],
                                 &sar_amp, &sar_width, &sar_cycle );

    entry_point_table[L_SCAN].epfilter = (unsigned char)echo1_filt->fslot;
    entry_point_table[L_SCAN].epprexres = rhfrsize; 

    /* Now copy into APS2 and MPS2 */
    /* The rf pulse and the x resolution used in MPS2 and APS2 are identical 
       to those in SCAN.  Note, PS2 will keep the same power monitor
       limits as SCAN even though SAT is never played in PS2; */
    entry_point_table[L_APS2] = entry_point_table[L_MPS2] =
        entry_point_table[L_SCAN];
    strcpy(entry_point_table[L_MPS2].epname, "mps2");
    strcpy(entry_point_table[L_APS2].epname, "aps2");

    initfilter();
    setfilter(echo1_filt, SCAN);
    filter_echo1 = echo1_filt->fslot;

@inline Monitor.e MonitorFilter
@inline Prescan.e PSfilter
@inline Prescan.e PSpredownload

    pos_moment_start = pos_start + t_exa;

    if (show_rtfilts==1)  {
        dump_filter(psd_filt_spec);
    }

    for (slice = 0; slice < equant; slice++)
    {
        int tmp_slice;
        
        if ( (heart3d_flag || cine3d_flag) && rvssliceenc) 
        {
            tmp_slice = equant-1-slice;
        } else {
            tmp_slice = slice;
        }

        volumetab[tmp_slice] = (((float)slice*(a_comb - a_end)/
                                 (float)(equant-1) - a_comb)/loggrd.tz)*max_pg_iamp;
        
        volumetab2[tmp_slice] = (((float)slice*(-a_comb2 + a_end2)/
                              (float)(equant-1) + a_comb2)/loggrd.tz)*max_pg_iamp;
        
    }


    /* MRIge44811 - Fill up export array of _ihtrtab for correct annotation -JFS */
    if( (exist(opcgate) == PSD_ON) || (exist(oprtcgate) == PSD_ON) ) {
        int i; 
        int nBytes; 
        int nSlices;

        nSlices = slicezp * exist(opslquant);  /* MRIge45848: times slicezp */

        if (heart3d_flag || cine3d_flag) nSlices *= exist(opvquant);

        /* _ihtrtab.addr is initialized to &ihtrtab in efgre3d.exportstr.h */
        nBytes = nSlices*sizeof(int);
        if( (nBytes > (int)(_ihtrtab.size)) ||
            (_ihtrtab.addr == (char*)(&ihtrtab)) ) {
            /* free old memory if neccessary */
            if( (_ihtrtab.addr != NULL) &&
                (_ihtrtab.addr != (char*)(&ihtrtab)) ) {
                free( _ihtrtab.addr );
            }

            /* allocate memory */
            if( NULL == (_ihtrtab.addr = (char *)malloc( nBytes )) ) {
                epic_error( use_ermes, "Malloc %s failed.",
                            EM_PSD_MALLOC_FAILURE, EE_ARGS(1),
                            STRING_ARG, "ihtrtab" );
                free(zy_export);
                return FAILURE;
            }

            _ihtrtab.size = nBytes;
        }

        ihtrtab = (int*)_ihtrtab.addr;
        for( i = 0; i < nSlices; ++i ) {
            ihtrtab[i] = act_tr;
        }
    }

    /* Fill up export array of _ihtdeltab for correct annotation -JFS */
    if( exist(opcgate) == PSD_ON ) {
        int i;
        int nBytes;
        int nSlices;

        nSlices = slicezp * exist(opslquant);  /* MRIge45848: times slicezp */

        if (heart3d_flag || cine3d_flag) nSlices *= exist(opvquant);

        /* _ihtdelta.addr is initialized to &ihtdelta in efgre3d.exportstr.h */
        nBytes = nSlices*sizeof(int);
        if( (nBytes > (int)(_ihtdeltab.size)) ||
            (_ihtdeltab.addr == (char*)(&ihtdeltab)) ) {
            /* free old memory if neccessary */
            if( (_ihtdeltab.addr != NULL) &&
                (_ihtdeltab.addr != (char*)(&ihtdeltab)) ) {
                free( _ihtdeltab.addr );
            }

            /* allocate memory */
            if( NULL == (_ihtdeltab.addr = (char *)malloc( nBytes )) ) {
                epic_error( use_ermes, "Malloc %s failed.",
                            EM_PSD_MALLOC_FAILURE, EE_ARGS(1),
                            STRING_ARG, "ihtdeltab" );
                free(zy_export);
                return FAILURE;
            }

            _ihtdeltab.size = nBytes;
        }

        ihtdeltab = (int*)_ihtdeltab.addr;
        for( i = 0;  i < nSlices; ++i ) {
            ihtdeltab[i] = optdel1;
        }
    }

@inline VAST.e VASTPredownload

    /* Enable/Disable Prescan Ahead CV */
    /* MRIge50275 - Changed set of autoadvtoscn based on opmultistation only */
    if( PSD_ON == exist(opmultistation) ) {
        firstSeriesFlag = !exist(opseriessave);
        pscahead = TRUE;
        autoadvtoscn = TRUE;
        tablespeed = cftablemaxspeed;
        tableaccel = cftablemaxaccel;
        tabledecel = cftablemaxdecel;
    } else {
        pscahead = FALSE;
        if(headneck_pos_scan)
        {
            autoadvtoscn = TRUE;
        }
        else
        {
            autoadvtoscn = FALSE;
        } 
        tablespeed = 0;
        tableaccel = 0;
        tabledecel = 0;
    }

    /* MRIhc22324 Fast table movement with multi station */
    pitablemaxspeed = tablespeed;
    pitablemaxaccel = tableaccel;
    pitablemaxdecel = tabledecel;

    /* Set pulse parameters */
    if( FAILURE == calcPulseParams(AVERAGE_POWER)) {
        free(zy_export);
        return FAILURE;
    }

    /* Half Alpha half TR MS */
    if( (ssfp_flag == PSD_ON) && (vast_mode == PSD_ON) ) {
        a_gzrf1htr = a_gzrf1;
        pw_gzrf1htr = pw_gzrf1;
        pw_gzrf1htra = pw_gzrf1a;
        pw_gzrf1htrd = pw_gzrf1d;

        a_rf1htr = a_rf1/2.0; /* half alpha */
        ia_rf1htr = ia_rf1/2; /* half alpha */
        pw_rf1htr = pw_rf1;
        res_rf1htr = res_rf1;
    }

    if (osfp_flag)
    {
       int i;

       for (i=1; i <= osfp_dda; i++) {
           osfp_vfa[i]= 0.5*(opflip)*(1-cos(PI*i/osfp_dda));
       }

       for (i=1; i <= osfp_dda; i++) {
           ia_rf1_osfp[i] = (int) (ia_rf1 * osfp_vfa[i] / osfp_vfa[osfp_dda]);
           osfp_vfa[i] = osfp_vfa[i]*opflip/osfp_vfa[osfp_dda];
       }
    }

    /* MRIge66079 - ATV: RTIA3D/ftMRA */
    if (ftmra_flag == PSD_ON )
    {
        int total_views;
        int time_per_slice;

        cvmax (rhexecctrl, 65535);
        /*
         * FTMRA oprealtime assignment must occur after entry_point_table continuous acquisition
         * flag is set. FTMRA is not truly continuous, but entrytabinit looks at oprealtime.
         */
        cvmax (oprealtime, PSD_ON);
        cvoverride(oprealtime, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);


        rtia3d_pass = 15ms;
        rtia3d_sat_views = 65;
        if (arc_flag) {
            total_views = phaseres;
        } else {
            total_views = rhnframes+rhhnover;
        }
        time_per_slice = 500ms;

        if (rtia3d_thkslab_proj_flag)
        {
            rtia3d_repeat_views = (int) ( (time_per_slice-rtia3d_pass-8*act_tr) /(2*act_tr)) ;
            rtia3d_repeat_views *=2;
            if (rtia3d_repeat_views < 65)
                rtia3d_repeat_views = 65;

        }
        else
        {
            if ( (act_tr+sp_sattime)*total_views < 1s)
            {
                rtia3d_repeat_views = total_views;
                rtia3d_sat_views = total_views;
            }
            else
            {
                rtia3d_repeat_views = (int) (1s-(rtia3d_sat_views*sp_sattime))/(2*act_tr) ;
                rtia3d_repeat_views *=2;
            }

            if (rtia3d_repeat_views < (total_views/2) )
            {
                rtia3d_repeat_views = total_views/2 ;
            }

        } /* end dephase flag */

        if ( (rtia3d_repeat_views > total_views) || rtia3d_irp_flag )
        {
            rtia3d_repeat_views = total_views;
        }

    }
    else
    {
        cvmax(oprealtime, PSD_OFF);
        cvoverride(oprealtime, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
    }
    /* End RTIA3D/ftMRA */

    rhrecon = 0;

    if (medal_flag && (exist(opmedal)==PSD_ON)) {
       rhmedal_mode = (exist(oplava) || (exist(opdisco) && !breastCoil_flag)) ? 514 : 2;
       rhmedal_param = (exist(oplava) || (exist(opdisco) && !breastCoil_flag)) ? 3.0 : 2.0;
       if (medal_enh_flag)
       {
           rhmedal_mode |= 64;
           if ((opfphases > 1) || (opdynaplan_nphases > 1))
           {
               rhmedal_mode |= 2048;
           }
       }
       rhmedal_nstack_size = 54;
       rhmedal_up_kernel_size = 15;
       rhmedal_down_kernel_size = 8;
       rhmedal_smooth_kernel_size = IMax(2, (int)(ceil(24.0/exist(opslthick))), 
                       _rhmedal_smooth_kernel_size.minval); /* MRIhc22326: slice filter extent */
       rhmedal_starting_slice = 0;
       rhmedal_ending_slice = exist(opslquant); 
       rhrcdixproc = exist(opdixproc);
       rhrcdixproc |= (DIXON_WATER + DIXON_FAT); 
    } else if(PSD_ON == ideal_flag) {
       if(PSD_ON == ideal_no_mag_im) {
          rhrcctrl &= ~RHRCMAG;
       } else {
          rhrcctrl |= RHRCMAG;
       }
       /* RV: To avoid any case where opdixproc and rhrcdixproc are out-of-sync */
       if((rhrcdixproc & 63) != opdixproc) {
          cvoverride(opdixproc,(rhrcdixproc & 63),PSD_FIX_ON,PSD_EXIST_ON);
       }
       if(!pfkyz2kr_flag && (fn == 0.5)) {
          rhtype &= ~RHTYPFRACTNEX;
          rhtype1 |= RHTYP1BAM0FILL;
       }
       cvmax(rhrcideal, (IDEAL_CENTER_KSPACE_HALF_ECHO<<1)-1);
       cvmax(rhrcdixproc, (DIXON_ORIGINAL<<1)-1);
       rhmedal_mode = 0;
    } else if(idealiq_flag) {
       cvmax(rhrcideal, (IDEAL_MAG_FITTING<<1)-1);
       cvmax(rhrcdixproc, (DIXON_RC<<1)-1);
       rhmedal_mode = 0;
    } else {
       rhrcideal = 0;
       rhrcdixproc = 0;
       rhmedal_mode = 0;
    }

    if ((rhfeextra < 2) && vstrte_flag) rhfeextra = 2;

    /* SVBranch, Smart Burst Mode */
    if(sbm_flag)
    {
        int y_max = 0; 
        int y_min = 0; 
        int z_max = 0;
        int z_min = 0;
        int y_max_i = 0;
        int y_min_i = 0;
        int z_max_i = 0;
        int z_min_i = 0;
        int time1 = 0;
        int time2 = 0;
        int time3 = 0;
        int time4 = 0;
        int act_time = 0;
        int sum_num = 0;
        float weight1 = 0.0;
        float weight2 = 0.0;
        float weight3 = 0.0;
        float weight4 = 0.0;
        float X1 = 0.0;
        float X2 = 0.0;
        float sum_time = 0.0;
        float dummy_time = 0.0;

        if(sbm_debug)
        {
            myf = fopen("/usr/g/service/log/sbm_timing.txt","w");
            fprintf(myf, "------------Begin to calculate min_seqgrad for each TR -----------------\n");
        }

        sbm_sum_dummy = 0.0;
        /* to calculate min_seqgrad for each view/slice encoding based on sampled points
           UNIT =  min_seqgrad/tmin_total * 100
           All sampled points are stored in zy_export */

        for(i = 0; i < sampledPoints; i ++)
        {

            /* to find indexs of nearest points in phase/slice encoding directions
             * there are four points.
             * format : [view, slice]       [view_index slice_index]
             * Point1 : [y_max, z_max]      [y_max_i, z_max_i]
             * Point2 : [y_max, z_min]      [y_max_i, z_min_i]
             * Point3 : [y_min, z_min]      [y_min_i, z_min_i]
             * Point4 : [y_min, z_max]      [y_min_i, z_max_i]
             **************************************************************************/
            for(j = 0; j < sbm_y_num; j ++)
            {
                if(zy_export[i].view <= y_index[j])
                {
                    y_max = y_index[j];
                    y_max_i = j;
                    if(0 == j)
                    {
                        y_min = y_max;
                        y_min_i = j;
                    }
                    else
                    {
                        y_min = y_index[j-1];
                        y_min_i = j-1;
                    }
                    break;
                }
            }

            for(j = 0; j < sbm_z_num; j ++)
            {
                if(zy_export[i].slice <= z_index[j])
                {
                    z_max = z_index[j];
                    z_max_i = j;
                    if(0 == j)
                    {
                        z_min = z_max;
                        z_min_i = j;
                    }
                    else
                    {
                        z_min = z_index[j-1];
                        z_min_i = j-1;
                    }
                    break;
                }
            }

            /* calculate min_seqgrad for each point from nearest 4 points */
            time1 = min_seqgrad_seq[sbm_z_num*y_min_i + z_min_i];  /* min_seqgrad for first point */
            time2 = min_seqgrad_seq[sbm_z_num*y_max_i + z_min_i];  /* min_seqgrad for second point */
            time3 = min_seqgrad_seq[sbm_z_num*y_min_i + z_max_i];  /* min_seqgrad for third point */
            time4 = min_seqgrad_seq[sbm_z_num*y_max_i + z_max_i];  /* min_seqgrad for forth point */


            weight1 = fabs(y_min - zy_export[i].view);

            weight2 = fabs(y_max - zy_export[i].view);

            weight3 = fabs(z_min - zy_export[i].slice);

            weight4 = fabs(z_max - zy_export[i].slice);

            if((weight1 == weight2) && (0 == weight1))
            {
                X1 = time1;
                X2 = time3;
            }
            else
            {
                X1 = (weight2 * time1 + weight1 * time2) / (weight1 + weight2);
                X2 = (weight2 * time3 + weight1 * time4) / (weight1 + weight2);
            }

            if((weight3 == weight4) && (0 == weight3))
            {
                act_time = X1 * sbm_margin;
            }
            else
            {
                act_time = ((weight4 * X1 + weight3 * X2) / (weight3 + weight4)) * sbm_margin;
            }

            zy_export[i].heat = (int)(((float)act_time / tmin_total)*100 + 0.5);  /*min_seqgrad/tmin_total * 100 is stored */

            if(sbm_debug)
            {
                fprintf( myf,"i=%d, min_seqgrad_* = %d \n", i, zy_export[i].heat);
            }
        }

        /* begin to calculate imaging period and waiting period */
        sum_time = 0.0;  /* accumulated heating. */
        sum_num = (int)(sbm_time_limit * 1000000.0 * 100.0 / tmin_total);
        sbm_dummy_num = (int)(sbm_time_limit * 1000000.0 / (tmin_total-min_seqgrad_no));
        dummy_time = sbm_dummy_num * (tmin_total-min_seqgrad_no)*100.0 / tmin_total; /* actual waiting time for waiting period */

        /* to simulate phase/slice/Nex loop in scancore()*/
        for(i = 0; i < sampledPoints; i = i+arc_equant)
        {
            for(ii = 0; ii < nex; ii ++)
            {
                for(j = 0; j < arc_equant; j ++)
                {
                    sum_time += (zy_export[i+j].heat - 100);

                    /*Once hardware recovers, sum_time should be zero */
                    if(sum_time < 0)
                    {
                        sum_time = 0;
                    }

                    if(sbm_debug)
                    {
                        fprintf(myf,"i=%d, NEX=%d, Slice=%d, sum_time=%f, minseqgrad =%d \n ", i,ii,j,sum_time,zy_export[i+j].heat);
                    }

                    /*  In below conditions, waiting sequence will begin.
                     *  The control flag will be installed in zy_export.flags
                     *  1. additional time exceeds Upper Limitation and it is at edge of slice encoding
                     *  2. additional time exceeds (Upper Limitation * ratio). (no matter slice encoding)
                     ***********************************************************************************/
                    if( ((sum_time >= sum_num) && ((arc_equant-1) == j)) ||
                        (sum_time >= (int)(sum_num * sbm_time_limit_ratio)) )
                    {
                        switch(ii)
                        {
                            case 0:
                                zy_export[i+j].flags |= HEAT_NEX1;
                                break;
                            case 1:
                                zy_export[i+j].flags |= HEAT_NEX2;
                                break;
                            case 2:
                                zy_export[i+j].flags |= HEAT_NEX3;
                                break;
                            case 3:
                                zy_export[i+j].flags |= HEAT_NEX4;
                                break;
                            case 4:
                                zy_export[i+j].flags |= HEAT_NEX5;
                                break;
                            case 5:
                                zy_export[i+j].flags |= HEAT_NEX6;
                                break;
                            default:
                                break;
                        }
                        sum_time -= dummy_time;
                        sbm_dda = sbm_dda_max -
                                       (int)( fabs(zy_export[i+j].view - phaseres/2) *
                                              ((float)(sbm_dda_max - sbm_dda_min) * 2.0 / phaseres) );
                        sum_time += (sbm_dda * (zy_export[i+j].heat - 100));
                        if(sum_time<0)
                        {
                            sum_time=0;
                        }
                        sbm_sum_dummy += sbm_dummy_num;
                        sbm_sum_dummy += sbm_dda;
                    }
                }
            }
        }
        if(sbm_debug)
        {
            fclose(myf);
        }
        /* waiting time is calculated to update pitscan and avmintscan in cveval() */
        sbm_waiting_time = sbm_sum_dummy * tmin_total;
    }

@inline Disco.e DiscoPredownload
@inline FastCINE3D.e fcine3d_predownload

    /* Transfer used portion of the zy_export table to AGP through a file to
       avoid transfering the worst case size through a static ipgexport
       array */
    if ( FAILURE == writeZyExport(zy_export, sampledPoints, zy_export_debug_files ) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "writeZyExport");
        free(zy_export);
        return FAILURE;
    }

    if (arc_flag && ((ACCEL_ARC == rhasset) || (ACCEL_DVCARC == rhasset)))
    {
        int unaccelPhases = ((15 == arc_pack_bam) ? (unaccel_dayres - 1) : (rhdayres - 1)) - ((idealiq_flag && idealiq_pc_flag) ? idealiq_pc_ylines : 0);
        int maxRy = (int) ceil(floor(arc_ph_stride*100) / 100.0);
        int maxRz = (int) ceil(floor(arc_sl_stride*100) / 100.0);

        if (SUCCESS != writeKacq(rhdaxres-exist(opxres)/2,
                                    unaccelPhases,
                                    equant,
                                    zy_export, 
                                    sampledPoints,
                                    ((ACCEL_ARC == rhasset) ? -1 : calibrationPoints), 
                                    (((ACCEL_ARC == rhasset) || (ACCEL_DVCARC == rhasset)) ? -1 : maskPoints),
                                    rhnecho,
                                    opfphases,
                                    rhdayres,
                                    arc_cal_echo,
                                    calRegion,
                                    rawdata,
                                    arc_pack_bam,
                                    arcPhaseRemapTable,
                                    arcSliceRemapTable,
                                    autolock,
                                    rhkacq_uid,
                                    maxRy,
                                    maxRz,
                                    pfkr_yz_flag,
                                    nr_of_segments,
                                    views_per_segment,
                                    &param4d))
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "writeKacq");
            return FAILURE;
        }

        if (disco_flag && exist(opdynaplan))
        {
            if (SUCCESS != writeKacq(rhdaxres-exist(opxres)/2,
                        unaccelPhases,
                        equant,
                        zy_export, 
                        sampledPoints,
                        ((ACCEL_ARC == rhasset) ? -1 : calibrationPoints), 
                        (((ACCEL_ARC == rhasset) || (ACCEL_DVCARC == rhasset)) ? -1 : maskPoints),
                        rhnecho,
                        opfphases,
                        rhdayres,
                        arc_cal_echo,
                        calRegion,
                        rawdata,
                        arc_pack_bam,
                        arcPhaseRemapTable,
                        arcSliceRemapTable,
                        autolock,
                        kacq_uid_washin,
                        maxRy,
                        maxRz,
                        pfkr_yz_flag,
                        nr_of_segments,
                        views_per_segment,
                        &param4d))
            {
                epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                        STRING_ARG, "writeKacq");
                return FAILURE;
            }
        }
    }
    free(zy_export);

    if (headneck_pos_scan)
    {
        rhposition_detection = opheadscout;
    }
    else
    {
        rhposition_detection = 0;
    }

@inline loadrheader.e rheaderpredownload

    return SUCCESS; 
} /* end predownload() */

/* BBA - improved SPECIAL */
STATUS
SpecIRSlorder( int *num_alphas,
               int *alpha0 )
{
    extern int optr;
    extern float opflip;
    extern int min_specirti;

    float E1 = 0.0;
    float E2 = 0.0;
    float q = 0.0;

    float mss = 0.0;
    float magn_lastalpha = 0.0;
    float magn_currentalpha = 0.0;
    float signchange = 0.0;

    int max_alphas = 0;
    int min_alphas = 0;

    int j = 0;
    int m = 0;
    int n = 0;
    int T1 = 0;
    int segments = 0;
    int extrakzlines = 0;

    T1 = 220;   /* T1 of targetted saturation tissue in ms.
                 This optimization is NOT very dependent on T1. */

    E1 = exp(-(float)optr/(T1*1000));
    E2 = exp(-(float)min_specirti/(T1*1000));
    q = E1*cos((float)opflip*DEG_TO_RAD);

    min_alphas = 6;
    max_alphas=arc_equant/2;
    extrakzlines = 100;  /* initialize to a very large value  */

    /* calculate optimal number of alpha pulses after each specIR pulse for TR, flip angle */

    *num_alphas = arc_equant/2;

    for (j = arc_equant/2; j>=min_alphas; j--) {
        mss = ( (1-E2)*(pow(q,j)) + (1-E1)*(1-(pow(q,j)))/(1-q) )/(1-(cos((float)180*DEG_TO_RAD))*E2*(pow(q,j)));
        if (mss < 0.21) {
            segments = ceil((float)arc_equant/j);
            if ( (segments*j - arc_equant) < extrakzlines) {
                extrakzlines = (segments*j - arc_equant);
                *num_alphas = j;
            }
            if (mss <0.16)
                break;
        }
    }

    /* MRIge89078 - Used sequential ordering as a default for Extraspecial */
    if( PSD_ON == extraspecial_seq_order_flag ) {
        if( (*num_alphas % 2) == 0 ) {
            *alpha0 = *num_alphas / 2; 
        } else {
            *alpha0 = *num_alphas / 2 + 1;
        }
    } else { 
        *alpha0 = 1;
        signchange = 1.0;
        n = *num_alphas;
        mss = ( (1-E2)*(pow(q,n)) + (1-E1)*(1-(pow(q,n)))/(1-q) )/(1-(cos((float)180*DEG_TO_RAD))*E2*(pow(q,n)));
        for (m=1;m<= n; m++) {
            magn_currentalpha = (mss*(cos((float)180*DEG_TO_RAD))*E2*(pow(q,m)) + (1 - E2))*(pow(q,m)) + (1-E1)*(1-(pow(q,m)))/(1-q);
            if (m>1) {
                signchange = magn_lastalpha*magn_currentalpha;
            }
            if (signchange < 0) {
                if (fabs(magn_lastalpha)< fabs(magn_currentalpha)) {
                    *alpha0 = m;
                }
                else {
                    *alpha0 = (m+1);
                }
                break;
            }
            magn_lastalpha = magn_currentalpha;
        }
    }

    return SUCCESS;
}   /* end SpecIRSlorder() */

/* ********************************************************************* 
   This function is used to calculate the optimal flip angle for IDEAL IQ.
   The optimal flip angle is calculated based of sequence length (act_tr).
   And the return value is dislayed with Auto FA scheme provided by Workflow 1.1
********************************************************************* */ 

int calc_optimal_fa_idealiq( int TR )
{
    int fat_t1;
    int water_t1;
    float E1w, E1f, ff_error, FF2;
    float ff_error_flip;
    float Sfat, Swater, ff_cos, ff_sin;
    int optfa;

    ff_error_flip = 0.0;   /* starting flip angle */
    FF2 = (1.0/(float)ff4error) - 1.0;  /* scale for water signal */

    if ( B0_30000 == (int)cffield )
    {
       fat_t1 = IDEALIQ_FAT_T1_30000;
       water_t1 = IDEALIQ_WAT_T1_30000;
    }
    else
    {
        /* These values for 1.5T system */
        fat_t1 = IDEALIQ_FAT_T1_15000;
        water_t1 = IDEALIQ_WAT_T1_15000;
    }

    E1w = exp(-(float)TR/(float)(water_t1*1000));
    E1f = exp(-(float)TR/(float)(fat_t1*1000));

    ff_error = ff4error; /* just to get us started */
    while ( ( ff_error_flip < 90.0) && ((ff_error - ff4error) <=  max_ff_error ) )
    {
       ff_error_flip = ff_error_flip + 1.0;
       ff_cos = cos(ff_error_flip*DEG_TO_RAD);
       ff_sin = sin(ff_error_flip*DEG_TO_RAD);

       Sfat =  ( (1.0 - E1f)*ff_sin) /(1.0 - E1f*ff_cos);
       Swater = (FF2*(1.0 - E1w)*ff_sin) /(1.0 - E1w*ff_cos);

       ff_error = Sfat / (Sfat + Swater);
    }

    optfa = (int)(ff_error_flip - 1.0);

    return optfa;
}    /* end calc_optimal_fa_idealiq() */

@inline ChemSatSpecIR.e ChemSatEval
@inline ChemSatSpecIR.e ChemSatCheck
@inline SpSat.e SpSatEval
@inline SpSat.e SatPlacement
@inline Prescan.e PShost
/* IFIR GRx */
@inline InversionGRx.e InversionGRxEval
@inline InversionGRx.e InversionGRxPredownload

@rspvar
/*********************************************************************
 *                    EFGRE3D.E RSPVAR SECTION                       *
 *                                                                   *
 * Declare here the real time variables that can be viewed and modi- *
 * fied while the Tgt PSD process is running. Only limited standard  *
 * C types are provided: short, int, long, float, double, and 1D     *
 * arrays of those types.                                            *
 *                                                                   *
 * NOTE: Do not declare all real-time variables here because of the  *
 *       overhead required for viewing and modifying them.           *
 *********************************************************************/
int   psd_seqtime;      /* sequence time */
int   d3ddab;                   /* Waveform index for the 3d dab pulse */
int   echo1dab;           	/* Waveform index for the echo1 dab pulse */
short amp_gy1;			/* Y grad variables */
short amp_gx1, amp_gxw, amp_gxwex;		/* X grad variables */
short amp_gx2, amp_gxw2;
int   dabecho, dabecho_multi, dabop, dabview;	/* vars for loaddab */
short debugstate;		/* if trace is on */
int   pass, view, excitation, excitation_seq, slice, baseviews, disdaqs;
int   exct; /* VAL15 12/14/2004 YI */
int   dabslice;			/* JFS */
int   sl_rcvcf;			/*  center freq receive offset */
int   slabquant, slab_phase;
int   exphase, spgr_count, rcphase, chop_phase, chop_exphase;
short slabindex,phaseindex; /* 3d oblique - added rspvariables slabindex and phaseindex - latha@mr */
short sliceindex;
short coilindex;
int psd_index;
/* MRIhc16353 - RV: IDEAL change */
int echo_index, inner_echo, outer_echo;
int seq_count; /* VAL15 12/14/2004 YI */
/* Auto Voice  04/18/2005 YI */
int pass_seqtime_def;
int pass_seqtime_mph;
int scan_deadtime;            /* deadtime in scan entry point */
int seqpass_deadtime;         /* deadtime in seqpass entry point - MRIhc20775 */

int threedpkt_debug = 0; /* For 3D plane packet debugging */

@inline Tricks.e TricksRspvars

/* HK for Fiesta-C */
int   pcfiesta_index;           /* Phase Cycling Index for FIESTA-C */

int j;
int specirprep = 0;

int resptrigger;  /* respiratory trigger */
int resp_reps;    /* number of times RespGate sampled waveform */

int rspir;            /* IR PREP (pjg) */
int slices_per_segment;

int first_slice;
int slicecount;
int viewcount;
@inline SpSat.e SpSatRspVar
@inline ChemSatSpecIR.e ChemSatRspVar 
@inline Prescan.e PSrspvar
@inline MSDE.e MSDE_RspVar

@inline Monitor.e MonitorRspVar
@inline InversionGRx.e InversionGRxRspVar /* IFIR GRx */

@inline Respgate.e RGrspvar
@inline VAST.e VASTrspvar
@inline FastCINE3D.e fcine3d_rspvar

/* MRIge66079 - ATV: RTIA3D/ftMRA */
@inline RTIA.e realtime_rspvar
@inline RTIA.e efgre3d_rspvar

int new_data;
int rtia3d_satview_start;
int rtia3d_satview_end;

/* End RITA3D/ftMRA  */

int rspent;
short rspdda, rspbas, rspvus, rspnex, rspchp, rspgy1,
    rspesl, rspasl, rspech, rspsct, rspskp, rspdex, rspslq, rsprlx,
    rmode, resdda, resbas, resvus, resnex, reschp, resdex, 
    resesl, resasl, resech, ressct, resslq, rspphs, 
    rspisi, rsptimessi, rspscptrg;
short  rspmpssl = 0;
short unaccel_rspvus;  /* rspvus without ARC acceleration */
int psc_slab_index=0;


/* RSP Control Variable Definitions. Listed above  are
   several variables all with the prefix "rsp".  These variables
   are set in the initial part of each entry point,
   before CORE is called. They are used in CORE to
   control the excitation and acquisition of data.
   Descriptions of the use of each of these variables is given
   below.  Each of the variables also has a reseach rsp variable
   counterpart.  When rsp variable rmode is set to 1,
   all "res" variables with the prefix "res" are used for CORE
   control instead of variables with the "rsp" prefix.

   
   dda = total number of disdaq acquisitions ( NOT in pairs )
   bas = total number of baseline acquisitions ( NOT in pairs )
   vus = total number of views to collect
   gy1 = index of initial amplitude of y dephaser
   -1 = calculate initial amplitude
   nex = total number of excitations
   chp = chopper states:
   0 = chop baselines only
   1 = chop everything
   2 = no chopping
   esl = index number of excited slice
   -1 = excite all slices
   asl = index number of acquired slice
   -1 = acquire all non-disdaq slices
   sct = slice number to turn on scope trigger
   -1 = scope trigger on all slices
   dex = total number of views to discard per
   excitation. This allow a disdaq to be done
   on each view.  Normally = 0
   slq = total number of slices to acquire
   cfm = not used
   ent = entry point

*/


short rsp_preview = 0; /* amplitude of phase encode for prescan entrypoints */
short tempamp; /* temporary amplitude storage */
int ssp_ctrl;
short temp_short;

int slice_cnt, view_cnt, segment_cnt;
int nshots;
int seg_cnt_nav;

int currentPhase_dynaplan;

@pg
/*********************************************************************
 *                     EFGRE3D.E PULSEGEN SECTION                    *
 *                                                                   *
 * Write here the functional code that loads hardware sequencer      *
 * memory with data that will allow it to play out the sequence.     *
 * These functions call pulse generation macros previously defined   *
 * with @pulsedef, and must return SUCCESS or FAILURE.               *
 *********************************************************************/

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#ifdef PSD_HW   /* Auto Voice */
#include "broadcast_autovoice_timing.h"
#endif

/* MRIhc11575 */
ZY_EXPORT * zy_export = NULL;

long deadtime;                 /* amount of deadtime */
short prescan_trigger;        /* save the prescan slice's trigger */
short viewtable[1025];        /* view table */
short rtia3d_viewtable[1025];        /* view table */
short viewtab[1025];
long rsptrigger_temp[1];     /* temp trigger array for pass packets 
                                sequences and other misc */
int sp_satindex, cs_satindex; /* index for multiple calls to spsat
                                 and chemsat routines */
/* Frequency offsets */
int *rf1_freq;
int *rf0_freq;                /* IR PREP (pjg) */
int *receive_freq1;
int *receive_freq2;
int *receive_freq1_rev;
int *receive_freq2_rev;

int *rf0_pha; /* TKF phase for adiabatic */
 
#ifdef PSD_IPG_DEBUG
int psdisivector = 7;
int psdisicnt = 0;
int psd_isi_on = 1;
long psdctrl = 0;
#endif

/* RBA pulse information */
WF_PULSE *echo1rba;
int echo1rbarsp;

int echo2toNdab[MAX_ECHOES];
int echo2toNrba[MAX_ECHOES];
WF_PULSE *echo2toN;
WF_PULSE_ADDR *p_echo2toNrba;
WF_PULSE_ADDR *p_echo2toNxtr;

int rf1frqrsp, echo1xtrrsp;
WF_PULSE_ADDR prf1frq, pecho1xtr, rec_unblank;

/* Move this array to ipg export when exports get shipped in the save */
const CHAR *entry_name_list[ENTRY_POINT_MAX] = { "scan","mps2","aps2",
@inline Prescan.e PSeplist
};

extern PSD_EXIT_ARG psdexitarg;

WF_PULSE rf1tmp = INITPULSE;    /* rf1 in ps1 */
int rf1tmp_addr;

/* spatial sat additions */
long rsprot_orig[DATA_ACQ_MAX][9];   /* vmx 05/04/95 KS */

SHORT temp_amp;

/* SPSP */ 
EXTERN_FILENAME2 grad_zrf1;
EXTERN_FILENAME2 rf_rf1 ;
EXTERN_FILENAME2 theta_rf1;
WF_PULSE thetarf1  = INITPULSE;
int *theta_freq;

@inline Monitor.e MonitorPGDecl
@inline T2Prep.e  T2PrepPG
@inline InversionGRx.e InversionGRxPGparams /* IFIR GRx */

@inline Tricks.e TricksPgvars
@inline FastCINE3D.e fcine3d_PGvars

/* TKF needed for adiabatic pulse */
STATUS
setupphases( int *phase,	/* output phase offsets */
             int *freq,	        /* precomputed frequency offsets */
             int slice,	        /* slice number */
             float rel_phase,	/* in cycles */
             int time_delay )   /* in micro seconds */
{
    double ftime_delay;		/* floating point time delay in seconds */
    double temp_freq;		/* frequency offset */
    float tmpphase;
    int intphase;
    int sign;

    ftime_delay = ((double)time_delay)/((double)(1s));

    /* Convert tardis int to frequency */
    temp_freq = ((double)(freq[slice]))*TARDIS_FREQ_RES;

    /* determine phase change in radians */
    tmpphase = (rel_phase - ( temp_freq * ftime_delay ))*2.0*M_PI;

    tmpphase /= (float)M_PI;	/* unwrap this phase bits */
    if (tmpphase < 0) {
        sign = -1;
        tmpphase *= -1;
    } else {
        sign = 1;
    }

    if ( ((int)floor((double)tmpphase) % 2) == 1) {
        sign *= -1;
        intphase = sign * (long)
            ( (1.0-(tmpphase - (float)floor((double)tmpphase)) ) * ((double)FSI));
    } else {
        intphase = sign * (long)
            ( (tmpphase - (float)floor((double)tmpphase)) * ((double)FSI));
    }

    phase[slice] = intphase;		

    return SUCCESS;
}   /* end setupphases() */


STATUS
pulsegen( void )
{
    EXTERN_FILENAME ext_filename; /* filename holder for 2dtof pulse */
    INT PosPhaseEncode1 = 0, PosPhaseRew1 = 0;    /* Y encode and rewinder pulse locs */
    INT PosYFE1 = 0;			  /* Y flow encoding */
    INT PosReadoutWindow = 0;                 /* Readout window location */
    INT PosDabPkt = 0;                        /* DAB packet location */
    INT PosXtrPkt = 0;                        /* XTR packet location */
    INT PosGx1 = 0;                           /* Readout dephaser location */
    INT PosGx2 = 0;
    INT PosXKiller = 0;                       /* X Killer location */
    INT PosGzcomb = 0;                        /* Comb refocus / slice encode location */
    INT PosGzp = 0;                           /* Comb rewinder / killer location */
    INT PosTemp = 0;                          /* 3D Packet location */
    INT PosISI = 0;                           /* ISI packet location */
    INT PosDabPkt2toN = 0;
    INT PosXtrPkt2toN = 0;
    INT PosReadoutWindow2toN = 0;
    INT PosTnsOff = 0;
    INT echoindex = 0;
    SHORT temp_amp = 0;
    INT PosFCRead = 0;
    INT PosGz1 = 0;
    INT DabSetUp = 0;

    /* MRIhc16353 - RV: IDEAL change */
    INT PosDix_xpre = 0;                      /* dixon wait time XGRAD */
    INT PosDix_ssppre = 0;                    /* dixon wait time SSP */
    INT PosDix_ssppost = 0;                    /* dixon wait time SSP */
    INT psd_seqtime = 0;                      /* sequence time */

    int temp_res = 0;         /* temporary resolution */
    short *temp_wave_space = NULL; /* temporary waveform space for rf scaling */
    short *wave_space = NULL; /* temporary waveform space for rf scaling */

#ifdef IPG
    INT sp_killerx = 0;                       /* Position of X sp sat crusher */
    INT sp_killerz = 0;                       /* Position of Z sp sat crusher */

    /* JP multi-phase variables */
    INT pass_seqtime = 0;      /* sequence time for pass section*/
    INT pass_seqtime2d = 0;
    INT delay1_seqtime = 0;      /* sequence time for first delay section*/

    INT resp_comp_type = TYPNORM;         /* low sort, high sort */
    INT ir_seqtime = 0;                       /* IR PREP (pjg) */
    INT psd_seqhtrtime = 0;                   /* sequence time for half alpha/TR */
#endif /* IPG */

    /* ********************************************************************
       Pulsegen
       In research and prototype PSDs, a majority of the work can be done
       in the pulsegen section and taken out of the CvEval section.  The user
       can allow the pulsegen section to define many pulsewidths and
       amplitudes for behind his back.  For product PSDs however, optimization
       and absolute knowledge of pulse widths and amplitudes are needed for
       the advisory panel.  Thus CV_Eval will define most pulse widths
       and amplitudes for pulsegen in product PSDs.
    ******************************************************************/

    /* initialize TG limit max system tg: 200 */
    TGlimit = MAX_SYS_TG;

    debugstate = debug;
    SetHWMem ();
@inline vmx.e VMXpg  /* vmx 12/28/94 YI */
    /* Initialize psdexitarg */
    /* MRIhc18005 */

    sspinit(psd_board_type);

    psdexitarg.abcode = 0;
    strcpy(psdexitarg.text_string, "pulsegen");
    view = slice = excitation = 0;
    psdexitarg.longarg[0] = (long *)&rspent;
    psdexitarg.longarg[1] = (long *)&view;
    psdexitarg.longarg[2] = (long *)&slice;
    psdexitarg.longarg[3] = (long *)&excitation;

/* MRIhc11575 */
#ifdef IPG
    /* Read zy_export table from disk.  The table is not setup until
       predownload, so it cannot be used in pulsegen on host since it
       has not been filled in yet. */
    zy_export = (ZY_EXPORT *) AllocNode((sampledPoints) * sizeof(ZY_EXPORT));
    if (NULL == zy_export)
    {
        printf("pulsegen: Unable to allocate memory (AllocNode) for zy_export!\n");
        return FAILURE; 
    }
    if (FAILURE == readZyExport(zy_export, sampledPoints, zy_export_debug_files))
    {
        return FAILURE;
    }

    /* SVBranch, Smart Burst Mode */
    /* SBM: recover ia_gx1 etc. */
    if(sbm_flag)
    {
        ia_gx1 = (a_gx1 / loggrd.tx) * MAX_PG_IAMP;
        ia_gxw = (a_gxw / loggrd.tx) * MAX_PG_IAMP;
        ia_gxwex = (a_gxwex / loggrd.tx) * MAX_PG_IAMP;
    }
#endif

@inline FastCINE3D.e fcine3d_genviewtable
    /* *********************
       Chem Sat
       ********************* */

    /* MRIge51364 - If chemsat is a part of the main imaging sequence (intermittant_chemsat is off), 
       then it must be generated prior to the pulses for the imaging sequence. This is due to a 
       limitation in pulsegen on host, where the first sequence must be the main imaging sequence - 
       seqcore. When this is fixed, the conditional check for intermittant_chemsat can be removed 
       - latha@mr */

    if (intermittant_chemsat == PSD_OFF) {
        cs_satindex = 0;
        if (cs_sat == PSD_ON)
            ChemSatPG(cs_satstart, &cs_satindex);
    }

    /* IFIR GRx */
#ifdef IPG
    if (ifir_flag)
    {
        InversionGRxPG(gir_start);
    }
#endif

    /* ********************
       Minimum phase alpha pulse and z slab select
    *******************/
    /* put external wave into memory */

    if (!ss_rf1) 
    {

        /* ATV: added linear phase excitation r.f. for FIESTA */
        if( ssfp_flag == PSD_ON ) 
        {
            switch (rf1_pulse_type){

                case RF_3D_600US_01P_01S_10KHZ :
                    strcpy(ext_filename, "rf3d_600us_01p_01s_10khz.rho");
                    break; 
                case RF_TBW8_001_001_200LP :
                    strcpy(ext_filename, "tbw8_001_001_200pm.rho");
                    break;
                case RF_TBW8_001_001_200 :
                    strcpy(ext_filename, "tbw8_001_001_200.rho");
                    break;
                case RF_HARD24:
                    strcpy(ext_filename, "fermi24.rho");
                    break;
                case RF_E3DFGRE:
                    strcpy(ext_filename, "rf3d16min.rho");
                    break;
                case RF_TB3_01_001_250:
                default:
                    strcpy(ext_filename, "tbw3_01_001_pm_250.rho");
                    break;     
            } /* end switch */
        }
        else
        {
            switch (rf1_pulse_type) {
                case RF_3DFGRE:       /* added backward compatibility - latha@mr */
                    strcpy(ext_filename, "rf3dfgre.rho");
                    break;
                case RF_E3DFGRE:
                    strcpy(ext_filename, "rf3d16min.rho");
                    break;
                case RF_TURBO:
                    strcpy(ext_filename, "rf3d8min.rho");
                    break;
                case RF_TBW3_005_01:
                    strcpy(ext_filename, "tbw3_005_01_150a.rho");
                    break;
                case RF_TBW3_005_01_48 :
                    strcpy(ext_filename, "tbw3_005_01_48.rho");
                    break;
                case RF_TBW6 :
                    strcpy(ext_filename, "tbw6_01_001_150.rho");
                    break;
                case RF_TBW8:
                    strcpy(ext_filename, "tbw8_01_001_150.rho");
                    break;
                case RF_HARD100:
                    strcpy(ext_filename, "fermi100.rho");
                    break;
                case RF_HARD24:
                    strcpy(ext_filename, "fermi24.rho");
                    break;
                case RF_TBW12:
                    strcpy(ext_filename, "tbw12_001_001_150.rho"); 
                    break;
                case RF_TBW24:
                    strcpy(ext_filename, "tbw24_001_001_200.rho");
                    break;
            }
        }

    } 
    temp_wave_space = (short *)AllocNode(res_rf1*sizeof(short));

#ifdef IPG
    if(!ss_rf1){
        /* MRIge59009 Pulsegen on host doesn't need this */
        uextwave(temp_wave_space,res_rf1,ext_filename);
    }

#endif

    wave_space = temp_wave_space;

    if (ss_rf1)
    {
        /* start adding code for SPSP pulse based on macro EFFSLICESELZ_SPSP */
        {
            /* Select proper filename */
            grad_zrf1=  ssgzfile;
            rf_rf1 =  ssrffile;
            theta_rf1 = ssgzfile;

            /* Now create the pulses */
            pulsename(&gzrf1a,"gzrf1a");
            pulsename(&gzrf1,"gzrf1");
            pulsename(&gzrf1d,"gzrf1d");
            pulsename(&rf1,"rf1");
            pulsename(&thetarf1, "thetarf1");

            /*  Now create the slice select trapezoid */
            pg_beta = loggrd.zbeta;


#if defined(IPG_TGT) || defined(MGD_TGT)
            /* Use external gradient file for now */
            createextwave( &gzrf1, ZGRAD, res_gzrf1,
                           grad_zrf1 );

            createinstr( &gzrf1, (long)pos_start+RUP_GRD(pw_gzrf1a*(1-ss_rf1)+psd_rf_wait),
                         pw_gzrf1, ia_gzrf1 );

#elif defined(HOST_TGT)
            /* Create train of trapezoids on the Host side */
            int i;
            int polarity = 1;

            pulsepos  = _pulsepos.fixedflag ?  ((void)(pos_start+RUP_GRD(pw_gzrf1a*(1-ss_rf1)+psd_rf_wait)), pulsepos) : pos_start+RUP_GRD(pw_gzrf1a*(1-ss_rf1)+psd_rf_wait); 

            for(i = 1; i <= num_rf1lobe; i++) {
                polarity *= -1;

                trapezoid( ZGRAD,"gzrf1", &gzrf1, 
                           &gzrf1a, &gzrf1d,
                           pw_constant, pw_ss_rampz, pw_ss_rampz, 
                           (polarity*(ia_gzrf1)),
                           (polarity*(ia_gzrf1)),
                           (polarity*(ia_gzrf1)), 0, 0, 
                           pulsepos, TRAP_ALL, &loggrd );

                pulsepos  = _pulsepos.fixedflag ?      ((void)(pw_constant+2*pw_ss_rampz), pulsepos) : pulsepos+pw_constant+2*pw_ss_rampz;
            }
#endif

            /* Now create the rf pulse */
            if ( 1 == PLAY_RFFILE) {
                createextwave( &rf1,TYPRHO1, res_rf1,
                               rf_rf1);
            } 

            createinstr( &rf1,(long)pos_start+RUP_GRD(pw_gzrf1a*(1-ss_rf1)+psd_rf_wait) + psd_rf_wait +
                         ss_rf_wait,  pw_rf1,ia_rf1);

            addrfbits( &rf1, off_rf1, (long)pos_start+RUP_GRD(pw_gzrf1a*(1-ss_rf1)+psd_rf_wait) +
                       psd_rf_wait + ss_rf_wait, pw_rf1 );

            /* Now create the theta pulse */
            createextwave( &thetarf1, TYPOMEGA,
                           res_thetarf1, theta_rf1 );

            createinstr( &thetarf1, (long)pos_start+RUP_GRD(pw_gzrf1a*(1-ss_rf1)+psd_rf_wait) + psd_rf_wait +
                         ss_rf_wait, pw_thetarf1,
                         ia_thetarf1 );

            addrfbits( &thetarf1, off_thetarf1,
                       (long)pos_start+RUP_GRD(pw_gzrf1a*(1-ss_rf1)+psd_rf_wait) + psd_rf_wait + ss_rf_wait,
                       pw_thetarf1 );
#if defined(IPG_TGT) || defined(MGD_TGT)
            linkpulses( 3,
                        &rf1, &gzrf1, &thetarf1);
#endif
        }        
        /*end insertion SPSP pulse, copied from epic.h EFFSLICESELZ_SPSP macro*/
    }
    else
    {
       /* Stretch rf pw if needed */
       temp_res = res_rf1;
       if (rfpulseInfo[RF1_SLOT].change==PSD_ON)
       {
           wave_space = (short *)AllocNode(rfpulseInfo[RF1_SLOT].newres*sizeof(short));
           stretchpulse((int)res_rf1,(int)rfpulseInfo[RF1_SLOT].newres,temp_wave_space,wave_space);
           res_rf1 = rfpulseInfo[RF1_SLOT].newres;
           res_rf1htr = rfpulseInfo[RF1_SLOT].newres;
           FreeNode(temp_wave_space);
       }
       else
           wave_space = temp_wave_space;

       /* move the wave to the hardware */ 
       SPACESAVER(RHO, rf1, res_rf1); 

       /* BJM: this function is similar to addrfbits in that it sets up  */
       /* the control words for an RF pulse.  This function allows the   */
       /* RF Amp Unblank time to be reduced to 50us and insures that the */
       /* total RF Amp unblank time is >= 260 us to allow the SSM to     */
       /* finish checking errors (faults occur if this is not obeyed...  */
       {
           int rfupa_time = abs(rfupacv);

           fastAddrfbits(&rf1, 0, pos_start+pw_gzrf1a+psd_rf_wait, pw_rf1, rfupa_time);
       }
       createinstr(&rf1,pos_start+pw_gzrf1a+psd_rf_wait,pw_rf1,ia_rf1);
    } 

    if (!ss_rf1)
    {
        getssppulse(&prf1frq, &rf1, "frq", 0);
        getwave(&rf1frqrsp, prf1frq);

        movewaveimm(wave_space, &rf1, (int)0, res_rf1, TOHARDWARE);
        FreeNode(wave_space);
    }

    /* Change back incase external grad_file used */
    if (rfpulseInfo[RF1_SLOT].change==PSD_ON)
        res_rf1 = temp_res;

    /* gets instruction number of scan, ps2 rf1 */
    scanrf1_inst = rf1.ninsts-1;

    /* ****************************************
       Z slice select
       **************************************** */
    if (!ss_rf1)
    {

       TRAPEZOID(ZGRAD,gzrf1,pbeg(&rf1,"rf1",scanrf1_inst)-psd_rf_wait,0,
                 TYPNDEF, loggrd);
    }

    /* ****************************************
       X Dephaser, Readout, and Data Acquisition
       ************************************** */
    PosReadoutWindow = RUP_GRD(pos_start + t_exa + te_time - t_rd1a);
    TRAPEZOID(XGRAD, gxw, PosReadoutWindow, 0, TYPNDEF, loggrd);

    /* BJM: move DAB packet after RF for less upfront deadtime */
    getssppulse(&rec_unblank, &rf1, "ubr", 0);

    /* MRIge73549 - use pendallssp to position dabpkt at the 
       end of receiver unblank pulse. - RJF */
    if((PSD_ON == ideal_flag) || (medal_flag && medal_multitr_flag) || idealiq_flag)
    {
       PosDabPkt = RUP_GRD(pendallssp(rec_unblank, 0)+GRAD_UPDATE_TIME);
    }
    else
    {
       PosDabPkt = RUP_GRD(pendallssp(rec_unblank, 0));
    }

    PosTemp = PosReadoutWindow;

    if ( (PosTemp - XTRSETLNG) < (PosDabPkt+DAB_length[bd_index]) )
    {
        PosTemp = RUP_GRD(PosDabPkt + DAB_length[bd_index] + XTRSETLNG);
    }

    PosXtrPkt = RUP_GRD(PosReadoutWindow+pw_gxwl+psd_grd_wait-XTR_length[bd_index]-XTRSETLNG);

    if (PosXtrPkt < (PosTemp - XTRSETLNG + DIM_length) )
    {
        PosXtrPkt = RUP_GRD(PosTemp - XTRSETLNG + DIM_length);
    }

        DabSetUp = IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]+DIM_length));

    if (opetl>=2)
    {
        PosDabPkt = RUP_GRD(PosReadoutWindow+pw_gxwl+psd_grd_wait-DabSetUp);
    }

    ACQUIREDATA(echo1, PosReadoutWindow+pw_gxwl+psd_grd_wait,
                PosDabPkt, PosXtrPkt, DABNORM);

    /* BJM: set TNS based on location of RBA and readout */
    getssppulse(&echo1rba, &echo1, "rba",0);

    if(opetl>=2) {
      char pulse_name[20];
      echo2toN = (WF_PULSE *)AllocNode(opetl*sizeof(WF_PULSE));
      p_echo2toNrba = (WF_PULSE_ADDR *)AllocNode(opetl*sizeof(WF_PULSE_ADDR));
      p_echo2toNxtr = (WF_PULSE_ADDR *)AllocNode(opetl*sizeof(WF_PULSE_ADDR));

      for(echoindex=0; echoindex < (opetl-1); echoindex++) {
        if (uniPolar_flag) {
            PosGx2 = RUP_GRD(pendall( &gxw, 0 ) + pw_gx2a + echoindex*esp);
            TRAPEZOID ( XGRAD, gx2, PosGx2, 0, TYPNDEF, loggrd);

        }

            PosDabPkt2toN = RUP_GRD(PosDabPkt + esp + echoindex*esp);
            PosReadoutWindow2toN = RUP_GRD(PosReadoutWindow + esp + echoindex*esp);
            PosXtrPkt2toN = RUP_GRD(PosXtrPkt + esp + echoindex*esp);

        TRAPEZOID ( XGRAD, gxw2, PosReadoutWindow2toN, 0, TYPNDEF, loggrd);

        if (uniPolar_flag == PSD_OFF) {
            getiamp(&temp_amp, &gxw2, echoindex);
            setiampt((echoindex%2)?temp_amp:-temp_amp, &gxw2, echoindex);
        }

        sprintf(pulse_name,"echo2toN%d",echoindex);
        pulsename(&(echo2toN[echoindex]),pulse_name);

        acqq(&(echo2toN[echoindex]), (long) (PosReadoutWindow2toN+pw_gxwl+psd_grd_wait), (long) PosDabPkt2toN,(long)(PosXtrPkt2toN),filter_echo1,(TYPDAB_PACKETS)DABNORM);

        getssppulse(&(p_echo2toNrba[echoindex]), &(echo2toN[echoindex]), "rba", 0);
        getssppulse(&(p_echo2toNxtr[echoindex]), &(echo2toN[echoindex]), "xtr", 0);
      }
    }

    TNSON(e1entns,pendallssp(echo1rba, 0));

    if (opetl>=2)
       PosTnsOff = RUP_GRD(PosReadoutWindow2toN + pw_gxw2 + psd_grd_wait);
    else
       PosTnsOff = RUP_GRD(pendallssp(echo1rba, 0) + ssp_pwisi7 - pw_gxwl);

    TNSOFF(e1distns,PosTnsOff);

    attenflagon(&echo1,0);
    getwave(&echo1dab, &echo1);

    getssppulse(&pecho1xtr, &echo1, "xtr", 0);
    getwave(&echo1xtrrsp, pecho1xtr);

    if(opetl>=2) {
       for(echoindex=0; echoindex <(opetl-1); echoindex++) {
          getwave(&(echo2toNdab[echoindex]), &(echo2toN[echoindex]));
          getwave(&(echo2toNrba[echoindex]), p_echo2toNrba[echoindex]);
       }
    }

    /* mark end of first aquisition window */
    ATTENUATOR(attenuator_key, pendallssp(&e1distns,0));

    if (flow4D_flag==PSD_ON) 
    {
        PosGx1 = RUP_GRD(pbegall(&gxw, 0)-(pw_gxfca+pw_gxfc+pw_gxfcd)-(pw_gx1+pw_gx1d));
    }
    else 
    {
        PosGx1 = RUP_GRD(pbegall(&gxw, 0) - (pw_gx1 + pw_gx1d));
    } 
    SINGLE_TRAP(XGRAD, gx1, PosGx1, 0, , TYPNDEF, TRAP_ALL, , , loggrd );

    if ((flow_comp_type == TYPFC) || (flow4D_flag==PSD_ON))
    {
       if (flow4D_flag == PSD_ON) 
       {
           PosFCRead = pbeg(&gxwa,"gxwa",0)-(pw_gxfc+pw_gxfcd);
       }
       else 
       {
           PosFCRead = RUP_GRD(PosGx1 - pw_gxfcd - pw_gxfc - pw_gx1a);
       }
       TRAPEZOID( XGRAD, gxfc, PosFCRead, 0, TYPNDEF, loggrd);
    }

    /* MRIhc16353 - RV: IDEAL change */
    if( (PSD_ON == ideal_flag) || (medal_flag && medal_multitr_flag) || idealiq_flag )
    {
       PosDix_xpre = pbegall(&gx1, 0) - GRAD_UPDATE_TIME;
       WAIT(XGRAD, dix_xpre, PosDix_xpre, GRAD_UPDATE_TIME);
       PosDix_ssppre = pbegallssp(&echo1, 0) - GRAD_UPDATE_TIME;
       WAIT(SSP, dix_ssppre, PosDix_ssppre, GRAD_UPDATE_TIME);
       PosDix_ssppost = pendallssp(&attenuator_key, 0) ;
       WAIT(SSP, dix_ssppost, PosDix_ssppost, (ideal_pw + idealiq_pw + medal_pw + GRAD_UPDATE_TIME));
    }

    /* MRIge66079 - ATV: RTIA3D/ftMRA */
    /* MRIge91973 */ 
    if ( (ftmra_flag) || (gxwex_on == PSD_OFF) || (maskv_ftmra_flag) || (ssfp_flag) || (opetl>=2) || (flow_comp_type==TYPFC) )
    {
        if( bridge_gxw2_gxwex_3dde ) { /* bridge gxw2 and gxwex */
            temp_wave_gen = XGRADB;
            PosXKiller = RUP_GRD(pend(&gxw2,"gxw2", gxw2.ninsts-1) + pw_gxwexa);
        } else {
            temp_wave_gen = XGRAD;
            if (opetl>=2)
               PosXKiller = RUP_GRD(pend(&gxw2, "gxw2", gxw2.ninsts - 1) + pw_gxwexa + pw_gxwd) ;
            else
               PosXKiller = RUP_GRD(pend(&gxw,"gxw",0) + pw_gxwexa + pw_gxwd) ;
        }
    }
    else
    {
        temp_wave_gen = XGRADB;
        PosXKiller = RUP_GRD(pend(&gxw,"gxw",0) + pw_gxwexa);

    }

    if (gxwex_on == PSD_ON)
    {
        TRAPEZOID(temp_wave_gen, gxwex, PosXKiller,
                  0, TYPNDEF, loggrd);
    }
    /* End RTIA3D/ftMRA */

    if(idealiq_flag && idealiq_pc_flag)
    {
        getiamp(&amp_gx1, &gx1, 0);
        getiamp(&amp_gxw, &gxw, 0);
        if (uniPolar_flag == PSD_ON)
        {
            getiamp(&amp_gx2,  &gx2, 0);
        }
        getiamp(&amp_gxw2,  &gxw2, 0);
        getiamp(&amp_gxwex, &gxwex, 0);
    }


    /*****************************************
      Z combined rephaser & slice encode (gzcomb),
      & combined slice rewinder & killer pulses (gzp)
    ******************************************/

    if ((flow_comp_type == TYPFC) || (flow4D_flag == PSD_ON) )
    {
        if (ss_rf1) {
#ifdef IPG
           PosGz1 = RUP_GRD(pend(&gzrf1, "gzrf1", 0) + pw_gz1a);
#else
           PosGz1 = RUP_GRD(pend(&gzrf1, "gzrf1", num_rf1lobe-1) + pw_ss_rampz + pw_gz1a);
#endif
        }
        else
        {
           PosGz1 = RUP_GRD(pend(&gzrf1, "gzrf1", 0) + pw_gzrf1d + pw_gz1a);
        }
        TRAPEZOID(ZGRAD,gz1,PosGz1,0,TYPNDEF, loggrd);
    }

    if (flow_comp_type == TYPFC)
    {
       PosGzcomb = RUP_GRD(PosReadoutWindow - pw_gzcomb_tot);
    } else if (ssfp_flag && ssfp_symmetry_flag) {
       PosGzcomb = RUP_GRD(pbeg(&gxw,"gxw",0) - rewinding_time + psd_grd_wait);
    } else {
       if (ss_rf1) {
#ifdef IPG
          PosGzcomb = RUP_GRD(pend(&gzrf1, "gzrf1", 0));
#else
          PosGzcomb = RUP_GRD(pend(&gzrf1, "gzrf1", num_rf1lobe-1) + pw_ss_rampz );
#endif
       }
       else {
           if (flow4D_flag == PSD_ON)
           {
                PosGzcomb = RUP_GRD(pend(&gz1d, "gz1d", 0));
           }
           else 
           {
                PosGzcomb = RUP_GRD(pend(&gzrf1, "gzrf1", 0) + pw_gzrf1d);
           }
       }

    }

    if (flow4D_flag)
    {
         temp_trap_type = TRAP_ALL;  /* for flow - use plain trapezoid */
    }
    else 
    {
         temp_trap_type = TRAP_ALL_SLOPED;
    }

    SINGLE_TRAP(ZGRAD, gzcomb, PosGzcomb+pw_gzcomba,,endviewz_scale,TYPNDEF,temp_trap_type,,,loggrd);
    if (zrewind_flag)
    {
        if( ( ssfp_flag == PSD_ON )  && (opetl==1) )
        {
            /* SVBranch, HCSDM00100069 */
            PosGzp =  RUP_GRD(pend(&gxw,"gxw",0) + rewinding_time - (count_grd_wait? psd_grd_wait : 0)  - pw_gzp - pw_gzpd);
        }
        else
        {
            /* MRIhc16353 - RV: IDEAL change */
            if ( (PSD_ON == ideal_flag) || (medal_flag && medal_multitr_flag) || idealiq_flag )
            {
		/* MRIhc24440 :Replaced act_tr by tmin */ 
               /* SVBranch, HCSDM00100069 */
               PosGzp = RUP_GRD(tmin - ((count_grd_wait? psd_grd_wait : 0) + time_ssi + 2*GRAD_UPDATE_TIME) - pw_gzp - pw_gzpd);
            }
            else 
            {
               if (opetl>=2)
                  PosGzp = RUP_GRD(pend(&gxw2, "gxw2", gxw2.ninsts - 1) + pw_gzpa) ;
               else
                  PosGzp = RUP_GRD(pend(&gxw, "gxw", 0) + pw_gzpa) ;
	    }
        }

        SINGLE_TRAP(ZGRAD, gzp, PosGzp,,endviewz_scale,TYPNDEF,TRAP_ALL_SLOPED,,,loggrd);
    }

#ifdef PSD_IPG_DEBUG
    if (isi_flag == PSD_ON)
    {
        /* MRIge14777, we don't want to update the rewinder or the
           combined slice refocus/killer untill they have started.
           Since the rewinder is at least 1ms, this should work.
           PosISI = pend(&gxw, "gxw", 0) - pw_gxwex + 10; */

        /* MRIge16285: 4/20/93 CFL Okay because we are using a
           memory trap lets move the isi just after the beginning. */
        if(cine3d_flag == PSD_ON)
        {
            PosISI = RUP_GRD(pbegallssp(&e1distns, 0) - pw_isi7 - 10);
        }
        else
        {
            PosISI = RUP_GRD(pbeg(&gzp, "gzp", 0) + 10);
        }

        WAIT(SSP, isi7, PosISI, pw_isi7);
    }
#endif



@inline FastCINE3D.e fcine3d_pulsegen

    /* *****************************************
       Create the 3d packet
    *****************************************/
    /* PosTemp = PosReadoutWindow + pw_gxwl + psd_grd_wait -
       XTR_length[bd_index] - XTRSETLNG - DIM_length; */
    /* position the 3d packet -XTRSETLNG from the readout window */

    THREEDIMDAB(d3d, PosTemp, (PosDabPkt+DAB_length[bd_index]));
    getwave(&d3ddab, &d3d); 

@inline Tricks.e TricksRegPkt
@inline Disco.e DiscoPhaseDonePkt        

    /* *****************************************
       Y phase encode and rewind
    *****************************************/
    if (rewinder_flag == PSD_ON)
    {  /* MRIhc16353 - RV: IDEAL change */
        if( (PSD_ON == ideal_flag) || (medal_flag && medal_multitr_flag) || idealiq_flag )
	{
	   /* MRIhc24440 : Replaced act_tr by tmin */
           /* SVBranch, HCSDM00100069 */
           PosPhaseRew1 = RUP_GRD(tmin - ((count_grd_wait? psd_grd_wait : 0) + time_ssi + 2*GRAD_UPDATE_TIME) - pw_gy1r_tot);
	}
	else
	{
           if (opetl>=2)
              PosPhaseRew1 = RUP_GRD(pend(&gxw2,"gxw2", gxw2.ninsts - 1)) ;
           else
              PosPhaseRew1 = RUP_GRD(pend(&gxw,"gxw", 0)) /* - pw_gxwex */ ;
	}
        SINGLE_TRAP(YGRAD, gy1r, PosPhaseRew1+pw_gy1ra,,endview_scale,TYPNDEF,TRAP_ALL_SLOPED,,,loggrd);
    }

    if (flow4D_flag == PSD_ON)
    {
       PosYFE1 = RDN_GRD(pbeg(&gxw,"gxw",0) - pw_gy1_tot -
                              pw_gyfe1 - pw_gyfe1d - pw_gyfe2a - pw_gyfe2 - pw_gyfe2d);
       TRAPEZOID( YGRAD, gyfe1, PosYFE1, 0, TYPNDEF, loggrd);  /* first flow
                                                                       encoding */
       TRAPEZOID( YGRAD, gyfe2, (pendall(&gyfe1, 0)+pw_gy1_tot+pw_gyfe2a),0, TYPNDEF, loggrd);
    }

    if( (ssfp_flag == PSD_ON) || (flow_comp_type == TYPFC) )
    {
        PosPhaseEncode1 = RUP_GRD(PosReadoutWindow - pw_gy1_tot);
    }
    else
    {
       if (flow4D_flag==PSD_ON)
       {
            PosPhaseEncode1 = RUP_GRD(pendall(&gyfe1,0));
       }
       else 
       {
            PosPhaseEncode1 = RUP_GRD((INT)(pend(&gzrf1,"gzrf1",0)/* + rfupd */));
       }
    }

    SINGLE_TRAP(YGRAD, gy1, PosPhaseEncode1+pw_gy1a,,endview_scale,TYPNDEF,TRAP_ALL_SLOPED,,,loggrd);
    getssppulse(&(echo1rba), &echo1, "rba", 0);
    getwave(&echo1rbarsp,echo1rba);

    psd_seqtime = RUP_GRD(act_tr - time_ssi);
    SEQLENGTH(seqcore, psd_seqtime, seqcore);

    /* save the scan deadtime */
    getperiod((long*)&scan_deadtime, &seqcore, 0);

    /* Assert the ESSP flag on the sync packet created by seq length */
    attenflagon(&seqcore, 0);

#ifdef IPG
    /****** Half Alpha Half TR sequence MS ******/
    if( (vast_mode == PSD_ON) && (ssfp_flag == PSD_ON) ) {

        SPACESAVER(RHO, rf1htr, res_rf1htr);
        {
            int rfupa_time = abs(rfupacv);

            fastAddrfbits(&rf1htr, 0, pos_start+pw_gzrf1htra+psd_rf_wait, pw_rf1htr, rfupa_time);
        }

        createinstr(&rf1htr,pos_start+pw_gzrf1htra+psd_rf_wait,pw_rf1htr,ia_rf1htr);

        movewaveimm(wave_space, &rf1htr, (int)0, res_rf1htr, TOHARDWARE);
        FreeNode(wave_space);


        /* Change back incase external grad_file used */
        if (rfpulseInfo[RF1_SLOT].change==PSD_ON)
            res_rf1htr = res_rf1;

        /* ****************************************
           Z slice select
           **************************************** */

        TRAPEZOID(ZGRAD,gzrf1htr,pbeg(&rf1htr,"rf1htr",scanrf1_inst)-psd_rf_wait,0,TYPNDEF, loggrd);

        PosGzcomb = RUP_GRD(pend(&gzrf1htr, "gzrf1htr", 0) + pw_gzrf1htrd + pw_gzcombhtra);

        SINGLE_TRAP( ZGRAD, gzcombhtr, PosGzcomb, ,
                     endviewz_scale,  TYPNDEF, TRAP_ALL_SLOPED,,,loggrd);

        PosGzp = RUP_GRD(pendall(&gzcombhtr,0) + pw_gzphtra);

        SINGLE_TRAP( ZGRAD, gzphtr, PosGzp, ,
                     endviewz_scale,  TYPNDEF, TRAP_ALL_SLOPED,,,loggrd);

        psd_seqhtrtime = RUP_GRD(act_htr - time_ssi);
        SEQLENGTH(seqhtrcore,psd_seqhtrtime, seqhtrcore);

        /* Assert the ESSP flag on the sync packet created by seq length */
        attenflagon(&seqhtrcore, 0);
    }
#endif

    /********************************
      T2 Prep Pulse
    ******************************/
    /* Do not execute this part on host side (NDG) */
#ifdef IPG

    if( PSD_OFF == tricks_flag ) { 
        if( FAILURE == t2prep_pg() ) {
            return FAILURE; 
        }
    }

    /*
     * Execute this only on the Tgt (simulation and hardware) side.
     */

    /* ********************************************************************
       Spatial SAT
    *********************************************************************/
    sp_satindex = 0;


    /* MRIge44642: use the actual width of the top pw_g[x|z]ks and */
    /* the actual ramp as it may be different than pw_satrampx+pw_gks */
    sp_killerx = sp_satend - (pw_gxks + pw_gxksd);
    sp_killerz = sp_satend - (pw_gzks + pw_gzksd);
    /* MRIge26267 RJL - If no sats used then don't process as the sp_killerx value
     * can be less than zero.
     */

    if (sp_sat)
    {
        printdbg("Entering SpSatPG_fgre3d section", debugstate);
        TRAPEZOID(XGRAD, gxks, sp_killerx, 0, TYPNDEF, loggrd);
        TRAPEZOID(ZGRAD, gzks, sp_killerz, 0, TYPNDEF, loggrd);
    }
    /* DDT 17276-- sequence time needs to have time_ssi subtracted fro
       it. */
    /* MRIge75771 - rounded up seq sat length - RJF */
    if (sp_sat)
    {
        SpSatPG_fgre(vrgsat, sp_satstart, &sp_satindex, sp_satcard_loc,
                     RUP_GRD(sp_sattime-time_ssi));
        printdbg("Left SpSatPG_fgre3d section", debugstate);
    }

    /* *******************
       Chem Sat
       **************** */

    /* MRIge51364 - If ChemSat is a separate sequence, we need to create it after seqcore. 
       This is due to a 
       limitation in pulsegen on host where the first sequence must be the main imaging sequence -
       seqcore. When this is fixed, the following segment of code can be removed - latha@mr */

    if (intermittant_chemsat == PSD_ON) {
        cs_satindex = 0;
        if (cs_sat == PSD_ON)
            ChemSatPG(cs_satstart, &cs_satindex);
    }

    /* *******************
       IR prep
    ******************/
    if( irprep_flag == PSD_ON )
    {
        /* 04/13/2006 HH MRIhc14895 - IRprep download failure with XRMB changes. Move
           temp_pos_start_ir setup to be outside use_slr_inv loop */
        int temp_pos_start_ir = pos_start_ir + pw_gzrf0a;

        switch (rf0_pulse_type)
        {
        case RF0_HS_20MS:
            strcpy(ext_filename, "hs.rho");
            strcpy(fileloc_omega_ir0, "hs.pha");
            break;
        case RF0_ADIABATIC:
            strcpy(ext_filename, "shNvrg5b.rho");
            strcpy(fileloc_omega_ir0, "shNvrg5b.pha");
            break;
        case RF0_HS_3T:
           	strcpy(ext_filename, "sh3t2.rho");
            strcpy(fileloc_omega_ir0, "sh3t2.pha");
            break;
        case RF0_ADIABTAN:
            strcpy(ext_filename,"adiabatic_tan.rho");
            strcpy(fileloc_omega_ir0, "adiabatic_tan.pha");
            break;
        case RF0_INVI0:
        default:
            strcpy(ext_filename, "rfinvI0.rho");
            break;
        }

        SLICESELZEXT2STR(rf0, temp_pos_start_ir, pw_rf0, (ifir_flag ? ifir_vthick : opvthick), flip_rf0, cyc_rf0, 
                         0, 1, NULL, res_rf0, ext_filename, RF0_SLOT, TYPNDEF, loggrd);

        if ( (RF0_HS_20MS == rf0_pulse_type) || (RF0_ADIABATIC == rf0_pulse_type) ||
             (RF0_HS_3T == rf0_pulse_type) || (RF0_ADIABTAN == rf0_pulse_type) )
        {
        /* This makes the file_name argument in EXTWAVE2 macro irrelevant */
            EXTWAVE2(THETA,omega_ir0,pos_start_ir,pw_omega_ir0,0,
                     res_rf0,fileloc_omega_ir0,0,RF0_SLOT);
        }

        TRAPEZOID(ZGRAD, gzrf0k, pendall(&gzrf0, 0)+pw_gzrf0ka, 0, TYPNDEF, loggrd);

        /* add tdel1_time for trigger delay for 3DMDE AP */
        if ((PSD_ON == slabtracking_flag) && (PSD_OFF == ifir_flag)) 
        {   /* Additional TI will be played in the Navtipup section */
            ir_seqtime = tlead + min_tseq_irprep + ir_seqtime_adjust;
        } else if ((PSD_ON == ifir_flag) && (PSD_ON == navtrig_flag) && (PSD_ON == ifir_dnav_flag)) {
            ir_seqtime = tlead + tseq_irprep + ir_seqtime_adjust - mon_tr;

        } else {
            ir_seqtime = tlead + tseq_irprep + ir_seqtime_adjust;
        }
            
        SEQLENGTH(seqir, RUP_GRD(ir_seqtime), seqir);
        attenflagon(&seqir, 0);
    }

    if (msde_flag)
    {
@inline MSDE.e MSDE_Pulsegen
    }

    if (ftmra_flag && rtia3d_irp_flag)
    {
       EXTWAVE2(RHO, hard180, pos_hard180, pw_hard180, 0,
                RES_FERMI124, fermi124.rho, 0, HARD180_SLOT);
       SEQLENGTH (seqhard180, RUP_GRD (hard180time - time_ssi), seqhard180);
       attenflagon(&seqhard180, 0);
       rfon(&hard180, 0);
       setfrequency(0, &hard180, 0);
    }

    if (fiesta_killer_flag)
    {
        TRAPEZOID(ZGRAD, gzk, pos_start_gzk+pw_gzka, 0, TYPNDEF, loggrd);
        SEQLENGTH(seqgzk, tseq_gzk, seqgzk); 
    }

    if(ifir_frir_flag)
    {
        strcpy(ext_filename, "hs.rho");

        SLICESELZEXT2STR(rffrir, pos_start_frir + pw_gzrffrira, pw_rffrir,  (ifir_flag?ifir_vthick:opvthick), flip_rffrir, cyc_rffrir,
                         0, 1, NULL, res_rffrir, ext_filename, RFFRIR_SLOT, TYPNDEF, loggrd);

        EXTWAVE2(THETA,omega_rffrir,pos_start_frir,pw_omega_rffrir,0,
                     res_rffrir,hs.pha,0,RFFRIR_SLOT);

        TRAPEZOID(ZGRAD, gzkrffrir, pendall(&gzrffrir, 0)+pw_gzkrffrira, 0, TYPNDEF, loggrd);

        SEQLENGTH(seqfrir, tseq_prep_frir, seqfrir);
        attenflagon(&seqfrir, 0);
    }

    /* IFIR GRx */
    if (ifir_flag)
    {
        SEQLENGTH(seqwait_dum, RUP_GRD(time_seqwait), seqwait_dum);
    }

@inline Prescan.e PSpulsegen

@inline Respgate.e RGpulsegen
 
    if (FAILURE == Monitor_pulsegen())
    {
        return FAILURE;
    }

    /************************************************************
     * Delay Between Acq. for MPH
     ***********************************************************/
    if  ((mph_flag == PSD_ON) && (sldeltime > 10s))
    {
        /* The maximum sldelay is 20s, which is longer than the maximum allowed
           period of 16s for a waveform. Therefore, if the total delay is larger
           than 10s, it is splited into two parts, part in seqdelay1 and part in
           seqpass */

        delay1_seqtime = RUP_GRD(sldeltime/2 - time_ssi);
        SEQLENGTH(seqdelay1, delay1_seqtime, seqdelay1);

    }


    /* MGD2, RJF */
    /* Use this sequence for playout during chnmap switching*/
    SEQLENGTH(seqdelay3, RUP_GRD(100ms-time_ssi), seqdelay3);

    if (end_segment_delay > 0)
    SEQLENGTH(seqdelayendsegment, RUP_GRD(end_segment_delay), seqdelayendsegment);

    /* NAV */
    /* Cardiac delay sequence */
    SEQLENGTH(seqcarddelay,RUP_GRD(psd_seqtime),seqcarddelay);

    /* Dummy sequence played when histogram is being calculated */
    SEQLENGTH(seqhistdelay, RUP_GRD(hist_wait_time), seqhistdelay); 
    
    /************************************************************
     * Pass Packet sequence
     ***********************************************************/

    if (mph_flag == PSD_ON)
    {
        if (sldeltime > 10s) /* split the delay */
        {
            pass_seqtime = RUP_GRD((int)(sldeltime/2) + TR_PASS - time_ssi);
        }
        else  /* do not split the delay */
        {
            pass_seqtime = RUP_GRD(sldeltime + TR_PASS - time_ssi);
        }
    }
    else
    {
        pass_seqtime = RUP_GRD(TR_PASS - time_ssi);
    }

    /* Move out last 3D dab packet to 100 msec so that we are sure that
       the previous frame has completed processing.
    */
    PosTemp = 100ms;

    THREEDIMDAB(d3dpass,0,PosTemp);

@inline Tricks.e TricksRegPassPkt

    PASSPACK(pass_pulse, TR_PASS - 1ms);
    SEQLENGTH(seqpass, pass_seqtime, seqpass);

    getperiod((long*)&seqpass_deadtime, &seqpass, 0);

    /* MRIge66079 - ATV: RTIA3D/ftMRA */
    pass_seqtime2d = RUP_GRD(rtia3d_pass - time_ssi);
    PASSPACK(pass_pulse2d, rtia3d_pass - 1ms);
    SEQLENGTH(seqpass2d, pass_seqtime2d , seqpass2d);
    /* End RTIA3D/ftMRA */

    /* If I move this down to right before the buildinstr() call I get the
       same pulses on all 3 axes! */


    /************************************************************
     * Gating. JFS
     ***********************************************************/
    if (optr > 1.7ms )
    {
        GatePulsegen(psd_seqtime);
    }
    /************************************************************
     * 3D Packet sequence  JFS
     ***********************************************************/
    THREEDIMDAB(d3dset,0, 50);
    SEQLENGTH(seq3d, seq3dtr, seq3d);

    /************************************************************
      Dummy 3D Plane Packet sequence for Fluoro Trigger  CRM

      This sequence is used to send a "dummy" 3D plane packet to
      notify recon of the transition from the 2D RTIA to the 3D
      acquisition.  Recon does not do the 3D recon for this 3D
      plane packet.  This sequence is the same as the seq3d,
      except it uses a smaller TR to reduce the delay between
      the button press in the 2D acquisition and the start of 
      the 3D acquisition.
     ***********************************************************/
    THREEDIMDAB(d3ddummy, 0, 50);
    SEQLENGTH(seq3ddummy, seq3ddummytr, seq3ddummy);

    /************************************************************
      RF Amp sequence - BJM
      This sequence simply unblanks the RF amp for 350us at the
      begining of each scan.  It allows the SSM to check for open
      circuits and will prevent hardware damge if an open has been
      detected as a result of a failure.

      We reuse all the rf1 pulsewidths and use a 5ms seqtime.  
      The ssi_time is set to 500us by default...
    ***********************************************************/
    if (PSD_ON == minimize_RFunblank_time) {
        SPACESAVER(RHO, dummyrf, res_rf1);
        addrfbits(&dummyrf, 0, 350us, pw_rf1);
        SEQLENGTH(dummyrfseq, dummyrf_time-dummyrf_ssitime, dummyrfseq);
    }

#endif /* IPG */

    if (buildinstr() == FAILURE)
    {
        return FAILURE;
    }

#ifdef IPG 
    /*
     * Execute this only on the Tgt (simulation and hardware) side.
     */
    getwave(&rf1tmp_addr, &rf1tmp);

    /*  ***********************************************************
        Initialization
        This section performs the equivalent of the IPI section
        DOWNLOAD in 4.X.
        ********************************************************** */
    slabquant = opvquant; /* 3d oblique - changed 1 to opvquant - latha@mr */

    /* Allocate memory for various arrays.
     * An extra 2 locations are saved in case the user wants to do
     * some tricks. */

    rf1_freq = (int *)AllocNode((slabquant + 2)*sizeof(int));

    /* IR PREP (pjg) */
    rf0_freq = (int *)AllocNode((slabquant + 2)*sizeof(int));
    rf0_pha = (int *)AllocNode((slabquant + 2)*sizeof(int));
    receive_freq1 = (int *)AllocNode((slabquant + 2)*sizeof(int));
    if (opetl>=2) {
       receive_freq2 = (int *)AllocNode((slabquant + 2)*sizeof(int));
    }
    if(idealiq_flag && idealiq_pc_flag)
    {
        receive_freq1_rev = (int *)AllocNode((slabquant + 2)*sizeof(int));
        receive_freq2_rev = (int *)AllocNode((slabquant + 2)*sizeof(int));
    }
    if (ss_rf1) {
       theta_freq = (int *)AllocNode((slabquant + 2)*sizeof(int));
    }

#ifdef IPG
    /* Swap index */ /* VAL15 12/14/2004 YI */
    if(pc_mode < PC_BASIC){
        phase_cycles = nex_save;
        nex = 1;
    }
#endif

    rspdex = dex;
    rspech = 0;
    rspchp = 1;
    /* research rsp initialization */
    rmode = 0;
    reschp = 1;
    resdda = dda;
    resbas = baseline;
    resvus = opyres;
    resnex = nex;
    reschp = 1;
    resesl = 0;
    resasl = 0;
    resslq = slquant1;
    ressct = 1;
    resech = 0;
    resdex = dex;

    debugstate = debug;

    /* Find frequency offsets */
    setupslices( rf1_freq, rsp_info, slabquant, a_gzrf1,
                 (float)1, opfreqfov*opfov, TYPTRANSMIT );

    if (ss_rf1) {
       setupslices( theta_freq, rsp_info, slabquant, a_gzrf1/omega_scale,
                    (float)1, opfreqfov*opfov, TYPTRANSMIT );
    }

    if( PSD_ON == swap_fat_cs ) {
        setupslices( receive_freq1, rsp_info, slabquant, (float)0,
                     echo1bw, opfreqfov*opfov, TYPRECGRDEVEN );
    } else {
        setupslices( receive_freq1, rsp_info, slabquant, (float)0,
                     echo1bw, opfreqfov*opfov, TYPREC );
    }

    if (opetl>=2) {
      if (uniPolar_flag == PSD_ON) {
         setupslices( receive_freq2, rsp_info, slabquant, (float)0,
                    echo2bw, opfreqfov*opfov, TYPREC );
      }
      else
      {
         setupslices( receive_freq2, rsp_info, slabquant, (float)0,
                    echo2bw, opfreqfov*opfov, TYPRECGRDEVEN );
      }
    }

    if(idealiq_flag && idealiq_pc_flag)
    {
        setupslices( receive_freq1_rev, rsp_info, slabquant, (float)0,
                     echo1bw, opfreqfov*opfov, TYPRECGRDEVEN );

        if (PSD_ON == uniPolar_flag)
        {
             setupslices( receive_freq2_rev, rsp_info, slabquant, (float)0,
                        echo2bw, opfreqfov*opfov, TYPRECGRDEVEN );
        }
        else
        {
             setupslices( receive_freq2_rev, rsp_info, slabquant, (float)0,
                        echo2bw, opfreqfov*opfov, TYPREC );
        }
    }

    if(debug )
    {
        int i=0;
        for( i=0;i<slabquant;i++)
        {
            printf("rf1_freq[%d]=%d, receive_freq1[%d]=%d\n",
                    i,rf1_freq[i],i,receive_freq1[i]);
        }
    }

    /* IR PREP (pjg) */
    /* For IR prep pulse fill in frequencies */
    if( irprep_flag == PSD_ON )
    {
        setupslices( rf0_freq, rsp_info, slabquant, a_gzrf0,
                     (float)1, opfov, TYPTRANSMIT );

        if (PSD_ON == ifir_flag) 
    	{
            rf0_freq[0] = GAM * a_gzrf0 * ifir_position / 10.0 / TARDIS_FREQ_RES;
    	}
 
        if ( (RF0_HS_20MS == rf0_pulse_type) || (RF0_ADIABATIC == rf0_pulse_type) ||
             (RF0_HS_3T == rf0_pulse_type) || (RF0_ADIABTAN == rf0_pulse_type) )
        {
            setupphases(rf0_pha, rf0_freq, slabquant, rf0_phase, 0);
        }
    }

    if (FAILURE == Monitor_Download())
    {
        return FAILURE;
    }

@inline Tricks.e WriteZYexport

    /* Inform the Tgt of the trigger array to be used */
    settriggerarray((SHORT)slabquant, rsptrigger); /* 3d oblique - changed opslquant to opvquant - latha@mr */

    if (ipg_trigtest == 0)
    {
        /* Inform the Tgt of the trigger array to be used */
        /* Following code is just here to support Tgt oversize
           board which only supports internal gating */
        /* 3d oblique - added opvquant - latha@mr */
        for (slice=0; slice < arc_equant*slabquant; slice++)
            rsptrigger[slice] = (short)TRIG_INTERN;
        slice = 0;
    }

    setrotatearray((SHORT)slabquant,rsprot[0]); /* 3d oblique - changed opslquant to opvquant  - latha@mr */

    setupphasetable(rtia3d_viewtable, resp_comp_type, phaseres);
    setupphasetable(viewtable, resp_comp_type, phaseres);

    if ( arc_debug_files == PSD_ON ) {
        FILE *arcky_logfile;
        FILE *arckz_logfile;
        CHAR arcky_logfilename[80];
        CHAR arckz_logfilename[80];

#ifdef PSD_HW
        sprintf(arcky_logfilename, "/usr/g/service/log/arc_viewtab_%d.log", rhkacq_uid);
        sprintf(arckz_logfilename, "/usr/g/service/log/arc_volumetab_%d.log", rhkacq_uid);
#else
        sprintf(arcky_logfilename, "./arc_viewtab_%d.log", rhkacq_uid);
        sprintf(arckz_logfilename, "./arc_volumetab_%d.log", rhkacq_uid);
#endif

        arcky_logfile = fopen(arcky_logfilename,"w");
        arckz_logfile = fopen(arckz_logfilename,"w");

        fprintf(arcky_logfile,"%d\n",rhnframes + rhhnover);
        fprintf(arckz_logfile,"%d\n",arc_equant);

        for (view = 1; view <= rhnframes + rhhnover ; view++)
        {
            fprintf(arcky_logfile,"%d\n",viewtable[view]);
        }

        for (slice = 0; slice < arc_equant; slice++)
        {
            fprintf(arckz_logfile,"%d\n",volumetab[slice]);
        }

        fclose(arcky_logfile);
        fclose(arckz_logfile);
    }

    /* ungated FatSat FIESTA: delay sequence */
    if( (ugfsf_flag==PSD_ON) && (ugfsf_shot_delay>0) ){
        WAIT(XGRAD, xdelay, tlead, RUP_GRD(12us) );
        SEQLENGTH(seqdelay, ugfsf_shot_delay, seqdelay);
    }

    sl_rcvcf = (int)((float)cfreceiveroffsetfreq / TARDIS_FREQ_RES);

    /* Save the trigger for the prescan slice. */
    prescan_trigger = rsptrigger[pre_slice];

    rsptrigger_temp[0] = TRIG_INTERN;

    navmph_cnt = 0;

    /* update RSP maxTG with min TGlimit value */
    maxTGAtOffset = updateTGLimitAtOffset(TGlimit, sat_TGlimit);
#endif /* IPG */

    return SUCCESS;
}   /* end pulsegen() */

@inline ChemSatSpecIR.e ChemSatPG
@inline SpSat.e SpSatPG
@inline Prescan.e PSipg
@inline Monitor.e MonitorPG
@inline InversionGRx.e InversionGRxPG /* IFIR GRx */


@rsp
/*********************************************************************
 *                      EFGRE3D.E RSP SECTION                        *
 *                                                                   *
 * Write here the functional code for the real time processing (Tgt  *
 * side). You may declare standard C variables, but of limited types *
 * short, int, long, float, double, and 1D arrays of those types.    *
 *********************************************************************/

#include "pgen_tmpl.h"
#include "epic_loadcvs.h"
/* NAV */
RtpDataValuesPkt navRtpPkt;

@inline VAST.e VASTrsp

@inline FastCINE3D.e fcine3d_rsp
int pause;

TYPDAB_PACKETS acq_echo1;		/* flags for data acquisiton */
TYPDAB_PACKETS acq_echo2;

INT *SPGRTable, *RCPhase;

#define GATE_REACQUIRE  2
#define GATE_RESP       1       /* flag to enable respirtory gating */
#define GATE_CARD       2       /* flag to enable cardiac gating */
#define GATE_ARRHY      4       /* flag to enable arrhythmia rejection */
#define GATE_PLAY_DISDAQ  8
#define GATE_DUMMY_SEQ_TR  4000 /* 4 msec */
#define GATE_RESYNC_ECG 0       /* MRIge45172: 1-resync to ECG,0-report time out */
#define GATE_RESP_RATE_MIN 3    /* minimum respiratory rate required for resp gating */

/* MRIge66079 - ATV: RTIA3D/ftMRA */

#define RECON_BUFFERS_AVAILABLE 3

@inline RTIA.e realtime_includes
@inline RTIA.e efgre3d_includes
@inline RTIA.e realtime_rsp
@inline RTIA.e efgre3d_rsp

short rtia3d_viewtab[1025];

/* End RTIA3D/ftMRA */

@inline cal3d.e cal3d_rsp

/* IDEAL IQ phase correction */
int *idealiq_pc_post_dixtime;
int *idealiq_pc_pre_dixtime;
int *idealiq_pc_dabview;
int *idealiq_pc_dabviewbam;
int *idealiq_pc_dabslice;
int *idealiq_pc_dabslicebam;
int *idealiq_pc_dabecho;
int *idealiq_pc_dabop;

/* NAV */

void psdisiupdate()
{
    /* The equivalent rsp routine generated by Tgt team for 'ipgsignal' is 
       rspsignalsend */

    if (look_for_trig == TRUE)
    {        
        trigger_detected = gettrigoccur();
        if (trigger_detected == TRUE) {
            trigger_count++;
        }
    }  /* end look for triggers option */
}


void dummylinks( void )
{
    epic_loadcvs("thefile");
}

void
ssisat(void)
{
    int next_slice;

    next_slice = sp_sat_index;
    sp_update_rot_matrix(&rsprot_orig[next_slice][0], sat_rot_matrices,
                         sat_rot_ex_num, sat_rot_df_num);

    return;
}

@inline FastCINE3D.e fcine3d_support

STATUS
psdinit( void )
{
    int i;		/* counter */
    /* variables to calculate the slab offset in cvinit */
    int slab_count;
    int trig_index;

    /* Reset global error handling variable */
    strcpy(psdexitarg.text_string, "psdinit");
    view = slice = excitation = 0;

    /* set up for exciter and receiver phases */
    exphase = 0;
    setiphase(exphase, &rf1, scanrf1_inst);
    /* set to not chop initially */
    chop_phase = 0;

    slabindex = 0;
    sp_sat_index = slabindex;

@inline T2Prep.e T2PrepPsdinit

    specirprep = 0;

    if (sp_sat)
    {
        ssivector(ssisat, (short) FALSE);
    }

    /* set dither control */
    setditherrsp(dither_on,dither_value);

    /* set up for isi interrupt use */
#ifdef PSD_IPG_DEBUG
    if(!cine3d_flag)
    {
        psdisicnt = 0;
        isivector((short)psdisivector, psdisiupdate, (short) FALSE);
    }
#endif

    /* initialize these status for isi routine */
    first_scan = YES;
    first_prepscan = YES;
    new_view = YES;

    /* set rfconfig */
    setrfconfig((short)rfconf);

    /* reset all the attenuator locks */
    if (rspent == L_SCAN)
        attenlockon(&attenuator_key);
    else
        attenlockoff(&attenuator_key);

    /* Reset all the scope triggers */
    scopeon(&seqcore);

    /* Reset all the synchronizations  - no need to use one in pass */
    syncon(&seqcore);
    syncoff(&seqpass);

    /* Assure trigger arrays are reset to standard ones */
    settriggerarray((SHORT)(slabquant),rsptrigger); /* 3d oblique - changed opslquant to opvquant - latha@mr */

    scptrg = 1;	/* trig off core seq */

    /* Allow for manual trigger override for testing. */
    if ((psd_mantrig == 1) && ((rspent == L_APS2) || 
                               (rspent == L_MPS2) || (rspent == L_SCAN)))
    {
        for (slab_count = 0; slab_count < slabquant; slab_count++) /* 3d oblique - changed opslquant to opvquant - latha@mr */
        {
            if (rsptrigger[slab_count] != TRIG_INTERN)
            {
                switch(rspent){
                case L_MPS2:
                    rsptrigger[slab_count] = trig_mps2;
                    break;
                case L_APS2:
                    rsptrigger[slab_count] = trig_aps2;
                    break;
                case L_SCAN:
                    rsptrigger[slab_count] = trig_scan;
                    break;
                default:
                    break;
                }
            }
        }
    }


    /* Inform the Tgt of the rotation matrix array to be used.
       For scan and ps2, the sat pulses are played out so the sat
       rotation matrix needs to be used.  Otherwise, the original
       slice rotation matrix is used. */

    if (sp_sat)
    {
        /* last parameter is 1 indicating that the table of sat rot
           matrices will be generated in addition to the table of
           slice rot matrices */
        /* 3d oblique - added opvquant - latha@mr */
        SpSat_set_sat1_matrix(rsprot_orig, rsprot, slabquant, sat_rot_matrices, sat_rot_ex_num, sat_rot_df_num, sp_satcard_loc, 1);
        if ((rspent == L_SCAN) || (rspent == L_MPS2) || (rspent == L_APS2))
            /* double size of array for both slice and sat rot matrices */
            setrotatearray((SHORT)(slabquant)*2, rsprot[0]); /* 3d oblique - changed opslquant to opvquant - latha@mr */
        else
            setrotatearray((SHORT)slabquant, rsprot_orig[0]); /* 3d oblique - changed opslquant to opvquant - latha@mr */

        trig_index = 0;
        /* 3d oblique - changed opslquant to opvquant - latha@mr */
        for (i = slabquant ; i < slabquant * 2; ++i)
        {
            rsptrigger[i] = rsptrigger[trig_index];
            ++trig_index;
        }
        /* 3d oblique - changed opslquant to opvquant - latha@mr */
        settriggerarray((SHORT)(slabquant * 2), rsptrigger);

    }
    else
    {
        /* 3d oblique - changed opslquant to opvquant - latha@mr */
        setrotatearray((SHORT)slabquant, rsprot[0]);
    }


    pass = 0;

    if (rmode)
    {
        rspdda = resdda;
        rspbas = resbas;
        rspvus = resvus;
        rspnex = resnex;
        rspchp = reschp;
        rspesl = resesl;
        rspasl = resasl;
        rspech = resech;
        rspslq = resslq;
    }

    /* initialize phase amplitudes */
    if (rspgy1 == 0)
    {
        amp_gy1 = rsp_preview;  /* Normally rsp_preview = 0 */
    }
    else
    {
        amp_gy1 = -viewtable[rspgy1];
    }
    setiamp(amp_gy1, &gy1, 0);
    if (rewinder_flag == PSD_ON)
    {
        setiamp(amp_gy1, &gy1r, 0);
    }

    /* initialize rf1 amplitude */
    setiamp(ia_rf1, &rf1, scanrf1_inst);

    /* MS */
    if( (vast_mode == PSD_ON) && (ssfp_flag == PSD_ON) )
    {
        setiamp(ia_rf1htr, &rf1htr, scanrf1_inst);
    }

    /* initialize DAB */
    dabop = 0;			/* Store data */
    dabview = 0; 
    dabecho = 0;		/* first dab packet is for echo 0 */
    dabecho_multi = -1;		/* use the autoincrement echo feature 
                               for subsequent echos */ 
    /* Initialize baseviews and disdaqs */
    baseviews = -rspbas + 1;
    disdaqs = -rspdda;

    CsSatMod(cs_satindex);
    if (sp_sat)
    {
        SpSatInitRsp((int)1, sp_satcard_loc, 0);
    }

    /* Set ssi time.  This is time from eos to start of sequence interrupt
       in internal triggering.  The minimum time is 50us plus 2us*(number of
       waveform and instruction words modified in the update queue) */

    if ( (rspent == L_SCAN) || (rspent == L_MPS2) || (rspent == L_APS2))
    {
        rsptimessi = time_ssi;
    }
    else
    {
        rsptimessi = time_ssi_pre;
    }

    setssitime((LONG)rsptimessi/HW_GRAD_UPDATE_TIME);

    /* IR PREP (pjg) */
    if( irprep_flag == PSD_ON )
    {
        switch (slorder)
        {
        case 1:
            rspir = arc_equant;
            break;

        case 2:
            rspir = arc_equant/2;
            break;

        case 3:
            rspir = arc_equant/4;
            break;

        case 4:
            rspir = arc_equant/8;
            break;

        }
    }
    else
    {
        rspir = 0;
    }

    /* MRIge66079 - ATV: RTIA3D/ftMRA */
    if (rspent == L_SCAN)
    {
        if (arc_flag) {
            phase_order_fgre3d(rtia3d_viewtab, rtia3d_phorder, unaccel_rspvus,
                               viewoffs, unaccel_rhnframes,
                               rhhnover, fn);
        } else {
            phase_order_fgre3d(rtia3d_viewtab, rtia3d_phorder, rspvus,
                               viewoffs, rhnframes, rhhnover, fn);
        }
        phase_order_fgre3d(viewtab, phorder, rspvus,
                           viewoffs, rhnframes, rhhnover, fn);
    }
    /* End RTIA3D/ftMRA */

    /*** debug step */  
    if (debug_viewtab)
    {
        for (view=0;view<rspvus;view++)
        {
            printf(" %d ",viewtab[view]);
            if (((view+1)%10) == 0)
                printf("\n");
        }
        printf("\n"); 
    }

#define GATE_PLAY_DISDAQ  8

    if( ( (ssfp_flag == PSD_ON) && (vast_mode == PSD_OFF) ) || 
        (reverseLoopOrder_flag == PSD_ON) || ecg_cont_dda_flag )
    {
        GateRspInit(GATE_PLAY_DISDAQ);
    }
    else
    {
        GateRspInit(0);
    }

@inline VAST.e VASTpsdinit
@inline FastCINE3D.e fcine3d_psdinit

    /* MGD2, RJF */
    /* NAV */
    if (L_SCAN == rspent)
    {
#ifdef PSD_HW
        if ((PSD_ON == navgate_flag) || (PSD_ON == navtrig_flag))
        {
            NavigatorRspInit();
            result = 0; 
            in_limit = 0;
            disp_x = 0.0;
            disp_y = 0.0;
            disp_z = 0.0;
        }
#endif /* PSD_HW */
    }

    /* IFIR GRx */
    /* Set ISI vector, RF on, setiamp of RF and GRAD */
    if (ifir_flag == PSD_ON)
    {
        InversionGRxInitRsp();
    }

    /* MRIge66079 - ATV: RTIA3D/ftMRA */
    if (ftmra_flag) 
    {
        if ( efgre3d_realtime_psdinit() == FAILURE)   
        {
            return FAILURE;  
        }

        if (arc_flag) {
            rtia3d_satview_start = unaccel_rspvus - rtia3d_sat_views + 1;
        } else {
            rtia3d_satview_start = rspvus - rtia3d_sat_views + 1;
        }

        if (rtia3d_satview_start <=0) 
        {
            rtia3d_satview_start = 1;
        }

        if (arc_flag) {
            rtia3d_satview_end = unaccel_rspvus;
        } else {
            rtia3d_satview_end = rspvus;
        }

    }
    /* End RTIA3D/ftMRA */

    if(idealiq_flag)
    {
        nshots = idealiq_nshots;
    }
    else
    {
        nshots = 1;
    }

    /* Reset R1 and coil switching in xtr packets (MRIhc49358) */
    fgre_loaddab_echo1_rfhub( 0, 0, dabop, 1, DABOFF, 
                              0, 0, PSD_LOAD_DAB_HUB_R1_RESET );
    if( opetl >= 2 )
    {
        fgre_loaddab_echo2_rfhub( 0, 1, (opetl-1), nshots, dabop, 1, DABOFF,
                                  0, 0, PSD_LOAD_DAB_HUB_R1_RESET );
    }

    if (disco_flag)
    {
        fgre_loadtreg(&ddphase, 0, DABOFF);
    }

    if (msde_flag && (L_SCAN == rspent))
    {
@inline MSDE.e MSDE_PoleSwitchRsp
    }
    else
    {
@inline MSDE.e MSDE_PoleSwitch_OFF
    }

    return SUCCESS;  
}   /* end psdinit() */	    


/* IR PREP (pjg) */
/* Calculate the centric slice encode order for IR prep option.
   Using the notation where 1 represents the center of K space.

   Case 1: slice order is 1, -1, 2, -2, 3, -3 ...
   Case 2: slice order is 1, 2, 3 ... for segment 1.
   -1, -2, -3 ... for segment 2.
   Case 3: slice order is 2, 4, 6 ... for segment 1.
   -1, -3, -5 .... for segment 2.
   1, 3, 5 ... for segment 3.
   -2, -4, -6 ... for segment 4.

   The middle of K space occurs when the slice number is total
   slice number/2.
*/

@inline Prescan.e PScore

STATUS mps2(void)
{
    printdbg("Greetings from MPS2", debugstate);
    rspent = L_MPS2;
    rspdda = ps2_dda;
    rspbas = 0;
    rspvus = 30000;
    rspgy1 = 0;
    rspnex = 2;

    if( (intslab_flag == PSD_ON) && (psc_vol_index>0))
    {
        if( noswitch_slab_psc == PSD_OFF )
            psc_slab_index = psc_vol_index-1;
        else
            psc_slab_index = PStest_slab-1;
    }
    else
    {
        psc_slab_index = pre_pass;
    }


    /*useless "if". but serves to minimize memory ;-)*/
    if(PSdebugstate)
    {
        char tempstr[200] = "";
        sprintf(tempstr,"MPS2:psc_vol_index = %d, psc_slab_index=%d\n",psc_vol_index,psc_slab_index);
        printdbg(tempstr,PSdebugstate);
    }

    rspesl = psc_slab_index;
    rspasl = psc_slab_index;
    rspslq = arc_equant;
    rspsct = 0;
    rspisi = isi_flag;	/* for use with isi interrupt */
    rspscptrg = scptrg;

    if (cs_sat == 1)
        cstun = 1;
  
    psdinit();
    pass = psc_slab_index;
  
    strcpy(psdexitarg.text_string, "mps2");

    /* change deadtime to SCAN TR */
    setperiod(scan_deadtime, &seqcore, 0);
    /* MRIhc16353 - RV: IDEAL change */
    if( (PSD_ON == ideal_flag) || (medal_flag && medal_multitr_flag) || idealiq_flag )
    {
       setperiod(GRAD_UPDATE_TIME, &dix_xpre,0 );
       setperiod(GRAD_UPDATE_TIME, &dix_ssppre,0);
       setperiod((ideal_pw+idealiq_pw+medal_pw+GRAD_UPDATE_TIME), &dix_ssppost,0);
    }

    if (rspisi == 1)
    {
#ifdef PSD_IPG_DEBUG
        if (psd_isi_on == 1) /* set isi7 bit to on */
        {
            getctrl(&psdctrl, &isi7, 0);
            psdctrl |= (PSD_ISI0_BIT | PSD_ISI1_BIT | PSD_ISI2_BIT);
            setctrl(psdctrl, &isi7, 0);
        }
        else
        {
            getctrl(&psdctrl, &isi7, 0);
            psdctrl &= ~(PSD_ISI0_BIT | PSD_ISI1_BIT | PSD_ISI2_BIT);
            setctrl(psdctrl, &isi7, 0);
        }
#endif
    } /* isi on */
  
    first_scan = YES;
    first_prepscan = YES;
  
    boffset(off_seqcore);

    ps2core();

    printdbg("Normal End of MPS2", debugstate);
    rspexit();
    return SUCCESS;
} /* End MPS2 */


STATUS aps2(void)
{
    if(cal3d_flag)
    {
        if((L_AUTOSHIM == rspent) || (L_RCVN == rspent))
        {
            rspdda = ps2_dda;
        }
        else
        {
            rspdda = ps2_dda_cal3d;
        }
    }
    else
    {
        rspdda = ps2_dda;
    }

    printdbg("Greetings from APS2", debugstate);
    rspent = L_APS2;
    rspbas = 0;
    rspvus = 1024;
    rspgy1 = 0;
    rspnex = 2;
    rspslq = slquant1;
    rspsct = -1;

    strcpy(psdexitarg.text_string, "aps2");

    if( (intslab_flag == PSD_ON) && (psc_vol_index>0) )
    {
        if (PSD_OFF == noswitch_slab_psc)
        {
            psc_slab_index = psc_vol_index - 1;
            if (FAILURE == CoilSwitchSetCoil(coilInfo_tgt[psc_vol_index - 1], 0))
            {
                return FAILURE;
            }
        }
        else
        {
            psc_slab_index = PStest_slab-1;
        }

        {
            char tempstr[200] = "";
            sprintf(tempstr,"APS2:psc_vol_index = %d, psc_slab_index=%d, after SwiFT prescan coil switch\n",
                    psc_vol_index,psc_slab_index);
            printdbg(tempstr,PSdebugstate);
        }
    }
    else
    {
        psc_slab_index = pre_pass;
    }

    rspesl = psc_slab_index;
    rspasl = -1;
    rspisi = isi_flag;	/* for use with isi interrupt */
    rspscptrg = scptrg;

    if (cs_sat == 1)
        cstun = 1;

    psdinit();
    pass = psc_slab_index;

    /* change deadtime to SCAN TR */
    setperiod(scan_deadtime, &seqcore, 0);
    /* MRIhc16353 - RV: IDEAL change */
    if( (PSD_ON == ideal_flag) || (medal_flag && medal_multitr_flag) || idealiq_flag )
    {
       setperiod(GRAD_UPDATE_TIME, &dix_xpre,0 );
       setperiod(GRAD_UPDATE_TIME, &dix_ssppre,0);
       setperiod((ideal_pw+idealiq_pw+medal_pw+GRAD_UPDATE_TIME), &dix_ssppost,0);
    }

    if (rspisi == 1)
    {
#ifdef PSD_IPG_DEBUG
        if (psd_isi_on == 1) /* set isi7 bit to on */
        {
            getctrl(&psdctrl, &isi7, 0);
            psdctrl |= (PSD_ISI0_BIT | PSD_ISI1_BIT | PSD_ISI2_BIT);
            setctrl(psdctrl, &isi7, 0);
        }
        else
        {
            getctrl(&psdctrl, &isi7, 0);
            psdctrl &= ~(PSD_ISI0_BIT | PSD_ISI1_BIT | PSD_ISI2_BIT);
            setctrl(psdctrl, &isi7, 0);
        }
#endif
    } /* isi on */
  
    first_scan = YES;
    first_prepscan = YES;
  
    boffset(off_seqcore);


    ps2core();

    printdbg("Normal End of APS2", debugstate);
    rspexit();
    return SUCCESS;
} /* End APS2 */

@inline Respgate.e RGcore
@inline Monitor.e MonitorCore
@inline FastCINE3D.e fcine3d_scancore

STATUS scan(void)
{
    /* MRIge66079 - ATV: RTIA3D/ftMRA */
    unsigned long *input_id_values_buffer;
    unsigned long *recon_id_values_buffer;
    INT issue_stop_scan ;
    /* End RTIA3D/ftMRA */


    rspent = L_SCAN;
    rspdda = dda;
    rspbas = baseline;
    rspvus = rhnframes + rhhnover;
    unaccel_rspvus = unaccel_rhnframes + rhhnover;
    rspgy1 = 1;
    rspnex = nex;
    rspslq = arc_equant;
    rspasl = 1;
    rspsct = 0;
    rspesl = 1;
    rspisi = isi_flag;	/* for use with isi interrupt */

    /* Initialize respgate variables JP */
    resptrigger = 0;
    resp_reps = 0; 
    spgr_count = 1;
    seq_count = 1; /* VAL15 12/14/2004 YI */

    if (cs_sat == 1)
        cstun = 1;

    psdinit();
    strcpy(psdexitarg.text_string, "scan");

    /* Initialize autovoice before any startseq calls.
       Calls to broadcast_autovoice_timing() automatically initialize
       autovoice, if necessary, but this initialization can take 2-5ms
       and cause EOS errors.  This initialization is now done
       automatically at TPS reset by the AGP (MRIhc11361).  The PSD
       fix is purely precautionary and can be removed if so desired. */
#ifdef PSD_HW
    broadcast_autovoice_init();
#endif

    /* set the mask time now for TRICKS. Has to be done before the 
     * next startseq MRIge82801-Venkat*/
    if( PSD_ON == tricks_flag ) {
#ifdef PSD_HW
        setscantimeimm(pidmode,pimscan,piviews,pitslice,opslicecnt);
        setscantimestop();
#endif
    }

    if(ifir_flag) {
#ifdef PSD_HW
        setscantimeimm(PSD_CLOCK_CARDIAC,avmintscan, piviews,pitslice,opslicecnt);
#endif
    }

    if (disco_flag)
    {
#ifdef PSD_HW
        if (navgate_flag)
        {
            pidmode = PSD_CLOCK_CARDIAC;
            piviews = nr_of_segments; /* number of segments in mask */
        }
        else
        {
            pidmode = PSD_CLOCK_NORM;
        }
        if (mask_phase_flag)
        {
            if (pause_after_mask_flag)
            {
                setscantimeimm(pidmode, pimscan, piviews, pitslice, opslicecnt);
            }
            else
            {
                /* if mask ON, but no pause, then show total scan time */
                setscantimeimm(pidmode, avmintscan + pimscan, piviews, pitslice, opslicecnt);
            }
        }
        else
        {
            setscantimeimm(pidmode, avmintscan, piviews, pitslice, opslicecnt);
        }
#endif
    }

    /* BJM: RF Check Sequence */
    /* This sequence simply unblanks the RF amp 250us early to   */
    /* check for any driver failures (no exciter output).  Any   */
    /* errors detected will cause the scan to abort and protect  */
    /* the RF hardware from further damage...*/

    if((PSD_ON == minimize_RFunblank_time) && (smartprep_flag==PSD_OFF) ) {
        setssitime((LONG)dummyrf_ssitime/HW_GRAD_UPDATE_TIME);
        boffset(off_dummyrfseq);
        startseq((short)0,(SHORT)MAY_PAUSE); 
        /* Switch back to the core sequence */
        setssitime((LONG)rsptimessi/HW_GRAD_UPDATE_TIME);
        boffset(off_seqcore);
    }

    /* set period */
    setperiod(scan_deadtime, &seqcore, 0);

    /* Setting the period of the last instruction of the seqpass sequence
       based on MPH flag and sldeltime for (acqs-1)passes and the last pass - MRIhc20775 */

    if(mph_flag == PSD_ON )
    {
        if(sldeltime > 10s)
        {
            pass_seqtime_def = RUP_GRD((seqpass_deadtime - (int)(sldeltime/2)));
        }
        else
        {
            pass_seqtime_def = RUP_GRD((seqpass_deadtime - sldeltime));
        }

        pass_seqtime_mph = seqpass_deadtime;
    }
    else
    {
        pass_seqtime_def = seqpass_deadtime;
    }

    /* MRIhc16353 - RV: IDEAL change */
    if( (PSD_ON == ideal_flag) || (medal_flag && medal_multitr_flag) || idealiq_flag )
    {
    	setperiod(GRAD_UPDATE_TIME, &dix_xpre,0 );
    	setperiod(GRAD_UPDATE_TIME, &dix_ssppre,0);
    	setperiod((ideal_pw+idealiq_pw+medal_pw+GRAD_UPDATE_TIME), &dix_ssppost,0);
    }


    if (rspisi == 1)	/* for use with isi interrupt */
    {
#ifdef PSD_IPG_DEBUG
        if (psd_isi_on == 1) /* set isi7 bit to on */
        {
            getctrl(&psdctrl, &isi7, 0);
            psdctrl |= (PSD_ISI0_BIT | PSD_ISI1_BIT | PSD_ISI2_BIT);
            setctrl(psdctrl, &isi7, 0);
        }
        else
        {
            getctrl(&psdctrl, &isi7, 0);
            psdctrl &= ~(PSD_ISI0_BIT | PSD_ISI1_BIT | PSD_ISI2_BIT);
            setctrl(psdctrl, &isi7, 0);
        }
#endif
    } /* end isi on */

    first_scan = YES;
    first_prepscan = YES;

    /* 3d oblique - changed sliceindex to slabindex - latha@mr */
    slabindex = 0;	 

    if (FAILURE==ssRsp3D()) 
    {
       return FAILURE;
    }
    setfrequency(rf1_freq[slabindex], &rf1, scanrf1_inst);
    set_echo1frequency(receive_freq1[slabindex],0);
    if (opetl>=2)
       set_echo2frequency(receive_freq2[slabindex],0);

@inline Respgate.e RGinit

@inline SlabTracking.e SlabTrackBaselinePhase
@inline SlabTracking.e SlabTrackGetLogicalDisp
    
    if ((PSD_OFF == opcgate) && ((PSD_ON == navgate_flag) || (PSD_ON == navtrig_flag))) {
        if(!skip_navigator_prescan)
        {
            nav_rrmeas_end_flag = 0;
            navigator_baseline_prescan(&nav_rrmeas_end_flag);
            if(nav_rrmeas_end_flag)
            {
                boffset(off_seqpass);
                setwamp(SSPD + DABPASS + DABSCAN, &pass_pulse, 2);
                startseq(0, MAY_PAUSE);
                rspexit();
            }

            if(PSD_ON == navtrig_flag)
            {
                setscantimestop();
                setscantimeimm(PSD_CLOCK_CARDIAC, pitscan, nav_nreps, pitslice, opslicecnt);
                setscantimestart();
            }
        }

#ifndef SIM
        hbs_total = nav_nreps;
        /* RespIntervals, usually fgre doesnot use. */

        hbs_left = hbs_total;

        view_accepted = 0;
        view_rejected = 0;
#endif

        /* reset trigger status */
        if((PSD_ON == navgate_flag) && (nav_dual_mode == 0))
            nav_active = 1;
        else
            nav_active = 0;
    }

    /* MRIge66079 - ATV: RTIA3D/ftMRA */
    if (ftmra_flag) {
        /* MRIge67603 */
        setscantimestop();
#ifdef PSD_HW
        setscantimeimm(PSD_CLOCK_NORM,0,piviews,pitslice,opslicecnt);
#endif
        setscantimeauto();


        cont_rtia_stop = 0;
        /* Allow first time entry */

        /* Allocate Space for RTIA RSP buffers */

        input_id_values_buffer = (unsigned long *)AllocNode( sizeof(unsigned long) *
                                                             (CS_MAX_NUM_RSPS * 2 + 1) );
        recon_id_values_buffer = (unsigned long *)AllocNode( sizeof(unsigned long) *
                                                             (CS_MAX_NUM_RSPS * 2 + 1) );


        while ( cont_rtia_stop == 0 ) {

#ifdef PSD_HW
            cont_rtia_stop = (INT)BoreOverTemp( btemp_monitor,
                                                btemp_debug );
#endif

            while (cont_recon_queue > ( RECON_BUFFERS_AVAILABLE -1 ) ) {
                /* Recon doesn't have a free buffer due to acquisition
                   being faster. Poll the cont_recon_queue RSP till
                   there's a free buffer. Poll doing wait sequences
                   before the next RSP update . */

                boffset(off_seqdelay3);
                startseq((short)0,(SHORT)MAY_PAUSE);
                boffset(off_seqcore);
            }


            efgre3d_realtime_update ( input_id_values_buffer,
                                      recon_id_values_buffer );
            boffset(off_seqcore);

            if (cont_3dhires == 0) {
                scancoreRTIA_2D();

                if (cont_rtia_stop == 1)
                    issue_stop_scan = 1;
                else
                    issue_stop_scan = 0;


                if ( (issue_stop_scan == 1) ) {
                    /* Set DAB pass packet to end of scan */
                    setwamp(SSPD + DABPASS + DABSCAN, &pass_pulse2d, 2);
                    printdbg("End of Scan and Pass", debugstate);
                }
                /* Send EOP if not fluoro */
                else {
                    /* Set DAB pass packet to end of pass */
                    setwamp(SSPD + DABPASS, &pass_pulse2d, 2);
                    printdbg("End of Pass", debugstate);
                }


                settriggerarray((short)1, rsptrigger); 
                pause = MAY_PAUSE;

                boffset(off_seqpass2d);

#ifdef PSD_HW
                cs_save_recon_values (recon_id_values_buffer) ;
#endif

                if (startseq( (SHORT)0, (SHORT) pause ) == FAILURE )
                    return FAILURE;

                boffset(off_seqcore);

            }
            else /*  3D mode */
            {
                /* Send a 3D plane packet after 2D RTIA is complete to notify
                   recon of the transition from the 2D RTIA to the 3D 
                   acquistion.  Recon does not do the 3D recon for this
                   3D plane packet */
                boffset(off_seq3ddummy);
                load3d(&d3ddummy, 0, DABON);
                startseq(0, MAY_PAUSE);
                boffset(off_seqcore);

                if (slicecnt != acqs)
                {
                    pitscan = pitslice * slicecnt;
                }
                
                for (phaseindex = 0;phaseindex <opfphases ;phaseindex++) {
                    for (slabindex = 0; slabindex < slabquant; slabindex++) {
                        pass = slabindex + phaseindex*slabquant; /* 3d oblique - latha@mr */

                        if ( (slicecnt != acqs) && 
                             ( (slicecnt > 1) && (pass == ((int)(acqs/slicecnt)*slicecnt - 1)) ) )  
                        {
                            pitscan = pitslice * (acqs % slicecnt);
                        }

                        scancoreRTIA_3D();

                        if ( (cont_rtia_stop == 1) || (pass == (acqs-1)) )
                            issue_stop_scan = 1;
                        else
                            issue_stop_scan = 0;

                        if ( (issue_stop_scan == 1) && (pass == (acqs-1)) ) {
                            /* Set DAB pass packet to end of scan */
                            setwamp(SSPD + DABPASS + DABSCAN, &pass_pulse, 2);
                            printdbg("End of Scan and Pass", debugstate);
                        }
                        else {
                            /* Set DAB pass packet to end of pass */
                            setwamp(SSPD + DABPASS, &pass_pulse, 2);
                            printdbg("End of Pass", debugstate);
                        }


                        settriggerarray((SHORT)(slabquant), rsptrigger);

                        if (pass == (acqs-1)) {
                            pause = MAY_PAUSE;
                            
                            /* If last pass, subtract sldetime part included in passtime
                               MRIge57698 ....no sldelay for last acq  -agilandk@mr*/

                            if  (mph_flag == PSD_ON ) {
                                setperiod ( (long)pass_seqtime_def, &seqpass, 0 ) ;
                            }

                        } else {                       /* if not last pass */
                            if (((pass+1) % slicecnt)==0) {
                                pause = MUST_PAUSE;     /* pause if desired */
                                setperiod ( (long)pass_seqtime_def, &seqpass, 0 ) ; /* Auto Voice  04/18/2005 YI */
                            } else {
                                pause = AUTO_PAUSE;     /* or if required */
                                /* Auto Voice  04/18/2005 YI */
                                if (mph_flag == PSD_ON ) {
                                    if(slicecnt == acqs) { /* MRIhc08979  08/05/2005 YI */
                                        setperiod ( (long)pass_seqtime_mph, &seqpass, 0 ) ;
                                    } else {
                                        setperiod ( (long)pass_seqtime_def, &seqpass, 0 ) ;
                                    }
                                }
                            }
                        }

                        boffset(off_seqpass);

#ifdef PSD_HW
                        cs_save_recon_values (recon_id_values_buffer) ;
#endif

                        /* load last 3d packet */
                        if (delay3Drecon_flag)
                        {
                           load3d(&d3dpass,0,DABOFF);
                        }
                        else
                        {
                            /* The last frame is ALWAYS the last frame of a xz-plane */
                            int phPackBamFlag = arc_flag && (arc_pack_bam & BAM_PACK_Y);
                            int view3dpkt = arcGetDabEncode(zy_export[sampledPoints - 1].view,
                                                             phPackBamFlag, arcPhaseRemapTable) + 1;

                            load3d(&d3dpass, view3dpkt, DABON);

                            if (threedpkt_debug)
                            {
                                printf("Playing 3D plane packet for view %d (seqpass)\n", view3dpkt);
                            }
                        }

#ifdef PSD_HW   /* Auto Voice */
                        if ((mph_flag == 1) && (pass != acqs-1) && (slicecnt == acqs)) { 
                            broadcast_autovoice_timing(0, sldelay/1ms, TRUE, TRUE);
                        }
#endif

                        if (startseq( (SHORT)0, (SHORT) pause ) == FAILURE ) 
                            return FAILURE;

                        boffset(off_seqcore);

                        if ( (pass == (acqs-1)) )
                        {
                            cont_rtia_stop = 1;
                            issue_stop_scan = 1;
                        }

                    } /* slabindex */

                    /* MRIhc08979  08/05/2005 YI */
                    if ( ( sldeltime > 10s ) && ( pass != ( acqs -1 ) ) && (slicecnt == acqs) )
                        /* no scandelay1 for the last acq. MRIge57698 */
                        scandelay1();

                } /* opfphase */


            } /* endif hires check */

        } /* end while */

        /* Free the memories allocated */
#ifdef PSD_HW
        FreeNode( (char *)input_id_values_buffer );
        FreeNode( (char *)recon_id_values_buffer );
#else /* !PSD_HW */
        FreeNode( (void *)input_id_values_buffer );
        FreeNode( (void *)recon_id_values_buffer );
#endif /* PSD_HW */

    } /* End RTIA3D/ftMRA */
    else /* non-ftMRA */
    {
        if (PSD_ON == monitor_test && (PSD_OFF == navgate_flag) && (PSD_OFF == navtrig_flag))
        {
            testcore();
        }
        else if (smartprep_flag && sprep_monit)
        {
            acq_echo1 = DABOFF;
            if (opetl>=2)
               acq_echo2 = DABOFF;
            view = zy_export[0].view;
            slice = zy_export[0].slice;
            dabview = view + 1;
            load3d(&d3d, 0, DABOFF);
            fgre_loaddab_echo1(slice, dabecho, dabop, dabview, acq_echo1);
            if (opetl>=2) {
                fgre_loaddab_echo2(slice, (dabecho+1), (opetl-1), nshots, dabop, dabview, acq_echo2);
            }

            setiamp(-viewtable[dabview], &gy1, 0);
            if (rewinder_flag) {
                setiamp(-viewtable[dabview], &gy1r, 0);
            }
    
            Monitor_load_SmartPrep_RTPtask();
            monitor_signal( );

            /*MRIhc04779 add this sequence so that RtpEnd
             * CoilSwitch will have enough time to excute*/

            /* Ending RTP Processing automatically switches the coil 
               back to the scancoil as specified in the RTP buffer by the 
               channel selection bitmap - scan_channel_map. The switch 
               requires a minimum of 100ms, which is guaranteed by the 
               disdaq time following.  - RJF, MRIge82249 
               MRIge91361: RtpEnd doesn't contain coilswitch code anymore,
               coil switch is performed by SmartPrep_CoilSwitch*/

            /*MRIhc05287 the Rtpend and coilswitch code are now in
             * Monitor.e , inside of monitor_signal() function*/

            if (use_ecg_scancore) {
                if (reverseLoopOrder_flag)
                    ecg_scancore_ZY();
                else
                    ecg_scancore_YZ();
            } else if (disco_flag) {
                discocore();
            } else {
                scancore();
            }

            write_data_file();

            /* MRIhc10282 - PSD removes the bolus (not) detected message with
            an agp function rsp_psd_err_clear. The bolus detected flag was
            sent by rtp through global smartprep buffer */

            if (smartprep_detected != 1) {
                rsp_psd_err_clear(EM_SPCOPROC_SPU_NO_DETECT);
            } else {
                rsp_psd_err_clear(EM_SPCOPROC_SPU_DETECT);
            }

        } else {
            boffset(off_seqcore);
            if (use_ecg_scancore) {
                if (reverseLoopOrder_flag) {
                    ecg_scancore_ZY();
                } else {
                    ecg_scancore_YZ();
                }
            } else {
                if (disco_flag) {
                    discocore();
                } else if(ifir_flag) {
                    vast_ifir_scancore();
                } else if( vast_mode && (!ssfp_flag) ) {
                    vast_gre_scancore();
                } else if( vast_mode && ssfp_flag ) {
                    vast_fiesta_scancore();
                } else if( PSD_ON == tricks_flag ) {
                    ectrickscore();
                } else if( cine3d_flag ){
                    scancore_fcine_ssfp_ktARC();
                } else if( PSD_ON == ugfsf_flag ) { /* ungated FatSat FIESTA */
                    scancore_ZY();
                } else {
                    scancore();               
                }
            }
        }

#ifdef PSD_HW
    if ( ((PSD_ON == navgate_flag) || (PSD_ON == navtrig_flag)) && (nav_test>3) ) {  /* MRIhc07063 */
        write_navigator_data_file();
    }
#endif  

    } /* end normal non-realtime core */

    if ((PSD_ON == navgate_flag) && (PSD_ON == opdynaplan))
    {
        nav_prev_window = nav_currwindow;
        nav_prev_thresh = nav_currthresh;
        
        navmph_cnt++;
        /* skip_navigator_prescan is updated to 1 by modify RSP after mask phase */
    }

    /* MGD2, RJF */
    /* NAV */
#ifdef PSD_HW
    if ((PSD_ON == navgate_flag) || (PSD_ON == navtrig_flag)) {
        RtpEnd();
        isrtplaunched = 0;
    }
#endif

    rspexit();
    return SUCCESS;
}   /* end scan() */


/********************* PS2CORE ************************/
STATUS ps2core(void)
{
    short temp_short,rfchop;
    int slice_loop;
    int ps_slices;
    int pre_dixtime, post_dixtime;
    int i;
    int old_psc_vol_index = -1; /* For SWIFT coil switching */
    int temp_rf1_amp = 0;
    int ps_etl_echo = 0; /* echo number used for scanTR. 0 means 1st echo in the TR */

    int sbm_number = 1; /* SVBranch, Smart Burst Mode */

    rfchop = 1;

    /* Initialize yres_phase and slab_phase to zero */
    yres_phase = 0;
    slab_phase = 0;

    /* Chop the receiver in APS2/MPS2 */
    chop_phase = -1;

    printdbg("Starting ps2core",PSdebugstate);

    /* set echo time for prescan based on k_ideal_pi */
    /* MRIhc16353 - RV: IDEAL change */
    if(PSD_ON == ideal_flag)
    {
       if  ( (k_ideal_pi % 2) == 0) {
           post_dixtime = (GRAD_UPDATE_TIME + ideal_pw - ideal_shift1);
           pre_dixtime = (GRAD_UPDATE_TIME + ideal_shift1);
       } else {
           post_dixtime = (GRAD_UPDATE_TIME + ideal_pw - ideal_shift_max);
           pre_dixtime = (GRAD_UPDATE_TIME + ideal_shift_max);
       }
       setperiod(post_dixtime, &dix_ssppost, 0);
       setperiod(pre_dixtime, &dix_xpre,0 );             
       setperiod(pre_dixtime, &dix_ssppre,0);
    }

    if(idealiq_flag)
    {
       int temp_int;
       ps_etl_echo = (int)(idealiq_ps_echo/idealiq_nshots);
       temp_int = (idealiq_ps_echo % idealiq_nshots);

       post_dixtime = (GRAD_UPDATE_TIME + idealiq_pw - idealiq_esp*temp_int);
       pre_dixtime = (GRAD_UPDATE_TIME + idealiq_esp*temp_int);
       setperiod(post_dixtime, &dix_ssppost, 0);
       setperiod(pre_dixtime, &dix_xpre,0 );
       setperiod(pre_dixtime, &dix_ssppre,0);
    }

    if(medal_flag && medal_multitr_flag)
    {
       post_dixtime = (GRAD_UPDATE_TIME + medal_pw - medal_shift2);
       pre_dixtime = (GRAD_UPDATE_TIME + medal_shift2);
       setperiod(post_dixtime, &dix_ssppost, 0);
       setperiod(pre_dixtime, &dix_xpre,0 );
       setperiod(pre_dixtime, &dix_ssppre,0);
    }

    temp_short = max_pg_iamp*(-a_base/loggrd.tz); /* set up zero slice encode */
    setiamp(temp_short,&gzcomb,0);	          /* (just refocus) */
    if (zrewind_flag) {
        temp_short = max_pg_iamp*(a_base2/loggrd.tz); /* set up zero rewinder */
        setiamp(temp_short,&gzp,0);		  /* (just killer) */
    }

    /* 3d oblique - changed sliceindex to slabindex - latha@mr */
    /* Need to set this to the prescan slab */
    slabindex = rspesl;
    sp_sat_index = slabindex;

    if (FAILURE==ssRsp3D()) 
    {
        return FAILURE;
    }
    setfrequency(rf1_freq[slabindex],&rf1,scanrf1_inst);
    set_echo1frequency(receive_freq1[slabindex],0);
    if (opetl>=2)
       set_echo2frequency(receive_freq2[slabindex],0);
    /* end 3d oblique - latha@mr */

    slice  = 0;               /* slices indexed from 0 instead of 1 */
    spgr_count = 1;           /*initialize spgr counter */ 
    seq_count = 1; /* VAL15 12/14/2004 YI */ 

    load3d(&d3d, 0, DABOFF);
    fgre_loaddab_echo1(slice, dabecho, dabop, dabview, DABOFF);

    if (opetl>=2) {
        fgre_loaddab_echo2(slice, (dabecho+1), (opetl-1), nshots, dabop, dabview, DABOFF);
    }

    /* ungated FatSat FIESTA */
    if(ugfsf_flag){
        rspdda = 0;
        if( oprtcgate && resp_gate_trig_sw==0 )
          prep_dda = 1;
    }

    if(ifir_flag) rspdda = 0; 

    /* SWIFT: No coil switch for RG */
    if ((intslab_flag) &&
        (VALUE_SYSTEM_SVEM == value_system_flag ||
         VALUE_SYSTEM_SVDM == value_system_flag ))
    {
        setwamp(SSPD, &coilsw_on, 2);
    }

    /* SVBranch, Smart Burst Mode */
    /* SBM: turn off Read encoding and phase encoding in discard period */
    if(sbm_flag)
    {
        setiamp(0, &gx1, 0);
        setiampt(0, &gxw, 0);
        setiampt(0, &gxwex, 0);

        setiamp(volumetab[equant/2], &gzcomb, 0);

        if(zrewind_flag)
        {
            setiamp(volumetab2[equant/2], &gzp, 0);
        }
        setiamp(0, &gy1, 0);

        if(rewinder_flag)
        {
            setiamp(0, &gy1r, 0);
        }
    }


    /* collect disdaq views */
    for (view = -rspdda; view < 0; view++)
    {
        if(PSD_ON == cal3d_flag)
        {
            if(view < -ps2_dda)
            {
                /* set rf1 amplitude to 0 for extra dda for CSF signal to recover */
                setiamp(0, &rf1, scanrf1_inst);
            }
            else
            {
                /* initialize rf1 amplitude */
                setiamp(ia_rf1, &rf1, scanrf1_inst);
            }
        }

        spoil();
        startseq((SHORT)slabindex,(SHORT)MAY_PAUSE); /* 3d oblique - made sliceindex as 0 - latha@mr */
        syncoff(&seqcore);

        /* Chop exciter even during ps2 disdaqs to make sure that dynamic 
           equilibrium is maintained */
        chop_phase = -chop_phase;
    }

    /* SVBranch, Smart Burst Mode */
    /* SBM: recover gradient amplitude for X axis */
    if(sbm_flag)
    {
        setiamp(ia_gx1, &gx1, 0);
        setiampt(ia_gxw, &gxw, 0);
        setiampt(ia_gxwex, &gxwex, 0);
    }


    if(ifir_flag)
    {
       rspskp = 2;
    } else { 
       rspskp = 1;
    }

    if (ifir_flag)
    {
        int loop_counter = 0;
        int carddelay_iteration;

        carddelay_iteration = (act_tr > 0) ? (2s / act_tr) : 100;

        for (view = -prep_dda; view <= rspvus; view++)
        {
            /* wait for T1 relaxation */
            settrigger((short)TRIG_INTERN, (short)0);
	        boffset(off_seqcarddelay);
	        scopeon(&seqcarddelay);
            for( loop_counter = 0; loop_counter < carddelay_iteration; ++ loop_counter ) 
            {
	            startseq((SHORT)0, (SHORT)MAY_PAUSE);
                scopeoff(&seqcarddelay);
            }

            /* IR PREP (pjg) */
            if( irprep_flag == PSD_ON ) IRPrep();

            if (sp_sat) SatPrep();

            if (specir_flag) SpecIRChemPrep();

            /* START UP */ 
            load3d(&d3d, 0, DABOFF);
            fgre_loaddab_echo1(slice, dabecho, dabop, dabview, DABOFF);

            settrigger((short)TRIG_INTERN, (short)0);

            for (loop_counter=1; loop_counter<=fiesta_gated_dda; loop_counter++) 
            {
                boffset(off_seqcore);
                if ( 1 == fiesta_rampup_type )
                {
                    temp_rf1_amp = (int)( (float)ia_rf1 * (float)loop_counter / (float)fiesta_gated_dda );
                }
                else if (2 == fiesta_rampup_type )
                {
                    temp_rf1_amp = (int)( (float)ia_rf1 /
                            ( 1 + exp((fiesta_gated_dda/2.0-(float)loop_counter)/(0.1*fiesta_gated_dda))));
                }
                else if (3 == fiesta_rampup_type) 
                {
                    temp_rf1_amp = (int)( 0.5 * (float)ia_rf1
                            * (1 - cos(M_PI*loop_counter/fiesta_gated_dda)));
                }
                else 
                {
                    temp_rf1_amp = ia_rf1;
                }

                setiamp(temp_rf1_amp, &rf1, scanrf1_inst);
                exphase ^= 0x8000;
                fgre_setiphase(rf1frqrsp,exphase);

                /* phase and slice encoding off */
                setiamp(0, &gy1, 0);
                if (rewinder_flag == PSD_ON)
                {
                    setiamp(0, &gy1r, 0);
                }
                setiamp((short)(max_pg_iamp*(-a_base/loggrd.tz)),&gzcomb,0);
                if (zrewind_flag) 
                {
                    setiamp((short)(max_pg_iamp*(a_base2/loggrd.tz)),&gzp,0);
                }

                startseq((SHORT)0, (SHORT)MAY_PAUSE);
                scopeoff(&seqcore);
            }

            /* start excitation loop */
            for (excitation = 1; excitation <= rspnex * rspskp; excitation++)
            {
                if((excitation == rspnex) || (rspent == L_APS2)) 
                {
                     attenlockoff(&attenuator_key);
                } else {
                     attenlockon(&attenuator_key);
                }

                if ((excitation % rspskp) == 0) {
                     acq_echo1 = DABON;
                } else {
                     acq_echo1 = DABOFF;
                }

                fgre_loaddab_echo1(slice, dabecho, dabop, dabview, acq_echo1);

                temp_rf1_amp = ia_rf1;
                setiamp(temp_rf1_amp, &rf1, scanrf1_inst);

                exphase ^= 0x8000;
                fgre_setiphase(rf1frqrsp,exphase);

                /* phase encode off */
                setiamp(0, &gy1, 0);
                if (rewinder_flag == PSD_ON)
                {
                    setiamp(0, &gy1r, 0);
                } 

                /* slice encode off */
                setiamp((short)(max_pg_iamp*(-a_base/loggrd.tz)),&gzcomb,0);
                if (zrewind_flag) 
                {
                    setiamp((short)(max_pg_iamp*(a_base2/loggrd.tz)),&gzp,0);
                }

                startseq(slabindex, (SHORT)MAY_PAUSE);
                syncoff(&seqcore);

            } /* excitation loop */

            if (fiesta_killer_flag)
            {
                boffset(off_seqgzk);
                scopeoff(&seqgzk);
                startseq((SHORT)0, (SHORT)MAY_PAUSE);
            }
        }
    }
    else
    {
        if (!osfp_flag) 
        { 
            /* IR PREP (pjg) */
            if( irprep_flag == PSD_ON )
            {
                for (view = 0; view < prep_dda; view++)
                {
                    IRPrep();
                    for (slice_loop = 0; slice_loop < rspir; slice_loop++)
                    {
                        spoil();

                        if (slice_loop == 0) {
                             PlayDisdaq(irdisdacqs);
                        }
                        startseq((SHORT) slabindex , (SHORT) MAY_PAUSE);
                        syncoff(&seqcore);
                    }
                } /* end disdacq loop */
            }

            if( PSD_ON == specir_flag )
            {
                for (view = 0; view < prep_dda; view++)
                {
                    /* ungated FatSat FIESTA */
                    if(ugfsf_flag)
                    {
                        if( oprtcgate && resp_gate_trig_sw==0 )
                            settrigger((short)TRIG_RESP, (short)slabindex);
                        else
                            settrigger((short)TRIG_INTERN, (short)slabindex);
                    }

                    ChemPrep();

                    /* ungated FatSat FIESTA */
                    if(ugfsf_flag && oprtcgate && resp_gate_trig_sw==0 )
                             settrigger((short)TRIG_INTERN, (short)slabindex);

                    for (slice_loop = 0; slice_loop < sl_per_chem; slice_loop++)
                    {
                        spoil();

                        if (slice_loop == 0) 
                        {
                            /* ungated FatSat FIESTA */
                            if( !(ugfsf_flag && (fiesta_rampup_type>0)) )
                            {
                                PlayDisdaq(chemsat_dda);
                            }
                            else
                            {
                                for (i=1;i<=ugfsf_ramp_dda;i++) 
                                {
                                    if(1==fiesta_rampup_type)
                                    {
                                        temp_rf1_amp = (int)((float)(ia_rf1*i)/(float)ugfsf_ramp_dda);
                                    }
                                    else if(2==fiesta_rampup_type)
                                    {
                                        temp_rf1_amp = (int)((float)ia_rf1 / 
                                                           (1.0 + exp((float)(ugfsf_ramp_dda/2.0-i)/(0.1*ugfsf_ramp_dda))));
                                    }
                                    else if(3 == fiesta_rampup_type)
                                    {
                                        temp_rf1_amp = (int)(0.5 * (float)(ia_rf1) * (1.0-cos((float)(M_PI*i)/(float)ugfsf_ramp_dda)));
                                    }
                                    else 
                                    {
                                        temp_rf1_amp = ia_rf1;
                                    }
                                    setiamp(temp_rf1_amp, &rf1, scanrf1_inst);

                                    if(pc_mode < PC_BASIC)
                                        multiphase();
                                    else
                                        spoil();

                                    startseq((SHORT)0, (SHORT)MAY_PAUSE);
                                }
                                if(ugfsf_flat_dda>0)
                                {
                                    PlayDisdaq(ugfsf_flat_dda);
                                }
                            }
                        }
                        startseq((SHORT) slabindex , (SHORT) MAY_PAUSE);
                        syncoff(&seqcore);
                    }

                    /* ungated FatSat FIESTA */
                    if( ugfsf_flag && ugfsf_linear_ramp_down>0 )
                    {
                        for (i=0;i<ugfsf_linear_ramp_down;i++) 
                        {
                            temp_rf1_amp = ia_rf1 - (int)((float)(ia_rf1*i)/(float)ugfsf_linear_ramp_down);
                            setiamp(temp_rf1_amp, &rf1, scanrf1_inst);

                            if(pc_mode < PC_BASIC)
                                multiphase();
                            else
                                spoil();

                            startseq((SHORT)0, (SHORT)MAY_PAUSE);
                        }
                        setiamp(ia_rf1, &rf1, scanrf1_inst); /* restore rf1 amp */
                    }

                } /* end disdacq loop */
            }
        }

        /* start view loop */
        for (view = 1; view <= rspvus; view++)
        {
            if (sp_sat && merge_flag)
            {
                SatPrep();
            }

            if( (irprep_flag == PSD_ON) && !osfp_flag )
            {
                /* Tom Foo recommended that the first 32 slices is all that
                   are necessary for prescan. */
                if (rspir < 32) 
                {
                    ps_slices = rspir;
                } else {
                    ps_slices = 32;
                }
                /* make it odd for correct chopping */
                ps_slices += !(ps_slices % 2);

                for (excitation = 1; excitation <= rspnex; excitation++)
                {
                    if((excitation == rspnex) || (rspent == L_APS2))
                    {	    
                        attenlockoff(&attenuator_key);
                    } else {
                        attenlockon(&attenuator_key);
                    }

                    if ( rspir != 0 ) 
                    {
                       IRPrep();
                       PlayDisdaq(irdisdacqs);
                    }

                    for (slice_loop = 0; slice_loop < ps_slices; slice_loop++)
                    {
                        if( (slice_loop == rspmpssl) || (rspmpssl < 0) ) 
                        {
                            acq_echo1 = DABON;
                        } else {
                            acq_echo1 = DABOFF;
                        }

                        if (opetl>=2) acq_echo2 = DABOFF;

                        spoil();

                        fgre_loaddab_echo1(slice, dabecho, dabop, dabview, acq_echo1);
                        if (opetl>=2) 
                        {
                            fgre_loaddab_echo2(slice, (dabecho+1), (opetl-1), nshots, dabop, dabview, acq_echo2);
                        }

                        startseq(slabindex, (SHORT)MAY_PAUSE);

                        syncoff(&seqcore);

                        /* Chopper logic */
                        chop_phase = -chop_phase;
                    } /* slice loop */
                } /* excitation loop */
            }
            else if( (PSD_ON == specir_flag) && !osfp_flag )
            {
               /* Tom Foo recommended that the first 32 slices is all that
                  are necessary for prescan. */
               if (sl_per_chem < 32) 
               {
                   ps_slices = sl_per_chem;
               } else {
                   ps_slices = 32;
               }
               /* make it odd for correct chopping */
               ps_slices += !(ps_slices % 2);

               for (excitation = 1; excitation <= rspnex; excitation++)
               {
                   if((excitation == rspnex) || (rspent == L_APS2)) 
                   {
                       attenlockoff(&attenuator_key);
                   } else {
                       attenlockon(&attenuator_key);
                   }

                   if ( sl_per_chem != 0 ) 
                   {
                       /* ungated FatSat FIESTA */
                       if(ugfsf_flag)
                       {
                           if( oprtcgate && resp_gate_trig_sw==0 )
                               settrigger((short)TRIG_RESP, (short)slabindex);
                           else
                               settrigger((short)TRIG_INTERN, (short)slabindex);
                       }

                       ChemPrep();

                       /* ungated FatSat FIESTA */
                       if(ugfsf_flag && oprtcgate && resp_gate_trig_sw==0 )
                            settrigger((short)TRIG_INTERN, (short)slabindex);

                       if( chemsat_dda != 0 ) 
                       {
                           /* ungated FatSat FIESTA */
                           if( !( ugfsf_flag && (fiesta_rampup_type>0) ) )
                           {
                               PlayDisdaq(chemsat_dda);
                           }
                           else
                           {
                               for (i=1;i<=ugfsf_ramp_dda;i++) 
                               {
                                   if(1==fiesta_rampup_type)
                                   {
                                       temp_rf1_amp = (int)((float)(ia_rf1*i)/(float)ugfsf_ramp_dda);
                                   }
                                   else if(2==fiesta_rampup_type)
                                   {
                                       float rf1_amp_scale;
                                       if(ugfsf_ramp_dda>1)
                                           temp_rf1_amp = (float)(ia_rf1)/(ugfsf_ramp_dda-1);
                                       else
                                           rf1_amp_scale = (float)(ia_rf1);
                                       temp_rf1_amp = (int)(rf1_amp_scale * ((float)i-0.5));
                                       if(temp_rf1_amp>ia_rf1) temp_rf1_amp=ia_rf1;
                                   }
                                   else
                                   {
                                       temp_rf1_amp = (int)(0.5*(float)(ia_rf1)*(1.0-cos((float)(M_PI*i)/(float)ugfsf_ramp_dda)));
                                   }
                                   setiamp(temp_rf1_amp, &rf1, scanrf1_inst);

                                   if(pc_mode < PC_BASIC)
                                       multiphase();
                                   else
                                       spoil();

                                   startseq((SHORT)0, (SHORT)MAY_PAUSE);
                               }
                               if(ugfsf_flat_dda>0)
                               {
                                   PlayDisdaq(ugfsf_flat_dda);
                               }
                           }
                       }
                   }

                   for (slice_loop = 0; slice_loop < ps_slices; slice_loop++)
                   {
                       if( (slice_loop == rspmpssl) || (rspmpssl < 0) ) 
                       {
                           acq_echo1 = DABON;
                       } else {
                           acq_echo1 = DABOFF;
                       }

                       if (opetl>=2) acq_echo2 = DABOFF;

                       spoil();

                       fgre_loaddab_echo1(slice, dabecho, dabop, dabview, acq_echo1);
                       if (opetl>=2) 
                       {
                           fgre_loaddab_echo2(slice, (dabecho+1), (opetl-1), nshots, dabop, dabview, acq_echo2);
                       }

                       startseq(slabindex, (SHORT)MAY_PAUSE);

                       syncoff(&seqcore);

                       /* Chopper logic */
                       chop_phase = -chop_phase;
                   } /* slice loop */

                   /* ungated FatSat FIESTA */
                   if( ugfsf_flag && ugfsf_linear_ramp_down>0 )
                   {
                       for (i=0;i<ugfsf_linear_ramp_down;i++) 
                       {
                           int temp_rf1_amp, rf1_amp_scale;

                           rf1_amp_scale = (int)(ia_rf1/ugfsf_linear_ramp_down);
                           temp_rf1_amp = ia_rf1 - rf1_amp_scale * i;
                           setiamp(temp_rf1_amp, &rf1, scanrf1_inst);

                           if(pc_mode < PC_BASIC)
                               multiphase();
                           else
                               spoil();

                           acq_echo1 = DABOFF;
                           if (opetl>=2) acq_echo2 = DABOFF;

                           fgre_loaddab_echo1(slice, dabecho, dabop, dabview, acq_echo1);
                           if (opetl>=2) 
                           {
                               fgre_loaddab_echo2(slice, (dabecho+1), (opetl-1), nshots, dabop, dabview, acq_echo2);
                           }

                           startseq((SHORT)0, (SHORT)MAY_PAUSE);
                       }
					   setiamp(ia_rf1, &rf1, scanrf1_inst); /* restore rf1 amp */
				   }
			   } /* excitation loop */
		    }
            else if(osfp_flag) 
            {
                ps_slices = views_per_segment;

                /* make it odd for correct chopping */
                ps_slices += !(ps_slices % 2);

                for (excitation = 1; excitation <= rspnex; excitation++)
                {
                    if((excitation == rspnex) || (rspent == L_APS2))
                    {
                        attenlockoff(&attenuator_key);
                    } else {
                        attenlockon(&attenuator_key);
                    }

                    osfp_prep(START_UP);

                    for (slice_loop = 0; slice_loop < ps_slices; slice_loop++)
                    {
                        if( (slice_loop == rspmpssl) || (rspmpssl < 0) ) 
                        {
                            acq_echo1 = DABON;
                        } else {
                            acq_echo1 = DABOFF;
                        }

                        if (opetl>=2) acq_echo2 = DABOFF;

                        spoil();

                        fgre_loaddab_echo1(slice, dabecho, dabop, dabview, acq_echo1);
                        if (opetl>=2)
                        {
                            fgre_loaddab_echo2(slice, (dabecho+1), (opetl-1), nshots, dabop, dabview, acq_echo2);
                        }

                        startseq(slabindex, (SHORT)MAY_PAUSE);

                        syncoff(&seqcore);

                        /* Chopper logic */
                        chop_phase = -chop_phase;
                    } /* slice loop */


                    if (osfp_flag && osfpsd_flag)
                    {
                        osfp_prep(SLOW_DOWN);
                    }

                    if (end_segment_delay>0)
                    {
                        delay_end_segment();
                    }
                } /* excitation loop */
            }
            else
            {
                /* initialize all echoes to DABOFF */
                fgre_loaddab_echo1(slice, dabecho, dabop, dabview, DABOFF);
                if (opetl>=2) 
                {
                    fgre_loaddab_echo2(slice, (dabecho+1), (opetl-1), nshots, dabop, dabview, DABOFF);
                }

                if ((view%rspskp) == 0) 
                {
                    acq_echo1 = DABON;
                } else {
                    acq_echo1 = DABOFF;
                }

                if (ps_etl_echo > 0) {
                    fgre_loaddab_echoN(slice, dabecho, ps_etl_echo, dabop, dabview, acq_echo1);
                } else {
                    fgre_loaddab_echo1(slice, dabecho, dabop, dabview, acq_echo1);
                }

                /* start excitation loop */	
                for (excitation = 1; excitation <= rspnex; excitation++)
                {
                    if((excitation == rspnex) || (rspent == L_APS2)) 
                    {
                        attenlockoff(&attenuator_key);
                    } else {
                        attenlockon(&attenuator_key);
                    }

                    /*SWIFT changes for MPS2*/
                    if( (intslab_flag == PSD_ON) && (psc_vol_index>0) && (rspent == L_MPS2))
                    {
                        if( old_psc_vol_index != psc_vol_index )
                        {
                            if( PSD_OFF == noswitch_slab_psc )
                            {
                                slabindex = psc_vol_index-1;
                            }
                            else
                            {
                                slabindex = rspesl;
                            }

                            if( PSD_OFF == noswitch_coil_psc )
                            {
                                if (FAILURE == CoilSwitchSetCoil(coilInfo_tgt[psc_vol_index - 1], 0))
                                {
                                    return FAILURE;
                                }
                                boffset(off_seqcore);
                                /*setperiod(scan_deadtime, &seqcore, 0);*/
                            }

                            {
                                char tempstr[200] = "";
                                sprintf(tempstr,"ps2core: psc_vol_index=%d, after SwiFT prescan coil switch\n",psc_vol_index);
                                printdbg(tempstr,PSdebugstate);
                            }
                            old_psc_vol_index = psc_vol_index;
                        }
                    }
                    else
                    {
                        slabindex = rspesl;
                    }

                    if (FAILURE==ssRsp3D()) 
                    {
                        return FAILURE;
                    }
                    setfrequency(rf1_freq[slabindex],&rf1,scanrf1_inst);
                    setfrequency(receive_freq1[slabindex], &echo1, 0);

                    spoil();

                    /* SVBranch, Smart Burst Mode */
                    if(sbm_flag)
                    {
                        sbm_number ++;
                    }

                    startseq(slabindex, (SHORT)MAY_PAUSE);

                    syncoff(&seqcore);

                    /* SVBranch, Smart Burst Mode */
                    /* when amount of imaging sequences reaches limit, begin waiting period */
                    if( (sbm_number >= sbm_mps2_imaging_num) && sbm_flag)
                    {
                        sbm_number = 1;
                        sbm_dda = 0;
                        sbm_dummy();
                    }


                    /* Chopper logic */
                    chop_phase = -chop_phase;
			    } /* excitation loop */
            } /* end else */
        } /* view loop */
    }
    printdbg("Returning from ps2core",debugstate);
    return SUCCESS;
}

STATUS
set_echo2frequency( INT freq,
                    INT n_inst )
{
    int echoindex;
    for(echoindex=0; echoindex <(opetl-1); echoindex+=2) {
        setfrequency( freq, &(echo2toN[echoindex]), n_inst );
    }

    return SUCCESS;
}   /* end set_echo2frequency() */
/********************* SCANCORE ***********************/
STATUS scancore(void)
{
    char psddbgstr[256] = "";
    int cntvus;     /* Flag for collecting central views in Oddnes NPW case */
    int rspsat=0;   /* Counter for deciding after which slices SAT plays    */
    int si;  /* Superindex for elliptical-centric*/
    int dabviewbam, dabslicebam;
    int j;
    int si_inc;  /* DCZ: Superindex increment step size */
    int slice_index; /* DCZ */
    int uppercutoff;
    int lowercutoff;
    int osfpsu_flag = PSD_ON;
    int pre_segment_flag = PSD_OFF;
    int post_segment_flag = PSD_OFF;
    /* MRIhc16353 - RV: IDEAL change */
    int pre_dixtime, post_dixtime;
    int dixon_necho;
    int phPackBamFlag = arc_flag && (arc_pack_bam & BAM_PACK_Y);
    int slPackBamFlag = arc_flag && (arc_pack_bam & BAM_PACK_Z);
    int idealiq_pc_num_ref_acq = 0;
    int idealiq_pc_counter = 0;

    int nav_gate_active = 0;
    int navgate_dummy_slice = 0;
    int nav_dummylines = 0;
    int navgate_iter = 0;
    int nav_lastslice = 0;

    int dummy_count = 0;
    int nex_count = 1;
    int num_exc = 1;

    int slice_num;
    int tmp_slindex;

    if(idealiq_flag && idealiq_pc_flag)
    {
        idealiq_pc_num_ref_acq = idealiq_pc_ylines*idealiq_pc_zlines*idealiq_nshots*rspnex;

        idealiq_pc_post_dixtime = (int *)AllocNode(idealiq_pc_num_ref_acq * sizeof(int));
        idealiq_pc_pre_dixtime  = (int *)AllocNode(idealiq_pc_num_ref_acq * sizeof(int));
        idealiq_pc_dabview      = (int *)AllocNode(idealiq_pc_num_ref_acq * sizeof(int));
        idealiq_pc_dabviewbam   = (int *)AllocNode(idealiq_pc_num_ref_acq * sizeof(int));
        idealiq_pc_dabslice     = (int *)AllocNode(idealiq_pc_num_ref_acq * sizeof(int));
        idealiq_pc_dabslicebam  = (int *)AllocNode(idealiq_pc_num_ref_acq * sizeof(int));
        idealiq_pc_dabecho      = (int *)AllocNode(idealiq_pc_num_ref_acq * sizeof(int));
        idealiq_pc_dabop        = (int *)AllocNode(idealiq_pc_num_ref_acq * sizeof(int));
        if( (NULL == idealiq_pc_post_dixtime) || (NULL == idealiq_pc_pre_dixtime) ||
            (NULL == idealiq_pc_dabview) || (NULL == idealiq_pc_dabviewbam) ||
            (NULL == idealiq_pc_dabslice) || (NULL == idealiq_pc_dabslicebam) ||
            (NULL == idealiq_pc_dabecho) || (NULL == idealiq_pc_dabop) )
        {
            printf("scancore: Unable to allocate memory (AllocNode) for IDEAL IQ phase correction!\n");
            return FAILURE; 
        }
    }

    if (pfkz_flag)
    {
        /* Improved SPECIAL (linestodiscard) not compatible with pfkz) */
        lowercutoff = 0;
        uppercutoff = pfkz_total;
    }
    else
    {
        /* BBA - improved SPECIAL
           Number of frames is increased to play out extra alpha pulses for 
           for optimized pulse train length after specir 
           Data is not acquired for frames outside the desired kz volume  */
        
        lowercutoff = floor((float)(linestodiscard)/2);        /* smallest kz line number to acquire */
        /* MRIge91682 */
        uppercutoff = rspslq + lowercutoff;   	     	   /* largest kz line number to acquire + 1 */
    }

    printdbg("Starting scancore", debugstate);

#ifdef PSD_HW   /* Auto Voice */
    if(!smartprep_flag) {
        broadcast_autovoice_timing(0, trigger_delay_silent_countdown/1ms, FALSE, TRUE);
    }
#endif
    scandelay0();

    if (trigger_delay_wosp > 0)
    {
        reset_clock();
    }

    if (ideal_flag) {
        dixon_necho = ideal_necho;
    } else if (idealiq_flag) {
        dixon_necho = idealiq_nshots;
    } else if (medal_flag && medal_multitr_flag) {
        dixon_necho = medal_necho;
    } else {
        dixon_necho = 1;
    }

    for (phaseindex = 0;phaseindex <opfphases ;phaseindex++) {                 
@inline cal3d.e cal3d_scancore_phase

        for (slabindex = 0; slabindex < slabquant; slabindex++) {
            /* MRIhc16353 - RV: IDEAL change */
            for (outer_echo = 0; outer_echo < seq_necho; outer_echo++)  {
                if (ideal_echo_mode == 1) {  /* sequential -- echo in outer loop */
                    echo_index =  outer_echo;
                } else {             /* interleaved -- set echo in inner loop */
                    echo_index = 0;
                }

                if (idealiq_flag) {
                    echo_index = 0; /* IDEQL IQ supports interleaved only */
                }

                if (medal_flag && medal_multitr_flag) {
                    if (medal_echo_mode)
                        echo_index =  outer_echo;
                    else
                        echo_index = 0;
                }

                dabecho=echo_index;
                if(PSD_ON == ideal_flag)
                {
                    if (echo_index == 0) {
                        post_dixtime = (GRAD_UPDATE_TIME + ideal_pw - ideal_shift1);
                        pre_dixtime = (GRAD_UPDATE_TIME + ideal_shift1);
                    } else {
                        if (echo_index == 1) {
                            post_dixtime = (GRAD_UPDATE_TIME + ideal_pw - ideal_shift2);
                            pre_dixtime = (GRAD_UPDATE_TIME + ideal_shift2);
                        } else {
                            post_dixtime = (GRAD_UPDATE_TIME + ideal_pw - ideal_shift3);
                            pre_dixtime = (GRAD_UPDATE_TIME + ideal_shift3);
                        }
                    }
                    setperiod(post_dixtime, &dix_ssppost, 0);

                    setperiod(pre_dixtime, &dix_xpre,0 );
                    setperiod(pre_dixtime, &dix_ssppre,0);
                }

                if(idealiq_flag)
                {
                    post_dixtime = (GRAD_UPDATE_TIME);
                    pre_dixtime = (GRAD_UPDATE_TIME + idealiq_pw);

                    setperiod(post_dixtime, &dix_ssppost, 0);
                    setperiod(pre_dixtime, &dix_xpre,0 );
                    setperiod(pre_dixtime, &dix_ssppre,0);
                }

                if(medal_flag && medal_multitr_flag)
                {
                    if (echo_index == 0) {
                        post_dixtime = (GRAD_UPDATE_TIME + medal_pw - medal_shift1);
                        pre_dixtime = (GRAD_UPDATE_TIME + medal_shift1);
                    } else {
                        post_dixtime = (GRAD_UPDATE_TIME + medal_pw - medal_shift2);
                        pre_dixtime = (GRAD_UPDATE_TIME + medal_shift2);
                    }
                    setperiod(post_dixtime, &dix_ssppost, 0);

                    setperiod(pre_dixtime, &dix_xpre,0 );
                    setperiod(pre_dixtime, &dix_ssppre,0);
                }

                pass = slabindex + phaseindex*slabquant; /* 3d oblique - latha@mr */
                sp_sat_index = slabindex;

                view =  zy_export[0].view;
                slice = zy_export[0].slice;

                dabview = view + 1;
                dabslice = slice;

                dabviewbam = arcGetDabEncode(view, phPackBamFlag, arcPhaseRemapTable) + 1;
                dabslicebam = arcGetDabEncode(slice, slPackBamFlag, arcSliceRemapTable);

                if (FAILURE==ssRsp3D()) 
                {
                    return FAILURE;
                }
                setfrequency(rf1_freq[slabindex],&rf1,scanrf1_inst); /* 3doblique - latha@mr */
                set_echo1frequency(receive_freq1[slabindex], 0);
                if (opetl>=2) {
                    set_echo2frequency(receive_freq2[slabindex], 0);
                }

                setiamp(volumetab[dabslice], &gzcomb, 0);

                if (zrewind_flag) {
                    setiamp(volumetab2[dabslice], &gzp, 0);
                }

                acq_echo1 = DABOFF;
                if (opetl>=2) {
                    acq_echo2 = DABOFF;
                }

                setiamp(-viewtable[dabview], &gy1, 0);

                if (rewinder_flag) {
                    setiamp(-viewtable[dabview], &gy1r, 0);
                }

                fgre_loaddab_echo1(dabslicebam, dabecho, dabop, dabviewbam, acq_echo1);
                if (opetl>=2) {
                    fgre_loaddab_echo2(dabslicebam, (dabecho+nshots), (opetl-1), nshots, dabop, dabviewbam, acq_echo2);
                }

                load3d(&d3d, 0, DABOFF);

                /* Initialize yres_phase and slab_phase to zero */
                yres_phase = 0;
                slab_phase = 0;

                /* HK for Fiesta-C */

                /* Start Phase Cycling loop for FIESTA */
                for (pcfiesta_index = 0; pcfiesta_index < phase_cycles; pcfiesta_index++) {
                    seq_count = 1; /* VAL15 12/14/2004 YI */

                    dabecho = pcfiesta_index;

                    /* collect disdaq views */

                    if (osfp_flag)
                    {
                        if (osfpsu_flag)
                        {
                            osfp_prep(START_UP);
                        }

                        for (view = 0; view <= views_per_segment; view++) {

                            spoil();
                            startseq((SHORT)slabindex,(SHORT)MAY_PAUSE);
                            syncoff(&seqcore);
                        }

                        if (osfpsd_flag)
                        {
                            osfp_prep(SLOW_DOWN);
                        }

                        if ((end_segment_delay>0))
                        {
                            delay_end_segment();
                        }
                    }
                    else
                    /* standard disdaq*/
                    {
                        /* SVBranch, Smart Burst Mode */
                        /* SBM: set waiting sequence for discard */
                        if(sbm_flag)
                        {
                            setiamp(0, &gx1, 0);
                            setiampt(0, &gxw, 0);
                            setiampt(0, &gxwex, 0);

                            setiamp(volumetab[equant/2], &gzcomb, 0);

                            if(zrewind_flag)
                            {
                                setiamp(volumetab2[equant/2], &gzp, 0);
                            }
                            setiamp(0, &gy1, 0);

                            if(rewinder_flag)
                            {
                                setiamp(0, &gy1r, 0);
                            }
                        }

                        for (view = disdaqs; view <= -1; view++) {

                            if ((PSD_ON == navgate_flag) && (PSD_ON == specir_flag) && (PSD_ON == nav_chemdda)) {
                               if (view % chemfreq == 0) {
                                    ChemPrep();
                                }
                            }

                            /* VAL15 12/14/2004 YI */
                            if(pc_mode < PC_BASIC)
                                multiphase();
                            else
                                spoil();

                            printdbg("  Before disdaq", debugstate);
                            startseq((SHORT)slabindex,(SHORT)MAY_PAUSE);

                            /* Chopper logic */
                            /* HK for Fiesta-C */
                            if (pcfiesta_flag == PSD_OFF) {
                                chop_phase = -chop_phase;
                            }
                            printdbg("  After disdaq", debugstate);

                            syncoff(&seqcore);

                            if ((sp_sat == 1) && (view == -4)) {
                                SatPrep();
                            }

                        }  /* End disdaqs */

                        for (view = -slice_dda; view <= -1; view++) {
                            /* BBA - improved SPECIAL */
                            /* MRIge91682 */
                            int no_slice_encs;

                            if (pfkr_yz_flag)
                            {
                                no_slice_encs = views_per_segment;
                            }
                            else if (pfkz_flag)
                            {
                                no_slice_encs = pfkz_total;
                            }
                            else
                            {
                                no_slice_encs = rspslq+linestodiscard;
                            }

                            for (slice = 0; slice < no_slice_encs; slice++) {

                                if (( slice < lowercutoff ) || (slice >= uppercutoff)) {
                                    dabslice = 0;
                                    dabslicebam = 0;
                                } else {
                                    dabslice = slice - lowercutoff;
                                    dabslicebam = arcGetDabEncode(dabslice, slPackBamFlag, arcSliceRemapTable);
                                }

                                /* set amp of gzcomb and gzp for dummy rf */
                                setiamp(volumetab[dabslice], &gzcomb, 0);
                                if ( zrewind_flag ) { 
                                    setiamp(volumetab2[dabslice], &gzp, 0);
                                }

                                /* IR PREP (pjg) */
                                /* MRIge91682 */
                                if (pfkz_flag == PSD_OFF)
                                { 
                                    if ((rspir != 0) && ((slice % rspir) == 0)) {
                                        IRPrep();
                                    }

                                    if ((sl_per_chem != 0) && ((slice % sl_per_chem) == 0)) {
                                        ChemPrep();
                                    }

                                    if (msde_flag &&
                                        (((rspir != 0) && ((slice % rspir) == 0)) ||
                                         ((sl_per_chem != 0) && ((slice % sl_per_chem) == 0))))
                                    {
                                        MSDE_Prep_Seq(); /* Spec IR cases */
                                        settrigger((SHORT)TRIG_INTERN, (SHORT)slabindex);
                                    }

                                    if ((rspir != 0) && ((slice % rspir) == 0)) {
                                        PlayDisdaq(irdisdacqs);
                                    }

                                    if ((sl_per_chem != 0) && 
                                        ((slice % sl_per_chem) == 0) && 
                                        (chemsat_dda != 0)) {
                                        PlayDisdaq(chemsat_dda);
                                    }
                                }

                                /* VAL15 12/14/2004 YI */
                                if(pc_mode < PC_BASIC)
                                    multiphase();
                                else
                                    spoil();

                                fgre_loaddab_echo1(dabslicebam, dabecho, dabop, dabviewbam, acq_echo1);
                                if (opetl>=2) {
                                    fgre_loaddab_echo2(dabslicebam, (dabecho+nshots), (opetl-1), nshots, dabop, dabviewbam, acq_echo2);
                                }

                                printdbg("      Before startseq", debugstate);
                                startseq((SHORT)slabindex,(SHORT)MAY_PAUSE);
                                printdbg("      After startseq", debugstate);
                                /* Chopper logic */
                                /* HK for Fiesta-C */
                                if (pcfiesta_flag == PSD_OFF) {
                                    chop_phase = -chop_phase;
                                }

                            } /* slice */
                        } /* view */

                    }

                    /* SVBranch, Smart Burst Mode */
                    /* SBM: recover gradient amplitude for X axis */
                    if(sbm_flag)
                    {
                        setiamp(ia_gx1, &gx1, 0);
                        setiampt(ia_gxw, &gxw, 0);
                        setiampt(ia_gxwex, &gxwex, 0);
                    }

                    /* no baselines are collected in fgre3D */

                    /* replace view and slice loop with single "superindex" loop.  This
                       enables the elliptical centric case, but is used for standard looping also
                       to avoid "if" statements. zy_export is loaded in predownload. */

                    /* MRIge91682 */
                    if (!ellipt_flag && !reverse_ellipt_flag && !radfb_flag && !pfkr_flag && 
                        !(ENCODE_GROUP_NONE != encode_group) && !segmented_flag &&
                        !(arc_flag && ((ELLIPTICAL_CAL == cal_shape) || (BOX_CAL == cal_shape))))
                    {
                        if (pfkz_flag)
                        {
                            si_inc = pfkz_total;
                        }
                        else 
                        {
                            si_inc = rspslq; /* DCZ: MRIge60917 fix begins */
                        }
                    }
                    else
                    {
                        si_inc = 1;       /* DCZ */
                    }

                    /* add dummy slices */
                    if ((PSD_ON == navgate_flag) && (PSD_ON == pfkz_flag) &&
                        (navky_views_per_segment == 0) && (si_inc%navkz_views_per_segment != 0) && (si_inc > 1)) {
                        nav_dummylines = navkz_views_per_segment - si_inc%navkz_views_per_segment - linestodiscard;                   
                    } else {
                        nav_dummylines = 0;
                    }

                    segment_cnt = 0;
                    seg_cnt_nav = 0;
                    nex_count = 1;
                    dummy_count = 0;

                    {
                        short ia_gykcs_temp, ia_gykcs_new, gykcs_sign=1;
                        float viewscale; /* AC */

                        if ((1 == lava_ave_mode) && (PSD_ON == oplava))
                        {
                            dabop = DABSTORE;
                        }

                        for (excitation_seq = 1; excitation_seq<=((1==lava_ave_mode)?rspnex:1); excitation_seq++) {

                            for (si = 0; si < sampledPoints; si= si + si_inc) {  /* DCZ */
                                view =  zy_export[si].view;

                                /* viewcount and slicecount are used to mimic the old view-slice loop
                                   order. They are used to determine when the sat pulses are played
                                   out. */

                                /* MRIge91682 */
                                if (pfkz_flag) {
                                    slicecount = si % pfkz_total;
                                    viewcount = si / pfkz_total;
                                }
                                else {
                                    slicecount = si % rspslq;
                                    viewcount = si / rspslq;
                                }

                                if (debugstate==1) {
                                    sprintf(psddbgstr, "  View=%6d", view);
                                }
                                printdbg(psddbgstr, debugstate);

                                dabview = view + 1;
                                if (1 != lava_ave_mode)
                                {
                                    if (PSD_OFF != pfkr_yz_flag)
                                    {
                                        if (nex_count == 1)
                                        {
                                            dabop = DABSTORE; /* store xcvr data */
                                        }
                                        else
                                        {
                                            dabop = DABADD;   /* add xcvr data */
                                        }
                                    }
                                    else
                                    {
                                        dabop = DABSTORE; /* store xcvr data */
                                    }
                                }

                                dabviewbam = arcGetDabEncode(view, phPackBamFlag, arcPhaseRemapTable) + 1;

                                setiamp(-viewtable[dabview], &gy1, 0);

                                /* Manipulate gykcs (fatsat killer) if the condition is satisfied AC MRIge83260 */
                                if(fatkiller_flag == 1) {

                                    viewscale = (float)(viewtable[dabview]/((float)viewtable[1]));

                                    area_gy1table = fabs((((a_gy1a + a_gy1b) * pw_gy1a/2.0) 
                                                          + ((a_gy1a + a_gy1b) * pw_gy1/2.0)) * fabs(viewscale));

                                    getiamp(&ia_gykcs_temp, &gykcs,0);

                                    /* Invert fatsat crusher if we are %40 outside the center of k-space */

                                    if (area_gy1table >= (area_gy1grad * 0.40)) {

                                        if ((-viewtable[dabview]) < 0) {

                                            gykcs_sign = -1;

                                        } else {

                                            gykcs_sign =  1;

                                        }

                                        ia_gykcs_temp = abs(ia_gykcs_temp)*gykcs_sign;
                                    }
                                    /* Lower the area of gykcs if area_gykcs is within %10 of gy1grad area AC */
                                    if( (area_gykcs > (0.90)*(area_gy1table)) && (area_gykcs < (1.1)*(area_gy1table)) ) {
                                        ia_gykcs_new = (short)(ia_gykcs_max * 0.80 *gykcs_sign);

                                    } else {
                                        ia_gykcs_new = (short)(ia_gykcs_max * gykcs_sign);
                                    }

                                    setiampt(ia_gykcs_new, &gykcs, 0);

                                } /* End of fatkiller_flag */

                                if (rewinder_flag) {
                                    setiamp(-viewtable[dabview], &gy1r, 0);
                                }


                                /* Set flag to determine when respiratory gating should be enabled */
                                if (slicecount == 0) {
                                    first_slice = PSD_ON;
                                } else {
                                    first_slice = PSD_OFF;
                                }


                                cntvus = 0;     /* Initialize flag for Oddnes NPW */

                                if (PSD_OFF != pfkr_yz_flag)
                                {
                                    num_exc = 1;
                                }
                                else
                                {
                                    num_exc = rspnex;
                                }

                                for (coilindex = 0; coilindex <= cal3d_interleave*((2 == cal3d_state) ? 1 : 0); coilindex++) {

                                    for (excitation = 1; (excitation<=((1 != lava_ave_mode)?num_exc:1)) && (cntvus<1); excitation++) {

                                        /* Condition to turn cntvus flag on/off *//* HCSDM00370772 */
                                        if ( (oddnex_npw == 1) && 
                                             (excitation == (rspnex - 1)) &&
                                             ((dabview <= ((arc_flag ? unaccel_rspvus : rspvus)/4)) ||
                                              (dabview > (3*(arc_flag ? unaccel_rspvus : rspvus)/4))) ) {
                                            cntvus = 1;
                                        } else {
                                            cntvus = 0;
                                        }

                                        if (debugstate==1) {
                                            sprintf(psddbgstr,"    Excitation=%6d",
                                                    excitation);
                                        }
                                        printdbg(psddbgstr, debugstate);

                                        if (slicecount == 0) {
                                            rspsat = scansat0;      /* Initialize 1st SAT buffer */
                                        }

                                        /* Respiratory gating */
                                        if ((respgate_flag) && (first_slice == PSD_ON)) {
                                            settrigger((short)TRIG_INTERN, (short)slabindex);
                                            RespGate(&resptrigger,&resp_reps);
                                            if (resptrigger == 0) {
                                                psdexit(EM_PSD_ARRYTHMIA_ABORT,0,"",
                                                        "psd scan entry point",PSD_ARG_INT,resp_reps,0);
                                            }
                                            if (resp_dda!=0) {
                                                PlayDisdaq(resp_dda);
                                            }
                                        }

                                        tmp_slindex = 0; /* track the acquired slices for extraspecial */

                                        for (slice_index = 0; slice_index < si_inc + linestodiscard + nav_dummylines; slice_index ++) {   
                                            if (extraspecial_flag)
                                            {
                                                /*retrieve the stored slice from extraspecial*/
                                                slice_num = extraspecial_slice[slice_index];
                                            }
                                            else
                                            {
                                                slice_num = slice_index;
                                            }

                                            if ((PSD_ON == navgate_flag) && (L_SCAN == rspent))
                                            {

                                                /* complete ky view fits in navTR */
                                                if (navky_views_per_segment != 0)
                                                {
                                                    int zviews_per_seg;
                                                    if (si_inc > 1)
                                                        zviews_per_seg = si_inc;
                                                    else if (pfkz_flag && (!pfkr_yz_flag))
                                                        zviews_per_seg = pfkz_total;
                                                    else 
                                                        zviews_per_seg = views_per_segment;

                                                    if (slabtracking_flag) {
                                                        if ( (slice_index == 0) && (si%(zviews_per_seg*navky_views_per_segment) == 0) ) {       
                                                            nav_gate_active = 1;
                                                            /*  printf("slice_index = %d si = %d nav_gate_active = %d\n", slice_index, si, nav_gate_active); */  
                                                        } else {
                                                            nav_gate_active = 0;
                                                        }

                                                    } else { /* not slabtracking */
                                                        if (si_inc > 1)
                                                        {
                                                            if ((si%(zviews_per_seg*navky_views_per_segment) == (zviews_per_seg*(navky_views_per_segment-1))) && (slice_index == si_inc+linestodiscard+nav_dummylines-1))
                                                                nav_gate_active = 1;
                                                            else
                                                                nav_gate_active = 0;
                                                        } else {
                                                            if (si%(zviews_per_seg*navky_views_per_segment) == zviews_per_seg*navky_views_per_segment-1)
                                                                nav_gate_active = 1;
                                                            else
                                                                nav_gate_active = 0;
                                                        }
                                                    }
                                                } else { /* navky_views_per_segment == 0 */
                                                    int slice_tmp;
                                                    if (si_inc > 1)
                                                        slice_tmp = slice_index;
                                                    else
                                                        slice_tmp = si;

                                                    if (slabtracking_flag) {
                                                        /* play nav at beginning of each navgate_tr */
                                                        if ( (slice_tmp%navkz_views_per_segment == 0) )  {
                                                            nav_gate_active = 1;
                                                            /* printf("slice_index = %d si = %d nav_gate_active = %d\n", slice_index, si, nav_gate_active); */
                                                        } else {
                                                            nav_gate_active = 0;
                                                        }
                                                    } else { /* not slabtracking */

                                                        if (slice_tmp%navkz_views_per_segment == navkz_views_per_segment-1) {
                                                            nav_gate_active = 1;
                                                        } else {
                                                            nav_gate_active = 0;
                                                        }
                                                    }
                                                }
                                            } /* end if nav */

                                            if ( (PSD_ON == navgate_flag) && (PSD_ON == slabtracking_flag) ) {

                                                if (nav_gate_active) {
                                                    result = 0;

                                                    if (navgate_iter < navgate_dda) {
                                                        nav_active = 0;
                                                    } else {
                                                        if (nav_dual_mode) {
                                                            if (nav_active==0 && in_limit) {
                                                                nav_active = 1;
                                                            } else if (nav_active==1 && in_limit==0) {
                                                                nav_active = 0;
                                                            }
                                                        } else {
                                                            nav_active = 1;
                                                        }
                                                    }

                                                    if (nav_wait_flag) {
                                                        settrigger((short)TRIG_INTERN, (short)0);
                                                        scopeoff(&seqnavend);
                                                        boffset(off_seqnavend);
#ifndef SIM
                                                        startseq((short)0, (SHORT)MAY_PAUSE); 
#endif
                                                    }

                                                    NavigatorPlayGate();
                                                    navgate_iter++;
                                                    if (navsegment_dda!=0) {
                                                        PlayDisdaq(navsegment_dda);
                                                    }
                                                }
                                            } /* end if navgate_flag */

@inline SlabTracking.e SlabTrackGetDisplacement

                                                if ((PSD_ON == navgate_flag) &&
                                                    (navky_views_per_segment == 0) && (slice_index >= si_inc)) {
                                                    navgate_dummy_slice = 1;
                                                } else {
                                                    navgate_dummy_slice = 0;
                                                }

                                            /* BBA - improved SPECIAL */
                                            if (( slice_num < lowercutoff ) || (slice_num >= uppercutoff) || (navgate_dummy_slice)) {
                                                slice = 0;
                                                dabslice = 0;
                                                dabslicebam = 0;
                                            } else {
                                                if (extraspecial_flag)
                                                {
                                                    /* acquired slice for extraspecial*/
                                                    slice = zy_export[si+tmp_slindex].slice;
                                                }
                                                else
                                                {
                                                    /* MRIge91682 */
                                                    slice = zy_export[si+slice_index-lowercutoff].slice;   /* DCZ */
                                                }
                                                tmp_slindex++;

                                                dabslice = slice;
                                                dabslicebam = arcGetDabEncode(slice, slPackBamFlag, arcSliceRemapTable);
                                            }

                                            if (debugstate==1) {
                                                sprintf(psddbgstr, "      Slice=%6d", slice);
                                            }
                                            printdbg(psddbgstr, debugstate);

                                            /* variable flip */
                                            if ((PSD_ON == navgate_flag) && (PSD_ON == pfkz_flag) &&
                                                ((navseg_weight<1.0) || (nav_linear_ramp_up>0) || (nav_linear_ramp_down>0)))
                                            {
                                                int temp_rf1_amp, cnt_ramp;
                                                float temp_rf1_float, rf1_base;
                                                temp_rf1_amp = ia_rf1;
                                                temp_rf1_float = (float)ia_rf1;

                                                if (nav_linear_ramp_up>0)
                                                {
                                                    cnt_ramp = slice_index % pfkz_views_per_segment;
                                                    if (cnt_ramp < nav_linear_ramp_up)
                                                    {
                                                        rf1_base = temp_rf1_float*nav_1st_factor;
                                                        temp_rf1_float = rf1_base + (temp_rf1_float-rf1_base)*cnt_ramp/(float)nav_linear_ramp_up;
                                                    }
                                                }

                                                if (nav_linear_ramp_down>0)
                                                {
                                                    cnt_ramp = pfkz_views_per_segment - (slice_index % pfkz_views_per_segment) - 1;
                                                    if (cnt_ramp < nav_linear_ramp_down)
                                                    {
                                                        rf1_base = temp_rf1_float*nav_last_factor;
                                                        temp_rf1_float = rf1_base + (temp_rf1_float-rf1_base)*cnt_ramp/(float)nav_linear_ramp_down;
                                                    }
                                                }

                                                if ((navseg_weight<1.0) && (slice_index%navkz_views_per_segment < pfkz_views_per_segment))
                                                {
                                                    temp_rf1_float *= navseg_weight;
                                                }

                                                temp_rf1_amp = (int)temp_rf1_float;
                                                setiamp(temp_rf1_amp, &rf1, scanrf1_inst);
                                            }

                                            /* set amp of gzcomb and gzp for dummy rf */
                                            setiamp(volumetab[dabslice], &gzcomb, 0);   /* DCZ */

                                            if (zrewind_flag) {
                                                setiamp(volumetab2[dabslice], &gzp, 0);
                                            }

                                            /* calculate the phase offset for the slice and view */
                                            yres_phase = phase_off[slabindex].ysign *
                                                (((dabview-1) * phase_off[slabindex].yoffs +
                                                  3L*FS_PI)%FS_2PI-FS_PI);

                                            /* grab the slab phase offset */
                                            slab_phase = slab_off[slabindex].zsign *
                                                ((dabslice * slab_off[slabindex].zoffs +
                                                  3L*FS_PI)%FS_2PI-FS_PI);

                                            if (slabtracking_flag)
                                            {
                                                yres_phase = yres_phase+(int)(nav_corr_phase_y*disp_y);
                                                slab_phase = slab_phase+(int)(nav_corr_phase_z*disp_z); /* disp_x is considered in spoil() */
                                            }

                                            if (!segmented_flag)
                                            {

                                                if (pfkz_flag == PSD_OFF)
                                                {
                                                    if (!ellipt_flag  && !reverse_ellipt_flag ){

                                                        if ((rspir != 0) && ((slice_index % rspir) == 0)) {
                                                            IRPrep();
                                                        }

                                                        /* Chem Prep Play this after IR Prep since TIs are shorter */
                                                        if ((sl_per_chem != 0) && ((slice_index % sl_per_chem) == 0)) {
                                                            ChemPrep();
                                                        }
                                                    }
                                                    else {
                                                        /* DCZ: IRprep or chemsat is
                                                           incompatible with
                                                           elliptical centric.
                                                           Keep it in case. */

                                                        /* IR PREP (pjg) */
                                                        /* MRIge57440 -- use slicecount for placing IR and ChemPrep pulses */
                                                        if ((rspir != 0) && ((slicecount % rspir) == 0)) {
                                                            IRPrep();
                                                        }

                                                        /* Chem Prep Play this after IR Prep since TIs are shorter */
                                                        if ((sl_per_chem != 0) && ((slicecount % sl_per_chem) == 0)) {
                                                            ChemPrep();
                                                        }
                                                    }
                                                }

                                                /* MRIge91682 */
                                                if( pfkz_flag && specir_flag ) {
                                                    if( ((si + slice_index) % pfkz_views_per_segment) == 0 ) {
                                                        ChemPrep();
                                                    }
                                                }
                                                if( (rspir != 0) && pfkz_flag ) {
                                                    if( ((si + slice_index) % pfkz_views_per_segment) == 0 ) {
                                                        IRPrep();
                                                    }
                                                }


                                                /* MRIge91682 */
                                                if (pfkz_flag == PSD_OFF) 
                                                {

                                                    if (!ellipt_flag  && !reverse_ellipt_flag ){

                                                        if ((rspir != 0) && ((slice_index % rspir) == 0)) { /* DCZ */
                                                            PlayDisdaq(irdisdacqs);
                                                        }
                                                    }

                                                    else if ((rspir != 0) && ((slicecount % rspir) == 0)) { /* DCZ */
                                                        PlayDisdaq(irdisdacqs);

                                                        /* DCZ: IRprep is
                                                           incompatible with
                                                           elliptical centric.
                                                           Keep it in case. */
                                                    }


                                                    /* chemsat_dda should be zero if irprep and specir are both on */
                                                    if (!ellipt_flag  && !reverse_ellipt_flag ){
                                                        if ((sl_per_chem != 0) && 
                                                            ((slice_index % sl_per_chem) == 0) && 
                                                            (chemsat_dda != 0)) {                /* DCZ */
                                                            PlayDisdaq(chemsat_dda);
                                                        }     
                                                    }

                                                    else if ((sl_per_chem != 0) && 
                                                             ((slicecount % sl_per_chem) == 0) && 
                                                             (chemsat_dda != 0)) {
                                                        PlayDisdaq(chemsat_dda);  
                                                        /* DCZ: Chemsat is
                                                           incompatible with
                                                           elliptical centric.
                                                           Keep it in case. */
                                                    }                    
                                                }

                                                /* MRIge91682 */
                                                if( (rspir != 0) && pfkz_flag ) {
                                                    if( ((si + slice_index) % pfkz_views_per_segment) == 0 ) {
                                                        PlayDisdaq(irdisdacqs); 
                                                    }
                                                }
                                                if( pfkz_flag && (chemsat_dda != 0) && specir_flag ) {
                                                    if( ((si + slice_index) % pfkz_views_per_segment) == 0 ) {
                                                        PlayDisdaq(chemsat_dda);
                                                    }
                                                }

                                            } 
                                            else /* !segmented */
                                            {

                                                if (zy_export[si].flags & ZY_FLAGS_SEG_START)
                                                {
                                                    segment_cnt++;
                                                    if (osfp_debug)
                                                        printf("seg %d-%d\n",segment_cnt,si);
                                                    pre_segment_flag = PSD_ON;
                                                }
                                                else
                                                {
                                                    pre_segment_flag = PSD_OFF;
                                                }

                                                /* Set post_segment_flag if next encode is the start of a segemnt.
                                                   Check for last encode separately to make sure that we don't
                                                   go beyond sampledPoints in zy_export */
                                                if ((si >= sampledPoints - 1) || (zy_export[si+1].flags & ZY_FLAGS_SEG_START))
                                                {
                                                    post_segment_flag = PSD_ON;
                                                    seg_cnt_nav++;
                                                }
                                                else
                                                {
                                                    post_segment_flag = PSD_OFF;
                                                }

                                                if (irprep_flag && pre_segment_flag)
                                                {
                                                    if (osfp_debug)
                                                        printf("IRPrep %d seg:%d v:%d s:%d\n",si,segment_cnt,dabview, dabslice);
                                                    IRPrep();
                                                    PlayDisdaq(irdisdacqs);
                                                    if (osfp_flag)
                                                        osfpsu_flag = PSD_ON;
                                                }

                                                if (specir_flag && pre_segment_flag)
                                                {
                                                    if (osfp_debug)
                                                        printf("ChemPrep %d seg:%d v:%d s:%d\n",si,segment_cnt,dabview, dabslice);
                                                    ChemPrep();
                                                    PlayDisdaq(chemsat_dda);
                                                    if (osfp_flag)
                                                        osfpsu_flag = PSD_ON;
                                                }

                                                if (msde_flag && pre_segment_flag)
                                                {
                                                    MSDE_Prep_Seq();
                                                    settrigger((SHORT)TRIG_INTERN, (SHORT)slabindex);
                                                    PlayDisdaq(msde_dda);
                                                }

                                                if (sp_sat && pre_segment_flag )
                                                {
                                                    if (osfp_debug)
                                                        printf("SatPrep %d seg:%d v:%d s:%d\n",si,segment_cnt,dabview, dabslice);
                                                    SatPrep();
                                                    if (osfp_flag)
                                                        osfpsu_flag = PSD_ON;
                                                }

                                                if (osfp_flag && osfpsu_flag)
                                                {
                                                    if (osfp_debug)
                                                        printf("U: %d seg:%d v:%d s:%d \n", si, segment_cnt, dabview, dabslice);
                                                    osfp_prep(START_UP);
                                                    osfpsu_flag = PSD_OFF;
                                                }
                                            } /*end segmented */


                                            /* MRIhc16353 - RV: IDEAL change */
                                            for (inner_echo = 0; inner_echo < inter_necho; inner_echo++) {

                                                if (ideal_echo_mode == 1) {  /* sequential -- echo in outer loop */
                                                    echo_index =  outer_echo;
                                                } else {             /* interleaved -- echo in inner loop */
                                                    echo_index =  inner_echo;
                                                }

                                                if (idealiq_flag) {
                                                    echo_index = inner_echo;
                                                }

                                                if (medal_flag && medal_multitr_flag) {
                                                    if (medal_echo_mode)
                                                        echo_index = outer_echo;
                                                    else
                                                        echo_index = inner_echo;
                                                }

                                                dabecho = (inner_echo + pcfiesta_index*inter_necho + outer_echo*phase_cycles*inter_necho)*opetl;

                                                if(PSD_ON == ideal_flag)
                                                {
                                                    if (echo_index == 0) {
                                                        post_dixtime = (GRAD_UPDATE_TIME + ideal_pw - ideal_shift1);
                                                        pre_dixtime = (GRAD_UPDATE_TIME + ideal_shift1);
                                                    } 
                                                    else {
                                                        if (echo_index == 1) {
                                                            post_dixtime = (GRAD_UPDATE_TIME + ideal_pw - ideal_shift2);
                                                            pre_dixtime = (GRAD_UPDATE_TIME + ideal_shift2);
                                                        } 
                                                        else {
                                                            post_dixtime = (GRAD_UPDATE_TIME + ideal_pw - ideal_shift3);
                                                            pre_dixtime = (GRAD_UPDATE_TIME + ideal_shift3);
                                                        }
                                                    }
                                                    setperiod(post_dixtime, &dix_ssppost, 0);
                                                    setperiod(pre_dixtime, &dix_xpre, 0);
                                                    setperiod(pre_dixtime, &dix_ssppre, 0);
                                                }

                                                if(idealiq_flag)
                                                {
                                                    post_dixtime = (GRAD_UPDATE_TIME + idealiq_pw - idealiq_esp*echo_index);
                                                    pre_dixtime = (GRAD_UPDATE_TIME + idealiq_esp*echo_index);
                                                    setperiod(post_dixtime, &dix_ssppost, 0);
                                                    setperiod(pre_dixtime, &dix_xpre, 0);
                                                    setperiod(pre_dixtime, &dix_ssppre, 0);

                                                    dabecho = echo_index;
                                                }

                                                if(medal_flag && medal_multitr_flag)
                                                {
                                                    if (echo_index == 0) {
                                                        post_dixtime = (GRAD_UPDATE_TIME + medal_pw - medal_shift1);
                                                        pre_dixtime = (GRAD_UPDATE_TIME + medal_shift1);
                                                    }
                                                    else {
                                                        post_dixtime = (GRAD_UPDATE_TIME + medal_pw - medal_shift2);
                                                        pre_dixtime = (GRAD_UPDATE_TIME + medal_shift2);
                                                    }
                                                    setperiod(post_dixtime, &dix_ssppost, 0);
                                                    setperiod(pre_dixtime, &dix_xpre, 0);
                                                    setperiod(pre_dixtime, &dix_ssppre, 0);
                                                }

                                                /* VAL15 12/14/2004 YI */
                                                if(pc_mode < PC_BASIC)
                                                    multiphase();
                                                else
                                                    spoil();

                                                /* (MRIhc07226) Slab tracking: restore yres_phase and slab_phase after spoil */
                                                if (slabtracking_flag)
                                                {              
                                                    yres_phase = yres_phase-(int)(nav_corr_phase_y*disp_y);
                                                    slab_phase = slab_phase-(int)(nav_corr_phase_z*disp_z); /* disp_x is considered in spoil() */
                                                }

                                                /* turn data acquisition on */

                                                /* BBA - improved SPECIAL */
                                                if (( slice_num < lowercutoff ) || (slice_num >= uppercutoff) || (navgate_dummy_slice)) {
                                                    acq_echo1 = DABOFF;
                                                    if (opetl>=2) {
                                                        acq_echo2 = DABOFF;
                                                    }

                                                } else {
                                                    acq_echo1 = DABON;
                                                    if (opetl>=2) {
                                                        acq_echo2 = DABON;
                                                    }
                                                }

                                                if (cal3d_flag && cal3d_interleave)
                                                {
                                                    if (0 == coilindex)
                                                    {
                                                        fgre_loaddab_echo1_rfhub(dabslicebam, dabecho, dabop, dabviewbam, acq_echo1, coilInfo_tgt[0].hubIndex, 0, PSD_LOAD_DAB_HUB);
                                                    }
                                                    else /* (1 == coilindex) */
                                                    {
                                                        fgre_loaddab_echo1_rfhub(dabslicebam, dabecho, dabop, dabviewbam, acq_echo1, volRecCoilInfo_tgt[0].hubIndex, 0, PSD_LOAD_DAB_HUB);
                                                    }
                                                }
                                                else
                                                {
                                                    fgre_loaddab_echo1(dabslicebam, dabecho, dabop, dabviewbam, acq_echo1);
                                                }
                                                if (opetl>=2) {
                                                    fgre_loaddab_echo2(dabslicebam, (dabecho+nshots), (opetl-1), nshots, dabop, dabviewbam, acq_echo2);
                                                }

                                                /* Play 3D packet as each xz-plane completes.  This mean there
                                                   will be no 3D packets for elliptical centric ordering
                                                   until the scan is about 80% done */

                                                /* 3D packet is delayed by threedpktdly TRs. This allows time for the
                                                   CERD to complete processing before xz FFT is started.*/

                                                /* HK for Fiesta-C */
                                                if( (slice_index >= lowercutoff) && (slice_index < uppercutoff) &&
                                                    (((PSD_OFF == pfkr_yz_flag) && (1 != lava_ave_mode)) ||
                                                     ((PSD_OFF != pfkr_yz_flag) && (((1 == lava_ave_mode) && (rspnex == excitation_seq)) || ((1 != lava_ave_mode) && (rspnex == nex_count))))) ) {
                                                    if ( (delay3Drecon_flag==0) &&  (si+slice_index-lowercutoff) > threedpktdly ) {
                                                        if ((zy_export[si + slice_index - lowercutoff - 1 - threedpktdly].flags & ZY_FLAGS_XZ_DONE)
                                                            && (pcfiesta_index == (phase_cycles-1)) && (excitation == 1)
                                                            && (echo_index==dixon_necho-1)) {

                                                            int view3dpkt = arcGetDabEncode(zy_export[si + slice_index - lowercutoff - 1 - threedpktdly].view, 
                                                                                            phPackBamFlag, arcPhaseRemapTable) + 1;
                                                            load3d(&d3d, view3dpkt, DABON);  /* DCZ */
                                                            if (threedpkt_debug)
                                                            {
                                                                printf("Playing 3D plane packet for view %d (si=%d)\n",
                                                                       view3dpkt, si + slice_index - lowercutoff);
                                                            }
                                                        } else {
                                                            load3d(&d3d, 0, DABOFF);
                                                        }
                                                    } /* if ((si+slice_index) > threedpktdly ) */
                                                } else {
                                                    /* No 3d plane packet for the improved SPECIAL disdaqs */
                                                    load3d(&d3d, 0, DABOFF);   
                                                }

                                                if(idealiq_flag && idealiq_pc_flag)
                                                {
                                                    if(TRUE == isReferenceLine(view, slice))
                                                    {
                                                        idealiq_pc_post_dixtime[idealiq_pc_counter] = post_dixtime;
                                                        idealiq_pc_pre_dixtime[idealiq_pc_counter] = pre_dixtime;
                                                        idealiq_pc_dabview[idealiq_pc_counter] = dabview;
                                                        idealiq_pc_dabviewbam[idealiq_pc_counter] = dabviewbam;
                                                        idealiq_pc_dabslice[idealiq_pc_counter] = dabslice;
                                                        idealiq_pc_dabslicebam[idealiq_pc_counter] = dabslicebam;
                                                        idealiq_pc_dabecho[idealiq_pc_counter] =dabecho;
                                                        idealiq_pc_dabop[idealiq_pc_counter] = dabop;
                                                        idealiq_pc_counter++;
                                                    }
                                                }

                                                printdbg("      Before startseq", debugstate);

                                                startseq((SHORT)slabindex,(SHORT)MAY_PAUSE);


                                                /* SVBranch, Smart Burst Mode */
                                                /* play waiting period based on control flag set in zy_export.flags*/
                                                if(sbm_flag)
                                                {
                                                    int sbm_enable = 0;

                                                    switch(excitation)
                                                    {   
                                                        case 1:
                                                            sbm_enable = HEAT_NEX1;
                                                            break;
                                                        case 2:
                                                            sbm_enable = HEAT_NEX2;
                                                            break;
                                                        case 3:
                                                            sbm_enable = HEAT_NEX3;
                                                            break;
                                                        case 4:
                                                            sbm_enable = HEAT_NEX4;
                                                            break;
                                                        case 5:
                                                            sbm_enable = HEAT_NEX5;
                                                            break;
                                                        case 6:
                                                            sbm_enable = HEAT_NEX6;
                                                            break;
                                                        default:
                                                            break;
                                                    }    

                                                    if(zy_export[si+slice_index].flags & sbm_enable)
                                                    {
                                                        sbm_dda = sbm_dda_max -
                                                            (int)( fabs(zy_export[si+slice_index-lowercutoff].view - phaseres/2) *
                                                                   ((float)(sbm_dda_max - sbm_dda_min) * 2.0 / phaseres) );
                                                        sbm_dummy();
                                                    }
                                                }

                                                printdbg("      After startseq", debugstate);
                                            } /* end of inner echo loop */
                                            /* Sat & ir are not compatible */
                                            if(extraspecial_flag == PSD_OFF) {
                                                if ( ((slicecount+slice_index) == rspsat) && sp_sat && !segmented_flag ) {
                                                    /* DCZ: if NOT elliptical centric,
                                                       slicecount = 0, slice_index increments.
                                                       If elliptical entric, slice_index = 0, 
                                                       and slicecount incremnts.*/
                                                    SatPrep();
                                                    rspsat += scansatint;  
                                                }
                                            }

                                            if ((PSD_ON == navgate_flag) && (L_SCAN == rspent))
                                            {
                                                if ( (PSD_ON == navgate_flag) && (PSD_OFF == slabtracking_flag) )
                                                {

                                                    if (nav_gate_active == 1) {
                                                        result = 0;
                                                        if (navgate_iter < navgate_dda) {
                                                            nav_active = 0;
                                                        } else {
                                                            if (nav_dual_mode) {
                                                                if (nav_active==0 && in_limit) {
                                                                    nav_active= 1;
                                                                } else if (nav_active==1 && in_limit==0) {
                                                                    nav_active =0;
                                                                }
                                                            } else {
                                                                nav_active= 1;
                                                            }
                                                        }

                                                        if (nav_wait_flag) {
                                                            settrigger((short)TRIG_INTERN, (short)0);
                                                            scopeoff(&seqnavend);
                                                            boffset(off_seqnavend);
#ifndef SIM                             
                                                            startseq((short)0, (SHORT)MAY_PAUSE);
#endif                            
                                                        }

                                                        NavigatorPlayGate();
                                                        navgate_iter++;
                                                        if (navsegment_dda!=0) {
                                                            PlayDisdaq(navsegment_dda);
                                                        }
                                                    }
                                                } /* end if nav */

                                                if (navky_views_per_segment == 0) {
                                                    int slice_tmp;
                                                    if (si_inc > 1)
                                                        slice_tmp = slice_index;
                                                    else
                                                        slice_tmp = si;

                                                    if (slice_tmp%navkz_views_per_segment == navkz_views_per_segment-1)
                                                        nav_lastslice = 1;
                                                    else
                                                        nav_lastslice = 0;
                                                } else {
                                                    int zviews_per_seg;
                                                    if (si_inc > 1)
                                                        zviews_per_seg = si_inc;
                                                    else if (pfkz_flag && (!pfkr_yz_flag))
                                                        zviews_per_seg = pfkz_total;
                                                    else 
                                                        zviews_per_seg = views_per_segment;

                                                    if (si_inc > 1) {
                                                        if ((si%(zviews_per_seg*navky_views_per_segment) == (zviews_per_seg*(navky_views_per_segment-1))) && (slice_index == si_inc+linestodiscard+nav_dummylines-1))
                                                            nav_lastslice = 1;
                                                        else
                                                            nav_lastslice = 0;
                                                    } else {
                                                        if (si%(zviews_per_seg*navky_views_per_segment) == zviews_per_seg*navky_views_per_segment-1)
                                                            nav_lastslice = 1;
                                                        else
                                                            nav_lastslice = 0;
                                                    }
                                                }

                                                if ( (!result) && nav_lastslice ) { /* reject */
                                                    if (debug_nav)
                                                        printf("view rejected, result = %d exc = %d\n", result, excitation);

                                                    if (pfkz_flag && (!pfkr_yz_flag)) {
                                                        if (navky_views_per_segment == 0) {
                                                            if (si_inc > 1)
                                                                slice_index -= navkz_views_per_segment;
                                                            else
                                                                si -= navkz_views_per_segment;
                                                        } else {
                                                            si -= pfkz_total*navky_views_per_segment;
                                                        }
                                                    } else { /* !pfkz_flag */
                                                        if (!segmented_flag)
                                                            si -= si_inc*navky_views_per_segment;
                                                        else
                                                            si -= (num_views_per_nav_tr);
                                                    }
                                                    if (debug_nav)
                                                        printf("si=%d view=%d slice_index=%d si_inc=%d dabop=%d acq=%d\n", si, view, slice_index, si_inc,dabop,acq_echo1);
                                                }
                                            }  /* end if nav & L_SCAN */

                                            if (PSD_OFF != pfkr_yz_flag)
                                            {
                                                /* disdaq for centric LAVA */
                                                if ((PSD_OFF == navgate_flag) && (lava_flag) && (centric_flag)
                                                    && (si != 0) && ((si+1)%views_per_segment == 0) && (dummy_count < num_dummy_segmentedTR))
                                                {
                                                    si -= views_per_segment;
                                                    dummy_count++;
                                                }
                                                else if (1 != lava_ave_mode)
                                                {
                                                    if ((si != 0) && ((si+1)%views_per_segment == 0))
                                                    {
                                                        if (nex_count < rspnex)
                                                        {
                                                            si -= views_per_segment;
                                                            nex_count++;
                                                        }
                                                        else
                                                        {
                                                            nex_count = 1;
                                                        }
                                                    }
                                                }
                                            }
                                        } /* DCZ: end of slice_index loop */

                                        if ((1 != lava_ave_mode) && (PSD_OFF == pfkr_yz_flag)){
                                            dabop = DABADD;      /* add xcvr data */
                                        }

                                        if (segmented_flag && post_segment_flag )
                                        {
                                            if (osfp_flag && osfpsd_flag)
                                            {
                                                if (osfp_debug)
                                                    printf("D: %d seg:%d v:%d s:%d \n", si, segment_cnt, dabview, dabslice);
                                                osfp_prep(SLOW_DOWN);
                                            }
                                            if ((end_segment_delay>0))
                                            {
                                                if (osfp_debug)
                                                    printf("Delay: %d seg:%d v:%d s:%d \n", si, segment_cnt, dabview, dabslice);
                                                delay_end_segment();
                                            }

                                            if (osfp_flag)
                                                osfpsu_flag = PSD_ON;

                                        } /* delay and startup for segmented osfp */

                                    } /* end excitation interleave loop */

                                } /* end coil interleave loop */

                            } /* end superindex loop*/

                            if ( 1 == lava_ave_mode )
                            {
                                dabop = DABADD;
                            }

                        } /* end of sequential excitation loop */

                    } /* end of AC scope loop  */
                
                } /* End of Phase Cycling Loop for Fiesta-C HK */
            
            } /* end of outer_echo loop */
          
            /* Send the remaining 3D packets. */
            if (threedpktdly > 0 ) {
                boffset(off_seq3d);
                if (delay3Drecon_flag || ((1 == lava_ave_mode) && (PSD_OFF == pfkr_yz_flag)))
                {
                    /* Play out 3D Plane Packet for all acquired kx-kz planes */
                    if (!arc_flag || phPackBamFlag)
                    {
                        for (view = 1; view <= rspvus; view++)
                        {
                            load3d(&d3dset, view, DABON);
                            startseq(0, MAY_PAUSE);
                            if (threedpkt_debug)
                            {
                                printf("Playing 3D plane packet for view %d (delay3Drecon, !ARC || ARC packed)\n", view);
                            }
                        }
                    }
                    else 
                    {
                        /* ARC, Full-sort NEX */
                        for (view = 1; view <= zy_views; view++)
                        {
                            if (ARC_UNUSED_ENCODE != arcGetDabEncode(view-1, 1, arcPhaseRemapTable))
                            {
                                load3d(&d3dset, view, DABON);
                                startseq(0, MAY_PAUSE);
                                if (threedpkt_debug)
                                {
                                    printf("Playing 3D plane packet for view %d (delay3Drecon, ARC !packed)\n", view);
                                }
                            }
                        }
                    }

                }
                else
                {
                    for (j = 0; j < threedpktdly; j++ ) {
                        if(zy_export[j + sampledPoints - threedpktdly - 1].flags & ZY_FLAGS_XZ_DONE) {

                            int view3dpkt = arcGetDabEncode(zy_export[j + sampledPoints - threedpktdly - 1].view,
                                                            phPackBamFlag, arcPhaseRemapTable) + 1;

                            load3d(&d3dset, view3dpkt, DABON);
                            startseq(0, MAY_PAUSE);
                            if (threedpkt_debug)
                            {
                                printf("Playing 3D plane packet for view %d (threedpktdly)\n", view3dpkt);
                            }
                        }
                    }
                }
            } /* if (threedpktdly > 0 ) */

            /* IDEAL IQ phase correction */
            if(idealiq_flag && idealiq_pc_flag)
            {
                boffset(off_seqcore);

                /* invert x gradient */
                setiamp(-amp_gx1, &gx1, 0);
                setiampt(-amp_gxw, &gxw, 0);
                if (uniPolar_flag == PSD_ON)
                {
                    setiampt(-amp_gx2, &gx2, INSTRALL);
                    setiampt(-amp_gxw2, &gxw2, INSTRALL);
                }
                else
                {
                    int echoindex;
                    for(echoindex=0; echoindex < (opetl-1); echoindex++)
                    {   /* HCSDM00274558 */
                        setiampt((echoindex%2)?amp_gxw2:-amp_gxw2, &gxw2, echoindex);
                    }
                }
                setiampt(-amp_gxwex, &gxwex, 0);

                /* invert receiver frequency */
                set_echo1frequency(receive_freq1_rev[slabindex],0);
                set_echo2frequency(receive_freq2_rev[slabindex],0);

                /* reference line acquisition */
                for (j = -idealiq_pc_dda*idealiq_nshots; j < idealiq_pc_num_ref_acq ; j++ )
                {
                    int index;

                    if(j < 0)
                    {
                        index = (j + idealiq_pc_dda*idealiq_nshots) % idealiq_nshots; /* disdacq */
                    }
                    else
                    {
                        index = j;
                    }

                    /* set y/z encoding */
                    post_dixtime = idealiq_pc_post_dixtime[index];
                    pre_dixtime  = idealiq_pc_pre_dixtime[index];
                    dabview      = idealiq_pc_dabview[index];
                    dabviewbam   = rhdayres - idealiq_pc_ylines + idealiq_pc_dabviewbam[index]-idealiq_pc_ylower-1;
                    dabslice     = idealiq_pc_dabslice[index];
                    dabslicebam  = idealiq_pc_dabslicebam[index];
                    dabecho      = idealiq_pc_dabecho[index];
                    dabop        = idealiq_pc_dabop[index];
                    if(j < 0)
                    {
                        acq_echo1 = DABOFF;
                        acq_echo2 = DABOFF;
                    }
                    else
                    {
                        acq_echo1 = DABON;
                        acq_echo2 = DABON;
                    }

                    setperiod(post_dixtime, &dix_ssppost, 0);
                    setperiod(pre_dixtime, &dix_xpre,0 );
                    setperiod(pre_dixtime, &dix_ssppre,0);
                    setiamp(-viewtable[dabview], &gy1, 0);
                    setiamp(-viewtable[dabview], &gy1r, 0);
                    setiamp(volumetab[dabslice], &gzcomb, 0);
                    setiamp(volumetab2[dabslice], &gzp, 0);

                    yres_phase = phase_off[slabindex].ysign * 
                                 (((dabview-1) * phase_off[slabindex].yoffs + 3L*FS_PI)%FS_2PI-FS_PI);
                    slab_phase = slab_off[slabindex].zsign *
                                 ((dabslice * slab_off[slabindex].zoffs + 3L*FS_PI)%FS_2PI-FS_PI);

                    fgre_loaddab_echo1(dabslicebam, dabecho, dabop, dabviewbam, acq_echo1);
                    fgre_loaddab_echo2(dabslicebam, (dabecho+nshots), (opetl-1), nshots, dabop, dabviewbam, acq_echo2);

                    load3d(&d3d, 0, DABOFF);   
                    spoil();
                    startseq((SHORT)slabindex,(SHORT)MAY_PAUSE);
                }

                /* Revert x gradient */
                setiamp(amp_gx1, &gx1, 0);
                setiampt(amp_gxw, &gxw, 0);
                if (uniPolar_flag == PSD_ON)
                {
                    setiampt(amp_gx2, &gx2, INSTRALL);
                    setiampt(amp_gxw2, &gxw2, INSTRALL);
                }
                else
                {
                    int echoindex;
                    for(echoindex=0; echoindex < (opetl-1); echoindex++)
                    {   /* HCSDM00274558 */
                        setiampt((echoindex%2)?-amp_gxw2:amp_gxw2, &gxw2, echoindex);
                    }
                }
                setiampt(amp_gxwex, &gxwex, 0);

                /* Revert receiver frequency */
                set_echo1frequency(receive_freq1[slabindex],0);
                set_echo2frequency(receive_freq2[slabindex],0);

                /* send 3D packet if ARC is turned off. If ARC is on, Recon controls when to apply Z FFT. */
                if(!arc_flag)
                {
                    for (j = 0; j < idealiq_pc_ylines ; j++ )
                    {
                        boffset(off_seq3d);
                        load3d(&d3dset, rhdayres-idealiq_pc_ylines+j, DABON);
                        startseq(0, MAY_PAUSE);
                    }
                }

                idealiq_pc_counter = 0;
            }

            /* pass packet logic */
            boffset(off_seqpass);

            if(pass == (acqs-1)) {
                /* Set DAB pass packet to end of scan */
                setwamp(SSPD + DABPASS + DABSCAN, &pass_pulse, 2);
                printdbg("  End of Scan and Pass", debugstate);
              
                pause = MAY_PAUSE;
                /* If last pass, subtract sldetime part included in passtime
                   MRIge57698 ....no sldelay for last acq  -agilandk@mr*/
                if  (mph_flag == PSD_ON ) {
                    /* Auto Voice  04/18/2005 YI */
                    setperiod ( (long)pass_seqtime_def, &seqpass, 0 ) ;
                }
            } else {
                /* Set DAB pass packet to end of pass */
                setwamp(SSPD + DABPASS, &pass_pulse, 2);
                printdbg("  End of Pass", debugstate);
                
                if (((pass+1) % slicecnt)==0) {
                    pause = MUST_PAUSE;     /* pause if desired */
                    setperiod ( (long)pass_seqtime_def, &seqpass, 0 ) ; /* Auto Voice  04/18/2005 YI */
                } else {
                    pause = AUTO_PAUSE;     /* or if required */
                    /* Auto Voice  04/18/2005 YI */
                    if (mph_flag == PSD_ON ) {
                        if(slicecnt == acqs) { /* MRIhc08979  08/05/2005 YI */
                            setperiod ( (long)pass_seqtime_mph, &seqpass, 0 ) ;
                        } else {
                            setperiod ( (long)pass_seqtime_def, &seqpass, 0 ) ;
                        }
                    }
                }
            }

@inline cal3d.e cal3d_scancore_pause

            /* load last 3d packet */
            if (delay3Drecon_flag)
            {
                load3d(&d3dpass,0,DABOFF);
            }
            else
            {
                /* The last frame is ALWAYS the last frame of a xz-plane */
                int view3dpkt = arcGetDabEncode(zy_export[sampledPoints - 1].view,
                                                phPackBamFlag, arcPhaseRemapTable) + 1;

                load3d(&d3dpass, view3dpkt, DABON);

                if (threedpkt_debug)
                {
                    printf("Playing 3D plane packet for view %d (seqpass)\n", view3dpkt);
                }
            }
          
#ifdef PSD_HW   /* Auto Voice */
            if ((mph_flag == 1) && (pass != acqs-1) && (slicecnt == acqs)) { 
                broadcast_autovoice_timing(0, sldelay/1ms, TRUE, TRUE);
            }
#endif

            startseq(0,(SHORT)pause);
            
            boffset(off_seqcore);
            
        } /* 3d oblique - end slab loop - latha@mr */
        
        /* MRIhc08979  08/05/2005 YI */
        if (( sldeltime > 10s) && (pass != acqs -1) && (slicecnt == acqs) ) {
            /* sldeltime> 10 only if mph_flag = 1, hence implied*/
            /* no scandelay1 for the last acq. MRIge57698 */
            scandelay1();
        }
        
    } /* pass (opfphases) loop */
    
    printdbg("Returning from scancore", debugstate);
    return SUCCESS;
} /* End scancore */

/* ungated FatSat FIESTA */
STATUS scancore_ZY(void)
{
    int shot;
    int i;
    int totview_div_4;
    int do_dda;

    totview_div_4 = (int)(opyres*nop/4);
    exphase = 0;

    printdbg("Starting scancore_ZY", debugstate);

    for (phaseindex = 0;phaseindex <opfphases ;phaseindex++) {

        for (slabindex = 0; slabindex < slabquant; slabindex++) {

            pass = slabindex + phaseindex*slabquant;

            if (FAILURE==ssRsp3D()) 
            {
                return FAILURE;
            }
            setfrequency(rf1_freq[slabindex],&rf1,scanrf1_inst);
            setfrequency(receive_freq1[slabindex],&echo1,0);

            set_zero_encode();


            dabslice = 0;
            dabecho = 0;
            dabop = 0;
            dabview = 0;
            acq_echo1 = DABOFF;
            fgre_loaddab_echo1(dabslice, dabecho, dabop, dabview, acq_echo1);
            fgre_loaddab_3d(0, DABOFF);
            yres_phase = 0;
            slab_phase = 0;

            for (pcfiesta_index = 0; pcfiesta_index < phase_cycles; pcfiesta_index++) {
                seq_count = 1;
                dabecho = pcfiesta_index;
                dabop = DABSTORE;

                for (excitation = 1; excitation<=rspnex; excitation++) {
                    if( ( excitation == 1) && (pcfiesta_index == 0) ) /* HDsv 03/16/2009 YI */
                        do_dda = ugfsf_slice_dda;
                    else
                        do_dda = 0;

                    for (slice = 0; slice < rspslq; slice++) {

                        if( do_dda > 0 ){
                            dabslice = 0;
                        }
                        else{
                            if(ugfsf_slice_order_flag == 0)
                                dabslice = slice;
                            else
                                dabslice = ((int)(rspslq/2) - (int)(opslicecnt/2) + slice + rspslq) % rspslq;
                        }
                        slab_phase = slab_off[slabindex].zsign * ((dabslice * slab_off[slabindex].zoffs +
                                         3L*FS_PI)%FS_2PI-FS_PI);

                        for (shot = 1; shot <= num_shot; shot++) {
                            if(oprtcgate){
                                if(resp_gate_trig_sw==0){
                                    settrigger((short)TRIG_RESP, (short)slabindex);
                                }
                                else{
                                    settrigger((short)TRIG_INTERN, (short)slabindex);
                                    set_zero_encode();
                                    RespGate(&resptrigger,&resp_reps);
                                    if (resptrigger == 0) {
                                        psdexit(EM_PSD_ARRYTHMIA_ABORT,0,"",
                                                "psd scan entry point",PSD_ARG_INT,resp_reps,0);
                                    }
                                    if(ugfsf_linear_ramp_down>0){
                                        set_zero_encode();
                                        acq_echo1 = DABOFF;
                                        fgre_loaddab_echo1(dabslice, dabecho, dabop, dabview, acq_echo1);

                                        for (i=0;i<ugfsf_linear_ramp_down;i++) {
                                            int temp_rf1_amp, rf1_amp_scale;

                                            rf1_amp_scale = (int)(ia_rf1/ugfsf_linear_ramp_down);
                                            temp_rf1_amp = ia_rf1 - rf1_amp_scale * i;
                                            setiamp(temp_rf1_amp, &rf1, scanrf1_inst);

                                            if(pc_mode < PC_BASIC)
                                                multiphase();
                                            else
                                                spoil();

                                            startseq((SHORT)0, (SHORT)MAY_PAUSE);
                                        }
                                        setiamp(ia_rf1, &rf1, scanrf1_inst); /* restore rf1 amp */
                                    }
                                }
                            }
                            else{
                                settrigger((short)TRIG_INTERN, (short)slabindex);
                            }

                            if (specir_flag) {
                                SpecIRChemPrep();
                                settrigger((short)TRIG_INTERN, (short)slabindex);
                                scopeoff(&seqcore);

                                set_zero_encode();
                                acq_echo1 = DABOFF;
                                fgre_loaddab_echo1(dabslice, dabecho, dabop, dabview, acq_echo1);

                                for (i=1;i<=ugfsf_ramp_dda;i++) {
                                    if (fiesta_rampup_type>0) {
                                        if(1==fiesta_rampup_type){
                                            int temp_rf1_amp, rf1_amp_scale;
                                            rf1_amp_scale = (int)(ia_rf1/ugfsf_ramp_dda);
                                            temp_rf1_amp = rf1_amp_scale * i;
                                            setiamp(temp_rf1_amp, &rf1, scanrf1_inst);
                                        }
                                        else if(2==fiesta_rampup_type){
                                            float rf1_amp_scale;
                                            int temp_rf1_amp;
                                            if(ugfsf_ramp_dda>1)
                                                rf1_amp_scale = (float)(ia_rf1)/(ugfsf_ramp_dda-1);
                                            else
                                                rf1_amp_scale = (float)(ia_rf1);
                                            temp_rf1_amp = (int)(rf1_amp_scale * ((float)i-0.5));
                                            if(temp_rf1_amp>ia_rf1) temp_rf1_amp=ia_rf1;
                                            setiamp(temp_rf1_amp, &rf1, scanrf1_inst);
                                        }
                                        else{
                                            int temp_rf1_amp;
                                            temp_rf1_amp = (int)(0.5 * (float)(ia_rf1) * (1-cos(M_PI*i/ugfsf_ramp_dda)));
                                            setiamp(temp_rf1_amp, &rf1, scanrf1_inst);
                                        }
                                    }
                                    if(pc_mode < PC_BASIC)
                                        multiphase();
                                    else
                                        spoil();

                                    startseq((SHORT)0, (SHORT)MAY_PAUSE);
                                    syncoff(&seqcore);
                                }
                                if(ugfsf_flat_dda>0){
                                    PlayDisdaq(ugfsf_flat_dda);
                                }
                            }
                            if( do_dda > 0 ){
                                temp_short = max_pg_iamp*(-a_base/loggrd.tz); /* set up zero slice encode */
                                setiamp(temp_short,&gzcomb,0);                /* (just refocus) */
                                if (zrewind_flag) 
                                {
                                    temp_short = max_pg_iamp*(a_base2/loggrd.tz); /* set up zero slice rewinder */
                                    setiamp(temp_short,&gzp,0);                   /* (just killer) */
                                }
                            }
                            else{
                                setiamp(volumetab[dabslice], &gzcomb, 0);
                                if (zrewind_flag) 
                                {
                                    setiamp(volumetab2[dabslice], &gzp, 0);
                                }
                            }

                            for (view = 1; view <= view_per_shot; view++) {
                                ugfsf_view_order( &dabview, shot, num_shot, view, rhnframes+rhhnover,
                                                     opyres*nop, view_to_center, ugfsf_view_order_flag);

                                if ( (dabview >0) && (do_dda <= 0) ) {
                                    acq_echo1 = DABON;
                                    setiamp(-viewtable[dabview], &gy1, 0);
                                    if (rewinder_flag) 
                                    {
                                        setiamp(-viewtable[dabview], &gy1r, 0);
                                    }

                                    if( ( (rhnframes+rhhnover)%num_shot ) &&
                                          ( shot > (rhnframes+rhhnover)%num_shot ) &&
                                          ( view == rspvus ) ) /* dummy view */
                                        acq_echo1 = DABOFF;
                                } else {
                                    /* if view is dummy, turn acq off and phase encodes is zero */
                                    acq_echo1 = DABOFF;
                                    setiamp(0, &gy1, 0);
                                    if (rewinder_flag) 
                                    {
                                        setiamp(0, &gy1r, 0);
                                    }
                                }
                                fgre_loaddab_echo1(dabslice, dabecho, dabop, dabview, acq_echo1);
                                yres_phase = phase_off[slabindex].ysign *
                                       (((dabview-1) * phase_off[slabindex].yoffs + 3L*FS_PI)%FS_2PI-FS_PI);

                                if(pc_mode < PC_BASIC)
                                    multiphase();
                                else
                                    spoil();

                                printdbg("      Before startseq", debugstate);
                                startseq((SHORT)slabindex,(SHORT)MAY_PAUSE);
                                settrigger((short)TRIG_INTERN, (short)slabindex);
                                printdbg("      After startseq", debugstate);

                            } /* view loop */

                            if( !(oprtcgate&&(resp_gate_trig_sw==1)) && (ugfsf_linear_ramp_down>0) ){
                                set_zero_encode();
                                acq_echo1 = DABOFF;
                                fgre_loaddab_echo1(dabslice, dabecho, dabop, dabview, acq_echo1);

                                for (i=0;i<ugfsf_linear_ramp_down;i++) {
                                    int temp_rf1_amp, rf1_amp_scale;

                                    rf1_amp_scale = (int)(ia_rf1/ugfsf_linear_ramp_down);
                                    temp_rf1_amp = ia_rf1 - rf1_amp_scale * i;
                                    setiamp(temp_rf1_amp, &rf1, scanrf1_inst);

                                    if(pc_mode < PC_BASIC)
                                        multiphase();
                                    else
                                        spoil();

                                    startseq((SHORT)0, (SHORT)MAY_PAUSE);
                                }
                                setiamp(ia_rf1, &rf1, scanrf1_inst); /* restore rf1 amp */
                            }

                            /* shot delay sequence */
                            if(ugfsf_shot_delay>0){
                                boffset(off_seqdelay);
                                startseq((SHORT)0, (SHORT)MAY_PAUSE);
                                boffset(off_seqcore);
                            }

                        } /* shot loop */

                        if(do_dda > 0){
                          --slice;
                          --do_dda;
                        }

                    } /* slice encode loop */

                    dabop = DABADD;

                } /* NEX loop */

            } /* phase cycle loop */

            /* 3d packets must be played out at the end */
            /* initiate the 3D packets */
            boffset(off_seq3d);
            for (view=1;view<=rspvus; view++) {
                load3d(&d3dset,view,(TYPDAB_PACKETS)DABON);
                startseq(0,(SHORT)MAY_PAUSE);
            }

            /* pass packet logic */
            boffset(off_seqpass);

            if(pass == (acqs-1)) {
                /* Set DAB pass packet to end of scan */
                setwamp(SSPD + DABPASS + DABSCAN, &pass_pulse, 2);
                printdbg("  End of Scan and Pass", debugstate);
            } else {
                /* Set DAB pass packet to end of pass */
                setwamp(SSPD + DABPASS, &pass_pulse, 2);
                printdbg("  End of Pass", debugstate);
            }

            if (pass == (acqs-1)) {
                pause = MAY_PAUSE;
            } else {                    /* if not last pass */
                if (((pass+1) % slicecnt)==0) {
                    pause = MUST_PAUSE; /* pause if desired */
                } else {
                    pause = AUTO_PAUSE; /* or if required */
                }
            }

            /* don't load last 3d packet */
            load3d(&d3dpass,0,DABOFF);
            startseq((SHORT)slabindex,(SHORT)pause);

            boffset(off_seqcore);

        } /* slabindex loop */

    } /* phaseindex loop */

    printdbg("Returning from vast_fiesta_scancore", debugstate);
    return SUCCESS;
} /* end scancore_ZY */




@inline Tricks.e TricksCore
@inline Disco.e DiscoCore



/* MRIge66079 - ATV: RTIA3D/ftMRA */

/*************** scancoreRTIA_3D ***********************/

STATUS scancoreRTIA_3D (void)
{
    char psddbgstr[256] = "";
    int cntvus;     /* Flag for collecting central views in Oddnes NPW case */
    int rspsat;   /* Counter for deciding after which slices SAT plays    */
    int si;  /* Superindex for elliptical-centric*/
    int dabviewbam, dabslicebam;
    /* MRIge91682 */
    int j;
    int si_inc;  /* DCZ: Superindex increment step size */
    int slice_index; /* DCZ */
    int pre_dixtime, post_dixtime;
    int dixon_necho;
    int phPackBamFlag = arc_flag && (arc_pack_bam & BAM_PACK_Y);
    int slPackBamFlag = arc_flag && (arc_pack_bam & BAM_PACK_Z);

    int nav_gate_active = 0;
    int navgate_dummy_slice = 0;
    int nav_dummylines = 0;
    int navgate_iter = 0;
    int nav_lastslice = 0;
    int disabler = 1;

    printdbg("Starting scancore", debugstate);

    pass = slabindex + phaseindex*slabquant;

    if (pass == 0) { 
#ifdef PSD_HW   /* Auto Voice */
        broadcast_autovoice_timing(0, trigger_delay_silent_countdown/1ms, FALSE, TRUE);
#endif
        scandelay0();
    }

    if ( ( (slicecnt == acqs) && (0 == pass)) || 
         ( (slicecnt != acqs) && ((pass % slicecnt) == 0) )  )
    {
        reset_clock();
    }

    if (ideal_flag) {
       dixon_necho = ideal_necho;
    } else if (idealiq_flag) {
       dixon_necho = idealiq_nshots;
    } else if (medal_flag && medal_multitr_flag) {
       dixon_necho = medal_necho;
    } else {
       dixon_necho = 1;
    }

    /* MRIhc16353 - RV: IDEAL change */
    for (outer_echo = 0; outer_echo < seq_necho; outer_echo++)  {
      if (ideal_echo_mode == 1) {  /* sequential -- echo in outer loop */
         echo_index =  outer_echo;
      } else {             /* interleaved -- set echo in inner loop */
         echo_index = 0;
      }

      if (idealiq_flag) {
          echo_index = 0; /* IDEQL IQ supports interleaved only */
      }

      if (medal_flag && medal_multitr_flag) {
         if (medal_echo_mode)
            echo_index =  outer_echo;
         else
            echo_index = 0;
      }

      dabecho=echo_index;
      if(PSD_ON == ideal_flag)
      {
         if (echo_index == 0) {
            post_dixtime = (GRAD_UPDATE_TIME + ideal_pw - ideal_shift1);
            pre_dixtime = (GRAD_UPDATE_TIME + ideal_shift1);
         } else {
            if (echo_index == 1) {
               post_dixtime = (GRAD_UPDATE_TIME + ideal_pw - ideal_shift2);
               pre_dixtime = (GRAD_UPDATE_TIME + ideal_shift2);
            } else {
               post_dixtime = (GRAD_UPDATE_TIME + ideal_pw - ideal_shift3);
               pre_dixtime = (GRAD_UPDATE_TIME + ideal_shift3);
            }
         }
         setperiod(post_dixtime, &dix_ssppost, 0);

         setperiod(pre_dixtime, &dix_xpre,0 );
         setperiod(pre_dixtime, &dix_ssppre,0);
      }

      if(idealiq_flag)
      {
          post_dixtime = (GRAD_UPDATE_TIME);
          pre_dixtime = (GRAD_UPDATE_TIME + idealiq_pw);

          setperiod(post_dixtime, &dix_ssppost, 0);
          setperiod(pre_dixtime, &dix_xpre,0 );
          setperiod(pre_dixtime, &dix_ssppre,0);
      }

      if(medal_flag && medal_multitr_flag)
      {
        if (echo_index == 0) {
           post_dixtime = (GRAD_UPDATE_TIME + medal_pw - medal_shift1);
           pre_dixtime = (GRAD_UPDATE_TIME + medal_shift1);
        } else {
           post_dixtime = (GRAD_UPDATE_TIME + medal_pw - medal_shift2);
           pre_dixtime = (GRAD_UPDATE_TIME + medal_shift2);
        }
        setperiod(post_dixtime, &dix_ssppost, 0);

        setperiod(pre_dixtime, &dix_xpre,0 );
        setperiod(pre_dixtime, &dix_ssppre,0);
      }

    sp_sat_index = slabindex;

    view =  zy_export[0].view;
    slice = zy_export[0].slice;

    dabview = view + 1;
    dabslice = slice;

    dabviewbam = arcGetDabEncode(view, phPackBamFlag, arcPhaseRemapTable) + 1;
    dabslicebam = arcGetDabEncode(slice, slPackBamFlag, arcSliceRemapTable);

    if (FAILURE==ssRsp3D()) 
    {
        return FAILURE;
    }
    setfrequency(rf1_freq[slabindex],&rf1,scanrf1_inst); /* 3doblique - latha@mr */
    set_echo1frequency(receive_freq1[slabindex],0);
    if (opetl>=2) {
       set_echo2frequency(receive_freq2[slabindex],0);
    }

    setiamp(volumetab[dabslice], &gzcomb, 0);

    if (zrewind_flag) {
        setiamp(volumetab2[dabslice], &gzp, 0);
    }

    acq_echo1 = DABOFF;
    if (opetl>=2) {
       acq_echo2 = DABOFF;
    }

    setiamp(-viewtable[dabview], &gy1, 0);

    if (rewinder_flag) {
        setiamp(-viewtable[dabview], &gy1r, 0);
    }

    fgre_loaddab_echo1(dabslicebam, dabecho, dabop, dabviewbam, acq_echo1);
    if (opetl>=2) {
        fgre_loaddab_echo2(dabslicebam, (dabecho+1), (opetl-1), nshots, dabop, dabviewbam, acq_echo2);
    }

    load3d(&d3d, 0, DABOFF);

    /* Initialize yres_phase and slab_phase to zero */
    yres_phase = 0;
    slab_phase = 0;

    /* collect disdaq views */
    for (view = disdaqs; view <= -1; view++) {
        if ((PSD_ON == navgate_flag) && (PSD_ON == specir_flag) && (PSD_ON == nav_chemdda)) {
            if (view % chemfreq == 0) {
                ChemPrep();
            }
        }

        spoil();

        printdbg("  Before disdaq", debugstate);
        startseq((SHORT)slabindex,(SHORT)MAY_PAUSE);
        printdbg("  After disdaq", debugstate);

        /* Chopper logic */
        chop_phase = -chop_phase;
        printdbg("  After disdaq", debugstate);

        syncoff(&seqcore);

    }  /* End disdaqs */

    for (view = -slice_dda; view <= -1; view++) {

        /* MRIge91682 */
        int no_slice_encs;
        if (pfkr_yz_flag)
        {
            no_slice_encs = views_per_segment;
        }
        else if (pfkz_flag)
        {
            no_slice_encs = pfkz_total;
        }
        else
        {
            no_slice_encs = rspslq;
        }

        for (slice = 0; slice < no_slice_encs; slice++) {

            dabslice = slice;
            dabslicebam = arcGetDabEncode(slice, slPackBamFlag, arcSliceRemapTable);

            /* set amp of gzcomb and gzp for dummy rf */
            setiamp(volumetab[dabslice], &gzcomb, 0);
            if ( zrewind_flag ) { 
                setiamp(volumetab2[dabslice], &gzp, 0);
            }
            /* MRIge91682 */
            if ((pfkz_flag == PSD_OFF) || (PSD_OFF != pfkr_yz_flag))
            {
                /* IR PREP (pjg) */
                if ((rspir != 0) && ((slice % rspir) == 0)) {
                    IRPrep();
                }

                if ((sl_per_chem != 0) && ((slice % sl_per_chem) == 0)) {
                    ChemPrep();
                }

                if ((rspir != 0) && ((slice % rspir) == 0)) {
                    PlayDisdaq(irdisdacqs);
                }

                if ((sl_per_chem != 0) &&
                    ((slice % sl_per_chem) == 0) &&
                    (chemsat_dda != 0)) {
                    PlayDisdaq(chemsat_dda);
                }
            }

            spoil();
            fgre_loaddab_echo1(dabslicebam, dabecho, dabop, dabviewbam, acq_echo1);
            if (opetl>=2) {
                fgre_loaddab_echo2(dabslicebam, (dabecho+1), (opetl-1), nshots, dabop, dabviewbam, acq_echo2);
            }

            printdbg("      Before startseq", debugstate);
            startseq((SHORT)slabindex,(SHORT)MAY_PAUSE);
            printdbg("      After startseq", debugstate);

            /* Chopper logic */
            chop_phase = -chop_phase;

        } /* slice */
    } /* view */

    /* no baselines are collected in fgre3D */

    /* replace view and slice loop with single "superindex" loop.  This
       enables the elliptical centric case, but is used for standard looping also
       to avoid "if" statements. zy_export is loaded in predownload. */

    /* MRIge91682 */
    if ((!ellipt_flag && !reverse_ellipt_flag && !pfkr_flag &&
        !(arc_flag && ((ELLIPTICAL_CAL == cal_shape) || (BOX_CAL == cal_shape)))) || (PSD_OFF != pfkr_yz_flag))
    {
        if (PSD_OFF != pfkr_yz_flag)
        {
            if(PSD_ON == navgate_flag)
            {
                si_inc = 1;
            }
            else
            {
                si_inc = views_per_segment;
            }
        }
        else if (pfkz_flag)
        {
            si_inc = pfkz_total;
        }
        else
        {
            si_inc = rspslq;  /* DCZ: MRIge60917 fix begins */
        }
    }
    else
    {
        si_inc = 1;       /* DCZ */
    }

    /* add dummy slices */
    if ((PSD_ON == navgate_flag) && (PSD_ON == pfkz_flag) &&
        (navky_views_per_segment == 0) && (si_inc%navkz_views_per_segment != 0) && (si_inc > 1)) {
        nav_dummylines = navkz_views_per_segment - si_inc%navkz_views_per_segment;                  
    } else {            
        nav_dummylines = 0;
    }                   

    for (si = 0; si < sampledPoints; si= si + si_inc) {  /* DCZ */
        view =  zy_export[si].view;

        /* viewcount and slicecount are used to mimic the old view-slice loop
           order. They are used to determine when the sat pulses are played
           out. */

        /* MRIge91682 */
        if (pfkz_flag) {
            slicecount = si % pfkz_total;
            viewcount = si / pfkz_total;
        }
        else {
            slicecount = si % rspslq;
            viewcount = si / rspslq;
        }

        if (debugstate==1) {
            sprintf(psddbgstr, "  View=%6d", view);
        }
        printdbg(psddbgstr, debugstate);

        dabview = view + 1;
        dabop = DABSTORE;      /* store xcvr data */
        dabviewbam = arcGetDabEncode(view, phPackBamFlag, arcPhaseRemapTable) + 1;

        setiamp(-viewtable[dabview], &gy1, 0);

        if (rewinder_flag) {
            setiamp(-viewtable[dabview], &gy1r, 0);
        }


        /* Set flag to determine when respiratory gating should be enabled */
        if (slicecount == 0) {
            first_slice = PSD_ON;
        } else {
            first_slice = PSD_OFF;
        }


        cntvus = 0;     /* Initialize flag for Oddnes NPW */


        for (excitation = 1; (excitation<=rspnex) && (cntvus<1); excitation++) {

            /* Condition to turn cntvus flag on/off */
            if ( (oddnex_npw == 1) &&
                 (excitation == (rspnex - 1)) &&
                 ((dabview <= (rspvus/4)) ||
                  (dabview > (3*rspvus/4))) ) {
                cntvus = 1;
            } else {
                cntvus = 0;
            }

            if (debugstate==1) {
                sprintf(psddbgstr,"    Excitation=%6d",
                        excitation);
            }
            printdbg(psddbgstr, debugstate);

            if (slicecount == 0) {
                rspsat = scansat0;      /* Initialize 1st SAT buffer */
            }

            /* Respiratory gating */
            if ((respgate_flag) && (first_slice == PSD_ON)) {
                settrigger((short)TRIG_INTERN, (short)slabindex);
                RespGate(&resptrigger,&resp_reps);
                if (resptrigger == 0) {
                    psdexit(EM_PSD_ARRYTHMIA_ABORT,0,"",
                            "psd scan entry point",PSD_ARG_INT,resp_reps,0);
                }
                if (resp_dda!=0) {
                    PlayDisdaq(resp_dda);
                }
            }

            for (slice_index = 0; slice_index < si_inc + nav_dummylines; slice_index ++) {
    
                if ((PSD_ON == navgate_flag) && (L_SCAN == rspent))
                {

                    /* complete ky view fits in navTR */
                    if (navky_views_per_segment != 0) {
                        int zviews_per_seg;
                        if (si_inc > 1)
                            zviews_per_seg = si_inc;
                        else if (pfkz_flag && (!pfkr_yz_flag)) 
                            zviews_per_seg = pfkz_total;
                        else
                            zviews_per_seg = views_per_segment;

                        if (slabtracking_flag) {
                            if ( (slice_index == 0) && (si%(zviews_per_seg*navky_views_per_segment) == 0) ) {
                                nav_gate_active = 1;
                                /*  printf("slice_index = %d si = %d nav_gate_active = %d\n", slice_index, si, nav_gate_active); */   
                            } else {
                                nav_gate_active = 0;
                            }
        
                        } else { /* not slabtracking */
                            if (si_inc > 1) {
                                if ((si%(zviews_per_seg*navky_views_per_segment) == (zviews_per_seg*(navky_views_per_segment-1))) && (slice_index == si_inc+linestodiscard+nav_dummylines-1))
                                    nav_gate_active = 1;
                                else
                                    nav_gate_active = 0;
                            } else {
                                if (si%(zviews_per_seg*navky_views_per_segment) == zviews_per_seg*navky_views_per_segment-1)
                                    nav_gate_active = 1;
                                else
                                    nav_gate_active = 0;
                            }
                        }
                    } else { /* navky_views_per_segment == 0 */
                        int slice_tmp;
                        if (si_inc > 1)
                            slice_tmp = slice_index;
                        else
                            slice_tmp = si;

                        if (slabtracking_flag) {
                            /* play nav at beginning of each navgate_tr */
                            if ( (slice_tmp%navkz_views_per_segment == 0) )  {
                                nav_gate_active = 1;
                                /* printf("slice_index = %d si = %d nav_gate_active = %d\n", slice_index, si, nav_gate_active); */
                            } else {
                                nav_gate_active = 0;
                            }
                        } else { /* not slabtracking */

                            if (slice_tmp%navkz_views_per_segment == navkz_views_per_segment-1) {
                                nav_gate_active = 1;
                            } else {
                                nav_gate_active = 0;
                            }
                        }
                    }
                } /* end if nav */

                if ( (PSD_ON == navgate_flag) && (PSD_ON == slabtracking_flag) ) {

                   if (nav_gate_active) {
                        result = 0;

                        if (navgate_iter < navgate_dda) {
                           nav_active = 0;
                        } else {
                           if (nav_dual_mode) {
                                if (nav_active==0 && in_limit) {
                                   nav_active = 1;
                                } else if (nav_active==1 && in_limit==0) {
                                   nav_active = 0;
                                }
                           } else {
                             nav_active = 1; 
                           }
                        }

                        if (nav_wait_flag) {
                            settrigger((short)TRIG_INTERN, (short)0);
                            scopeoff(&seqnavend);
                            boffset(off_seqnavend);
#ifndef SIM
                            startseq((short)0, (SHORT)MAY_PAUSE);
#endif
                        }

                        NavigatorPlayGate();
                        navgate_iter++;
                        if (navsegment_dda!=0) {
                            PlayDisdaq(navsegment_dda);
                        }
                   }
                } /* end if navgate_flag */

@inline SlabTracking.e SlabTrackGetDisplacement

                if ((PSD_ON == navgate_flag) && (navky_views_per_segment == 0) && (slice_index >= si_inc)) {
                    navgate_dummy_slice = 1;
                } else {
                    navgate_dummy_slice = 0;
                }

                if (navgate_dummy_slice) {
                    slice = 0;
                    dabslice = 0;
                    dabslicebam = 0;
                } else {
                    /* MRIge91682 */
                    slice = zy_export[si+slice_index].slice;   /* DCZ */
                    dabslice = slice;
                    dabslicebam = arcGetDabEncode(slice, slPackBamFlag, arcSliceRemapTable);
                    if((PSD_OFF != pfkr_yz_flag) && !navgate_flag) {
                        view =  zy_export[si+slice_index].view;
                        dabview = view + 1;
                        dabviewbam = arcGetDabEncode(view, phPackBamFlag, arcPhaseRemapTable) + 1;
                        setiamp(-viewtable[dabview], &gy1, 0);
                        if (rewinder_flag) {
                            setiamp(-viewtable[dabview], &gy1r, 0);
                        }
                     }
                }

                if (pfkz_flag == PSD_OFF)
                {
                    if (!ellipt_flag  && !reverse_ellipt_flag ){

                        if ((rspir != 0) && ((slice_index % rspir) == 0)) {
                            IRPrep();
                        }

                        /* Chem Prep Play this after IR Prep since TIs are shorter */
                        if ((sl_per_chem != 0) && ((slice_index % sl_per_chem) == 0)) {
                            ChemPrep();
                        }
                    }
                    else {
                        /* DCZ: IRprep or chemsat is
                           incompatible with
                           elliptical centric.
                           Keep it in case. */

                        /* IR PREP (pjg) */
                        /* MRIge57440 -- use slicecount for placing IR and
                           ChemPrep pulses */
                        if ((rspir != 0) && ((slicecount % rspir) == 0)) {
                            IRPrep();
                        }

                        /* Chem Prep Play this after IR Prep since TIs are shorter */
                        if ((sl_per_chem != 0) && ((slicecount % sl_per_chem) == 0)) {
                            ChemPrep();
                        }
                    }
                }

                /* MRIge91682 */ 
                if( pfkz_flag && specir_flag )
                {
                    if( pfkr_yz_flag == PSD_OFF )
                    {
                        if( ((si + slice_index) % pfkz_views_per_segment) == 0 )
                        {
                            ChemPrep();
                        }
                    }
                    else
                    {
                        if( ((si + slice_index) % views_per_segment) == 0 )
                        {
                            ChemPrep();
                        }
                    }
                }

                if( (rspir != 0) && pfkz_flag ) {
                    if( ((si + slice_index) % pfkz_views_per_segment) == 0 ) {
                        IRPrep();
                    }
                }

                if (debugstate==1) {
                    sprintf(psddbgstr, "      Slice=%6d", slice);
                }
                printdbg(psddbgstr, debugstate);

                /* variable flip */
                if ((PSD_ON == navgate_flag) && (PSD_ON == pfkz_flag) &&
                    ((navseg_weight<1.0) || (nav_linear_ramp_up>0) || (nav_linear_ramp_down>0)))
                {
                    int temp_rf1_amp, cnt_ramp;
                    float temp_rf1_float, rf1_base;
                    temp_rf1_amp = ia_rf1;
                    temp_rf1_float = (float)ia_rf1;

                    if (nav_linear_ramp_up>0)
                    {
                        cnt_ramp = slice_index % pfkz_views_per_segment;
                        if (cnt_ramp < nav_linear_ramp_up)
                        {
                            rf1_base = temp_rf1_float*nav_1st_factor;
                            temp_rf1_float = rf1_base + (temp_rf1_float-rf1_base)*cnt_ramp/(float)nav_linear_ramp_up;
                        } 
                    }

                    if (nav_linear_ramp_down>0)
                    {
                        cnt_ramp = pfkz_views_per_segment - (slice_index % pfkz_views_per_segment) - 1;
                        if (cnt_ramp < nav_linear_ramp_down)
                        {
                            rf1_base = temp_rf1_float*nav_last_factor;
                            temp_rf1_float = rf1_base + (temp_rf1_float-rf1_base)*cnt_ramp/(float)nav_linear_ramp_down;
                        }
                    }

                    if ((navseg_weight<1.0) && (slice_index%navkz_views_per_segment < pfkz_views_per_segment))
                    {
                        temp_rf1_float *= navseg_weight;
                    }

                    temp_rf1_amp = (int)temp_rf1_float;
                    setiamp(temp_rf1_amp, &rf1, scanrf1_inst);
                }

                /* set amp of gzcomb and gzp for dummy rf */
                setiamp(volumetab[dabslice], &gzcomb, 0);   /* DCZ */

                if (zrewind_flag) {
                    setiamp(volumetab2[dabslice], &gzp, 0);
                }

                yres_phase = phase_off[slabindex].ysign *
                    (((dabview-1) * phase_off[slabindex].yoffs +
                      3L*FS_PI)%FS_2PI-FS_PI);

                /* grab the slab phase offset */
                slab_phase = slab_off[slabindex].zsign *
                    ((dabslice * slab_off[slabindex].zoffs +
                      3L*FS_PI)%FS_2PI-FS_PI);

                if (slabtracking_flag)
                {
                    yres_phase = yres_phase+(int)(nav_corr_phase_y*disp_y);
                    slab_phase = slab_phase+(int)(nav_corr_phase_z*disp_z); /* disp_x is considered in spoil() */
                }

                /* MRIge91682 */
                if (pfkz_flag == PSD_OFF)
                {
                    if (!ellipt_flag  && !reverse_ellipt_flag ){

                        if ((rspir != 0) && ((slice_index % rspir) == 0)) { /* DCZ */
                            PlayDisdaq(irdisdacqs);
                        }
                    }

                    else if ((rspir != 0) && ((slicecount % rspir) == 0)) { /* DCZ */
                        PlayDisdaq(irdisdacqs);

                        /* DCZ: IRprep is
                           incompatible with
                           elliptical centric.
                           Keep it in case. */
                    }


                    /* chemsat_dda should be zero if irprep and specir are both on */
                    if (!ellipt_flag  && !reverse_ellipt_flag ){
                        if ((sl_per_chem != 0) &&
                            ((slice_index % sl_per_chem) == 0) &&
                            (chemsat_dda != 0)) {                /* DCZ */
                            PlayDisdaq(chemsat_dda);
                        }
                    }

                    else if ((sl_per_chem != 0) &&
                             ((slicecount % sl_per_chem) == 0) &&
                             (chemsat_dda != 0)) {
                        PlayDisdaq(chemsat_dda);
                        /* DCZ: Chemsat is
                           incompatible with
                           elliptical centric.
                           Keep it in case. */
                    }
                }

                if ((rspir != 0) && pfkz_flag) {
                    if (((si+slice_index) % pfkz_views_per_segment) == 0) {
                        PlayDisdaq(irdisdacqs);
                    }
                }
                /* MRIge91682 */
                if( pfkz_flag && (chemsat_dda != 0) && specir_flag )
                {
                    if( pfkr_yz_flag == PSD_OFF )
                    {
                        if( ((si + slice_index) % pfkz_views_per_segment) == 0 )
                        {
                            PlayDisdaq(chemsat_dda);
                        }
                    }
                    else
                    {
                        if( ((si + slice_index) % views_per_segment) == 0 )
                        {
                            PlayDisdaq(chemsat_dda);
                        }
                    }
                }

                /* MRIhc16353 - RV: IDEAL change */
                for (inner_echo = 0; inner_echo < inter_necho; inner_echo++) {

                    if (ideal_echo_mode == 1) {  /* sequential -- echo in outer loop */
                       echo_index =  outer_echo;
                    } else {             /* interleaved -- echo in inner loop */
                       echo_index =  inner_echo;
                    }

                    if (idealiq_flag) {
                       echo_index = inner_echo;
                    }

                    if (medal_flag && medal_multitr_flag) {
                       if (medal_echo_mode)
                           echo_index = outer_echo;
                       else
                           echo_index = inner_echo;
                    }

                    dabecho = (inner_echo + (0*pcfiesta_index)*inter_necho + outer_echo*phase_cycles*inter_necho)*opetl; 

                    if(PSD_ON == ideal_flag)
                    {
                        if (echo_index == 0) {
                            post_dixtime = (GRAD_UPDATE_TIME + ideal_pw - ideal_shift1);
                            pre_dixtime = (GRAD_UPDATE_TIME + ideal_shift1);
                        }
                        else {
                            if (echo_index == 1) {
                                post_dixtime = (GRAD_UPDATE_TIME + ideal_pw - ideal_shift2);
                                pre_dixtime = (GRAD_UPDATE_TIME + ideal_shift2);
                            }
                            else {
                                post_dixtime = (GRAD_UPDATE_TIME + ideal_pw - ideal_shift3);
                                pre_dixtime = (GRAD_UPDATE_TIME + ideal_shift3);
                            }
                        }
                        setperiod(post_dixtime, &dix_ssppost, 0);
                        setperiod(pre_dixtime, &dix_xpre, 0);
                        setperiod(pre_dixtime, &dix_ssppre, 0);
                    }

                    if(idealiq_flag)
                    {
                        if (echo_index == 0) {
                            post_dixtime = (GRAD_UPDATE_TIME + idealiq_pw);
                            pre_dixtime = (GRAD_UPDATE_TIME);
                        }
                        else { /* currently 2 shot only */
                            post_dixtime = (GRAD_UPDATE_TIME);
                            pre_dixtime = (GRAD_UPDATE_TIME + idealiq_pw);
                        }
                        setperiod(post_dixtime, &dix_ssppost, 0);
                        setperiod(pre_dixtime, &dix_xpre, 0);
                        setperiod(pre_dixtime, &dix_ssppre, 0);
                    }

                    if(medal_flag && medal_multitr_flag)
                    {
                       if (echo_index == 0) {
                          post_dixtime = (GRAD_UPDATE_TIME + medal_pw - medal_shift1);
                          pre_dixtime = (GRAD_UPDATE_TIME + medal_shift1);
                       }
                       else {
                          post_dixtime = (GRAD_UPDATE_TIME + medal_pw - medal_shift2);
                          pre_dixtime = (GRAD_UPDATE_TIME + medal_shift2);
                       }
                       setperiod(post_dixtime, &dix_ssppost, 0);
                       setperiod(pre_dixtime, &dix_xpre, 0);
                       setperiod(pre_dixtime, &dix_ssppre, 0);
                    }

                    spoil();

                    /* (MRIhc07226) Slice tracking: restore yres_phase and slab_phase after spoil */            
                    if (slabtracking_flag)
                    {   
                        yres_phase = yres_phase-(int)(nav_corr_phase_y*disp_y);
                        slab_phase = slab_phase-(int)(nav_corr_phase_z*disp_z); /* disp_x is considered in spoil() */
                    }       

                    /* turn data acquisition on */
                    if (navgate_dummy_slice) {
                        acq_echo1 = DABOFF;
                        if (opetl>=2) {
                            acq_echo2 = DABOFF;
                        }
                    } else {
                        acq_echo1 = DABON;
                        if (opetl>=2)
                            acq_echo2 = DABON;
                    }

                    fgre_loaddab_echo1(dabslicebam, dabecho, dabop, dabviewbam, acq_echo1);
                    if (opetl>=2) {
                        fgre_loaddab_echo2(dabslicebam, (dabecho+1), (opetl-1), nshots, dabop, dabviewbam, acq_echo2);
                    }
 
                    /* Play 3D packet as each xz-plane completes.  This mean there
                       will be no 3D packets for elliptical centric ordering
                       until the scan is about 80% done */
                    /* 3D packet is delayed by threedpktdly TRs. This allows time for the
                       CERD to complete processing before xz FFT is started.
                    */
                    if ( (delay3Drecon_flag==0) && (si+slice_index) > threedpktdly ) {
                        if ((zy_export[si+slice_index - 1 - threedpktdly].flags & ZY_FLAGS_XZ_DONE)
                            && (echo_index == dixon_necho-1) && ((PSD_OFF == pfkr_yz_flag) ? (excitation == 1) : (excitation == rspnex))) {
                            int view3dpkt = arcGetDabEncode(zy_export[si + slice_index - 1 - threedpktdly].view, 
                                                            phPackBamFlag, arcPhaseRemapTable) + 1;
                            load3d(&d3d, view3dpkt, DABON);  /* DCZ */
                            if (threedpkt_debug)
                            {
                                printf("Playing 3D plane packet for view %d (si=%d)\n",
                                       view3dpkt, si + slice_index);
                            }
                        } else {
                            load3d(&d3d, 0, DABOFF);
                        }
                    } /* if ((si+slice_index > threedpktdly ) */

                    printdbg("      Before startseq", debugstate);
                    startseq((SHORT)slabindex,(SHORT)MAY_PAUSE);
                    printdbg("      After startseq", debugstate);

                } /* end of inner echo loop */

                if ((PSD_ON == navgate_flag) && (L_SCAN == rspent))
                {
                    if (disabler == 0) {

                        if (pfkz_flag ) {
                            if (navky_views_per_segment != 0) {
                                if ((si%(si_inc*navky_views_per_segment) == (si_inc*(navky_views_per_segment-1))) && (slice_index == si_inc+nav_dummylines-1))
                                    nav_gate_active = 1;
                                else
                                    nav_gate_active = 0;
                            } else { /* navky_views_per_segment == 0 */
                                if (slice_index%navkz_views_per_segment == navkz_views_per_segment-1)
                                    nav_gate_active = 1;
                                else
                                    nav_gate_active = 0;
                            }
                        } else { /* !pfkz_flag */
                            if ((si%(si_inc*navky_views_per_segment) == (si_inc*(navky_views_per_segment-1))) && (slice_index == si_inc+nav_dummylines-1)) {
                                nav_gate_active = 1;
                                printf("non-seg: si=%d nav_gate_active=%d\n", si, nav_gate_active);
                            } else {
                                nav_gate_active = 0;
                            }

                        } /* end !pfkz_flag */
                    } /* end disabler */

                    if ( (PSD_ON == navgate_flag) && (PSD_OFF == slabtracking_flag) ) {

                        if (nav_gate_active == 1) {
                            result = 0;
                            if (navgate_iter < navgate_dda) {
                                nav_active = 0;
                            } else {
                                if (nav_dual_mode){
                                    if (nav_active==0 && in_limit) {
                                        nav_active= 1;
                                    } else if (nav_active==1 && in_limit==0) {
                                        nav_active =0;
                                    }
                                } else {
                                    nav_active= 1;
                                }
                            }

                            if (nav_wait_flag) {
                                settrigger((short)TRIG_INTERN, (short)0);
                                scopeoff(&seqnavend);
                                boffset(off_seqnavend);
#ifndef SIM
                                startseq((short)0, (SHORT)MAY_PAUSE);
#endif              
                            }

                            NavigatorPlayGate();
                            navgate_iter++;
                            if (navsegment_dda!=0) {
                                PlayDisdaq(navsegment_dda);
                            }
                        }
                    } /* end if nav */

                    if (navky_views_per_segment == 0) {
                        int slice_tmp;
                        if (si_inc > 1)
                            slice_tmp = slice_index;
                        else
                            slice_tmp = si;

                        if (slice_tmp%navkz_views_per_segment == navkz_views_per_segment-1)
                            nav_lastslice = 1;
                        else
                            nav_lastslice = 0;
                    } else {
                        int zviews_per_seg;
                        if (si_inc > 1)
                            zviews_per_seg = si_inc;
                        else if (pfkz_flag && (!pfkr_yz_flag)) 
                            zviews_per_seg = pfkz_total;
                        else 
                            zviews_per_seg = views_per_segment;

                        if (si_inc > 1) {
                            if ((si%(zviews_per_seg*navky_views_per_segment) == (zviews_per_seg*(navky_views_per_segment-1))) && (slice_index == si_inc+linestodiscard+nav_dummylines-1))
                                nav_lastslice = 1;
                            else
                                nav_lastslice = 0;
                        } else {
                            if (si%(zviews_per_seg*navky_views_per_segment) == zviews_per_seg*navky_views_per_segment-1)
                                nav_lastslice = 1;
                            else
                                nav_lastslice = 0;
                        }
                    }

                    if ( (!result) && nav_lastslice ) { /* reject */
                        if (debug_nav)
                            printf("view rejected, result = %d exc = %d\n", result, excitation);

                        if (pfkz_flag && (!pfkr_yz_flag)) { 
                            if (navky_views_per_segment == 0) {
                                if(si_inc > 1)
                                    slice_index -= navkz_views_per_segment;
                                else
                                    si -= pfkz_total*navky_views_per_segment;

                            } else {
                                si -= si_inc*navky_views_per_segment;
                            }
                        } else { /* !pfkz_flag */
                            if (!segmented_flag)
                                si -= si_inc*navky_views_per_segment;
                            else
                                si -= (num_views_per_nav_tr);
                        }
                        if (debug_nav)
                            printf("si=%d view=%d slice_index=%d si_inc=%d\n", si, view, slice_index, si_inc);
                    }
                }  /* end if nav & L_SCAN */

            } /* DCZ: end of slice_index loop */

            dabop = DABADD;      /* add xcvr data */

        } /* end excitation loop */

    } /* end superindex loop*/

    } /* end of outer_echo loop */

    /* Send the remaining 3D packets. */
    if (threedpktdly > 0 ) {
        boffset(off_seq3d);
        if (delay3Drecon_flag)
        {
            /* Play out 3D Plane Packet for all acquired kx-kz planes */
            if (!arc_flag || phPackBamFlag)
            {
                for (view = 1; view <= rspvus; view++)
                {
                    load3d(&d3dset, view, DABON);
                    startseq(0, MAY_PAUSE);
                    if (threedpkt_debug)
                    {
                        printf("Playing 3D plane packet for view %d (delay3Drecon, !ARC || ARC packed)\n", view);
                    }
                }
            }
            else 
            {
                /* ARC, Full-sort NEX */
                for (view = 1; view <= zy_views; view++)
                {
                    if (ARC_UNUSED_ENCODE != arcGetDabEncode(view-1, 1, arcPhaseRemapTable))
                    {
                        load3d(&d3dset, view, DABON);
                        startseq(0, MAY_PAUSE);
                        if (threedpkt_debug)
                        {
                            printf("Playing 3D plane packet for view %d (delay3Drecon, ARC !packed)\n", view);
                        }
                    }
                }
            }
        }
        else
        {
            for (j = 0; j < threedpktdly; j++ ) {
                if(zy_export[j + sampledPoints - threedpktdly - 1].flags & ZY_FLAGS_XZ_DONE) {
                    
                    int view3dpkt = arcGetDabEncode(zy_export[j + sampledPoints - threedpktdly - 1].view,
                                                     phPackBamFlag, arcPhaseRemapTable) + 1;
                    
                    load3d(&d3dset, view3dpkt, DABON);
                    startseq(0, MAY_PAUSE);
                    if (threedpkt_debug)
                    {
                        printf("Playing 3D plane packet for view %d (threedpktdly)\n", view3dpkt);
                    }			 
                }
            }
        }
    } /* if (threedpktdly > 0 ) */

    printdbg("Returning from scancore", debugstate);
    return SUCCESS;
} /* End scancoreRTIA_3D */

/********************* scancoreRTIA_2D ***********************/
STATUS scancoreRTIA_2D(void)
{
    int start_view, end_view;
    int start_slice, end_slice; 
    SHORT ia_refocus=0;
    SHORT ia_killer=0;
    SHORT ia_gy1_gy1r=0;
    float a_refocus=0.0;

    if (cont_new_slice || cont_change_slice || 
        (rtia3d_turbo==0) || (cont_same_slice_counter < rtia3d_buffers) )
    {
        start_view=(INT) (1);
        if (arc_flag) {
            end_view = (INT) unaccel_rspvus;
        } else {
            end_view=(INT) (rspvus);
        }
    }
    else
    {
        start_view = rspvus - rtia3d_repeat_views + 1;

        if (start_view <=0) 
        {
            start_view=1;
        }
        if (arc_flag) {
            end_view = (INT) unaccel_rspvus;
        } else {
            end_view=(INT) (rspvus);
        }
    }

    if (rtia3d_satview_start <start_view)
    {
        rtia3d_satview_start =  start_view;
    }
    /*MRIhc07887*/
    if (arc_flag) {
        start_slice= (INT) (opslquant/2);
    }else {
        start_slice = (INT)(rspslq/2);
    }
    end_slice= start_slice+1;

    printdbg("Entering scancoreRTIA2D", debugstate);

    slabindex = 0;
    sp_sat_index = slabindex;
    phaseindex = 0;
    dabview = rtia3d_viewtab[start_view]-1;
    dabslice = start_slice;

    if (FAILURE==ssRsp3D()) 
    {
        return FAILURE;
    }
    setfrequency(rf1_freq[slabindex],&rf1,scanrf1_inst); 
    set_echo1frequency(receive_freq1[slabindex],0);
    if (opetl>=2)
       set_echo2frequency(receive_freq2[slabindex],0);

    /* collect disdaq views */
    if (rtia3d_thkslab_proj_flag && cont_spSat )
    {
        a_refocus = a_base_proj_dephaser;
    }
    else
    {
        a_refocus = a_base;
    }

    ia_refocus =(SHORT) (  (float)  max_pg_iamp*(-a_refocus/loggrd.tz) / slthick_scale_factor) ;
    fgre_setiamp(ia_refocus,&gzcomb);

    if (zrewind_flag) {
        ia_killer = (SHORT) ( (float) max_pg_iamp*(a_base2/loggrd.tz) ) ;
        fgre_setiamp(ia_killer,&gzp);
    }

    /*KK - multiply by asset_factor to allow 3D scan to have ASSET */
    /*      reduced FOV and 2D scan to have full FOV*/
    ia_gy1_gy1r = (short) ((float) -rtia3d_viewtable[(INT) (dabview)]/waveform_scale_factor/rtia_rel_fov_phase_scale*asset_factor);
    fgre_setiamp(ia_gy1_gy1r , &gy1);

    if (rewinder_flag) 
        fgre_setiamp(ia_gy1_gy1r, &gy1r);

    acq_echo1 = DABOFF;
    if (opetl>=2)
       acq_echo2 = DABOFF;

    fgre_loaddab_echo1(dabslice, dabecho, dabop, dabview, acq_echo1);
    if (opetl>=2) {
        fgre_loaddab_echo2(dabslice, (dabecho+1), (opetl-1), nshots, dabop, dabview, acq_echo2);
    }

    fgre_loaddab_3d(0, DABOFF);

    /* Initialize yres_phase and slab_phase to zero */

    yres_phase = 0;
    slab_phase = 0;

    /*extra disdaqs for a new slice MRIge84131--Venkat*/
    if( cont_same_slice_counter == 0 )
    {
        for( view = -dda_one_second; view <= -1; view++)
        {
            RTIA_spoil();
            startseq(slabindex,(SHORT)MAY_PAUSE);
        }
    }

    if (rtia3d_irp_flag && cont_spSat)
       PlayHard180();

    for (view = -8; view <= -1; view++)
    {
        RTIA_spoil();
        startseq(slabindex, (SHORT)MAY_PAUSE);

        if ( (cont_spSat == 1)  && (view == -4) && (rtia3d_thkslab_proj_flag==0)  && !rtia3d_irp_flag )
            SatPrep();
    }  /* End disdaqs */


    /* turn data acquisition on */
    acq_echo1 = DABON;
    if (opetl>=2)
       acq_echo2 = DABOFF;

    for (view = start_view; view <= end_view; view++)
    {
        for (slice = start_slice; slice < end_slice; slice++)
        {

            dabview = rtia3d_viewtab[view-1];
            dabslice = slice;

            dabop = DABSTORE; /* store xcvr data */

            /*KK - multiply by asset_factor to allow 3D scan to have ASSET reduced */
            /*     FOV and 2D scan to have full FOV*/
            ia_gy1_gy1r = (short) ((float) -rtia3d_viewtable[(INT) (dabview)]/waveform_scale_factor/rtia_rel_fov_phase_scale*asset_factor);

            fgre_setiamp(ia_gy1_gy1r , &gy1);

            if (rewinder_flag) 
                fgre_setiamp(ia_gy1_gy1r, &gy1r);


            fgre_setiamp(ia_refocus,&gzcomb);
            if (zrewind_flag)
                fgre_setiamp(ia_killer,&gzp);

            /* calculate the phase offset for the slice and view */
            yres_phase = phase_off[slabindex].ysign*(dabview-1)*phase_off[slabindex].yoffs;
            /* grab the slab phase offset */
            slab_phase = slab_off[slabindex].zsign * dabslice * slab_off[slabindex].zoffs;

            RTIA_spoil();

            fgre_loaddab_echo1(dabslice, dabecho, dabop, dabview, acq_echo1);
            if (opetl>=2) {
                fgre_loaddab_echo2(dabslice, (dabecho+1), (opetl-1), nshots, dabop, dabview, acq_echo2);
            }

            startseq(slabindex, (SHORT)MAY_PAUSE);

            if ( (cont_spSat == 1) && (view >= rtia3d_satview_start) && 
                 (view <= rtia3d_satview_end) && (rtia3d_thkslab_proj_flag==0) && !rtia3d_irp_flag)
                SatPrep();


            dabop = DABADD;      /* add xcvr data */

        } /* end slice loop*/
    } /* end view loop*/

    return SUCCESS;

} /* End scancoreRTIA_2D */

/* End RTIA3D/ftMRA */ 

STATUS osfp_prep(int flag)
{
    int i;
    int ia_rf1_curr = 0;

    acq_echo1 = DABOFF;
    if (opetl>=2) {
       acq_echo2 = DABOFF;
    } 

    fgre_loaddab_echo1(dabslice,dabecho,dabop,dabview,acq_echo1);
    if (opetl>=2) {
        fgre_loaddab_echo2(dabslice, (dabecho+1), (opetl-1), nshots, dabop, dabview, acq_echo2);
    }

    for (i=1; i <= osfp_dda; i++) {
        if (flag == START_UP) {
            ia_rf1_curr = ia_rf1_osfp[i];
        }
        else if (flag == SLOW_DOWN) {
            ia_rf1_curr = ia_rf1_osfp[osfp_dda + 1 - i];
        }

        setiamp(ia_rf1_curr, &rf1, scanrf1_inst);

        spoil();
        startseq((SHORT) slabindex, (SHORT)MAY_PAUSE);
        scopeoff(&seqcore);
    }

    setiamp(ia_rf1, &rf1, scanrf1_inst);

   return SUCCESS;
}

STATUS delay_end_segment(void)
{
    boffset(off_seqdelayendsegment);
    startseq((SHORT)slabindex,(SHORT)MAY_PAUSE);
    boffset(off_seqcore);
    return SUCCESS;
}

/********************* WaitForECGTrigger  ***********************/
STATUS WaitForECGTrigger(void)
{
    while (trigger_detected == FALSE)
    {
        trigger_detected = gettrigoccur();

        if (ecg_cont_dda_flag)
        {
            load3d(&d3d, view-1, DABOFF);
            fgre_loaddab_echo1(dabslice, dabecho, dabop, dabview, DABOFF);
            boffset(off_seqcore);
        } else {
            boffset(off_seqgate);
        }
        /* VAL15 12/14/2004 YI */
        if(pc_mode < PC_BASIC)
            multiphase();
        else
            spoil();
        startseq((SHORT)slabindex, (SHORT)MAY_PAUSE);
    }
    trigger_detected = FALSE;
    return SUCCESS;
}
/********************* ecg_scancore_YZ  ***********************/
/* based on 8.2.5 and TKF's various ecg scancore              */
/**************************************************************/
STATUS ecg_scancore_YZ(void)
{
    int ecg_segments_total, ecg_segments_left;
    int cntvus;   
    int rspsat; 
    int temp_view;
    int last_view;
    int arrhythmiaDetected=FALSE;
    printdbg("Starting ecg_scancore_YZ", debugstate);


    trigger_detected = FALSE;  
    ecg_segments_total = rspvus;
    ecg_segments_left = ecg_segments_total;

    setscantimemanual();
    setscantimeimm(pidmode, pitscan, ecg_segments_total , pitslice,opslicecnt);
    setscantimeauto();


    psd_index = slabquant - 1;
    slabindex = 0;       /* Location in slice table */
    slice = slabindex;
    setfrequency(receive_freq1[slabindex], &echo1, 0);

    chop_phase = 0;

    setiamp(ia_rf1, &rf1, scanrf1_inst);

    for (pass = 0;pass <acqs;pass++) 
    {
        dabview = viewtab[0];
        dabslice= 0;
        fgre_setiamp(volumetab[0], &gzcomb);

        if ( zrewind_flag ) { 
            fgre_setiamp(volumetab2[0], &gzp);
        }

        fgre_setiamp(-viewtable[dabview], &gy1);
        if (rewinder_flag) 
        {
            fgre_setiamp(-viewtable[dabview], &gy1r);
        } 

        acq_echo1 = DABOFF;
        fgre_loaddab_echo1(dabslice,dabecho,dabop,dabview,acq_echo1);
        if (FAILURE==ssRsp3D()) 
        {
            return FAILURE;
        }
        setfrequency(rf1_freq[slabindex], &rf1, scanrf1_inst);

        load3d(&d3d, 0, DABOFF);

        /* Initialize yres_phase and slab_phase to zero */
        yres_phase = 0;
        slab_phase = 0;
        boffset(off_seqcore);

        /*ECG disdaqs */
        for (view = -ecg_dda; view <= -1; view++) 
        {
            WaitForECGTrigger();    
             
            if ((rspir != 0) ) {
                IRPrep();
                settrigger((SHORT)TRIG_INTERN, (SHORT)slabindex);
            }

            if ((sl_per_chem != 0)) {
                ChemPrep();
                settrigger((SHORT)TRIG_INTERN, (SHORT)slabindex);
            }

            if ((rspir != 0)) {
                PlayDisdaq(irdisdacqs);
            }

            if ((sl_per_chem != 0) && (chemsat_dda != 0)) {
                PlayDisdaq(chemsat_dda);
            }

            /* VAL15 12/14/2004 YI */
            if(pc_mode < PC_BASIC)
                multiphase();
            else
                spoil();
            fgre_loaddab_echo1(dabslice, dabecho, dabop, dabview, acq_echo1);

            startseq((SHORT)slabindex,(SHORT)MAY_PAUSE);
            chop_phase = -chop_phase;

            if (sp_sat == 1) {
                SatPrep();
            }

        } /* view */

        acq_echo1 = DABON;

        arrhythmiaDetected = FALSE;
        last_view = 1;

        /* start view loop */
        for (view = 1; view <= rspvus; view++)
        {
            if (arrhythmiaDetected) {      
                view = last_view;
                arrhythmiaDetected = FALSE;
            }

            dabview = viewtab[view-1];
            dabop = DABSTORE;      

            fgre_setiamp(-viewtable[dabview], &gy1);
            if (rewinder_flag)
                fgre_setiamp(-viewtable[dabview], &gy1r);

            cntvus = 0;     /* Initialize flag for Oddnes NPW */

            for (excitation = 1-rspdex; (excitation<=rspnex) && (cntvus<1); excitation++)
            {
                if ( (oddnex_npw == 1) && (excitation == (rspnex - 1)) &&
                     ((dabview <= (rspvus/4)) || (dabview > (3*rspvus/4))) )
                {
                    cntvus = 1;
                }
                else
                {
                    cntvus = 0;
                }

                rspsat = scansat0;    
                setscantimeimm(pidmode, scantime, ecg_segments_left, pitslice,opslicecnt);
                boffset(off_seqcore);

                {
                    int status;
                    status = GateWaitForValidTrig();
                    if (status == FAILURE)
                        psdexit(EM_PSD_NO_HRATE,0,"","psd scan entry point",0);

                    if (status == GATE_REACQUIRE) {
                        temp_view = view;
                        if (excitation == (-rspdex))
                            temp_view--; /* to re-acquire previous segment */

                        last_view = temp_view>last_view ?
                            temp_view: last_view;

                        arrhythmiaDetected = TRUE;

                        break;          /* break out of the excitation loop */
                    }
                }
 
                for (slice = 0; slice < rspslq; slice++)
                {
                    dabslice = slice;

                    if ((rspir != 0) && ((slice % rspir) == 0) ) {
                        IRPrep();
                        settrigger((SHORT)TRIG_INTERN, (SHORT)slabindex);
                    }

                    if ((sl_per_chem != 0) && ((slice % sl_per_chem) == 0)) {
                        ChemPrep();
                        settrigger((SHORT)TRIG_INTERN, (SHORT)slabindex);
                    }

                    yres_phase = phase_off[slabindex].ysign *
                        (((dabview-1) * phase_off[slabindex].yoffs +
                          3L*FS_PI)%FS_2PI-FS_PI);

                    slab_phase = slab_off[slabindex].zsign *
                        ((dabslice * slab_off[slabindex].zoffs +
                          3L*FS_PI)%FS_2PI-FS_PI);

                    fgre_setiamp(volumetab[dabslice], &gzcomb);
                    if (zrewind_flag)
                        fgre_setiamp(volumetab2[dabslice], &gzp);


                    if ((rspir != 0) && ((slice % rspir) == 0)) {
                        PlayDisdaq(irdisdacqs);
                    }

                    if ((sl_per_chem != 0) &&
                        ((slice % sl_per_chem) == 0) &&
                        (chemsat_dda != 0)) {                
                        PlayDisdaq(chemsat_dda);
                    }

                    /* VAL15 12/14/2004 YI */
                    if(pc_mode < PC_BASIC)
                        multiphase();
                    else
                        spoil();
                    fgre_loaddab_echo1(dabslice, dabecho, dabop, dabview, acq_echo1);
                    startseq((SHORT)slabindex, (SHORT)MAY_PAUSE);

                    if ((slice == rspsat) && sp_sat) {
                        SatPrep();
                        settrigger((SHORT)TRIG_INTERN, (SHORT)slabindex);
                        rspsat += scansatint;
                    }
                } /* end slice loop */

                dabop = DABADD; 

            } /* end excitation loop */

            if (arrhythmiaDetected == FALSE)
                ecg_segments_left--;
            scantime = pitscan*ecg_segments_left/(float)ecg_segments_total;
        } /* end view loop */


        boffset(off_seq3d);
        for (view=1;view<=rspvus; view++)
        {
            dabview = viewtab[view-1];
            load3d(&d3dset,dabview,DABON);
            startseq((SHORT)slabindex, (SHORT)MAY_PAUSE);
        }

        boffset(off_seqpass);

        if (pass == (acqs-1))
        {
            setwamp(SSPD + DABPASS + DABSCAN, &pass_pulse, 2);
        }
        else
        {
            setwamp(SSPD + DABPASS, &pass_pulse, 2);
        }

        if (pass == (acqs-1))
            pause = MAY_PAUSE;
        else
        {                 /* if not last pass */
            if (((pass+1) % slicecnt)==0)
                pause = MUST_PAUSE;   /* pause if desired */
            else
                pause = AUTO_PAUSE; /* or if required */
        }

        load3d(&d3dpass,0,DABOFF);
        sp_sat_index = 0;
        startseq((SHORT)slabindex,(SHORT)pause);

    } /* pass (opfphases) loop */

    printdbg("Returning from ecg_scancore_YZ", debugstate);
    return SUCCESS;
} /* End ecg_scancore_YZ */

/********************* ecg_scancore_YZ  ***********************/
/* based on 8.2.5 and TKF's various ecg scancore              */
/**************************************************************/
STATUS ecg_scancore_ZY(void)
{
    int ecg_segments_total, ecg_segments_left;
    int cntvus;
    int rspsat;
    int temp_slice;
    int last_slice;
    int arrhythmiaDetected=FALSE;
    printdbg("Starting ecg_scancore_ZY", debugstate);

    trigger_detected = FALSE;
    ecg_segments_total = rspslq;
    ecg_segments_left = ecg_segments_total;

    setscantimemanual();
    setscantimeimm(pidmode, pitscan, ecg_segments_total , pitslice,opslicecnt);
    setscantimeauto();


    psd_index = slabquant - 1;
    slabindex = 0;       /* Location in slice table */
    slice = slabindex;
    setfrequency(receive_freq1[slabindex], &echo1, 0);

    chop_phase = 0;

    setiamp(ia_rf1, &rf1, scanrf1_inst);

    for (pass = 0;pass <acqs;pass++)
    {
        dabview = viewtab[0];
        dabslice= 0;
        fgre_setiamp(volumetab[0], &gzcomb);

        if ( zrewind_flag ) {
            fgre_setiamp(volumetab2[0], &gzp);
        }

        fgre_setiamp(-viewtable[dabview], &gy1);
        if (rewinder_flag) 
        {
            fgre_setiamp(-viewtable[dabview], &gy1r);
        }

        acq_echo1 = DABOFF;
        fgre_loaddab_echo1(dabslice, dabecho, dabop, dabview, acq_echo1);
        if (FAILURE==ssRsp3D()) 
        {
            return FAILURE;
        }
        setfrequency(rf1_freq[slabindex], &rf1, scanrf1_inst);

        load3d(&d3d, 0, DABOFF);

        /* Initialize yres_phase and slab_phase to zero */
        yres_phase = 0;
        slab_phase = 0;
        boffset(off_seqcore);

        /*ECG disdaqs */
        for (slice = -ecg_dda; slice <= -1; slice++)
        {
            WaitForECGTrigger();

            if ((rspir != 0) ) {
                IRPrep();
                settrigger((SHORT)TRIG_INTERN, (SHORT)slabindex);
            }

            if ((sl_per_chem != 0)) {
                ChemPrep();
                settrigger((SHORT)TRIG_INTERN, (SHORT)slabindex);
            }

            if ((rspir != 0)) {
                PlayDisdaq(irdisdacqs);
            }

            if ((sl_per_chem != 0) && (chemsat_dda != 0)) {
                PlayDisdaq(chemsat_dda);
            }

            /* VAL15 12/14/2004 YI */
            if(pc_mode < PC_BASIC)
                multiphase();
            else
                spoil();
            fgre_loaddab_echo1(dabslice, dabecho, dabop, dabview, acq_echo1);

            startseq((SHORT)slabindex,(SHORT)MAY_PAUSE);
            chop_phase = -chop_phase;

            if (sp_sat == 1) {
                SatPrep();
            }

        } /* slice */

        acq_echo1 = DABON;

        arrhythmiaDetected=FALSE;
        last_slice = 0;

        /* start slice loop */
        for (slice = 0; slice < rspslq; slice++)
        {
            if (arrhythmiaDetected) {
                slice = last_slice;
                arrhythmiaDetected = FALSE;
            }

            dabslice = slice;
            dabview = viewtab[0];
            dabop = DABSTORE;
            cntvus = 0;     /* Initialize flag for Oddnes NPW */

            for (excitation = 1-rspdex; (excitation<=rspnex) && (cntvus<1); excitation++)
            {
                if ( (oddnex_npw == 1) && (excitation == (rspnex - 1)) &&
                     ((dabview <= (rspvus/4)) || (dabview > (3*rspvus/4))) )
                {
                    cntvus = 1;
                }
                else
                {
                    cntvus = 0;
                }

                rspsat = scansat0;

                setscantimeimm(pidmode, scantime, ecg_segments_left, pitslice,opslicecnt);
                boffset(off_seqcore);

                {
                    int status;
                    status = GateWaitForValidTrig();
                    if (status == FAILURE)
                        psdexit(EM_PSD_NO_HRATE,0,"","psd scan entry point",0);

                    if (status == GATE_REACQUIRE) {
                        temp_slice = slice;
                        if (excitation == (-rspdex))
                            temp_slice--; /* to re-acquire previous segment */

                        last_slice = temp_slice>last_slice ?
                            temp_slice: last_slice;

                        arrhythmiaDetected = TRUE;

                        break;          /* break out of the excitation loop */
                    }
                }

                for (view = 1; view <= rspvus; view++)
                {
                    dabview = viewtab[view-1];
                    dabop = DABSTORE;

                    fgre_setiamp(-viewtable[dabview], &gy1);
                    if (rewinder_flag)
                        fgre_setiamp(-viewtable[dabview], &gy1r);

                    if ((rspir != 0) && (( (view-1) % rspir) == 0) ) {
                        IRPrep();
                        settrigger((SHORT)TRIG_INTERN, (SHORT)slabindex);
                    }

                    if ((sl_per_chem != 0) && (((view-1) % sl_per_chem) == 0)) {
                        ChemPrep();
                        settrigger((SHORT)TRIG_INTERN, (SHORT)slabindex);
                    }

                    yres_phase = phase_off[slabindex].ysign *
                        (((dabview-1) * phase_off[slabindex].yoffs +
                          3L*FS_PI)%FS_2PI-FS_PI);

                    slab_phase = slab_off[slabindex].zsign *
                        ((dabslice * slab_off[slabindex].zoffs +
                          3L*FS_PI)%FS_2PI-FS_PI);

                    fgre_setiamp(volumetab[dabslice], &gzcomb);
                    if (zrewind_flag)
                        fgre_setiamp(volumetab2[dabslice], &gzp);


                    if ((rspir != 0) && (( (view-1) % rspir) == 0)) {
                        PlayDisdaq(irdisdacqs);
                    }

                    if ((sl_per_chem != 0) &&
                        (( (view-1) % sl_per_chem) == 0) &&
                        (chemsat_dda != 0)) {
                        PlayDisdaq(chemsat_dda);
                    }

                    /* VAL15 12/14/2004 YI */
                    if(pc_mode < PC_BASIC)
                        multiphase();
                    else
                        spoil();
                    fgre_loaddab_echo1(dabslice, dabecho, dabop, dabview, acq_echo1);
                    startseq((SHORT)slabindex, (SHORT)MAY_PAUSE);

                    if (((view-1) == rspsat) && sp_sat) {
                        SatPrep();
                        settrigger((SHORT)TRIG_INTERN, (SHORT)slabindex);
                        rspsat += scansatint;
                    }
                } /* end view loop */

                dabop = DABADD;

            } /* end excitation loop */

            if (arrhythmiaDetected == FALSE)
                ecg_segments_left--;
            scantime = pitscan*ecg_segments_left/(float)ecg_segments_total;
        } /* end slice loop */

        boffset(off_seq3d);
        for (view=1;view<=rspvus; view++)
        {
            dabview = viewtab[view-1];
            load3d(&d3dset,dabview,DABON);
            startseq((SHORT)slabindex, (SHORT)MAY_PAUSE);
        }

        boffset(off_seqpass);

        if (pass == (acqs-1))
        {
            setwamp(SSPD + DABPASS + DABSCAN, &pass_pulse, 2);
        }
        else
        {
            setwamp(SSPD + DABPASS, &pass_pulse, 2);
        }

        if (pass == (acqs-1))
            pause = MAY_PAUSE;
        else
        {                 /* if not last pass */
            if (((pass+1) % slicecnt)==0)
                pause = MUST_PAUSE;   /* pause if desired */
            else
                pause = AUTO_PAUSE; /* or if required */
        }

        load3d(&d3dpass,0,DABOFF);
        sp_sat_index = 0;
        startseq((SHORT)slabindex,(SHORT)pause);

    } /* pass (opfphases) loop */

    printdbg("Returning from ecg_scancore_ZY", debugstate);
    return SUCCESS;
} /* End ecg_scancore_ZY */

/* ungated FatSat FIESTA */
STATUS ugfsf_view_order(INT *dab_view,
                        const INT curshot,
                        const INT num_sht,
                        const INT curview,
                        const INT tot_vus,
                        const INT full_ky_view,
                        const INT view2center,
                        const INT vieworder_flag)
{
    if(vieworder_flag == 0){ /* modified interleaved sequential for full NEX (or possibly 0.75 NEX)*/
        *dab_view = viewtab[((curview - view2center)*num_sht + (curshot-1) +
                             full_ky_view/2 + tot_vus) % tot_vus];
    }
    else if(vieworder_flag == 1){ /* reversed interleaved sequential for 0.5 NEX */
        *dab_view = viewtab[(curview-1)*num_sht + (curshot-1)];
    }
    else{ /* interleaved centric for full NEX*/
            *dab_view = viewtab[((curview-1)*num_sht + (curshot-1) + tot_vus) % tot_vus];
    }

    return SUCCESS;
}

/* ungated FatSat FIESTA */
STATUS set_zero_encode(void)
{
    temp_short = max_pg_iamp*(-a_base/loggrd.tz); /* set up zero slice encode */
    setiamp(temp_short,&gzcomb,0);                /* (just refocus) */
    if (zrewind_flag) 
    {
        temp_short = max_pg_iamp*(a_base2/loggrd.tz); /* set up zero slice rewinder */
        setiamp(temp_short,&gzp,0);                   /* (just killer) */
    }
    setiamp(0, &gy1, 0);  /* set up zero phase encode */
    if (rewinder_flag) 
    {
        setiamp(0, &gy1r, 0); /* set up zero phase rewinder */
    }

    return SUCCESS;
}

/************************************************/

STATUS fgre_setiamp( INT amplitude,
                     WF_PULSE_ADDR pulse )
{
    setamprsp(pulse->wavegen_type,
              amplitude,
              TYPINSTRMEM,
              (pulse->inst_hdr_tail)->wf_instr_ptr);

    return SUCCESS;
}

/************************************************/

STATUS fgre_setiphase(INT pulse, LONG phase) /* Courtesy of JAP's prototype */
{

    /* This complicated line will round phase to the nearest upper 12
       bits, by first determining if the lower 4 bits are > 7 and if
       they are rounding to the next higher value. It will then mask
       off bits 0 - 3 and bit 17. Bit 17 can get set if the phase was
       set to a value greater than or equal to 0xFFF8 in which case the rounding
       will set the value to 0x10008, in which case the masking will
       set the value to 0x0.

    */

    unsigned short sphase;

    if (!old_phase) {
        if (phase < 0) {
            phase += FS_2PI;
        }

        phase = ( phase  + ((phase & 0x8L) << 1) ) & 0xFFF0;

        if ( ( phase < 0x0 ) || ( phase > 0xFFF0 ) ) {
            return FAILURE;
        }

    } else {
        /*** Verify that the first four bits are not set and that the
         ***  phase value is neither greater then PI, nor less then negative
         ***  PI.   If the phase is negative, add 15 before shifting the
         ***  clearing the bits.
         ***/
        if (phase < 0)
            phase +=  0xFL;

        phase &=  ~0xFL;
    }

    sphase = phase;

    /* Move the bits to hardware */
    ssploadrsp((short *)&sphase,
               (INT) (pulse + PSD_PHASE_OFFSET2),
               (SHORT)1,
               (HW_DIRECTION)TOHARDWARE,
               (SSP_S_ATTRIB)SSPS2);

    return SUCCESS;
}

STATUS
fgre_loaddab_3d( long view,
                 TYPDAB_PACKETS acqon_flag)

{
    SHORT dabbits;

    dabbits = (acqon_flag == DABON) ? DABDC: 0;

    /* Add DABON/DABOFF to the DAB packet */
    ssploadrsp( &dabbits,
                d3ddab,
                1,
                TOHARDWARE,
                SSPS1 );

    if (acqon_flag == DABON) {
        sspextloadrsp( &view,
                       d3ddab + 2,
                       1,
                       TOHARDWARE,
                       SSPS2 );
    }

    return SUCCESS;
}   /* end fgre_loaddab_3d() */

/* 
 * fgre_loaddab_echo1
 *
 * Wrapper function for fgre_loaddab_echo1_rfhub with hub index and R1
 * index switching off.
 * 
 */

STATUS
fgre_loaddab_echo1( LONG slice, 
                    LONG echo, 
                    LONG oper, 
                    LONG view, 
                    TYPDAB_PACKETS acqon_flag)
{

    LONG hubIndex = 0;
    LONG r1Index = 0;
    LONG hubctrlmask = 0;
    STATUS status;

    status =  fgre_loaddab_echo1_rfhub( slice,
                                        echo,
                                        oper,
                                        view,
                                        acqon_flag,
                                        hubIndex,
                                        r1Index,
                                        hubctrlmask );

    return status;
}

/*
 *  fgre_loaddab_echo1_rfhub
 *
 *  Type: Function
 *
 *  Description:
 *    This function is an optimization of loaddab where a ctrlmask of
 *    PSD_LOAD_DAB_ALL is assumed.  echo1 is assumed as the pulse.
 *    A more generic optimization of loaddab would include a pulse
 *    parameter to specifiy which DAB packet to load.
 *    Another generic optimization might call sspload instead of
 *    ssploadrsp, but it would be better to do the parameter checking
 *    once during pulsegen rather than in every sequence preparation.
 *    Arguments are:
 *      LONG slice;                 -> Slice number
 *      LONG echo;                  -> Echo Number
 *      LONG oper;                  -> Operation field
 *      LONG view;                  -> View number
 *      TYPDAB_PACKETS acqon_flag;  -> Acquisition on/off
 *      LONG hubIndex;              -> Hub index to use
 *      LONG r1Index;               -> R1 index to use
 *      LONG hubctrlmask;           -> Mask to control if hubIndex
 *                                     and R1 index are applied
 *
 */
STATUS
fgre_loaddab_echo1_rfhub ( LONG slice, 
                           LONG echo, 
                           LONG oper, 
                           LONG view, 
                           TYPDAB_PACKETS acqon_flag,
                           LONG hubIndex,
                           LONG r1Index,
                           LONG hubctrlmask)
{
    SHORT dabbits;
    SHORT rbabits;
    SHORT dabis_data[6];
    LONG  ssp_ix=0;

    switch( psd_board_type ) {
    case PSDCERD:
    case PSDDVMR:
        ssp_ix = 8;
        break;
    }
    
    if ( acqon_flag == DABON ) {
        dabbits = DABDC;
        rbabits = RDC;
    } else {
        dabbits = 0;
        rbabits = 0;
    }

    /* Add DABON/DABOFF to the DAB packet */
    ssploadrsp( (SHORT *)&dabbits, 
                (INT)echo1dab, 
                (SHORT)1, 
                (HW_DIRECTION)TOHARDWARE, 
                (SSP_S_ATTRIB)SSPS1 );

    /* RBA pulse is the associated pulse of the XTR pulse which is the */
    /* associated pulse of the DAB pulse which is passed in */
    ssploadrsp( (SHORT *)&rbabits, 
                (INT)( echo1rbarsp + 0 ), 
                (SHORT)1, 
                (HW_DIRECTION)TOHARDWARE, 
                (SSP_S_ATTRIB)SSPS1 );

    /* Prepare an array with the 6 new DAB packet bytes. */
    /* Only the lower 8 bits of each array element are used. */
    dabis_data[ 0 ] = (SHORT)( slice >> 8 );
    dabis_data[ 1 ] = (SHORT)slice;
    if ( echo == -1 ) {
        dabis_data[ 2 ] = DABIE;
    } else {
        dabis_data[ 2 ] = (SHORT)echo;
    }

    dabis_data[ 3 ] = (SHORT)oper;
    dabis_data[ 4 ] = (SHORT)( view >> 8 );
    dabis_data[ 5 ] = (SHORT)view;
    
    /* Add the 6 bytes to the DAB packet */
    ssploadrsp( (SHORT *)dabis_data, 
                (INT)( echo1dab + ssp_ix ), 
                (SHORT)6, 
                (HW_DIRECTION)TOHARDWARE, 
                (SSP_S_ATTRIB)SSPS1 );

    /* We use setwamp command to change the tag bit for the SSP data. 
     * sspload() interface functions provided by the AGP would not
     * support changing the SSP Tag bits - The PSDs have to use 
     * setwamp() functions instead. (as per MRIge68262) 
     */
    /* MRIhc21427 */

    /* 
     * SSP commands for coil and R1 switching only available on DV
     * receive chain 
     */ 
    if( PSDDVMR == psd_board_type )
    {
        if( hubctrlmask & PSD_LOAD_DAB_HUB )
        {
            /* Set coil configuration change */
            dabbits = SSPOC + RFHUBSEL;
            setwamp (dabbits, pecho1xtr, PSD_HUB_SELECT_OFFSET);

            dabbits = SSPD + HUBIND + hubIndex;
            setwamp (dabbits, pecho1xtr, PSD_HUB_SELECT_OFFSET+1);
        }
        else if( hubctrlmask & PSD_LOAD_DAB_HUB_RESET )
        {
            /* Clear coil configuration change */
            dabbits = SSPNOP;
            setwamp (dabbits, pecho1xtr, PSD_HUB_SELECT_OFFSET);

            dabbits = SSPNOP;
            setwamp (dabbits, pecho1xtr, PSD_HUB_SELECT_OFFSET+1);
        }

        if( hubctrlmask & PSD_LOAD_DAB_R1 )
        {
            /* Set R1 change */
            dabbits = SSPOC + RFHUBSEL;
            setwamp (dabbits, pecho1xtr, PSD_HUB_SELECT_OFFSET+2);

            dabbits = SSPD + R1IND + r1Index -1;
            setwamp (dabbits, pecho1xtr, PSD_HUB_SELECT_OFFSET+3);
        }
        else if( hubctrlmask & PSD_LOAD_DAB_R1_RESET )
        {
            /* Clear R1 change */
            dabbits = SSPNOP;
            setwamp (dabbits, pecho1xtr, PSD_HUB_SELECT_OFFSET+2);

            dabbits = SSPNOP;
            setwamp (dabbits, pecho1xtr, PSD_HUB_SELECT_OFFSET+3);
        }
    }

    return SUCCESS;
}   /* end fgre_loaddab_echo1_rfhub() */

/* 
 * fgre_loaddab_echo2
 *
 * Wrapper function for fgre_loaddab_echo2_rfhub with hub index and R1
 * index switching off.
 * 
 */

STATUS
fgre_loaddab_echo2( LONG slice,
                    LONG startecho,
                    LONG numecho,
                    LONG nshots,
                    LONG oper,
                    LONG view,
                    TYPDAB_PACKETS acqon_flag)
{

    LONG hubIndex = 0;
    LONG r1Index = 0;
    LONG hubctrlmask = 0;
    STATUS status;

    status = fgre_loaddab_echo2_rfhub( slice,
                                       startecho,
                                       numecho,
                                       nshots,
                                       oper,
                                       view,
                                       acqon_flag,
                                       hubIndex,
                                       r1Index,
                                       hubctrlmask );

    return status;
}

STATUS
fgre_loaddab_echo2_rfhub( LONG slice,
                          LONG startecho,
                          LONG numecho,
                          LONG nshots,
                          LONG oper,
                          LONG view,
                          TYPDAB_PACKETS acqon_flag,
                          LONG hubIndex,
                          LONG r1Index,
                          LONG hubctrlmask)
{
    SHORT dabbits;
    SHORT rbabits;
    SHORT dabis_data[6];
    LONG  ssp_ix = 0;
    INT   echoindex;

    switch( psd_board_type ) {
    case PSDCERD:
    case PSDDVMR:
        ssp_ix = 8;
        break;
    }

    if ( acqon_flag == DABON ) {
        dabbits = DABDC;
        rbabits = RDC;
    } else {
        dabbits = 0;
        rbabits = 0;
    }


    for (echoindex=0; echoindex<numecho; echoindex++) {
        /* Add DABON/DABOFF to the DAB packet */
        ssploadrsp( (SHORT *)&dabbits,
                    (INT)echo2toNdab[echoindex],
                    (SHORT)1,
                    (HW_DIRECTION)TOHARDWARE,
                    (SSP_S_ATTRIB)SSPS1 );

        /* RBA pulse is the associated pulse of the XTR pulse which is the */
        /* associated pulse of the DAB pulse which is passed in */
        ssploadrsp( (SHORT *)&rbabits,
                    (INT)( echo2toNrba[echoindex] + 0 ),
                    (SHORT)1,
                    (HW_DIRECTION)TOHARDWARE,
                    (SSP_S_ATTRIB)SSPS1 );

        /* Prepare an array with the 6 new DAB packet bytes. */
        /* Only the lower 8 bits of each array element are used. */
        dabis_data[ 0 ] = (SHORT)( slice >> 8 );
        dabis_data[ 1 ] = (SHORT)slice;
        if ( (startecho + echoindex*nshots) == -1 ) {
            dabis_data[ 2 ] = DABIE;
        } else {
            dabis_data[ 2 ] = (SHORT) (startecho + echoindex*nshots);
        }

        dabis_data[ 3 ] = (SHORT)oper;
        dabis_data[ 4 ] = (SHORT)( view >> 8 );
        dabis_data[ 5 ] = (SHORT)view;

        /* Add the 6 bytes to the DAB packet */
        ssploadrsp( (SHORT *)dabis_data,
                    (INT)( echo2toNdab[echoindex] + ssp_ix ),
                    (SHORT)6,
                    (HW_DIRECTION)TOHARDWARE,
                    (SSP_S_ATTRIB)SSPS1 );

        /* We use setwamp command to change the tag bit for the SSP data. 
         * sspload() interface functions provided by the AGP would not
         * support changing the SSP Tag bits - The PSDs have to use 
         * setwamp() functions instead. (as per MRIge68262) 
         */

        /* MRIhc21427 */

        /* 
         * SSP commands for coil and R1 switching only available on DV
         * receive chain 
         */ 
        if( PSDDVMR == psd_board_type )
        {
            if( hubctrlmask & PSD_LOAD_DAB_HUB )
            {
                /* Set coil configuration change */
                dabbits = SSPOC + RFHUBSEL;
                setwamp (dabbits, p_echo2toNxtr[echoindex], PSD_HUB_SELECT_OFFSET);

                dabbits = SSPD + HUBIND + hubIndex;
                setwamp (dabbits, p_echo2toNxtr[echoindex], PSD_HUB_SELECT_OFFSET+1);
            }
            else if( hubctrlmask & PSD_LOAD_DAB_HUB_RESET )
            {
                /* Clear coil configuration change */
                dabbits = SSPNOP;
                setwamp (dabbits, p_echo2toNxtr[echoindex], PSD_HUB_SELECT_OFFSET);

                dabbits = SSPNOP;
                setwamp (dabbits, p_echo2toNxtr[echoindex], PSD_HUB_SELECT_OFFSET+1);
            }

            if( hubctrlmask & PSD_LOAD_DAB_R1 )
            {
                /* Set R1 change */
                dabbits = SSPOC + RFHUBSEL;
                setwamp (dabbits, p_echo2toNxtr[echoindex], PSD_HUB_SELECT_OFFSET+2);

                dabbits = SSPD + R1IND + r1Index -1;
                setwamp (dabbits, p_echo2toNxtr[echoindex], PSD_HUB_SELECT_OFFSET+3);
            }
            else if( hubctrlmask & PSD_LOAD_DAB_R1_RESET )
            {
                /* Clear R1 change */
                dabbits = SSPNOP;
                setwamp (dabbits, p_echo2toNxtr[echoindex], PSD_HUB_SELECT_OFFSET+2);

                dabbits = SSPNOP;
                setwamp (dabbits, p_echo2toNxtr[echoindex], PSD_HUB_SELECT_OFFSET+3);
            }
        }
    }
    return SUCCESS;
}   /* end fgre_loaddab_echo2() */

/*
 * fgre_loaddab_echoN
 *
 * Wrapper function for fgre_loaddab_echoN_rfhub with hub index and R1
 * index switching off.
 *
 */

STATUS
fgre_loaddab_echoN( LONG slice,
                    LONG echo,
                    LONG etl_echo,
                    LONG oper,
                    LONG view,
                    TYPDAB_PACKETS acqon_flag)
{

    LONG hubIndex = 0;
    LONG r1Index = 0;
    LONG hubctrlmask = 0;
    STATUS status;

    status =  fgre_loaddab_echoN_rfhub( slice,
                                        echo,
                                        etl_echo,
                                        oper,
                                        view,
                                        acqon_flag,
                                        hubIndex,
                                        r1Index,
                                        hubctrlmask);

    return status;
}

/*
 *  fgre_loaddab_echoN_rfhub
 *
 *  Type: Function
 *
 *  Description:
 *    This function is an optimization of loaddab where a ctrlmask of
 *    PSD_LOAD_DAB_ALL is assumed.  echo1 is assumed as the pulse.
 *    A more generic optimization of loaddab would include a pulse
 *    parameter to specifiy which DAB packet to load.
 *    Another generic optimization might call sspload instead of
 *    ssploadrsp, but it would be better to do the parameter checking
 *    once during pulsegen rather than in every sequence preparation.
 *    Arguments are:
 *      LONG slice;                 -> Slice number
 *      LONG echo;                  -> Echo Number
 *      LONG oper;                  -> Operation field
 *      LONG view;                  -> View number
 *      TYPDAB_PACKETS acqon_flag;  -> Acquisition on/off
 *      LONG hubIndex;              -> Hub index to use
 *      LONG r1Index;               -> R1 index to use
 *      LONG hubctrlmask;           -> Mask to control if hubIndex
 *                                     and R1 index are applied
 *
 */
STATUS
fgre_loaddab_echoN_rfhub ( LONG slice,
                           LONG echo,
                           LONG etl_echo,
                           LONG oper,
                           LONG view,
                           TYPDAB_PACKETS acqon_flag,
                           LONG hubIndex,
                           LONG r1Index,
                           LONG hubctrlmask)
{
    SHORT dabbits;
    SHORT rbabits;
    SHORT dabis_data[6];
    LONG  ssp_ix=0;

    switch( psd_board_type ) {
    case PSDCERD:
    case PSDDVMR:
        ssp_ix = 8;
        break;
    }

    if ( acqon_flag == DABON ) {
        dabbits = DABDC;
        rbabits = RDC;
    } else {
        dabbits = 0;
        rbabits = 0;
    }

    /* Add DABON/DABOFF to the DAB packet */
    ssploadrsp( (SHORT *)&dabbits,
                (INT)echo2toNdab[etl_echo-1],
                (SHORT)1,
                (HW_DIRECTION)TOHARDWARE,
                (SSP_S_ATTRIB)SSPS1 );

    /* RBA pulse is the associated pulse of the XTR pulse which is the */
    /* associated pulse of the DAB pulse which is passed in */
    ssploadrsp( (SHORT *)&rbabits,
                (INT)(echo2toNrba[etl_echo-1] + 0),
                (SHORT)1,
                (HW_DIRECTION)TOHARDWARE,
                (SSP_S_ATTRIB)SSPS1 );

    /* Prepare an array with the 6 new DAB packet bytes. */
    /* Only the lower 8 bits of each array element are used. */
    dabis_data[ 0 ] = (SHORT)( slice >> 8 );
    dabis_data[ 1 ] = (SHORT)slice;
    if ( echo == -1 ) {
        dabis_data[ 2 ] = DABIE;
    } else {
        dabis_data[ 2 ] = (SHORT)echo;
    }

    dabis_data[ 3 ] = (SHORT)oper;
    dabis_data[ 4 ] = (SHORT)( view >> 8 );
    dabis_data[ 5 ] = (SHORT)view;

    /* Add the 6 bytes to the DAB packet */
    ssploadrsp( (SHORT *)dabis_data,
                (INT)( echo2toNdab[etl_echo-1] + ssp_ix ),
                (SHORT)6,
                (HW_DIRECTION)TOHARDWARE,
                (SSP_S_ATTRIB)SSPS1 );

    /* We use setwamp command to change the tag bit for the SSP data.
     * sspload() interface functions provided by the AGP would not
     * support changing the SSP Tag bits - The PSDs have to use
     * setwamp() functions instead. (as per MRIge68262)
     */
    /* MRIhc21427 */

    /*
     * SSP commands for coil and R1 switching only available on DV
     * receive chain
     */
    if( PSDDVMR == psd_board_type )
    {
        if( hubctrlmask & PSD_LOAD_DAB_HUB )
        {
            /* Set coil configuration change */
            dabbits = SSPOC + RFHUBSEL;
            setwamp (dabbits, p_echo2toNxtr[etl_echo-1], PSD_HUB_SELECT_OFFSET);

            dabbits = SSPD + HUBIND + hubIndex;
            setwamp (dabbits, p_echo2toNxtr[etl_echo-1], PSD_HUB_SELECT_OFFSET+1);
        }
        else if( hubctrlmask & PSD_LOAD_DAB_HUB_RESET )
        {
            /* Clear coil configuration change */
            dabbits = SSPNOP;
            setwamp (dabbits, p_echo2toNxtr[etl_echo-1], PSD_HUB_SELECT_OFFSET);

            dabbits = SSPNOP;
            setwamp (dabbits, p_echo2toNxtr[etl_echo-1], PSD_HUB_SELECT_OFFSET+1);
        }

        if( hubctrlmask & PSD_LOAD_DAB_R1 )
        {
            /* Set R1 change */
            dabbits = SSPOC + RFHUBSEL;
            setwamp (dabbits, p_echo2toNxtr[etl_echo-1], PSD_HUB_SELECT_OFFSET+2);

            dabbits = SSPD + R1IND + r1Index -1;
            setwamp (dabbits, p_echo2toNxtr[etl_echo-1], PSD_HUB_SELECT_OFFSET+3);
        }
        else if( hubctrlmask & PSD_LOAD_DAB_R1_RESET )
        {
            /* Clear R1 change */
            dabbits = SSPNOP;
            setwamp (dabbits, p_echo2toNxtr[etl_echo-1], PSD_HUB_SELECT_OFFSET+2);

            dabbits = SSPNOP;
            setwamp (dabbits, p_echo2toNxtr[etl_echo-1], PSD_HUB_SELECT_OFFSET+3);
        }
    }
    return SUCCESS;
}   /* end fgre_loaddab_echoN_rfhub() */


/********************* TESTCORE ***********************/
STATUS testcore(void)
{
    int cntvus;	/* Flag for collecting central views in Oddnex NPW case */
    int temp_seqcount;

    temp_seqcount = 10;

    printdbg("Starting testcore", debugstate);

    /* initialize rf1 amplitude */
    setiamp(ia_rf1, &rf1, scanrf1_inst);

    spgr_count = 1;


    setiamp(-viewtable[0], &gy1, 0);
    if (rewinder_flag) 
    {
        setiamp(-viewtable[0], &gy1r, 0);
    }

    acq_echo1 = DABOFF;
    if (opetl>=2)
        acq_echo2 = DABOFF;

    fgre_loaddab_echo1(slice, dabecho, dabop, 0, acq_echo1);
    if (opetl>=2) {
        fgre_loaddab_echo2(slice, (dabecho+1), (opetl-1), nshots, dabop, dabview, acq_echo2);
    }

    load3d(&d3d, 0, DABOFF);

    /* turn data acquisition on */
    acq_echo1 = DABON;
    if (opetl>=2)
        acq_echo2 = DABON;

    /* start view loop */
    for (view = 0; view < rspvus; view++)
    {

        dabview = view + 1;
        dabop = 0;	/* store xcvr data */

        setiamp(-viewtable[dabview], &gy1, 0);
        if (rewinder_flag)
            setiamp(-viewtable[dabview], &gy1r, 0);

        cntvus = 0;	/* Initialize flag for Oddnes NPW */

        /* start excitation loop */
        for (excitation = 1-rspdex; (excitation<=rspnex) && (cntvus<1); excitation++)
        {
            /* Condition to turn cntvus flag on/off */
            if ( (oddnex_npw == 1) && (excitation == (rspnex - 1)) &&
                 ((dabview <= (rspvus/4)) || (dabview > (3*rspvus/4))) )
            {
                cntvus = 1;
            }
            else
            {
                cntvus = 0;
            }

            /* ******************
               test feature here  */
            monitor_core(0,0,1);

            reset_for_scan();

            /* ******************* */

            /* start slice loop */
            for (slice = 0; slice < rspslq; slice++)
            {
                dabslice = slice;

                /* calculate the phase offset for the slice and view */
                yres_phase = phase_off[slabindex].ysign*(((dabview-1)*
                                                          phase_off[slabindex].yoffs + 3L*FS_PI)%FS_2PI-FS_PI);
                /* grab the slab phase offset */
                slab_phase = slab_off[slabindex].zsign*((dabslice*
                                                         slab_off[slabindex].zoffs + 3L*FS_PI)%FS_2PI-FS_PI);
                /* set receiver phase - exor is not supported */
                rcphase = (slab_phase + yres_phase + 3L * FS_PI) % FS_2PI - FS_PI;
                setiphase(rcphase, &echo1, 0); /* slab and offset phase */

                /* set amp of gzcomb and gzp for dummy rf */
                setiamp(volumetab[dabslice], &gzcomb, 0);
                if ( zrewind_flag ) { 
                    setiamp(volumetab2[dabslice], &gzp, 0);
                }

                spoil();

                fgre_loaddab_echo1(dabslice, dabecho, dabop, dabview, acq_echo1);
                if (opetl>=2) {
                    fgre_loaddab_echo2(dabslice, (dabecho+1), (opetl-1), nshots, dabop, dabview, acq_echo2);
                }

                if ((slice == 2) && (excitation == 1) && (view>=1))
                {
                    load3d(&d3d, view, DABON);
                }

                startseq(0, (SHORT)MAY_PAUSE);

                load3d(&d3d, view, DABOFF);
            } /* end slice loop */
            dabop = 1;	/* add xcvr data */

        } /* end excitation loop */

    } /* end view loop */

    /* pass packet logic */
    boffset(off_seqpass);

    if(slice >= rspslq)
    {
        /* Set DAB pass packet to end of scan */
        setwamp(SSPD + DABPASS + DABSCAN, &pass_pulse, 2);
        printdbg("  End of Scan and Pass", debugstate);
    }
    else
    {
        /* Set DAB pass packet to end of pass */
        setwamp(SSPD + DABPASS, &pass_pulse, 2);
        printdbg("  End of Pass", debugstate);
    }

    /* load last 3d packet */
    load3d(&d3dpass,rspvus, DABON);

    sp_sat_index = 0;
    startseq(0,(SHORT)AUTO_PAUSE);

    printdbg("Returning from testcore", debugstate);
    return SUCCESS;
} /* End testcore */

/********************** SPOIL ROUTINE ************************/
/* set exciter and receiver phases */
/* all variables and constants used are global */
STATUS
spoil( void )
{
    /* ATV: rf chopping for FIESTA */
    if( ssfp_flag == PSD_ON ) {
        /* HK for Fiesta-C */
        if( (pcfiesta_flag == PSD_ON) && (rspent == L_SCAN) ) {
            exphase = (exphase + (long)(pcfiesta_index*FS_2PI/phase_cycles) + 4L*FS_PI) % FS_2PI;
            rcphase = (exphase + slab_phase + yres_phase + 4L*FS_PI) % FS_2PI;
        } else {
            exphase = (exphase +  4L*FS_PI) % FS_2PI  - FS_PI;
            if(rspent == L_SCAN) { /* YMSmr07289  09/28/05 YI  Fixed no spectrum problem in mps2. */
                rcphase = (exphase + slab_phase + yres_phase + 4L*FS_PI)  % FS_2PI - FS_PI;
            }
        }
    } else {
        /* not FIESTA mode */
        if( spgr_flag == PSD_ON ) {
            exphase += (spgr_count++) * seed;

            if( opsat == PSD_ON ) {
                if ( (fatFlag != PSD_OFF) || (opwater != PSD_OFF) )
                    setiphase(exphase, &rfcssat, 0);
                if (sp_sat)
                    SpSatSPGR(exphase);
            }
        } else {
            exphase = 0;
        }

        exphase = (exphase + 3L*FS_PI)%FS_2PI - FS_PI;

        if ((rspent == L_SCAN) && slabtracking_flag) {
            rcphase = (exphase + slab_phase + yres_phase + (int)(nav_corr_phase_x*disp_x) + 3L*FS_PI) % FS_2PI - FS_PI;
        } else {
            rcphase = (exphase + slab_phase + yres_phase + 3L*FS_PI) % FS_2PI - FS_PI;
        }

        if( chop_phase == PSD_ON ) {
            /* Add PI to receiver phase */
            rcphase = (rcphase + 4L*FS_PI)%FS_2PI - FS_PI;
        }
    }

    setiphase(exphase, &rf1, scanrf1_inst);
    setiphase(rcphase, &echo1, 0);

    if(opetl>=2) {
        int echoindex;
        for(echoindex=0; echoindex < (opetl-1); echoindex++) {
            if ((rspent == L_SCAN) && slabtracking_flag) {
                if (uniPolar_flag || (echoindex%2 == 1)) {
                    rcphase = (exphase + slab_phase + yres_phase + (int)(nav_corr_phase_x*disp_x) + 3L*FS_PI) % FS_2PI - FS_PI;
                } else {
                    rcphase = (exphase + slab_phase + yres_phase - (int)(nav_corr_phase_x*disp_x) + 3L*FS_PI) % FS_2PI - FS_PI;
                }
            } else {
                rcphase = (exphase + slab_phase + yres_phase + 3L*FS_PI) % FS_2PI - FS_PI;
            }
            setiphase( rcphase, &(echo2toN[echoindex]), 0);
        }
    }

    return SUCCESS;
}   /* end spoil() */

/********************** SPOIL ROUTINE ************************/
/* set exciter and receiver phases */
/* all variables and constants used are global */
STATUS
RTIA_spoil( void )
{
    /* ATV: rf chopping for FIESTA */
    if( ssfp_flag == PSD_ON ) {
        exphase = (exphase +  4L*FS_PI) % FS_2PI  - FS_PI;
        rcphase = (exphase + slab_phase + yres_phase + 4L*FS_PI)  % FS_2PI - FS_PI;
    } else {
        /* not ssc mode */
        if( (spgr_flag == PSD_ON) && !rtia3d_irp_flag ) {
            exphase += (spgr_count++) * seed;
            if( (cont_spSat == 1) && !rtia3d_irp_flag ) {
                SpSatSPGR(exphase);
            }
        } else {
            exphase = 0;
        }

        exphase = (exphase + 3L*FS_PI)%FS_2PI - FS_PI;
        rcphase = (exphase + slab_phase + yres_phase + 3L*FS_PI) % FS_2PI - FS_PI;

        if( chop_phase == PSD_ON ) {
            /* Add PI to receiver phase */
            rcphase = (rcphase + 4L*FS_PI)%FS_2PI - FS_PI;
        }
    }

    fgre_setiphase(rf1frqrsp, exphase);
    fgre_setiphase(echo1xtrrsp,rcphase);

    if(opetl>=2) {
        int echoindex;
        for(echoindex=0; echoindex < (opetl-1); echoindex++) {
            setiphase( rcphase, &(echo2toN[echoindex]), 0);
        }
    }

    return SUCCESS;
}   /* end RTIA_spoil() */

/********************** FIESTA-C Phase Cycling ************************/ /* VAL15 12/14/2004 YI */
STATUS multiphase(void) /* set exciter and receiver phases */
{
    exct = pcfiesta_index + 1;
    if(pc_mode == PC_SGS){
        chop_exphase = (seq_count%phase_cycles)*FS_PI*2*(exct-1)/phase_cycles;
    } else if(pc_mode == PC_APC){
        if(exct == 1){
            chop_exphase = (seq_count%2)*FS_PI;
        } else {
            if(phase_cycles%2 == 0){
                chop_exphase = (seq_count%(phase_cycles+1))*FS_PI*2*exct/(phase_cycles+1);
            } else {
                chop_exphase = (seq_count%phase_cycles)*FS_PI*2*(exct-1)/phase_cycles;
            }
        }
    }
    seq_count++;
    chop_exphase = (chop_exphase +  4L*FS_PI) % FS_2PI  - FS_PI;
    exphase = chop_exphase + (slab_phase + yres_phase + 3L*FS_PI) % FS_2PI - FS_PI;
    setiphase(chop_exphase, &rf1, 0);
    setiphase(exphase, &echo1, 0);

    return SUCCESS;
}  /* end multiphase */

/* IR PREP (pjg) */
/**************************************************
  IR prep Routine
 ****************************************************/
void IRPrep(void)
{
    scopeon(&seqir);
    boffset(off_seqir);

    /* Load Transmit Frequencies */
    setfrequency(rf0_freq[slabindex], &rf0, 0);
    if ( (RF0_HS_20MS == rf0_pulse_type) || (RF0_ADIABATIC == rf0_pulse_type) ||
         (RF0_HS_3T == rf0_pulse_type) || (RF0_ADIABTAN == rf0_pulse_type) )
    {
        setiphase(rf0_pha[psd_index], &rf0, 0);
    }
    setiamp(ia_rf0, &rf0, 0);
    printdbg("I", debugstate);
    startseq((short)slabindex,(SHORT)MAY_PAUSE);

    boffset(off_seqcore);
    return;
}

/********************** SAT ROUTINE ************************/
STATUS SatPrep(void)
    /* sat section of the sequence */
{
    INT rot_offset;

    rot_offset = slabindex + slabquant; /* 3d oblique - latha@mr */
    boffset(off_seqsat_fgre);  /* offset to sat code */
    startseq((short)rot_offset,(SHORT)MAY_PAUSE);

    acq_echo1 = DABOFF;
    if (opetl>=2)
        acq_echo2 = DABOFF;

    fgre_loaddab_echo1(dabslice, dabecho, dabop, dabview, acq_echo1);
    if (opetl>=2) {
        fgre_loaddab_echo2(dabslice, (dabecho+1), (opetl-1), nshots, dabop, dabview, acq_echo2);
    }

    /* MRIge51587 - Turn OFF 3D DAB packet, before the next startseq(). It is 
       possible that we set this in previous sequence and never turn it OFF. 
       This might lead to reFFTing the same view - LR/JAP */

    load3d(&d3d, 0, DABOFF);  /* end MRIge51587 */

    boffset(off_seqcore);   /* offset back to scan */

    /* 3d oblique - changed slice to slabindex */

    /* MRIge66079 - ATV: RTIA3D/ftMRA */
    /* for ftMRA mode, do not play out an additional TR */
    if ( (ftmra_flag == PSD_OFF) && (osfp_flag == PSD_OFF) && (!merge_flag) && (!ifir_flag) )
    {  
        startseq((short)slabindex, (SHORT)MAY_PAUSE);
    }
    /* End RTIA3D/ftMRA */

    /* end 3d oblique */

    acq_echo1 = DABON;
    if (opetl>=2)
        acq_echo2 = DABON;

    printdbg("Returning from SATPREP", debugstate);
    return SUCCESS;
}  /* end SatPrep */ 

STATUS SpecIRChemPrep(void)
{
    scopeon(&seqcssat);
    boffset(off_seqcssat);
    startseq((short)slabindex,(short)MAY_PAUSE);
    boffset(off_seqcore); 

    return SUCCESS;
}

STATUS PlayHard180(void)
{
    boffset(off_seqhard180);
    startseq((short) slabindex, (short) MAY_PAUSE);
    boffset(off_seqcore);
    return SUCCESS;
} 

/**************************************************
  ChemSat prep Routine
 ****************************************************/
STATUS ChemPrep(void)
{
    int exphase_old;

    exphase_old = exphase;
    spoil();
    /* Maintain same exphase for the next disdaq */
    exphase = exphase_old;
    spgr_count--;

    /* MGD2, RJF */
    /* NAV */
    if (specirprep)
    {
        setfrequency( (int)(0), &rfcssat,0);
    }
    else
    {
        setfrequency( (int)(off_rfcssat/TARDIS_FREQ_RES), &rfcssat,0);
    }

    boffset(off_seqcssat);
    startseq((short)slabindex,(short)MAY_PAUSE);
    boffset(off_seqcore); 

    return SUCCESS;
}

@inline MSDE.e MSDE_Rsp

/********************** PLAYDISDAQ ROUTINE ************************/
STATUS PlayDisdaq(int NumDisdaqs)
{
    int ndisdaq;

    /* Make sure sequence is played with echo1 and d3d dab packets
       turned off */
    load3d(&d3d, view-1, DABOFF);
    fgre_loaddab_echo1(dabslice, dabecho, dabop, dabview, DABOFF);

    if(opetl >= 2)
    {
        fgre_loaddab_echo2(dabslice, (dabecho+nshots), (opetl-1), nshots, dabop, dabview, DABOFF);
    }

    for (ndisdaq = 0; ndisdaq< NumDisdaqs; ndisdaq++)
    {
        /* VAL15 12/14/2004 YI */
        if(pc_mode < PC_BASIC)
            multiphase();
        else
            spoil();
        startseq((SHORT)slabindex,(SHORT)MAY_PAUSE);

        /* Chopper logic */
        chop_phase = -chop_phase;

    }

    return SUCCESS;
}

STATUS scandelay1(void)/* first half of delay between acqisition for mph scans */
{
    boffset(off_seqdelay1);

    startseq((short)0,(SHORT)MAY_PAUSE);

    boffset(off_seqcore); 
    /* offset back to scan */
    printdbg("Returning from SCANDELAY1", debugstate); 
    return SUCCESS; 
}


STATUS set_clock_for_total_trigger_delay_time(void)
{
    if (trigger_delay_wosp > 0)
    {

        setscantimestop();
#ifdef PSD_HW
        setscantimeimm(PSD_CLOCK_NORM,trigger_delay_wosp,piviews,pitslice,opslicecnt);
#endif
        setscantimestart();
        setscantimeauto();   /* return clock to auto */
    }
    return SUCCESS;
}

STATUS play_trigger_delay_silent_countdown(void)
{
    if (dda_trigger_delay_silent_countdown > 0)
    {
        boffset(off_seqdelay3);
        for (j=0; j< dda_trigger_delay_silent_countdown; j++)
        {
            startseq((short)0,(SHORT)MAY_PAUSE);
        }
        boffset(off_seqcore);
    }
    return SUCCESS;
}

STATUS reset_clock(void)
{

    setscantimestop();
#ifdef PSD_HW
    if (ftmra_flag)
        setscantimeimm(PSD_CLOCK_NORM,pitscan,piviews,pitslice,opslicecnt); 
    else
        setscantimeimm(pidmode,pitscan,piviews,pitslice,opslicecnt); 
#endif
    setscantimestart();
    setscantimeauto();   /* return clock to auto */

    return SUCCESS;
}
STATUS setmask_clock(void)
{
    setscantimestart();
    setscantimeauto();   /* return clock to auto */
    return SUCCESS;
}


STATUS scandelay0(void)/* trigger delay time for non-SmartPrep studies */
{
    if (trigger_delay_wosp > 0)
    {
        set_clock_for_total_trigger_delay_time();
    }


    if (dda_trigger_delay_silent_countdown > 0)
    {
        play_trigger_delay_silent_countdown();
    }


    if ( dda_trigger_delay_disdaqs > 0 )
    {
        view =  zy_export[0].view;
        slice = zy_export[0].slice;

        dabview = view + 1;

        dabslice = slice;

        if (FAILURE==ssRsp3D()) 
        {
            return FAILURE;
        }
        setfrequency(rf1_freq[0],&rf1,scanrf1_inst); /* 3doblique - latha@mr */
        set_echo1frequency(receive_freq1[0],0);
        if (opetl>=2)
            set_echo2frequency(receive_freq2[0],0);

        setiamp(volumetab[dabslice], &gzcomb, 0);

        if (zrewind_flag) {
            setiamp(volumetab2[dabslice], &gzp, 0);
        }

        acq_echo1 = DABOFF;
        if (opetl>=2)
            acq_echo2 = DABOFF;

        setiamp(-viewtable[dabview], &gy1, 0);

        if (rewinder_flag) {
            setiamp(-viewtable[dabview], &gy1r, 0);
        }


        fgre_loaddab_echo1(dabslice, dabecho, dabop, dabview, acq_echo1);
        if (opetl>= 2 ) {
            fgre_loaddab_echo2(dabslice, (dabecho+1), (opetl-1), nshots, dabop, dabview, acq_echo2);
        }

        load3d(&d3d, 0, DABOFF);

        /* Initialize yres_phase and slab_phase to zero */
        yres_phase = 0;
        slab_phase = 0;


        /* collect disdaq views */
        for (view = -dda_trigger_delay_disdaqs; view <= -1; view++) {
            spoil();

            printdbg("  Before disdaq", debugstate);
            startseq(0, (SHORT)MAY_PAUSE);

            /* Chopper logic */

            chop_phase = -chop_phase;
            printdbg("  After disdaq", debugstate);

            syncoff(&seqcore);

        }  /* End disdaqs */

    } /* end delay period */

    return SUCCESS;
}

STATUS execute_slice_loop(int ntimes,int flag)
{
    int i,nz,ny;

    ny = ntimes;
    if (flag)
        nz = 1;
    else
        nz = rspslq;

    for (i=0;i<ntimes;i++)
    {
        /* start slice loop */
        /* For elliptic centric we don't loop thru' the slice encoding, instead
           we repeat the first slice-encoding value */
        if ( (ellipt_flag == PSD_OFF) && (reverse_ellipt_flag == PSD_OFF) ) {
            slice = i%nz;
        }
        dabslice = slice;  /* the value of slice is already set in scancore() */

        /* set amp of gzcomb and gzp for dummy rf */
        setiamp(volumetab[dabslice], &gzcomb, 0);
        if (zrewind_flag)
            setiamp(volumetab2[dabslice], &gzp, 0);

        spoil();

        printdbg("      Before startseq", debugstate);
        sp_sat_index = slabindex;
        startseq(slabindex, (SHORT)MAY_PAUSE);
        printdbg("      After startseq", debugstate);

    }

    return SUCCESS;
}

@inline VAST.e VASTcore
@inline VAST.e VASTcore_fiesta3d

void reset_for_scan(void)
{
    /* RF1, echo1 and trigger array are already set */
    boffset(off_seqcore);

    /* MGD2, RJF */
    /* NAV */
    setrfltrs((int)filter_echo1, &echo1);

    /* Fix for MRIge41368 */
    setrotatearray((SHORT)((sp_sat + 1) * slabquant),rsprot[0]);
}

/* SVBranch, Smart Burst Mode */
/* SBM: play waiting sequence to let system recover */
void sbm_dummy(void)
{
    int i;
    SHORT tmp_gx1, tmp_gxw, tmp_gxwex, tmp_gy1, tmp_gy1r, tmp_gzcomb, tmp_gzp;

    getiamp(&tmp_gx1, &gx1, 0);
    getiamp(&tmp_gxw, &gxw, 0);
    getiamp(&tmp_gxwex, &gxwex, 0);
    getiamp(&tmp_gy1, &gy1, 0);
    getiamp(&tmp_gy1r, &gy1r, 0);
    getiamp(&tmp_gzcomb, &gzcomb, 0);
    getiamp(&tmp_gzp, &gzp, 0);

    setiamp(0, &gx1, 0);
    setiampt(0, &gxw, 0);
    setiampt(0, &gxwex, 0);

    setiamp(0, &gy1, 0);
    setiamp(0, &gy1r, 0);

    setiamp(volumetab[equant/2], &gzcomb, 0);
    setiamp(volumetab2[equant/2], &gzp, 0);

    load3d(&d3d, 0, DABOFF);
    fgre_loaddab_echo1(dabslice, dabecho, dabop, dabview, DABOFF);

    for(i = 0; i < sbm_dummy_num; i ++)
    {
        if(pc_mode < PC_BASIC)
        {
              multiphase();
        }
        else
        {
              spoil();
        }
        startseq((short)slabindex, (short)MAY_PAUSE);
    }
    setiamp(tmp_gx1, &gx1, 0);
    setiampt(tmp_gxw, &gxw, 0);
    setiampt(tmp_gxwex, &gxwex, 0);

    setiamp(tmp_gy1, &gy1, 0);
    setiamp(tmp_gy1r, &gy1r, 0);

    setiamp(tmp_gzcomb, &gzcomb, 0);
    setiamp(tmp_gzp, &gzp, 0);

    for(i = 0; i < sbm_dda; i ++)
    {
        if(pc_mode < PC_BASIC)
        {
              multiphase();
        }
        else
        {
              spoil();
        }
        startseq((short)slabindex, (short)MAY_PAUSE);
    }
}


@inline ChemSatSpecIR.e CsSatMod
@inline ChemSatSpecIR.e CsSatPrep
@inline SpSat.e SpSatInitRsp 
@inline SpSat.e SpSatUpdateRsp
@inline SpSat.e SpSatSPGR
@inline InversionGRx.e InversionGRxInitRsp /* IFIR GRx */
@inline InversionGRx.e InversionGRxUpdateRsp /* IFIR GRx */

@inline ss.e ssRsp3D

STATUS isReferenceLine(int view, int slice)
{
    if((idealiq_pc_ylower <= view)  && (view  <= idealiq_pc_yupper) &&
       (idealiq_pc_zlower <= slice) && (slice <= idealiq_pc_zupper))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

@global
#include <string.h>
/*********************************************************************
 *                    EFGRE3D.E GLOBAL SECTION                       *
 *                           (Part II)                               *
 *                                                                   *
 * Common code shared between the Host and Tgt PSD processes.  This  *
 * section contains all the #define's, global variables and function *
 * declarations (prototypes).                                        *
 *********************************************************************/

short isibit; /* bit set for isi routine */
STATUS new_view;
STATUS first_scan;

STATUS first_prepscan;

/* for ipgsignal.c */
int sun_success_flag1 = 0;
int sun_success_flag2 = 0;
int sun_done_flag = 0;

/* NAV assorted psdisi variables */
int look_for_trig;
volatile int isi_done;

/*MRIge91361 record the information of bias setting for the coil that is
 *  *  * plugged in for coilswitch purpose in PURE calibration scans*/


@inline Gate.eh
@inline Navigator.e

/************************** END OF EFGRE3D.E ******************************/

